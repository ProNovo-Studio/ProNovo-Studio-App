{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/camera.js", "../../../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/manager/focus-camera/focus-object.js", "../../../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/structure/visual/util/element.js", "../../../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/structure/visual/label-text.js"],
  "sourcesContent": ["/**\n * Copyright (c) 2025 mol* contributors, licensed under MIT, See LICENSE file for more info.\n *\n * @author Adam Midlik <midlik@gmail.com>\n * @author David Sehnal <david.sehnal@gmail.com>\n */\nimport { Vec3 } from '../mol-math/linear-algebra';\n/** Return the distance adjustment ratio for conversion from the \"reference camera\"\n * to a camera with an arbitrary field of view `fov`. */\nfunction distanceAdjustment(mode, fov) {\n    if (mode === 'orthographic')\n        return 1 / (2 * Math.tan(fov / 2));\n    else\n        return 1 / (2 * Math.sin(fov / 2));\n}\n/** Return the position for a camera with an arbitrary field of view `fov`\n * necessary to just fit into view the same sphere (with center at `target`)\n * as the \"reference camera\" placed at `refPosition` would fit, while keeping the camera orientation.\n * The \"reference camera\" is a camera which can just fit into view a sphere of radius R with center at distance 2R\n * (this corresponds to FOV = 2 * asin(1/2) in perspective mode or FOV = 2 * atan(1/2) in orthographic mode). */\nexport function fovAdjustedPosition(target, refPosition, mode, fov) {\n    const delta = Vec3.sub(Vec3(), refPosition, target);\n    const adjustment = distanceAdjustment(mode, fov);\n    return Vec3.scaleAndAdd(delta, target, delta, adjustment); // return target + delta * adjustment\n}\n/** Return the inverse of fovAdjustedPosition to be able to store invariant camera position,\n * e.g., in MolViewSpec snapshots.\n */\nexport function fovNormalizedCameraPosition(target, refPosition, mode, fov) {\n    const delta = Vec3.sub(Vec3(), refPosition, target);\n    const adjustment = distanceAdjustment(mode, fov) || 1;\n    return Vec3.scaleAndAdd(delta, target, delta, 1 / adjustment); // return target + delta / adjustment\n}\n", "/**\n * Copyright (c) 2024 mol* contributors, licensed under MIT, See LICENSE file for more info.\n *\n * @author Adam Midlik <midlik@gmail.com>\n */\nimport { Sphere3D } from '../../../mol-math/geometry';\nimport { BoundaryHelper } from '../../../mol-math/geometry/boundary-helper';\nimport { Vec3 } from '../../../mol-math/linear-algebra';\nimport { Loci } from '../../../mol-model/loci';\nimport { Structure } from '../../../mol-model/structure';\nimport { PluginStateObject } from '../../objects';\n/** Return camera snapshot focused on a plugin state object cell (if `targetRef` is defined)\n * or on the whole scene (if `targetRef` is undefined).\n * If `direction` and `up` are not provided, use current camera orientation. */\nexport function getFocusSnapshot(plugin, options) {\n    var _a, _b;\n    if (!plugin.canvas3d)\n        return undefined;\n    const targetSpheres = (_a = options.targets) === null || _a === void 0 ? void 0 : _a.map(target => {\n        var _a, _b, _c;\n        const bounding = (target.targetRef !== undefined) ? getCellBoundingSphere(plugin, target.targetRef) : getPluginBoundingSphere(plugin);\n        if (!bounding)\n            return undefined;\n        const radius = (_a = target.radius) !== null && _a !== void 0 ? _a : bounding.radius * ((_b = target.radiusFactor) !== null && _b !== void 0 ? _b : 1) + ((_c = target.extraRadius) !== null && _c !== void 0 ? _c : 0);\n        return Sphere3D.create(bounding.center, radius);\n    }).filter(sphere => sphere !== undefined);\n    const mergedSphere = (targetSpheres && targetSpheres.length > 0) ? boundingSphereOfSpheres(targetSpheres) : getPluginBoundingSphere(plugin);\n    return snapshotFromSphereAndDirections(plugin.canvas3d.camera, {\n        center: mergedSphere.center,\n        radius: Math.max(mergedSphere.radius, (_b = options.minRadius) !== null && _b !== void 0 ? _b : 0),\n        up: options.up,\n        direction: options.direction,\n    });\n}\nconst _tmpVec = Vec3();\n/** Return camera snapshot for focusing a sphere with given `center` and `radius`,\n * while ensuring given view `direction` (aligns with vector position->target)\n * and `up` (aligns with screen Y axis). */\nfunction snapshotFromSphereAndDirections(camera, options) {\n    var _a, _b;\n    // This might seem to repeat `plugin.canvas3d.camera.getFocus` but avoid flipping\n    const target = options.center;\n    const radius = Math.max(options.radius, 0.01);\n    const direction = (_a = options.direction) !== null && _a !== void 0 ? _a : Vec3.sub(Vec3(), camera.target, camera.position);\n    const up = Vec3.orthogonalize(Vec3(), direction, (_b = options.up) !== null && _b !== void 0 ? _b : camera.up);\n    const distance = camera.getTargetDistance(radius);\n    const deltaDirection = Vec3.setMagnitude(_tmpVec, direction, distance);\n    const position = Vec3.sub(Vec3(), target, deltaDirection);\n    return { target, position, up, radius };\n}\n/** Return the bounding sphere of a plugin state object cell */\nexport function getCellBoundingSphere(plugin, cellRef) {\n    const spheres = collectCellBoundingSpheres([], plugin, cellRef);\n    if (spheres.length === 0)\n        return undefined;\n    if (spheres.length === 1)\n        return spheres[0];\n    return boundingSphereOfSpheres(spheres);\n}\n/** Push bounding spheres within cell `cellRef` to `out`. If a cell does not define bounding spheres, collect bounding spheres from subtree. */\nfunction collectCellBoundingSpheres(out, plugin, cellRef) {\n    const cell = plugin.state.data.cells.get(cellRef);\n    const spheres = getStateObjectBoundingSpheres(cell === null || cell === void 0 ? void 0 : cell.obj);\n    if (spheres) {\n        out.push(...spheres);\n    }\n    else {\n        const children = plugin.state.data.tree.children.get(cellRef);\n        children.forEach(child => collectCellBoundingSpheres(out, plugin, child));\n    }\n    return out;\n}\n/** Return a set of bounding spheres of a plugin state object. Return `undefined` if this plugin state object type does not define bounding spheres. */\nfunction getStateObjectBoundingSpheres(obj) {\n    if (!obj)\n        return undefined;\n    if (!obj.data) {\n        console.warn('Focus: no data');\n        return undefined;\n    }\n    if (obj.data instanceof Structure) {\n        const sphere = Loci.getBoundingSphere(Structure.Loci(obj.data));\n        return sphere ? [sphere] : [];\n    }\n    else if (PluginStateObject.isRepresentation3D(obj)) {\n        const out = [];\n        for (const renderObject of obj.data.repr.renderObjects) {\n            const sphere = renderObject.values.boundingSphere.ref.value;\n            if (sphere.radius > 0)\n                out.push(sphere);\n        }\n        return out;\n    }\n    return undefined;\n}\n/** Return the bounding sphere of the whole visible scene. */\nexport function getPluginBoundingSphere(plugin) {\n    const renderObjects = getRenderObjects(plugin, false);\n    const spheres = renderObjects.map(r => r.values.boundingSphere.ref.value).filter(sphere => sphere.radius > 0);\n    return boundingSphereOfSpheres(spheres);\n}\nfunction getRenderObjects(plugin, includeHidden) {\n    let reprCells = Array.from(plugin.state.data.cells.values()).filter(cell => cell.obj && PluginStateObject.isRepresentation3D(cell.obj));\n    if (!includeHidden)\n        reprCells = reprCells.filter(cell => !cell.state.isHidden);\n    const renderables = reprCells.flatMap(cell => cell.obj.data.repr.renderObjects);\n    return renderables;\n}\nlet boundaryHelper = undefined;\nfunction boundingSphereOfSpheres(spheres) {\n    boundaryHelper !== null && boundaryHelper !== void 0 ? boundaryHelper : (boundaryHelper = new BoundaryHelper('98'));\n    boundaryHelper.reset();\n    for (const s of spheres)\n        boundaryHelper.includeSphere(s);\n    boundaryHelper.finishedIncludeStep();\n    for (const s of spheres)\n        boundaryHelper.radiusSphere(s);\n    return boundaryHelper.getSphere();\n}\n", "/**\n * Copyright (c) 2018-2023 mol* contributors, licensed under MIT, See LICENSE file for more info.\n *\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\n * @author David Sehnal <david.sehnal@gmail.com>\n */\nimport { Vec3 } from '../../../../mol-math/linear-algebra';\nimport { Unit, StructureElement, Structure } from '../../../../mol-model/structure';\nimport { EmptyLoci } from '../../../../mol-model/loci';\nimport { Interval, OrderedSet, SortedArray } from '../../../../mol-data/int';\nimport { Mesh } from '../../../../mol-geo/geometry/mesh/mesh';\nimport { sphereVertexCount } from '../../../../mol-geo/primitive/sphere';\nimport { MeshBuilder } from '../../../../mol-geo/geometry/mesh/mesh-builder';\nimport { addSphere } from '../../../../mol-geo/geometry/mesh/builder/sphere';\nimport { LocationIterator } from '../../../../mol-geo/util/location-iterator';\nimport { Spheres } from '../../../../mol-geo/geometry/spheres/spheres';\nimport { SpheresBuilder } from '../../../../mol-geo/geometry/spheres/spheres-builder';\nimport { isTrace, isHydrogen } from './common';\nimport { Sphere3D } from '../../../../mol-math/geometry';\n// avoiding namespace lookup improved performance in Chrome (Aug 2020)\nconst v3add = Vec3.add;\nexport function makeElementIgnoreTest(structure, unit, props) {\n    const { ignoreHydrogens, ignoreHydrogensVariant, traceOnly } = props;\n    const isCoarse = Unit.isCoarse(unit);\n    const { child } = structure;\n    const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);\n    if (child && !childUnit)\n        throw new Error('expected childUnit to exist if child exists');\n    if (!child && !ignoreHydrogens && !traceOnly)\n        return;\n    return (element) => {\n        return ((!!childUnit && !SortedArray.has(childUnit.elements, element)) ||\n            (!isCoarse && ignoreHydrogens && isHydrogen(structure, unit, element, ignoreHydrogensVariant)) ||\n            (traceOnly && !isTrace(unit, element)));\n    };\n}\nexport function createElementSphereMesh(ctx, unit, structure, theme, props, mesh) {\n    const { child } = structure;\n    const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);\n    if (child && !childUnit)\n        return Mesh.createEmpty(mesh);\n    const { detail, sizeFactor, stride } = props;\n    const { elements, conformation: c } = unit;\n    const elementCount = elements.length;\n    const vertexCount = elementCount * sphereVertexCount(detail);\n    const builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);\n    const v = Vec3();\n    const ignore = makeElementIgnoreTest(structure, unit, props);\n    const l = StructureElement.Location.create(structure, unit);\n    const themeSize = theme.size.size;\n    const center = Vec3();\n    let maxSize = 0;\n    let count = 0;\n    for (let i = 0; i < elementCount; i++) {\n        if (stride && i % stride !== 0)\n            continue;\n        if (ignore && ignore(elements[i]))\n            continue;\n        c.invariantPosition(elements[i], v);\n        v3add(center, center, v);\n        count += 1;\n        l.element = elements[i];\n        const size = themeSize(l);\n        if (size > maxSize)\n            maxSize = size;\n        builderState.currentGroup = i;\n        addSphere(builderState, v, size * sizeFactor, detail);\n    }\n    const m = MeshBuilder.getMesh(builderState);\n    if (count === 0)\n        return m;\n    // re-use boundingSphere if it has not changed much\n    let boundingSphere;\n    Vec3.scale(center, center, 1 / count);\n    const oldBoundingSphere = mesh ? Sphere3D.clone(mesh.boundingSphere) : undefined;\n    if (oldBoundingSphere && Vec3.distance(center, oldBoundingSphere.center) / oldBoundingSphere.radius < 0.1) {\n        boundingSphere = oldBoundingSphere;\n    }\n    else {\n        boundingSphere = Sphere3D.expand(Sphere3D(), (childUnit !== null && childUnit !== void 0 ? childUnit : unit).boundary.sphere, maxSize * sizeFactor + 0.05);\n    }\n    m.setBoundingSphere(boundingSphere);\n    return m;\n}\nexport function createElementSphereImpostor(ctx, unit, structure, theme, props, spheres) {\n    const { child } = structure;\n    const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);\n    if (child && !childUnit)\n        return Spheres.createEmpty(spheres);\n    const { sizeFactor, stride } = props;\n    const { elements, conformation: c } = unit;\n    const elementCount = elements.length;\n    const builder = SpheresBuilder.create(elementCount, elementCount / 2, spheres);\n    const v = Vec3();\n    const ignore = makeElementIgnoreTest(structure, unit, props);\n    const l = StructureElement.Location.create(structure, unit);\n    const themeSize = theme.size.size;\n    const center = Vec3();\n    let maxSize = 0;\n    let count = 0;\n    if ((stride && stride > 1) || ignore || theme.size.granularity !== 'uniform') {\n        for (let i = 0; i < elementCount; i++) {\n            if (stride && i % stride !== 0)\n                continue;\n            if (ignore && ignore(elements[i]))\n                continue;\n            c.invariantPosition(elements[i], v);\n            builder.add(v[0], v[1], v[2], i);\n            v3add(center, center, v);\n            count += 1;\n            l.element = elements[i];\n            const size = themeSize(l);\n            if (size > maxSize)\n                maxSize = size;\n        }\n    }\n    else {\n        for (let i = 0; i < elementCount; i++) {\n            c.invariantPosition(elements[i], v);\n            builder.add(v[0], v[1], v[2], i);\n            v3add(center, center, v);\n        }\n        count = elementCount;\n        maxSize = themeSize(l);\n    }\n    const s = builder.getSpheres();\n    if (count === 0)\n        return s;\n    // re-use boundingSphere if it has not changed much\n    let boundingSphere;\n    Vec3.scale(center, center, 1 / count);\n    const oldBoundingSphere = spheres ? Sphere3D.clone(spheres.boundingSphere) : undefined;\n    if (oldBoundingSphere && Vec3.distance(center, oldBoundingSphere.center) / oldBoundingSphere.radius < 0.1) {\n        boundingSphere = oldBoundingSphere;\n    }\n    else {\n        boundingSphere = Sphere3D.expand(Sphere3D(), (childUnit !== null && childUnit !== void 0 ? childUnit : unit).boundary.sphere, maxSize * sizeFactor + 0.05);\n    }\n    s.setBoundingSphere(boundingSphere);\n    return s;\n}\nexport function eachElement(loci, structureGroup, apply) {\n    let changed = false;\n    if (!StructureElement.Loci.is(loci))\n        return false;\n    const { structure, group } = structureGroup;\n    if (!Structure.areEquivalent(loci.structure, structure))\n        return false;\n    const elementCount = group.elements.length;\n    const { unitIndexMap } = group;\n    for (const e of loci.elements) {\n        const unitIdx = unitIndexMap.get(e.unit.id);\n        if (unitIdx !== undefined) {\n            const offset = unitIdx * elementCount; // to target unit instance\n            if (Interval.is(e.indices)) {\n                const start = offset + Interval.start(e.indices);\n                const end = offset + Interval.end(e.indices);\n                if (apply(Interval.ofBounds(start, end)))\n                    changed = true;\n            }\n            else {\n                for (let i = 0, _i = e.indices.length; i < _i; i++) {\n                    const start = e.indices[i];\n                    let endI = i + 1;\n                    while (endI < _i && e.indices[endI] === start)\n                        endI++;\n                    i = endI - 1;\n                    const end = e.indices[i];\n                    changed = apply(Interval.ofRange(offset + start, offset + end)) || changed;\n                }\n            }\n        }\n    }\n    return changed;\n}\nexport function getElementLoci(pickingId, structureGroup, id) {\n    const { objectId, instanceId, groupId } = pickingId;\n    if (id === objectId) {\n        const { structure, group } = structureGroup;\n        const unit = group.units[instanceId];\n        const indices = OrderedSet.ofSingleton(groupId);\n        return StructureElement.Loci(structure.target, [{ unit, indices }]);\n    }\n    return EmptyLoci;\n}\n//\nexport function createStructureElementSphereMesh(ctx, structure, theme, props, mesh) {\n    const { child } = structure;\n    const { detail, sizeFactor, stride } = props;\n    const { getSerialIndex } = structure.serialMapping;\n    const structureElementCount = structure.elementCount;\n    const vertexCount = structureElementCount * sphereVertexCount(detail);\n    const builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);\n    const themeSize = theme.size.size;\n    const center = Vec3();\n    let maxSize = 0;\n    let count = 0;\n    for (const unit of structure.units) {\n        const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);\n        if (child && !childUnit)\n            continue;\n        const { elements, conformation: c } = unit;\n        const elementCount = elements.length;\n        const v = Vec3();\n        const ignore = makeElementIgnoreTest(structure, unit, props);\n        const l = StructureElement.Location.create(structure, unit);\n        for (let i = 0; i < elementCount; i++) {\n            const eI = elements[i];\n            if (stride && i % stride !== 0)\n                continue;\n            if (ignore && ignore(eI))\n                continue;\n            c.position(eI, v);\n            v3add(center, center, v);\n            count += 1;\n            l.element = eI;\n            const size = themeSize(l);\n            if (size > maxSize)\n                maxSize = size;\n            builderState.currentGroup = getSerialIndex(unit, eI);\n            addSphere(builderState, v, size * sizeFactor, detail);\n        }\n    }\n    const m = MeshBuilder.getMesh(builderState);\n    if (count === 0)\n        return m;\n    // re-use boundingSphere if it has not changed much\n    let boundingSphere;\n    Vec3.scale(center, center, 1 / count);\n    const oldBoundingSphere = mesh ? Sphere3D.clone(mesh.boundingSphere) : undefined;\n    if (oldBoundingSphere && Vec3.distance(center, oldBoundingSphere.center) / oldBoundingSphere.radius < 1.0) {\n        boundingSphere = oldBoundingSphere;\n    }\n    else {\n        boundingSphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, maxSize * sizeFactor + 0.05);\n    }\n    m.setBoundingSphere(boundingSphere);\n    return m;\n}\nexport function createStructureElementSphereImpostor(ctx, structure, theme, props, spheres) {\n    const { child } = structure;\n    const { sizeFactor, stride } = props;\n    const { getSerialIndex } = structure.serialMapping;\n    const structureElementCount = structure.elementCount;\n    const builder = SpheresBuilder.create(structureElementCount, structureElementCount / 2, spheres);\n    const themeSize = theme.size.size;\n    const center = Vec3();\n    let maxSize = 0;\n    let count = 0;\n    for (const unit of structure.units) {\n        const childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);\n        if (child && !childUnit)\n            continue;\n        const { elements, conformation: c } = unit;\n        const elementCount = elements.length;\n        const v = Vec3();\n        const ignore = makeElementIgnoreTest(structure, unit, props);\n        const l = StructureElement.Location.create(structure, unit);\n        if ((stride && stride > 1) || ignore || theme.size.granularity !== 'uniform') {\n            for (let i = 0; i < elementCount; i++) {\n                const eI = elements[i];\n                if (stride && i % stride !== 0)\n                    continue;\n                if (ignore && ignore(eI))\n                    continue;\n                c.position(eI, v);\n                builder.add(v[0], v[1], v[2], getSerialIndex(unit, eI));\n                v3add(center, center, v);\n                count += 1;\n                l.element = eI;\n                const size = themeSize(l);\n                if (size > maxSize)\n                    maxSize = size;\n            }\n        }\n        else {\n            for (let i = 0; i < elementCount; i++) {\n                const eI = elements[i];\n                c.position(eI, v);\n                builder.add(v[0], v[1], v[2], getSerialIndex(unit, eI));\n                v3add(center, center, v);\n            }\n            count += elementCount;\n            maxSize = themeSize(l);\n        }\n    }\n    const s = builder.getSpheres();\n    if (count === 0)\n        return s;\n    // re-use boundingSphere if it has not changed much\n    let boundingSphere;\n    Vec3.scale(center, center, 1 / count);\n    const oldBoundingSphere = spheres ? Sphere3D.clone(spheres.boundingSphere) : undefined;\n    if (oldBoundingSphere && Vec3.distance(center, oldBoundingSphere.center) / oldBoundingSphere.radius < 1.0) {\n        boundingSphere = oldBoundingSphere;\n    }\n    else {\n        boundingSphere = Sphere3D.expand(Sphere3D(), (child !== null && child !== void 0 ? child : structure).boundary.sphere, maxSize * sizeFactor + 0.05);\n    }\n    s.setBoundingSphere(boundingSphere);\n    return s;\n}\nexport function eachSerialElement(loci, structure, apply) {\n    let changed = false;\n    if (!StructureElement.Loci.is(loci))\n        return false;\n    if (!Structure.areEquivalent(loci.structure, structure))\n        return false;\n    const { cumulativeUnitElementCount } = structure.serialMapping;\n    for (const e of loci.elements) {\n        const unitIdx = structure.unitIndexMap.get(e.unit.id);\n        if (unitIdx !== undefined) {\n            if (Interval.is(e.indices)) {\n                const start = cumulativeUnitElementCount[unitIdx] + Interval.start(e.indices);\n                const end = cumulativeUnitElementCount[unitIdx] + Interval.end(e.indices);\n                if (apply(Interval.ofBounds(start, end)))\n                    changed = true;\n            }\n            else {\n                for (let i = 0, _i = e.indices.length; i < _i; i++) {\n                    const idx = cumulativeUnitElementCount[unitIdx] + e.indices[i];\n                    if (apply(Interval.ofSingleton(idx)))\n                        changed = true;\n                }\n            }\n        }\n    }\n    return changed;\n}\nexport function getSerialElementLoci(pickingId, structure, id) {\n    const { objectId, groupId } = pickingId;\n    if (id === objectId) {\n        const { unitIndices, cumulativeUnitElementCount } = structure.serialMapping;\n        const unitIdx = unitIndices[groupId];\n        const unit = structure.units[unitIdx];\n        const idx = groupId - cumulativeUnitElementCount[unitIdx];\n        const indices = OrderedSet.ofSingleton(idx);\n        return StructureElement.Loci(structure, [{ unit, indices }]);\n    }\n    return EmptyLoci;\n}\n//\nexport var ElementIterator;\n(function (ElementIterator) {\n    function fromGroup(structureGroup) {\n        const { group, structure } = structureGroup;\n        const groupCount = group.elements.length;\n        const instanceCount = group.units.length;\n        const location = StructureElement.Location.create(structure);\n        const getLocation = (groupIndex, instanceIndex) => {\n            const unit = group.units[instanceIndex];\n            location.unit = unit;\n            location.element = unit.elements[groupIndex];\n            return location;\n        };\n        return LocationIterator(groupCount, instanceCount, 1, getLocation);\n    }\n    ElementIterator.fromGroup = fromGroup;\n    function fromStructure(structure) {\n        const { units, elementCount } = structure;\n        const groupCount = elementCount;\n        const instanceCount = 1;\n        const { unitIndices, elementIndices } = structure.serialMapping;\n        const location = StructureElement.Location.create(structure);\n        const getLocation = (groupIndex) => {\n            location.unit = units[unitIndices[groupIndex]];\n            location.element = elementIndices[groupIndex];\n            return location;\n        };\n        return LocationIterator(groupCount, instanceCount, 1, getLocation, true);\n    }\n    ElementIterator.fromStructure = fromStructure;\n})(ElementIterator || (ElementIterator = {}));\n", "/**\n * Copyright (c) 2019-2023 mol* contributors, licensed under MIT, See LICENSE file for more info.\n *\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\n * @author David Sehnal <david.sehnal@gmail.com>\n */\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { StructureElement, StructureProperties } from '../../../mol-model/structure';\nimport { TextBuilder } from '../../../mol-geo/geometry/text/text-builder';\nimport { ComplexTextVisual, ComplexTextParams } from '../complex-visual';\nimport { ElementIterator, getSerialElementLoci, eachSerialElement } from './util/element';\nimport { ColorNames } from '../../../mol-util/color/names';\nimport { Vec3 } from '../../../mol-math/linear-algebra';\nimport { BoundaryHelper } from '../../../mol-math/geometry/boundary-helper';\nimport { makeElementIgnoreTest } from './util/element';\nexport const LabelTextParams = {\n    ...ComplexTextParams,\n    background: PD.Boolean(false),\n    backgroundMargin: PD.Numeric(0, { min: 0, max: 1, step: 0.01 }),\n    backgroundColor: PD.Color(ColorNames.black),\n    backgroundOpacity: PD.Numeric(0.5, { min: 0, max: 1, step: 0.01 }),\n    borderWidth: PD.Numeric(0.25, { min: 0, max: 0.5, step: 0.01 }),\n    level: PD.Select('residue', [['chain', 'Chain'], ['residue', 'Residue'], ['element', 'Element']], { isEssential: true }),\n    ignoreHydrogens: PD.Boolean(false),\n    ignoreHydrogensVariant: PD.Select('all', PD.arrayToOptions(['all', 'non-polar'])),\n    chainScale: PD.Numeric(10, { min: 0, max: 20, step: 0.1 }),\n    residueScale: PD.Numeric(1, { min: 0, max: 20, step: 0.1 }),\n    elementScale: PD.Numeric(0.5, { min: 0, max: 20, step: 0.1 }),\n};\nexport function LabelTextVisual(materialId) {\n    return ComplexTextVisual({\n        defaultProps: PD.getDefaultValues(LabelTextParams),\n        createGeometry: createLabelText,\n        createLocationIterator: ElementIterator.fromStructure,\n        getLoci: getSerialElementLoci,\n        eachLocation: eachSerialElement,\n        setUpdateState: (state, newProps, currentProps) => {\n            state.createGeometry = (newProps.level !== currentProps.level ||\n                (newProps.level === 'chain' && newProps.chainScale !== currentProps.chainScale) ||\n                (newProps.level === 'residue' && newProps.residueScale !== currentProps.residueScale) ||\n                (newProps.level === 'element' && newProps.elementScale !== currentProps.elementScale) ||\n                newProps.ignoreHydrogens !== currentProps.ignoreHydrogens ||\n                newProps.ignoreHydrogensVariant !== currentProps.ignoreHydrogensVariant);\n        }\n    }, materialId);\n}\nfunction createLabelText(ctx, structure, theme, props, text) {\n    switch (props.level) {\n        case 'chain': return createChainText(ctx, structure, theme, props, text);\n        case 'residue': return createResidueText(ctx, structure, theme, props, text);\n        case 'element': return createElementText(ctx, structure, theme, props, text);\n    }\n}\n//\nconst tmpVec = Vec3();\nconst boundaryHelper = new BoundaryHelper('98');\nfunction createChainText(ctx, structure, theme, props, text) {\n    const l = StructureElement.Location.create(structure);\n    const { units, serialMapping } = structure;\n    const { auth_asym_id, label_asym_id } = StructureProperties.chain;\n    const { cumulativeUnitElementCount } = serialMapping;\n    const count = units.length;\n    const { chainScale } = props;\n    const builder = TextBuilder.create(props, count, count / 2, text);\n    for (let i = 0, il = units.length; i < il; ++i) {\n        const unit = units[i];\n        l.unit = unit;\n        l.element = unit.elements[0];\n        const { center, radius } = unit.lookup3d.boundary.sphere;\n        Vec3.transformMat4(tmpVec, center, unit.conformation.operator.matrix);\n        const authId = auth_asym_id(l);\n        const labelId = label_asym_id(l);\n        const text = authId === labelId ? labelId : `${labelId} [${authId}]`;\n        builder.add(text, tmpVec[0], tmpVec[1], tmpVec[2], radius, chainScale, cumulativeUnitElementCount[i]);\n    }\n    return builder.getText();\n}\nfunction createResidueText(ctx, structure, theme, props, text) {\n    const l = StructureElement.Location.create(structure);\n    const { units, serialMapping } = structure;\n    const { label_comp_id } = StructureProperties.atom;\n    const { auth_seq_id } = StructureProperties.residue;\n    const { cumulativeUnitElementCount } = serialMapping;\n    const count = structure.polymerResidueCount * 2;\n    const { residueScale } = props;\n    const builder = TextBuilder.create(props, count, count / 2, text);\n    for (let i = 0, il = units.length; i < il; ++i) {\n        const unit = units[i];\n        const c = unit.conformation;\n        const { elements } = unit;\n        l.unit = unit;\n        l.element = unit.elements[0];\n        const residueIndex = unit.model.atomicHierarchy.residueAtomSegments.index;\n        const groupOffset = cumulativeUnitElementCount[i];\n        let j = 0;\n        const jl = elements.length;\n        while (j < jl) {\n            const start = j, rI = residueIndex[elements[j]];\n            j++;\n            while (j < jl && residueIndex[elements[j]] === rI)\n                j++;\n            boundaryHelper.reset();\n            for (let eI = start; eI < j; eI++) {\n                c.position(elements[eI], tmpVec);\n                boundaryHelper.includePosition(tmpVec);\n            }\n            boundaryHelper.finishedIncludeStep();\n            for (let eI = start; eI < j; eI++) {\n                c.position(elements[eI], tmpVec);\n                boundaryHelper.radiusPosition(tmpVec);\n            }\n            l.element = elements[start];\n            const { center, radius } = boundaryHelper.getSphere();\n            const authSeqId = auth_seq_id(l);\n            const compId = label_comp_id(l);\n            const text = `${compId} ${authSeqId}`;\n            builder.add(text, center[0], center[1], center[2], radius, residueScale, groupOffset + start);\n        }\n    }\n    return builder.getText();\n}\nfunction createElementText(ctx, structure, theme, props, text) {\n    const l = StructureElement.Location.create(structure);\n    const { units, serialMapping } = structure;\n    const { label_atom_id, label_alt_id } = StructureProperties.atom;\n    const { cumulativeUnitElementCount } = serialMapping;\n    const sizeTheme = theme.size;\n    const count = structure.elementCount;\n    const { elementScale } = props;\n    const builder = TextBuilder.create(props, count, count / 2, text);\n    for (let i = 0, il = units.length; i < il; ++i) {\n        const unit = units[i];\n        const c = unit.conformation;\n        const { elements } = unit;\n        l.unit = unit;\n        const groupOffset = cumulativeUnitElementCount[i];\n        const ignore = makeElementIgnoreTest(structure, unit, { ...props, traceOnly: false });\n        for (let j = 0, _j = elements.length; j < _j; j++) {\n            if (ignore && ignore(elements[j]))\n                continue;\n            l.element = elements[j];\n            c.position(l.element, tmpVec);\n            const atomId = label_atom_id(l);\n            const altId = label_alt_id(l);\n            const text = altId ? `${atomId}%${altId}` : atomId;\n            builder.add(text, tmpVec[0], tmpVec[1], tmpVec[2], sizeTheme.size(l), elementScale, groupOffset + j);\n        }\n    }\n    return builder.getText();\n}\n"],
  "mappings": "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",
  "names": ["_a", "_b", "ElementIterator", "boundaryHelper", "text"]
}
