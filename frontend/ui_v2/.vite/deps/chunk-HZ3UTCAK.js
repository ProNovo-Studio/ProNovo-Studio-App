import {
  BitFlags,
  ChunkedArray,
  ColorMap,
  Column,
  Database,
  EPSILON,
  EquivalenceClasses,
  IntMap,
  IntTuple,
  Interval,
  Iterator,
  LinkedIndex,
  Mat3,
  Mat4,
  NumberTypes,
  OrderedSet,
  Quat,
  Segmentation,
  SortedArray,
  StringBuilder,
  Table,
  Tensor,
  UUID,
  ValueBox,
  Vec2,
  Vec3,
  arrayEqual,
  arrayFind,
  arrayPickIndices,
  arraySwap,
  assertUnreachable,
  canonicalJsonString,
  cantorPairing,
  column_helpers_exports,
  createRangeArray,
  deepClone,
  equalEps,
  getColorListFromName,
  getNumberType,
  hash1,
  hash2,
  hashFnv32a,
  hashString,
  idFactory,
  invertCantorPairing,
  iterableToArray,
  lerp,
  makeBuckets,
  now,
  parseFloat as parseFloat2,
  parseInt as parseInt2,
  radToDeg,
  shallowEqualObjects,
  sort,
  sortArray,
  sortedCantorPairing,
  stringToWords
} from "./chunk-TA3F3DCY.js";
import {
  __export
} from "./chunk-WOOG5QLI.js";

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/coordinates/coordinates.js
function Time(value, unit2) {
  return { value, unit: unit2 };
}
var Coordinates;
(function(Coordinates2) {
  function create(frames, deltaTime, timeOffset) {
    const hasCell = !!frames[0].cell;
    const hasVelocities = !!frames[0].velocities;
    const hasForces = !!frames[0].forces;
    return {
      id: UUID.create22(),
      frames,
      hasCell,
      hasVelocities,
      hasForces,
      deltaTime,
      timeOffset
    };
  }
  Coordinates2.create = create;
  function getAtomicConformation(frame, fields, ordering) {
    var _a, _b;
    let { x, y, z } = frame;
    if (frame.xyzOrdering.frozen) {
      if (ordering) {
        if (frame.xyzOrdering.isIdentity) {
          x = getOrderedCoords(x, ordering);
          y = getOrderedCoords(y, ordering);
          z = getOrderedCoords(z, ordering);
        } else if (!arrayEqual(frame.xyzOrdering.index, ordering)) {
          x = getSourceOrderedCoords(x, frame.xyzOrdering.index, ordering);
          y = getSourceOrderedCoords(y, frame.xyzOrdering.index, ordering);
          z = getSourceOrderedCoords(z, frame.xyzOrdering.index, ordering);
        }
      } else if (!frame.xyzOrdering.isIdentity) {
        x = getInvertedCoords(x, frame.xyzOrdering.index);
        y = getInvertedCoords(y, frame.xyzOrdering.index);
        z = getInvertedCoords(z, frame.xyzOrdering.index);
      }
    } else if (ordering) {
      if (frame.xyzOrdering.isIdentity) {
        frame.xyzOrdering.isIdentity = false;
        frame.xyzOrdering.index = ordering;
        reorderCoordsInPlace(x, ordering);
        reorderCoordsInPlace(y, ordering);
        reorderCoordsInPlace(z, ordering);
      } else {
        if (!arrayEqual(frame.xyzOrdering.index, ordering)) {
          x = getSourceOrderedCoords(x, frame.xyzOrdering.index, ordering);
          y = getSourceOrderedCoords(y, frame.xyzOrdering.index, ordering);
          z = getSourceOrderedCoords(z, frame.xyzOrdering.index, ordering);
        }
      }
    }
    frame.xyzOrdering.frozen = true;
    return {
      id: UUID.create22(),
      atomId: fields.atomId,
      occupancy: (_a = fields.occupancy) !== null && _a !== void 0 ? _a : Column.ofConst(1, frame.elementCount, Column.Schema.int),
      B_iso_or_equiv: (_b = fields.B_iso_or_equiv) !== null && _b !== void 0 ? _b : Column.ofConst(0, frame.elementCount, Column.Schema.float),
      xyzDefined: true,
      x,
      y,
      z
    };
  }
  Coordinates2.getAtomicConformation = getAtomicConformation;
  const _reorderBuffer = [0.123];
  function reorderCoordsInPlace(xs, index) {
    const buffer = _reorderBuffer;
    for (let i = 0, _i = xs.length; i < _i; i++) {
      buffer[i] = xs[index[i]];
    }
    for (let i = 0, _i = xs.length; i < _i; i++) {
      xs[i] = buffer[i];
    }
  }
  function getSourceOrderedCoords(xs, srcIndex, index) {
    const ret = new Float32Array(xs.length);
    for (let i = 0, _i = xs.length; i < _i; i++) {
      ret[i] = xs[srcIndex[index[i]]];
    }
    return ret;
  }
  function getOrderedCoords(xs, index) {
    const ret = new Float32Array(xs.length);
    for (let i = 0, _i = xs.length; i < _i; i++) {
      ret[i] = xs[index[i]];
    }
    return ret;
  }
  function getInvertedCoords(xs, index) {
    const ret = new Float32Array(xs.length);
    for (let i = 0, _i = xs.length; i < _i; i++) {
      ret[index[i]] = xs[i];
    }
    return ret;
  }
})(Coordinates || (Coordinates = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/topology/topology.js
var Topology;
(function(Topology2) {
  function create(label, basic, bonds, format) {
    return {
      id: UUID.create22(),
      label,
      basic,
      sourceData: format,
      bonds
    };
  }
  Topology2.create = create;
})(Topology || (Topology = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/custom-property.js
function CustomPropertyDescriptor(desc) {
  return desc;
}
(function(CustomPropertyDescriptor2) {
  function getUUID(prop) {
    if (!prop.__key) {
      prop.__key = UUID.create22();
    }
    return prop.__key;
  }
  CustomPropertyDescriptor2.getUUID = getUUID;
})(CustomPropertyDescriptor || (CustomPropertyDescriptor = {}));
var CustomProperties = class {
  constructor() {
    this._list = [];
    this._set = /* @__PURE__ */ new Set();
    this._refs = /* @__PURE__ */ new Map();
    this._assets = /* @__PURE__ */ new Map();
  }
  get all() {
    return this._list;
  }
  add(desc) {
    if (this._set.has(desc))
      return;
    this._list.push(desc);
    this._set.add(desc);
  }
  reference(desc, add) {
    let refs = this._refs.get(desc) || 0;
    refs += add ? 1 : -1;
    this._refs.set(desc, Math.max(refs, 0));
  }
  hasReference(desc) {
    return (this._refs.get(desc) || 0) > 0;
  }
  has(desc) {
    return this._set.has(desc);
  }
  /** Sets assets for a prop, disposes of existing assets for that prop */
  assets(desc, assets) {
    const prevAssets = this._assets.get(desc);
    if (prevAssets) {
      for (const a of prevAssets)
        a.dispose();
    }
    if (assets)
      this._assets.set(desc, assets);
    else
      this._assets.delete(desc);
  }
  /** Disposes of all assets of all props */
  dispose() {
    this._assets.forEach((assets) => {
      for (const a of assets)
        a.dispose();
    });
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/array.js
function arrayMax(array2) {
  let max = -Infinity;
  for (let i = 0, il = array2.length; i < il; ++i) {
    if (array2[i] > max)
      max = array2[i];
  }
  return max;
}
function arrayMin(array2) {
  let min = Infinity;
  for (let i = 0, il = array2.length; i < il; ++i) {
    if (array2[i] < min)
      min = array2[i];
  }
  return min;
}
function arrayMinMax(array2) {
  let min = Infinity;
  let max = -Infinity;
  for (let i = 0, il = array2.length; i < il; ++i) {
    if (array2[i] < min)
      min = array2[i];
    if (array2[i] > max)
      max = array2[i];
  }
  return [min, max];
}
function arraySum(array2, stride = 1, offset = 0) {
  const n = array2.length;
  let sum = 0;
  for (let i = offset; i < n; i += stride) {
    sum += array2[i];
  }
  return sum;
}
function arrayMean(array2, stride = 1, offset = 0) {
  return arraySum(array2, stride, offset) / (array2.length / stride);
}
function arrayRms(array2) {
  const n = array2.length;
  let sumSq = 0;
  for (let i = 0; i < n; ++i) {
    const di = array2[i];
    sumSq += di * di;
  }
  return Math.sqrt(sumSq / n);
}
function fillSerial(array2, n) {
  for (let i = 0, il = n ? Math.min(n, array2.length) : array2.length; i < il; ++i)
    array2[i] = i;
  return array2;
}
function arrayRemoveInPlace(xs, x) {
  let i = 0, found = false;
  for (const il = xs.length; i < il; i++) {
    if (xs[i] === x) {
      found = true;
      break;
    }
  }
  if (!found)
    return false;
  arrayRemoveAtInPlace(xs, i);
  return true;
}
function arrayRemoveAtInPlace(xs, idx) {
  for (let i = idx, _i = xs.length - 1; i < _i; i++) {
    xs[i] = xs[i + 1];
  }
  xs.pop();
}
function arraySetAdd(xs, x) {
  if (xs.indexOf(x) >= 0)
    return false;
  xs.push(x);
  return true;
}
function arraySetRemove(xs, x) {
  const idx = xs.indexOf(x);
  if (idx < 0)
    return false;
  for (let i = idx, _i = xs.length - 1; i < _i; i++) {
    xs[i] = xs[i + 1];
  }
  xs.pop();
  return true;
}
function arrayIntersectionSize(xs, ys) {
  let count = 0;
  for (let i = 0, il = xs.length; i < il; ++i) {
    if (ys.includes(xs[i]))
      count += 1;
  }
  return count;
}
function arrayEqual2(xs, ys) {
  if (!xs || xs.length === 0)
    return !ys || ys.length === 0;
  if (!ys)
    return false;
  const lenX = xs.length;
  if (lenX !== ys.length)
    return false;
  for (let i = 0; i < lenX; i++) {
    if (xs[i] !== ys[i])
      return false;
  }
  return true;
}
function arrayIsIdentity(xs) {
  for (let i = 0, _i = xs.length; i < _i; i++) {
    if (xs[i] !== i)
      return false;
  }
  return true;
}
function arrayMapUpsert(xs, key, value) {
  for (let i = 0, il = xs.length; i < il; ++i) {
    if (xs[i][0] === key) {
      xs[i][1] = value;
      return;
    }
  }
  xs.push([key, value]);
}
function range(start, end) {
  if (end === void 0) {
    end = start;
    start = 0;
  }
  const length = Math.max(end - start, 0);
  const result2 = Array(length);
  for (let i = 0; i < length; i++) {
    result2[i] = start + i;
  }
  return result2;
}
function arrayExtend(dst, src) {
  const offset = dst.length;
  const nCopy = src.length;
  dst.length += nCopy;
  for (let i = 0; i < nCopy; i++) {
    dst[offset + i] = src[i];
  }
  return dst;
}
function sortIfNeeded(array2, compareFn) {
  return arrayIsSorted(array2, compareFn) ? array2 : array2.sort(compareFn);
}
function arrayIsSorted(array2, compareFn) {
  for (let i = 1, n = array2.length; i < n; i++) {
    if (compareFn(array2[i - 1], array2[i]) > 0) {
      return false;
    }
  }
  return true;
}
function filterInPlace(array2, predicate) {
  const n = array2.length;
  let iDest = 0;
  for (let iSrc = 0; iSrc < n; iSrc++) {
    if (predicate(array2[iSrc])) {
      array2[iDest++] = array2[iSrc];
    }
  }
  array2.length = iDest;
  return array2;
}
function arrayDistinct(values) {
  const seen = /* @__PURE__ */ new Set();
  const result2 = [];
  for (const value of values) {
    const key = canonicalJsonString(value);
    if (!seen.has(key)) {
      seen.add(key);
      result2.push(value);
    }
  }
  return result2;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/util.js
function calcModelCenter(atomicConformation, coarseConformation) {
  const rangesX = [];
  const rangesY = [];
  const rangesZ = [];
  if (atomicConformation.x.length) {
    rangesX.push(...arrayMinMax(atomicConformation.x));
    rangesY.push(...arrayMinMax(atomicConformation.y));
    rangesZ.push(...arrayMinMax(atomicConformation.z));
  }
  if (coarseConformation) {
    if (coarseConformation.spheres.x.length) {
      rangesX.push(...arrayMinMax(coarseConformation.spheres.x));
      rangesY.push(...arrayMinMax(coarseConformation.spheres.y));
      rangesZ.push(...arrayMinMax(coarseConformation.spheres.z));
    }
    if (coarseConformation.gaussians.x.length) {
      rangesX.push(...arrayMinMax(coarseConformation.gaussians.x));
      rangesY.push(...arrayMinMax(coarseConformation.gaussians.y));
      rangesZ.push(...arrayMinMax(coarseConformation.gaussians.z));
    }
  }
  const [minX, maxX] = arrayMinMax(rangesX);
  const [minY, maxY] = arrayMinMax(rangesY);
  const [minZ, maxZ] = arrayMinMax(rangesZ);
  const x = minX + (maxX - minX) / 2;
  const y = minY + (maxY - minY) / 2;
  const z = minZ + (maxZ - minZ) / 2;
  return Vec3.create(x, y, z);
}
function getAsymIdCount(model) {
  const auth = /* @__PURE__ */ new Set();
  const label = /* @__PURE__ */ new Set();
  model.properties.structAsymMap.forEach(({ auth_id }, label_id) => {
    auth.add(auth_id);
    label.add(label_id);
  });
  return { auth: auth.size, label: label.size };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-task/util/scheduler.js
function createImmediateActions() {
  const thisGlobal = function() {
    const _window = typeof window !== "undefined" && window;
    const _self = typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self;
    const _global = typeof global !== "undefined" && global;
    return _window || _global || _self;
  }();
  const tasksByHandle = {};
  const doc = typeof document !== "undefined" ? document : void 0;
  let nextHandle = 1;
  let registerImmediate;
  function setImmediate2(callback, ...args) {
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    }
    const task = { callback, args };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }
  function clearImmediate2(handle) {
    delete tasksByHandle[handle];
  }
  function run(task) {
    const callback = task.callback;
    const args = task.args;
    switch (args.length) {
      case 0:
        callback();
        break;
      case 1:
        callback(args[0]);
        break;
      case 2:
        callback(args[0], args[1]);
        break;
      case 3:
        callback(args[0], args[1], args[2]);
        break;
      default:
        callback.apply(void 0, args);
        break;
    }
  }
  function runIfPresent(handle) {
    const task = tasksByHandle[handle];
    clearImmediate2(handle);
    run(task);
  }
  function installNextTickImplementation() {
    registerImmediate = function(handle) {
      process.nextTick(function() {
        runIfPresent(handle);
      });
    };
  }
  function canUsePostMessage() {
    if (thisGlobal && thisGlobal.postMessage && !thisGlobal.importScripts) {
      let postMessageIsAsynchronous = true;
      const oldOnMessage = thisGlobal.onmessage;
      thisGlobal.onmessage = function() {
        postMessageIsAsynchronous = false;
      };
      thisGlobal.postMessage("", "*");
      thisGlobal.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }
  function installPostMessageImplementation() {
    const messagePrefix = "setImmediate$" + Math.random() + "$";
    const onGlobalMessage = function(event) {
      if (event.source === thisGlobal && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };
    if (window.addEventListener) {
      window.addEventListener("message", onGlobalMessage, false);
    } else {
      window.attachEvent("onmessage", onGlobalMessage);
    }
    registerImmediate = function(handle) {
      window.postMessage(messagePrefix + handle, "*");
    };
  }
  function installMessageChannelImplementation() {
    const channel = new MessageChannel();
    channel.port1.onmessage = function(event) {
      const handle = event.data;
      runIfPresent(handle);
    };
    registerImmediate = function(handle) {
      channel.port2.postMessage(handle);
    };
  }
  function installReadyStateChangeImplementation() {
    const html = doc.documentElement;
    registerImmediate = function(handle) {
      let script = doc.createElement("script");
      script.onreadystatechange = function() {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };
      html.appendChild(script);
    };
  }
  function installSetTimeoutImplementation() {
    registerImmediate = function(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  }
  if (typeof process !== "undefined" && {}.toString.call(process) === "[object process]") {
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    installPostMessageImplementation();
  } else if (typeof MessageChannel !== "undefined") {
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    installReadyStateChangeImplementation();
  } else {
    installSetTimeoutImplementation();
  }
  return {
    setImmediate: setImmediate2,
    clearImmediate: clearImmediate2
  };
}
var immediateActions = function() {
  if (typeof setImmediate !== "undefined") {
    if (typeof window !== "undefined") {
      return {
        setImmediate: (handler, ...args) => window.setImmediate(handler, ...args),
        clearImmediate: (handle) => window.clearImmediate(handle)
      };
    } else {
      return { setImmediate, clearImmediate };
    }
  }
  return createImmediateActions();
}();
function resolveImmediate(res) {
  immediateActions.setImmediate(res);
}
var Scheduler = {
  setImmediate: immediateActions.setImmediate,
  clearImmediate: immediateActions.clearImmediate,
  immediatePromise() {
    return new Promise(resolveImmediate);
  },
  delay(timeout, value = void 0) {
    return new Promise((r) => setTimeout(r, timeout, value));
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/debug.js
var isProductionMode = function() {
  try {
    return false;
  } catch (_a) {
    return false;
  }
}();
var isDebugMode = function getIsDebug() {
  try {
    const val = process.env.DEBUG;
    return val === "*" || val === "molstar";
  } catch (_a) {
    return false;
  }
}();
var isTimingMode = false;
var consoleStatsProviders = [];
function addConsoleStatsProvider(p3) {
  if (!consoleStatsProviders.includes(p3))
    consoleStatsProviders.push(p3);
}
function removeConsoleStatsProvider(p3) {
  const idx = consoleStatsProviders.indexOf(p3);
  if (idx !== -1)
    consoleStatsProviders.splice(idx, 1);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-task/util/user-timing.js
var hasPerformance = typeof performance !== "undefined" && !!performance.mark && performance.measure;
var timingEnabled = hasPerformance && isTimingMode;
var UserTiming;
(function(UserTiming2) {
  function startMarkName(task) {
    return `startTask${task.id}`;
  }
  function endMarkName(task) {
    return `endTask${task.id}`;
  }
  function markStart(task) {
    if (timingEnabled)
      performance.mark(startMarkName(task));
  }
  UserTiming2.markStart = markStart;
  function markEnd(task) {
    if (timingEnabled)
      performance.mark(endMarkName(task));
  }
  UserTiming2.markEnd = markEnd;
  function measure(task) {
    if (timingEnabled)
      performance.measure(`✳️ ${task.name}`, startMarkName(task), endMarkName(task));
  }
  UserTiming2.measure = measure;
})(UserTiming || (UserTiming = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-task/execution/observable.js
function ExecuteObservable(task, observer, updateRateMs = 250) {
  const info = ProgressInfo(task, observer, updateRateMs);
  const ctx = new ObservableRuntimeContext(info, info.root);
  return execute(task, ctx);
}
function CreateObservableCtx(task, observer, updateRateMs = 250) {
  const info = ProgressInfo(task, observer, updateRateMs);
  return new ObservableRuntimeContext(info, info.root);
}
function ExecuteInContext(ctx, task) {
  return execute(task, ctx);
}
function ExecuteObservableChild(ctx, task, progress) {
  return ctx.runChild(task, progress);
}
function defaultProgress(task) {
  return {
    taskId: task.id,
    taskName: task.name,
    message: "",
    startedTime: 0,
    canAbort: true,
    isIndeterminate: true,
    current: 0,
    max: 0
  };
}
function ProgressInfo(task, observer, updateRateMs) {
  const abortToken = { abortRequested: false, treeAborted: false, reason: "" };
  return {
    updateRateMs,
    lastNotified: now(),
    observer,
    abortToken,
    taskId: task.id,
    root: { progress: defaultProgress(task), children: [] },
    tryAbort: createAbortFunction(abortToken)
  };
}
function createAbortFunction(token) {
  return (reason) => {
    token.abortRequested = true;
    token.reason = reason || token.reason;
  };
}
function cloneTree(root) {
  return { progress: { ...root.progress }, children: root.children.map(cloneTree) };
}
function canAbort(root) {
  return root.progress.canAbort && root.children.every(canAbort);
}
function snapshotProgress(info) {
  return { root: cloneTree(info.root), canAbort: canAbort(info.root), requestAbort: info.tryAbort };
}
async function execute(task, ctx) {
  UserTiming.markStart(task);
  ctx.node.progress.startedTime = now();
  try {
    const ret = await task.f(ctx);
    UserTiming.markEnd(task);
    UserTiming.measure(task);
    if (ctx.info.abortToken.abortRequested) {
      abort(ctx.info);
    }
    return ret;
  } catch (e) {
    if (Task.isAbort(e)) {
      ctx.isAborted = true;
      if (ctx.node.children.length > 0) {
        await new Promise((res) => {
          ctx.onChildrenFinished = res;
        });
      }
      if (task.onAbort) {
        task.onAbort();
      }
    }
    throw e;
  }
}
function abort(info) {
  if (!info.abortToken.treeAborted) {
    info.abortToken.treeAborted = true;
    abortTree(info.root);
    notifyObserver(info, now());
  }
  throw Task.Aborted(info.abortToken.reason);
}
function abortTree(root) {
  const progress = root.progress;
  progress.isIndeterminate = true;
  progress.canAbort = false;
  progress.message = "Aborting...";
  for (const c of root.children)
    abortTree(c);
}
function notifyObserver(info, time) {
  info.lastNotified = time;
  const snapshot = snapshotProgress(info);
  info.observer(snapshot);
}
var ObservableRuntimeContext = class _ObservableRuntimeContext {
  checkAborted() {
    if (this.info.abortToken.abortRequested) {
      this.isAborted = true;
      abort(this.info);
    }
  }
  get shouldUpdate() {
    this.checkAborted();
    return now() - this.lastUpdatedTime > this.info.updateRateMs;
  }
  updateProgress(update) {
    this.checkAborted();
    if (!update)
      return;
    const progress = this.node.progress;
    if (typeof update === "string") {
      progress.message = update;
      progress.isIndeterminate = true;
    } else {
      if (typeof update.canAbort !== "undefined")
        progress.canAbort = update.canAbort;
      if (typeof update.message !== "undefined")
        progress.message = update.message;
      if (typeof update.current !== "undefined")
        progress.current = update.current;
      if (typeof update.max !== "undefined")
        progress.max = update.max;
      progress.isIndeterminate = typeof progress.current === "undefined" || typeof progress.max === "undefined";
      if (typeof update.isIndeterminate !== "undefined")
        progress.isIndeterminate = update.isIndeterminate;
    }
  }
  update(progress, dontNotify) {
    this.lastUpdatedTime = now();
    this.updateProgress(progress);
    if (!!dontNotify)
      return;
    notifyObserver(this.info, this.lastUpdatedTime);
    this.checkAborted();
    return Scheduler.immediatePromise();
  }
  async runChild(task, progress) {
    this.updateProgress(progress);
    const node = { progress: defaultProgress(task), children: [] };
    const children = this.node.children;
    children.push(node);
    const ctx = new _ObservableRuntimeContext(this.info, node);
    try {
      return await execute(task, ctx);
    } catch (e) {
      if (Task.isAbort(e)) {
        if (this.isAborted)
          return void 0;
      }
      throw e;
    } finally {
      const idx = children.indexOf(node);
      if (idx >= 0) {
        for (let i = idx, _i = children.length - 1; i < _i; i++) {
          children[i] = children[i + 1];
        }
        children.pop();
      }
      if (children.length === 0 && this.onChildrenFinished)
        this.onChildrenFinished();
    }
  }
  constructor(info, node) {
    this.isSynchronous = false;
    this.isExecuting = true;
    this.lastUpdatedTime = 0;
    this.onChildrenFinished = void 0;
    this.node = node;
    this.info = info;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-task/execution/synchronous.js
var SynchronousRuntimeContext = class {
  constructor() {
    this.shouldUpdate = false;
    this.isSynchronous = true;
  }
  update(progress, dontNotify) {
  }
};
var SyncRuntimeContext = new SynchronousRuntimeContext();

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-task/task.js
var Task;
(function(Task2) {
  class Impl {
    run(observer, updateRateMs = 250) {
      if (observer)
        return ExecuteObservable(this, observer, updateRateMs);
      return this.f(SyncRuntimeContext);
    }
    runAsChild(ctx, progress) {
      if (ctx.isSynchronous)
        return this.f(SyncRuntimeContext);
      return ExecuteObservableChild(ctx, this, progress);
    }
    runInContext(ctx) {
      if (ctx.isSynchronous)
        return this.f(SyncRuntimeContext);
      return ExecuteInContext(ctx, this);
    }
    constructor(name, f, onAbort) {
      this.name = name;
      this.f = f;
      this.onAbort = onAbort;
      this.id = getNextId();
    }
  }
  function is(t) {
    const _t = t;
    return !!t && typeof _t.id === "number" && typeof _t.name === "string" && !!_t.run;
  }
  Task2.is = is;
  function isAbort(e) {
    return !!e && !!e.isAborted;
  }
  Task2.isAbort = isAbort;
  function Aborted(reason) {
    return { isAborted: true, reason, toString() {
      return `Aborted${reason ? ": " + reason : ""}`;
    } };
  }
  Task2.Aborted = Aborted;
  function create(name, f, onAbort) {
    return new Impl(name, f, onAbort);
  }
  Task2.create = create;
  function constant2(name, value) {
    return create(name, async (ctx) => value);
  }
  Task2.constant = constant2;
  function empty() {
    return create("", async (ctx) => {
    });
  }
  Task2.empty = empty;
  function fail(name, reason) {
    return create(name, async (ctx) => {
      throw new Error(reason);
    });
  }
  Task2.fail = fail;
  function resolveInContext(object, ctx) {
    if (is(object))
      return ctx ? object.runInContext(ctx) : object.run();
    return object;
  }
  Task2.resolveInContext = resolveInContext;
  const getNextId = idFactory(0, 1073741823);
})(Task || (Task = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-task/execution/runtime-context.js
var RuntimeContext;
(function(RuntimeContext2) {
  RuntimeContext2.Synchronous = SyncRuntimeContext;
})(RuntimeContext || (RuntimeContext = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-task/execution/progress.js
var Progress;
(function(Progress2) {
  function _format(root, prefix = "") {
    const p3 = root.progress;
    if (!root.children.length) {
      if (p3.isIndeterminate)
        return `${prefix}${p3.taskName}: ${p3.message}`;
      return `${prefix}${p3.taskName}: [${p3.current}/${p3.max}] ${p3.message}`;
    }
    const newPrefix = prefix + "  |_ ";
    const subTree = root.children.map((c) => _format(c, newPrefix));
    if (p3.isIndeterminate)
      return `${prefix}${p3.taskName}: ${p3.message}
${subTree.join("\n")}`;
    return `${prefix}${p3.taskName}: [${p3.current}/${p3.max}] ${p3.message}
${subTree.join("\n")}`;
  }
  function format(p3) {
    return _format(p3.root);
  }
  Progress2.format = format;
})(Progress || (Progress = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-task/util/chunked.js
async function chunkedSubtask(ctx, initialChunk, state, f, update) {
  let chunkSize = Math.max(initialChunk, 0);
  let globalProcessed = 0, globalTime = 0;
  if (ctx.isSynchronous) {
    f(Number.MAX_SAFE_INTEGER, state);
    return state;
  }
  let start = now();
  let lastSize = 0, currentTime = 0;
  while ((lastSize = f(chunkSize, state)) > 0) {
    globalProcessed += lastSize;
    const delta2 = now() - start;
    currentTime += delta2;
    globalTime += delta2;
    if (ctx.shouldUpdate) {
      await update(ctx, state, globalProcessed);
      chunkSize = Math.round(currentTime * globalProcessed / globalTime) + 1;
      start = now();
      currentTime = 0;
    }
  }
  if (ctx.shouldUpdate) {
    await update(ctx, state, globalProcessed);
  }
  return state;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/graph/int-adjacency-graph.js
var IntAdjacencyGraph;
(function(IntAdjacencyGraph2) {
  function areEqual(a, b) {
    if (a === b)
      return true;
    if (a.vertexCount !== b.vertexCount || a.edgeCount !== b.edgeCount)
      return false;
    const { a: aa, b: ab, offset: ao } = a;
    const { a: ba, b: bb, offset: bo } = b;
    for (let i = 0, _i = a.a.length; i < _i; i++) {
      if (aa[i] !== ba[i])
        return false;
    }
    for (let i = 0, _i = a.b.length; i < _i; i++) {
      if (ab[i] !== bb[i])
        return false;
    }
    for (let i = 0, _i = a.offset.length; i < _i; i++) {
      if (ao[i] !== bo[i])
        return false;
    }
    for (const k of Object.keys(a.edgeProps)) {
      const pa = a.edgeProps[k], pb = b.edgeProps[k];
      if (!pb)
        return false;
      for (let i = 0, _i = pa.length; i < _i; i++) {
        if (pa[i] !== pb[i])
          return false;
      }
    }
    return true;
  }
  IntAdjacencyGraph2.areEqual = areEqual;
  class IntGraphImpl {
    getEdgeIndex(i, j) {
      let a, b;
      if (i < j) {
        a = i;
        b = j;
      } else {
        a = j;
        b = i;
      }
      for (let t = this.offset[a], _t = this.offset[a + 1]; t < _t; t++) {
        if (this.b[t] === b)
          return t;
      }
      return -1;
    }
    getDirectedEdgeIndex(i, j) {
      for (let t = this.offset[i], _t = this.offset[i + 1]; t < _t; t++) {
        if (this.b[t] === j)
          return t;
      }
      return -1;
    }
    getVertexEdgeCount(i) {
      return this.offset[i + 1] - this.offset[i];
    }
    constructor(offset, a, b, edgeCount, edgeProps, props) {
      this.offset = offset;
      this.a = a;
      this.b = b;
      this.edgeCount = edgeCount;
      this.props = props;
      this.vertexCount = offset.length - 1;
      this.edgeProps = edgeProps || {};
    }
  }
  function create(offset, a, b, edgeCount, edgeProps, props) {
    return new IntGraphImpl(offset, a, b, edgeCount, edgeProps, props);
  }
  IntAdjacencyGraph2.create = create;
  class EdgeBuilder {
    createGraph(edgeProps, props) {
      return create(this.offsets, this.a, this.b, this.edgeCount, edgeProps, props);
    }
    /**
     * @example
     *   const property = new Int32Array(builder.slotCount);
     *   for (let i = 0; i < builder.edgeCount; i++) {
     *     builder.addNextEdge();
     *     builder.assignProperty(property, srcProp[i]);
     *   }
     *   return builder.createGraph({ property });
     */
    addNextEdge() {
      const a = this.xs[this.current], b = this.ys[this.current];
      const oa = this.offsets[a] + this.bucketFill[a];
      this.a[oa] = a;
      this.b[oa] = b;
      this.bucketFill[a]++;
      const ob = this.offsets[b] + this.bucketFill[b];
      this.a[ob] = b;
      this.b[ob] = a;
      this.bucketFill[b]++;
      this.current++;
      this.curA = oa;
      this.curB = ob;
    }
    /** Builds property-less graph */
    addAllEdges() {
      for (let i = 0; i < this.edgeCount; i++) {
        this.addNextEdge();
      }
    }
    assignProperty(prop, value) {
      prop[this.curA] = value;
      prop[this.curB] = value;
    }
    assignDirectedProperty(propA, valueA, propB, valueB) {
      propA[this.curA] = valueA;
      propA[this.curB] = valueB;
      propB[this.curB] = valueA;
      propB[this.curA] = valueB;
    }
    constructor(vertexCount, xs, ys) {
      this.vertexCount = vertexCount;
      this.xs = xs;
      this.ys = ys;
      this.current = 0;
      this.curA = 0;
      this.curB = 0;
      this.edgeCount = xs.length;
      this.offsets = new Int32Array(this.vertexCount + 1);
      this.bucketFill = new Int32Array(this.vertexCount);
      const bucketSizes = new Int32Array(this.vertexCount);
      for (let i = 0, _i = this.xs.length; i < _i; i++)
        bucketSizes[this.xs[i]]++;
      for (let i = 0, _i = this.ys.length; i < _i; i++)
        bucketSizes[this.ys[i]]++;
      let offset = 0;
      for (let i = 0; i < this.vertexCount; i++) {
        this.offsets[i] = offset;
        offset += bucketSizes[i];
      }
      this.offsets[this.vertexCount] = offset;
      this.slotCount = offset;
      this.a = new Int32Array(offset);
      this.b = new Int32Array(offset);
    }
  }
  IntAdjacencyGraph2.EdgeBuilder = EdgeBuilder;
  class DirectedEdgeBuilder {
    createGraph(edgeProps, props) {
      return create(this.offsets, this.a, this.b, this.edgeCount, edgeProps, props);
    }
    /**
     * @example
     *   const property = new Int32Array(builder.slotCount);
     *   for (let i = 0; i < builder.edgeCount; i++) {
     *     builder.addNextEdge();
     *     builder.assignProperty(property, srcProp[i]);
     *   }
     *   return builder.createGraph({ property });
     */
    addNextEdge() {
      const a = this.xs[this.current], b = this.ys[this.current];
      const oa = this.offsets[a] + this.bucketFill[a];
      this.a[oa] = a;
      this.b[oa] = b;
      this.bucketFill[a]++;
      this.current++;
      this.curA = oa;
    }
    /** Builds property-less graph */
    addAllEdges() {
      for (let i = 0; i < this.edgeCount; i++) {
        this.addNextEdge();
      }
    }
    assignProperty(prop, value) {
      prop[this.curA] = value;
    }
    constructor(vertexCount, xs, ys) {
      this.vertexCount = vertexCount;
      this.xs = xs;
      this.ys = ys;
      this.current = 0;
      this.curA = 0;
      this.edgeCount = xs.length;
      this.offsets = new Int32Array(this.vertexCount + 1);
      this.bucketFill = new Int32Array(this.vertexCount);
      const bucketSizes = new Int32Array(this.vertexCount);
      for (let i = 0, _i = this.xs.length; i < _i; i++)
        bucketSizes[this.xs[i]]++;
      let offset = 0;
      for (let i = 0; i < this.vertexCount; i++) {
        this.offsets[i] = offset;
        offset += bucketSizes[i];
      }
      this.offsets[this.vertexCount] = offset;
      this.slotCount = offset;
      this.a = new Int32Array(offset);
      this.b = new Int32Array(offset);
    }
  }
  IntAdjacencyGraph2.DirectedEdgeBuilder = DirectedEdgeBuilder;
  class UniqueEdgeBuilder {
    addEdge(i, j) {
      let u = i, v = j;
      if (i > j) {
        u = j;
        v = i;
      }
      const id = cantorPairing(u, v);
      if (this.included.has(id))
        return false;
      this.included.add(id);
      this.xs[this.xs.length] = u;
      this.ys[this.ys.length] = v;
      return true;
    }
    getGraph() {
      return fromVertexPairs(this.vertexCount, this.xs, this.ys);
    }
    // if we cant to add custom props as well
    getEdgeBuiler() {
      return new EdgeBuilder(this.vertexCount, this.xs, this.ys);
    }
    constructor(vertexCount) {
      this.vertexCount = vertexCount;
      this.xs = [];
      this.ys = [];
      this.included = /* @__PURE__ */ new Set();
    }
  }
  IntAdjacencyGraph2.UniqueEdgeBuilder = UniqueEdgeBuilder;
  function fromVertexPairs(vertexCount, xs, ys) {
    const graphBuilder = new IntAdjacencyGraph2.EdgeBuilder(vertexCount, xs, ys);
    graphBuilder.addAllEdges();
    return graphBuilder.createGraph({});
  }
  IntAdjacencyGraph2.fromVertexPairs = fromVertexPairs;
  function induceByVertices(graph, vertexIndices, props) {
    const { b, offset, vertexCount, edgeProps } = graph;
    const vertexMap = new Int32Array(vertexCount);
    for (let i = 0, _i = vertexIndices.length; i < _i; i++)
      vertexMap[vertexIndices[i]] = i + 1;
    let newEdgeCount = 0;
    for (let i = 0; i < vertexCount; i++) {
      if (vertexMap[i] === 0)
        continue;
      for (let j = offset[i], _j = offset[i + 1]; j < _j; j++) {
        if (b[j] > i && vertexMap[b[j]] !== 0)
          newEdgeCount++;
      }
    }
    const newOffsets = new Int32Array(vertexIndices.length + 1);
    const edgeIndices = new Int32Array(2 * newEdgeCount);
    const newA = new Int32Array(2 * newEdgeCount);
    const newB = new Int32Array(2 * newEdgeCount);
    let eo = 0, vo = 0;
    for (let i = 0; i < vertexCount; i++) {
      if (vertexMap[i] === 0)
        continue;
      const aa = vertexMap[i] - 1;
      for (let j = offset[i], _j = offset[i + 1]; j < _j; j++) {
        const bb = vertexMap[b[j]];
        if (bb === 0)
          continue;
        newA[eo] = aa;
        newB[eo] = bb - 1;
        edgeIndices[eo] = j;
        eo++;
      }
      newOffsets[++vo] = eo;
    }
    const newEdgeProps = {};
    for (const key of Object.keys(edgeProps)) {
      newEdgeProps[key] = arrayPickIndices(edgeProps[key], edgeIndices);
    }
    return create(newOffsets, newA, newB, newEdgeCount, newEdgeProps, props);
  }
  IntAdjacencyGraph2.induceByVertices = induceByVertices;
  function connectedComponents(graph) {
    const vCount = graph.vertexCount;
    if (vCount === 0)
      return { componentCount: 0, componentIndex: new Int32Array(0) };
    if (graph.edgeCount === 0) {
      const componentIndex2 = new Int32Array(vCount);
      for (let i = 0, _i = vCount; i < _i; i++) {
        componentIndex2[i] = i;
      }
      return { componentCount: vCount, componentIndex: componentIndex2 };
    }
    const componentIndex = new Int32Array(vCount);
    for (let i = 0, _i = vCount; i < _i; i++)
      componentIndex[i] = -1;
    let currentComponent = 0;
    componentIndex[0] = currentComponent;
    const { offset, b: neighbor } = graph;
    const stack = [0];
    const list2 = LinkedIndex(vCount);
    list2.remove(0);
    while (stack.length > 0) {
      const v = stack.pop();
      const cIdx = componentIndex[v];
      for (let eI = offset[v], _eI = offset[v + 1]; eI < _eI; eI++) {
        const n = neighbor[eI];
        if (!list2.has(n))
          continue;
        list2.remove(n);
        stack.push(n);
        componentIndex[n] = cIdx;
      }
      if (stack.length === 0 && list2.head >= 0) {
        stack.push(list2.head);
        componentIndex[list2.head] = ++currentComponent;
        list2.remove(list2.head);
      }
    }
    return { componentCount: vCount, componentIndex };
  }
  IntAdjacencyGraph2.connectedComponents = connectedComponents;
  function areVertexSetsConnected(graph, verticesA, verticesB, maxDistance) {
    if (SortedArray.areIntersecting(verticesA, verticesB))
      return true;
    if (maxDistance < 1)
      return false;
    const visited = /* @__PURE__ */ new Set();
    for (let i = 0, il = verticesA.length; i < il; ++i) {
      visited.add(verticesA[i]);
    }
    return areVertexSetsConnectedImpl(graph, verticesA, verticesB, maxDistance, visited);
  }
  IntAdjacencyGraph2.areVertexSetsConnected = areVertexSetsConnected;
})(IntAdjacencyGraph || (IntAdjacencyGraph = {}));
function areVertexSetsConnectedImpl(graph, frontier, target, distance, visited) {
  const { b: neighbor, offset } = graph;
  const newFrontier = [];
  for (let i = 0, il = frontier.length; i < il; ++i) {
    const src = frontier[i];
    for (let j = offset[src], jl = offset[src + 1]; j < jl; ++j) {
      const other = neighbor[j];
      if (visited.has(other))
        continue;
      if (SortedArray.has(target, other))
        return true;
      visited.add(other);
      newFrontier[newFrontier.length] = other;
    }
  }
  return distance > 1 ? areVertexSetsConnectedImpl(graph, newFrontier, target, distance - 1, visited) : false;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/common/property.js
var FormatRegistry = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
    this.applicable = /* @__PURE__ */ new Map();
  }
  add(kind, obtain, applicable) {
    this.map.set(kind, obtain);
    if (applicable)
      this.applicable.set(kind, applicable);
  }
  remove(kind) {
    this.map.delete(kind);
    this.applicable.delete(kind);
  }
  get(kind) {
    return this.map.get(kind);
  }
  isApplicable(model) {
    if (!this.map.has(model.sourceData.kind))
      return false;
    const isApplicable = this.applicable.get(model.sourceData.kind);
    return isApplicable ? isApplicable(model) : true;
  }
};
var FormatPropertyProvider;
(function(FormatPropertyProvider2) {
  function create(descriptor, options) {
    const { name } = descriptor;
    const formatRegistry = new FormatRegistry();
    return {
      descriptor,
      formatRegistry,
      isApplicable(model) {
        return formatRegistry.isApplicable(model);
      },
      get(model) {
        const store = (options === null || options === void 0 ? void 0 : options.asDynamic) ? model._dynamicPropertyData : model._staticPropertyData;
        if (store[name])
          return store[name];
        if (model.customProperties.has(descriptor))
          return;
        const obtain = formatRegistry.get(model.sourceData.kind);
        if (!obtain)
          return;
        store[name] = obtain(model);
        model.customProperties.add(descriptor);
        return store[name];
      },
      set(model, value) {
        if (options === null || options === void 0 ? void 0 : options.asDynamic) {
          model._dynamicPropertyData[name] = value;
        } else {
          model._staticPropertyData[name] = value;
        }
      },
      delete(model) {
        if (options === null || options === void 0 ? void 0 : options.asDynamic) {
          delete model._dynamicPropertyData[name];
        } else {
          delete model._staticPropertyData[name];
        }
      }
    };
  }
  FormatPropertyProvider2.create = create;
})(FormatPropertyProvider || (FormatPropertyProvider = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/types.js
var types_exports = {};
__export(types_exports, {
  AminoAcidNames: () => AminoAcidNames,
  AminoAcidNamesD: () => AminoAcidNamesD,
  AminoAcidNamesL: () => AminoAcidNamesL,
  BaseNames: () => BaseNames,
  BetaProteinComponentTypeNames: () => BetaProteinComponentTypeNames,
  BondType: () => BondType,
  CommonProteinCaps: () => CommonProteinCaps,
  DNAComponentTypeNames: () => DNAComponentTypeNames,
  DProteinComponentTypeNames: () => DProteinComponentTypeNames,
  DefaultMaxAsa: () => DefaultMaxAsa,
  DefaultResidueHydrophobicity: () => DefaultResidueHydrophobicity,
  DnaBaseNames: () => DnaBaseNames,
  ElementSymbol: () => ElementSymbol,
  EntityType: () => EntityType,
  GammaProteinComponentTypeNames: () => GammaProteinComponentTypeNames,
  IonComponentTypeNames: () => IonComponentTypeNames,
  LProteinComponentTypeNames: () => LProteinComponentTypeNames,
  LipidComponentTypeNames: () => LipidComponentTypeNames,
  MaxAsa: () => MaxAsa,
  MoleculeType: () => MoleculeType,
  NucleicBackboneAtoms: () => NucleicBackboneAtoms,
  OtherComponentTypeNames: () => OtherComponentTypeNames,
  OtherProteinComponentTypeNames: () => OtherProteinComponentTypeNames,
  PeptideBaseNames: () => PeptideBaseNames,
  PolymerNames: () => PolymerNames,
  PolymerType: () => PolymerType,
  PolymerTypeAtomRoleId: () => PolymerTypeAtomRoleId,
  ProteinBackboneAtoms: () => ProteinBackboneAtoms,
  ProteinComponentTypeNames: () => ProteinComponentTypeNames,
  ProteinTerminusComponentTypeNames: () => ProteinTerminusComponentTypeNames,
  PurineBaseNames: () => PurineBaseNames,
  PyrimidineBaseNames: () => PyrimidineBaseNames,
  RNAComponentTypeNames: () => RNAComponentTypeNames,
  ResidueHydrophobicity: () => ResidueHydrophobicity,
  RnaBaseNames: () => RnaBaseNames,
  SaccharideComponentTypeNames: () => SaccharideComponentTypeNames,
  SecondaryStructureType: () => SecondaryStructureType,
  WaterNames: () => WaterNames,
  getComponentType: () => getComponentType,
  getDefaultChemicalComponent: () => getDefaultChemicalComponent,
  getElementFromAtomicNumber: () => getElementFromAtomicNumber,
  getEntitySubtype: () => getEntitySubtype,
  getEntityType: () => getEntityType,
  getMoleculeType: () => getMoleculeType,
  getPolymerType: () => getPolymerType,
  isNucleic: () => isNucleic,
  isPolymer: () => isPolymer,
  isProtein: () => isProtein,
  isPurineBase: () => isPurineBase,
  isPyrimidineBase: () => isPyrimidineBase
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/types/saccharides.js
var SaccharideNames = /* @__PURE__ */ new Set(["145", "147", "149", "289", "291", "293", "445", "475", "491", "510", "604", "045", "05L", "07E", "07Y", "08U", "09X", "0AT", "0BD", "0H0", "0HX", "0LP", "0MK", "0NZ", "0TS", "0UB", "0V4", "0WK", "0XY", "0YT", "10M", "12E", "14T", "15L", "16F", "16G", "16O", "17T", "18D", "18O", "18T", "1AR", "1BW", "1CF", "1FT", "1GL", "1GN", "1JB", "1LL", "1NA", "1S3", "1S4", "1SD", "1X4", "20S", "20X", "22O", "22S", "23V", "24S", "25E", "26M", "26O", "26Q", "26R", "26V", "26W", "26Y", "27C", "2DG", "2DR", "2F8", "2FG", "2FL", "2FP", "2GL", "2GS", "2H5", "2HA", "2M4", "2M5", "2M8", "2OS", "2SI", "2WP", "2WS", "32O", "34V", "38J", "3BU", "3CM", "3DO", "3DY", "3FM", "3GR", "3HD", "3J3", "3J4", "3LJ", "3LR", "3MF", "3MG", "3MK", "3R3", "3S6", "3SA", "3YW", "40J", "42D", "44S", "46D", "46M", "46Z", "48Z", "49A", "49S", "49T", "49V", "4AM", "4CQ", "4GC", "4GL", "4GP", "4JA", "4N2", "4NN", "4QY", "4R1", "4RS", "4SG", "4U0", "4U1", "4U2", "4UZ", "4V5", "50A", "51N", "56N", "57S", "5DI", "5GF", "5GO", "5II", "5KQ", "5KS", "5KT", "5KV", "5L2", "5L3", "5LS", "5LT", "5MM", "5N6", "5QP", "5RP", "5SA", "5SP", "5TH", "5TJ", "5TK", "5TM", "61J", "62I", "64K", "66O", "6BG", "6C2", "6DM", "6GB", "6GP", "6GR", "6K3", "6KH", "6KL", "6KS", "6KU", "6KW", "6LA", "6LS", "6LW", "6MJ", "6MN", "6PG", "6PY", "6PZ", "6S2", "6SA", "6UD", "6Y6", "6YR", "6ZC", "73E", "79J", "7CV", "7D1", "7GP", "7JZ", "7K2", "7K3", "7NU", "7SA", "83Y", "89Y", "8B7", "8B9", "8EX", "8GA", "8GG", "8GP", "8I4", "8LM", "8LR", "8OQ", "8PK", "8S0", "8YV", "95Z", "96O", "98U", "9AM", "9C1", "9CD", "9GP", "9KJ", "9MR", "9OK", "9PG", "9QG", "9QZ", "9RN", "9S7", "9SG", "9SJ", "9SM", "9SP", "9T1", "9T7", "9VP", "9WJ", "9WN", "9WZ", "9YW", "A0K", "A1AIO", "A1EKO", "A1H03", "A1H0P", "A1H0Z", "A1H10", "A1H1B", "A1H1F", "A1H1V", "A1IH4", "A1JAQ", "A1L1P", "A1Q", "A2G", "A5C", "A6P", "AAL", "AAO", "ABC", "ABD", "ABE", "ABF", "ABL", "AC1", "ACG", "ACR", "ACX", "ADA", "ADG", "ADR", "AF1", "AFD", "AFL", "AFO", "AFP", "AFR", "AGC", "AGH", "AGL", "AGR", "AH2", "AH8", "AHG", "AHM", "AHR", "AIG", "ALL", "ALX", "AMG", "AMN", "AMU", "AMV", "ANA", "AOG", "AOS", "AQA", "ARA", "ARB", "ARE", "ARI", "ARW", "ASC", "ASG", "ASO", "AXP", "AXR", "AY9", "AZC", "B0D", "B16", "B1H", "B1N", "B2G", "B4G", "B6D", "B7G", "B8D", "B9D", "BBK", "BBV", "BCD", "BCW", "BDF", "BDG", "BDP", "BDR", "BDZ", "BEM", "BFN", "BFP", "BG6", "BG8", "BGC", "BGL", "BGN", "BGP", "BGS", "BHG", "BM3", "BM7", "BMA", "BMX", "BND", "BNG", "BNX", "BO1", "BOG", "BQY", "BRI", "BS7", "BTG", "BTU", "BW3", "BWG", "BXF", "BXP", "BXX", "BXY", "BZD", "C3B", "C3G", "C3X", "C4B", "C4W", "C4X", "C5X", "CAP", "CBF", "CBI", "CBK", "CDR", "CE5", "CE6", "CE8", "CEG", "CEX", "CEY", "CEZ", "CGF", "CJB", "CKB", "CKP", "CNP", "CR1", "CR6", "CRA", "CT3", "CTO", "CTR", "CTT", "D0N", "D1M", "D5E", "D6G", "DAF", "DAG", "DAN", "DDA", "DDB", "DDL", "DEG", "DEL", "DFR", "DFX", "DG0", "DGC", "DGD", "DGM", "DGO", "DGS", "DGU", "DIG", "DJB", "DJE", "DK4", "DKX", "DKZ", "DL6", "DLD", "DLF", "DLG", "DMU", "DNO", "DO8", "DOM", "DP5", "DPC", "DQQ", "DQR", "DR2", "DR3", "DR4", "DR5", "DRI", "DSR", "DT6", "DVC", "DYM", "E3M", "E4P", "E5G", "EAG", "EBG", "EBQ", "ED6", "EEN", "EEQ", "EGA", "EJT", "EMP", "EMZ", "EPG", "EQP", "EQV", "ERE", "ERI", "ETT", "EUS", "F1P", "F1X", "F55", "F58", "F6P", "F8X", "FBP", "FCA", "FCB", "FCT", "FDP", "FDQ", "FFC", "FFX", "FIF", "FIX", "FK9", "FKD", "FMF", "FMO", "FNG", "FNY", "FRU", "FSA", "FSI", "FSM", "FSR", "FSW", "FU4", "FUB", "FUC", "FUD", "FUF", "FUL", "FUY", "FVQ", "FX1", "FYJ", "G0S", "G16", "G1P", "G20", "G28", "G2F", "G3F", "G3I", "G4D", "G4S", "G6D", "G6P", "G6S", "G7P", "G8Z", "GAA", "GAC", "GAD", "GAF", "GAL", "GAT", "GBH", "GC1", "GC4", "GC9", "GCB", "GCD", "GCN", "GCO", "GCS", "GCT", "GCU", "GCV", "GCW", "GDA", "GDL", "GE1", "GE3", "GFP", "GIV", "GL0", "GL1", "GL2", "GL4", "GL5", "GL6", "GL7", "GL9", "GLA", "GLB", "GLC", "GLD", "GLF", "GLG", "GLO", "GLP", "GLS", "GLT", "GLW", "GM0", "GMB", "GMH", "GMT", "GMZ", "GN1", "GN4", "GNS", "GNX", "GP0", "GP1", "GP4", "GPH", "GPK", "GPM", "GPO", "GPQ", "GPU", "GPV", "GPW", "GQ1", "GRF", "GRX", "GS1", "GS4", "GS9", "GSA", "GSD", "GTE", "GTH", "GTK", "GTM", "GTR", "GU0", "GU1", "GU2", "GU3", "GU4", "GU5", "GU6", "GU8", "GU9", "GUF", "GUL", "GUP", "GUZ", "GXL", "GXV", "GYE", "GYG", "GYP", "GYU", "GYV", "GZL", "H1M", "H1S", "H2P", "H3S", "H53", "H6Q", "H6Z", "HBZ", "HD4", "HDL", "HLA", "HMS", "HNV", "HNW", "HSG", "HSH", "HSJ", "HSQ", "HSR", "HSU", "HSX", "HSY", "HSZ", "HTG", "HTM", "HVC", "I57", "IAB", "IDC", "IDF", "IDG", "IDR", "IDS", "IDT", "IDU", "IDX", "IDY", "IEM", "IN1", "IPT", "ISD", "ISL", "ISX", "IVG", "IXD", "J5B", "JFZ", "JHM", "JLT", "JRV", "JS2", "JSV", "JV4", "JVA", "JVS", "JZR", "K5B", "K99", "KBA", "KBG", "KD5", "KDA", "KDB", "KDD", "KDE", "KDF", "KDM", "KDN", "KDO", "KDR", "KFN", "KG1", "KGM", "KHP", "KME", "KO1", "KO2", "KOT", "KQC", "KTU", "L1L", "L6N", "L6S", "L6T", "LAG", "LAH", "LAI", "LAK", "LAO", "LAT", "LB2", "LBS", "LBT", "LCN", "LDY", "LEC", "LER", "LFC", "LFR", "LGC", "LGU", "LKA", "LKS", "LM2", "LMO", "LMT", "LMU", "LNV", "LOG", "LOX", "LPK", "LRH", "LSM", "LTG", "LTM", "LVO", "LVZ", "LXB", "LXC", "LXZ", "LZ0", "M1F", "M1P", "M2F", "M3M", "M3N", "M55", "M6D", "M6P", "M7B", "M7P", "M8C", "MA1", "MA2", "MA3", "MA8", "MAB", "MAF", "MAG", "MAL", "MAN", "MAT", "MAV", "MAW", "MBE", "MBF", "MBG", "MCU", "MDA", "MDP", "MFA", "MFB", "MFU", "MG5", "MGA", "MGC", "MGL", "MGS", "MJJ", "MLB", "MLR", "MMA", "MMN", "MN0", "MNA", "MQG", "MQT", "MRH", "MRP", "MSX", "MTT", "MUB", "MUG", "MUR", "MVP", "MXY", "MXZ", "MYG", "N1L", "N3U", "N9S", "NA1", "NAA", "NAG", "NBG", "NBX", "NBY", "NDG", "NED", "NFG", "NG1", "NG6", "NGA", "NGB", "NGC", "NGE", "NGF", "NGK", "NGL", "NGR", "NGS", "NGY", "NGZ", "NHF", "NLC", "NM6", "NM9", "NNG", "NOJ", "NPF", "NSQ", "NT1", "NTF", "NTO", "NTP", "NXD", "NYT", "O1G", "OAK", "OEL", "OI7", "OPM", "ORP", "OSU", "OTG", "OTN", "OTU", "OX2", "P53", "P6P", "P8E", "PA1", "PA5", "PAV", "PDX", "PH5", "PKM", "PNA", "PNG", "PNJ", "PNW", "PPC", "PRP", "PSG", "PSJ", "PSV", "PTQ", "PUF", "PZU", "QDK", "QIF", "QKH", "QPS", "QV4", "R1P", "R1X", "R2B", "R2G", "R5P", "RAA", "RAE", "RAF", "RAM", "RAO", "RAT", "RB5", "RBL", "RCD", "RDP", "REL", "RER", "RF5", "RG1", "RGG", "RHA", "RHC", "RI2", "RIB", "RIP", "RM4", "RNS", "RNT", "ROB", "ROR", "RP3", "RP5", "RP6", "RPA", "RR7", "RRJ", "RRY", "RST", "RTG", "RTV", "RUB", "RUG", "RUU", "RV7", "RVG", "RVM", "RWI", "RY7", "RZM", "S6P", "S7P", "S81", "SA0", "SCG", "SCR", "SDD", "SDY", "SEJ", "SF6", "SF9", "SFJ", "SFU", "SG4", "SG5", "SG6", "SG7", "SGA", "SGC", "SGD", "SGN", "SGS", "SHB", "SHD", "SHG", "SI3", "SIA", "SID", "SIO", "SIZ", "SLB", "SLM", "SLT", "SMD", "SN5", "SNG", "SOE", "SOG", "SOL", "SOR", "SR1", "SSG", "SSH", "STW", "STZ", "SUC", "SUP", "SUS", "SWE", "SZZ", "T68", "T6D", "T6P", "T6T", "TA6", "TAG", "TCB", "TCG", "TDG", "TEU", "TF0", "TFU", "TGA", "TGK", "TGR", "TGY", "TH1", "TM5", "TM6", "TM9", "TMR", "TMX", "TNX", "TOA", "TOC", "TQY", "TRE", "TRV", "TS8", "TT7", "TTV", "TTZ", "TU4", "TUG", "TUJ", "TUP", "TUR", "TVD", "TVG", "TVM", "TVS", "TVV", "TVY", "TW7", "TWA", "TWD", "TWG", "TWJ", "TWY", "TXB", "TY6", "TYV", "U1Y", "U2A", "U2D", "U63", "U8V", "U97", "U9A", "U9D", "U9G", "U9J", "U9M", "UAP", "UBH", "UBO", "UCD", "UDC", "UEA", "V3M", "V3P", "V71", "VDF", "VG1", "VJ1", "VJ4", "VKN", "VTB", "W9T", "WIA", "WKO", "WKT", "WOO", "WT8", "WUN", "WZ1", "WZ2", "WZ4", "X0X", "X1P", "X1X", "X2F", "X2Y", "X34", "X4S", "X5S", "X6N", "X6X", "X6Y", "X6Z", "XBP", "XDP", "XDX", "XGP", "XIL", "XIQ", "XKJ", "XLF", "XLS", "XMM", "XS2", "XUL", "XXM", "XXR", "XXX", "XY6", "XY9", "XYB", "XYF", "XYL", "XYP", "XYS", "XYT", "XYZ", "YDR", "YIO", "YJM", "YKR", "YO5", "YX0", "YX1", "YYB", "YYD", "YYH", "YYJ", "YYK", "YYM", "YYQ", "YYR", "YZ0", "YZT", "Z0F", "Z15", "Z16", "Z2D", "Z2T", "Z3K", "Z3L", "Z3Q", "Z3U", "Z4K", "Z4R", "Z4S", "Z4U", "Z4V", "Z4W", "Z4Y", "Z57", "Z5J", "Z5L", "Z61", "Z6G", "Z6H", "Z6J", "Z6W", "Z8H", "Z8T", "Z9D", "Z9E", "Z9H", "Z9K", "Z9L", "Z9M", "Z9N", "Z9W", "ZB0", "ZB1", "ZB2", "ZB3", "ZCD", "ZCZ", "ZD0", "ZDC", "ZDM", "ZDO", "ZEE", "ZEL", "ZGE", "ZMR", "UMQ", "SQD"]);

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/carbohydrates/constants.js
var SaccharideShape;
(function(SaccharideShape2) {
  SaccharideShape2[SaccharideShape2["FilledSphere"] = 0] = "FilledSphere";
  SaccharideShape2[SaccharideShape2["FilledCube"] = 1] = "FilledCube";
  SaccharideShape2[SaccharideShape2["CrossedCube"] = 2] = "CrossedCube";
  SaccharideShape2[SaccharideShape2["DividedDiamond"] = 3] = "DividedDiamond";
  SaccharideShape2[SaccharideShape2["FilledCone"] = 4] = "FilledCone";
  SaccharideShape2[SaccharideShape2["DevidedCone"] = 5] = "DevidedCone";
  SaccharideShape2[SaccharideShape2["FlatBox"] = 6] = "FlatBox";
  SaccharideShape2[SaccharideShape2["FilledStar"] = 7] = "FilledStar";
  SaccharideShape2[SaccharideShape2["FilledDiamond"] = 8] = "FilledDiamond";
  SaccharideShape2[SaccharideShape2["FlatDiamond"] = 9] = "FlatDiamond";
  SaccharideShape2[SaccharideShape2["FlatHexagon"] = 10] = "FlatHexagon";
  SaccharideShape2[SaccharideShape2["Pentagon"] = 11] = "Pentagon";
  SaccharideShape2[SaccharideShape2["DiamondPrism"] = 12] = "DiamondPrism";
  SaccharideShape2[SaccharideShape2["PentagonalPrism"] = 13] = "PentagonalPrism";
  SaccharideShape2[SaccharideShape2["HexagonalPrism"] = 14] = "HexagonalPrism";
  SaccharideShape2[SaccharideShape2["HeptagonalPrism"] = 15] = "HeptagonalPrism";
})(SaccharideShape || (SaccharideShape = {}));
var SaccharideColors = ColorMap({
  Blue: 37052,
  Green: 42577,
  Yellow: 16765952,
  Orange: 16021792,
  Pink: 16162465,
  Purple: 10830745,
  LightBlue: 9424105,
  Brown: 10582605,
  Red: 15539236,
  Secondary: 15854817
});
var SaccharideType;
(function(SaccharideType2) {
  SaccharideType2[SaccharideType2["Hexose"] = 0] = "Hexose";
  SaccharideType2[SaccharideType2["HexNAc"] = 1] = "HexNAc";
  SaccharideType2[SaccharideType2["Hexosamine"] = 2] = "Hexosamine";
  SaccharideType2[SaccharideType2["Hexuronate"] = 3] = "Hexuronate";
  SaccharideType2[SaccharideType2["Deoxyhexose"] = 4] = "Deoxyhexose";
  SaccharideType2[SaccharideType2["DeoxyhexNAc"] = 5] = "DeoxyhexNAc";
  SaccharideType2[SaccharideType2["DiDeoxyhexose"] = 6] = "DiDeoxyhexose";
  SaccharideType2[SaccharideType2["Pentose"] = 7] = "Pentose";
  SaccharideType2[SaccharideType2["Deoxynonulosonate"] = 8] = "Deoxynonulosonate";
  SaccharideType2[SaccharideType2["DiDeoxynonulosonate"] = 9] = "DiDeoxynonulosonate";
  SaccharideType2[SaccharideType2["Unknown"] = 10] = "Unknown";
  SaccharideType2[SaccharideType2["Assigned"] = 11] = "Assigned";
})(SaccharideType || (SaccharideType = {}));
var SaccharideTypeNameMap = {
  [SaccharideType.Hexose]: "Hexose",
  [SaccharideType.HexNAc]: "HexNAc",
  [SaccharideType.Hexosamine]: "Hexosamine",
  [SaccharideType.Hexuronate]: "Hexuronate",
  [SaccharideType.Deoxyhexose]: "Deoxyhexose",
  [SaccharideType.DeoxyhexNAc]: "DeoxyhexNAc",
  [SaccharideType.DiDeoxyhexose]: "Di-deoxyhexose",
  [SaccharideType.Pentose]: "Pentose",
  [SaccharideType.Deoxynonulosonate]: "Deoxynonulosonate",
  [SaccharideType.DiDeoxynonulosonate]: "Di-deoxynonulosonate",
  [SaccharideType.Unknown]: "Unknown",
  [SaccharideType.Assigned]: "Assigned"
};
var SaccharideTypeShapeMap = {
  [SaccharideType.Hexose]: SaccharideShape.FilledSphere,
  [SaccharideType.HexNAc]: SaccharideShape.FilledCube,
  [SaccharideType.Hexosamine]: SaccharideShape.CrossedCube,
  [SaccharideType.Hexuronate]: SaccharideShape.DividedDiamond,
  [SaccharideType.Deoxyhexose]: SaccharideShape.FilledCone,
  [SaccharideType.DeoxyhexNAc]: SaccharideShape.DevidedCone,
  [SaccharideType.DiDeoxyhexose]: SaccharideShape.FlatBox,
  [SaccharideType.Pentose]: SaccharideShape.FilledStar,
  [SaccharideType.Deoxynonulosonate]: SaccharideShape.FilledDiamond,
  [SaccharideType.DiDeoxynonulosonate]: SaccharideShape.FlatDiamond,
  [SaccharideType.Unknown]: SaccharideShape.FlatHexagon,
  [SaccharideType.Assigned]: SaccharideShape.Pentagon
};
function getSaccharideShape(type3, ringMemberCount) {
  if (type3 === SaccharideType.Unknown) {
    if (ringMemberCount === 4)
      return SaccharideShape.DiamondPrism;
    else if (ringMemberCount === 5)
      return SaccharideShape.PentagonalPrism;
    else if (ringMemberCount === 6)
      return SaccharideShape.HexagonalPrism;
    else if (ringMemberCount === 7)
      return SaccharideShape.HeptagonalPrism;
    else
      return SaccharideShape.FlatHexagon;
  } else {
    return SaccharideTypeShapeMap[type3];
  }
}
var UnknownSaccharideComponent = {
  abbr: "Unk",
  name: "Unknown",
  color: SaccharideColors.Secondary,
  type: SaccharideType.Unknown
};
var Monosaccharides = [
  { abbr: "Glc", name: "Glucose", color: SaccharideColors.Blue, type: SaccharideType.Hexose },
  { abbr: "Man", name: "Mannose", color: SaccharideColors.Green, type: SaccharideType.Hexose },
  { abbr: "Gal", name: "Galactose", color: SaccharideColors.Yellow, type: SaccharideType.Hexose },
  { abbr: "Gul", name: "Gulose", color: SaccharideColors.Orange, type: SaccharideType.Hexose },
  { abbr: "Alt", name: "Altrose", color: SaccharideColors.Pink, type: SaccharideType.Hexose },
  { abbr: "All", name: "Allose", color: SaccharideColors.Purple, type: SaccharideType.Hexose },
  { abbr: "Tal", name: "Talose", color: SaccharideColors.LightBlue, type: SaccharideType.Hexose },
  { abbr: "Ido", name: "Idose", color: SaccharideColors.Brown, type: SaccharideType.Hexose },
  { abbr: "GlcNAc", name: "N-Acetyl Glucosamine", color: SaccharideColors.Blue, type: SaccharideType.HexNAc },
  { abbr: "ManNAc", name: "N-Acetyl Mannosamine", color: SaccharideColors.Green, type: SaccharideType.HexNAc },
  { abbr: "GalNAc", name: "N-Acetyl Galactosamine", color: SaccharideColors.Yellow, type: SaccharideType.HexNAc },
  { abbr: "GulNAc", name: "N-Acetyl Gulosamine", color: SaccharideColors.Orange, type: SaccharideType.HexNAc },
  { abbr: "AltNAc", name: "N-Acetyl Altrosamine", color: SaccharideColors.Pink, type: SaccharideType.HexNAc },
  { abbr: "AllNAc", name: "N-Acetyl Allosamine", color: SaccharideColors.Purple, type: SaccharideType.HexNAc },
  { abbr: "TalNAc", name: "N-Acetyl Talosamine", color: SaccharideColors.LightBlue, type: SaccharideType.HexNAc },
  { abbr: "IdoNAc", name: "N-Acetyl Idosamine", color: SaccharideColors.Brown, type: SaccharideType.HexNAc },
  { abbr: "GlcN", name: "Glucosamine", color: SaccharideColors.Blue, type: SaccharideType.Hexosamine },
  { abbr: "ManN", name: "Mannosamine", color: SaccharideColors.Green, type: SaccharideType.Hexosamine },
  { abbr: "GalN", name: "Galactosamine", color: SaccharideColors.Yellow, type: SaccharideType.Hexosamine },
  { abbr: "GulN", name: "Gulosamine", color: SaccharideColors.Orange, type: SaccharideType.Hexosamine },
  { abbr: "AltN", name: "Altrosamine", color: SaccharideColors.Pink, type: SaccharideType.Hexosamine },
  { abbr: "AllN", name: "Allosamine", color: SaccharideColors.Purple, type: SaccharideType.Hexosamine },
  { abbr: "TalN", name: "Talosamine", color: SaccharideColors.LightBlue, type: SaccharideType.Hexosamine },
  { abbr: "IdoN", name: "Idosamine", color: SaccharideColors.Brown, type: SaccharideType.Hexosamine },
  { abbr: "GlcA", name: "Glucuronic Acid", color: SaccharideColors.Blue, type: SaccharideType.Hexuronate },
  { abbr: "ManA", name: "Mannuronic Acid", color: SaccharideColors.Green, type: SaccharideType.Hexuronate },
  { abbr: "GalA", name: "Galacturonic Acid", color: SaccharideColors.Yellow, type: SaccharideType.Hexuronate },
  { abbr: "GulA", name: "Guluronic Acid", color: SaccharideColors.Orange, type: SaccharideType.Hexuronate },
  { abbr: "AltA", name: "Altruronic Acid", color: SaccharideColors.Pink, type: SaccharideType.Hexuronate },
  { abbr: "AllA", name: "Alluronic Acid", color: SaccharideColors.Purple, type: SaccharideType.Hexuronate },
  { abbr: "TalA", name: "Taluronic Acid", color: SaccharideColors.LightBlue, type: SaccharideType.Hexuronate },
  { abbr: "IdoA", name: "Iduronic Acid", color: SaccharideColors.Brown, type: SaccharideType.Hexuronate },
  { abbr: "Qui", name: "Quinovose", color: SaccharideColors.Blue, type: SaccharideType.Deoxyhexose },
  { abbr: "Rha", name: "Rhamnose", color: SaccharideColors.Green, type: SaccharideType.Deoxyhexose },
  { abbr: "6dGul", name: "6-Deoxy Gulose", color: SaccharideColors.Orange, type: SaccharideType.Deoxyhexose },
  { abbr: "6dAlt", name: "6-Deoxy Altrose", color: SaccharideColors.Pink, type: SaccharideType.Deoxyhexose },
  { abbr: "6dTal", name: "6-Deoxy Talose", color: SaccharideColors.LightBlue, type: SaccharideType.Deoxyhexose },
  { abbr: "Fuc", name: "Fucose", color: SaccharideColors.Red, type: SaccharideType.Deoxyhexose },
  { abbr: "QuiNAc", name: "N-Acetyl Quinovosamine", color: SaccharideColors.Blue, type: SaccharideType.DeoxyhexNAc },
  { abbr: "RhaNAc", name: "N-Acetyl Rhamnosamine", color: SaccharideColors.Green, type: SaccharideType.DeoxyhexNAc },
  { abbr: "6dAltNAc", name: "N-Acetyl 6-Deoxy Altrosamine", color: SaccharideColors.Pink, type: SaccharideType.DeoxyhexNAc },
  { abbr: "6dTalNAc", name: "N-Acetyl 6-Deoxy Talosamine", color: SaccharideColors.LightBlue, type: SaccharideType.DeoxyhexNAc },
  { abbr: "FucNAc", name: "N-Acetyl Fucosamine", color: SaccharideColors.Red, type: SaccharideType.DeoxyhexNAc },
  { abbr: "Oli", name: "Olivose", color: SaccharideColors.Blue, type: SaccharideType.DiDeoxyhexose },
  { abbr: "Tyv", name: "Tyvelose", color: SaccharideColors.Green, type: SaccharideType.DiDeoxyhexose },
  { abbr: "Abe", name: "Abequose", color: SaccharideColors.Orange, type: SaccharideType.DiDeoxyhexose },
  { abbr: "Par", name: "Paratose", color: SaccharideColors.Pink, type: SaccharideType.DiDeoxyhexose },
  { abbr: "Dig", name: "Digitoxose", color: SaccharideColors.Purple, type: SaccharideType.DiDeoxyhexose },
  { abbr: "Col", name: "Colitose", color: SaccharideColors.LightBlue, type: SaccharideType.DiDeoxyhexose },
  { abbr: "Ara", name: "Arabinose", color: SaccharideColors.Green, type: SaccharideType.Pentose },
  { abbr: "Lyx", name: "Lyxose", color: SaccharideColors.Yellow, type: SaccharideType.Pentose },
  { abbr: "Xyl", name: "Xylose", color: SaccharideColors.Orange, type: SaccharideType.Pentose },
  { abbr: "Rib", name: "Ribose", color: SaccharideColors.Pink, type: SaccharideType.Pentose },
  { abbr: "Kdn", name: "Keto-Deoxy Nonulonic Acid", color: SaccharideColors.Green, type: SaccharideType.Deoxynonulosonate },
  { abbr: "Neu5Ac", name: "N-Acetyl Neuraminic Acid", color: SaccharideColors.Purple, type: SaccharideType.Deoxynonulosonate },
  { abbr: "Neu5Gc", name: "N-Glycolyl Neuraminic Acid", color: SaccharideColors.LightBlue, type: SaccharideType.Deoxynonulosonate },
  { abbr: "Neu", name: "Neuraminic Acid", color: SaccharideColors.Brown, type: SaccharideType.Deoxynonulosonate },
  { abbr: "Sia", name: "Sialic acid", color: SaccharideColors.Red, type: SaccharideType.Deoxynonulosonate },
  { abbr: "Pse", name: "Pseudaminic Acid", color: SaccharideColors.Green, type: SaccharideType.DiDeoxynonulosonate },
  { abbr: "Leg", name: "Legionaminic Acid", color: SaccharideColors.Yellow, type: SaccharideType.DiDeoxynonulosonate },
  { abbr: "Aci", name: "Acinetaminic Acid", color: SaccharideColors.Pink, type: SaccharideType.DiDeoxynonulosonate },
  { abbr: "4eLeg", name: "4-Epilegionaminic Acid", color: SaccharideColors.LightBlue, type: SaccharideType.DiDeoxynonulosonate },
  { abbr: "Bac", name: "Bacillosamine", color: SaccharideColors.Blue, type: SaccharideType.Unknown },
  { abbr: "LDmanHep", name: "L-Glycero-D-Manno Heptose", color: SaccharideColors.Green, type: SaccharideType.Unknown },
  { abbr: "Kdo", name: "Keto-Deoxy Octulonic Acid", color: SaccharideColors.Yellow, type: SaccharideType.Unknown },
  { abbr: "Dha", name: "3-Deoxy Lyxo-Heptulosaric Acid", color: SaccharideColors.Orange, type: SaccharideType.Unknown },
  { abbr: "DDmanHep", name: "D-Glycero-D-Manno-Heptose", color: SaccharideColors.Pink, type: SaccharideType.Unknown },
  { abbr: "MurNAc", name: "N-Acetyl Muramic Acid", color: SaccharideColors.Purple, type: SaccharideType.Unknown },
  { abbr: "MurNGc", name: "N-Glycolyl Muramic Acid", color: SaccharideColors.LightBlue, type: SaccharideType.Unknown },
  { abbr: "Mur", name: "Muramic Acid", color: SaccharideColors.Brown, type: SaccharideType.Unknown },
  { abbr: "Api", name: "Apicose", color: SaccharideColors.Green, type: SaccharideType.Assigned },
  { abbr: "Fru", name: "Fructose", color: SaccharideColors.Green, type: SaccharideType.Assigned },
  { abbr: "Tag", name: "Tagatose", color: SaccharideColors.Yellow, type: SaccharideType.Assigned },
  { abbr: "Sor", name: "Sorbose", color: SaccharideColors.Orange, type: SaccharideType.Assigned },
  { abbr: "Psi", name: "Psicose", color: SaccharideColors.Pink, type: SaccharideType.Assigned }
];
var SaccharidesSnfgMap = function() {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = 0, il = Monosaccharides.length; i < il; ++i) {
    const saccharide = Monosaccharides[i];
    map2.set(saccharide.abbr, saccharide);
  }
  return map2;
}();
var MonosaccharidesColorTable = [
  ["Glc-family", SaccharideColors.Blue],
  ["Man-family", SaccharideColors.Green],
  ["Gal-family", SaccharideColors.Yellow],
  ["Gul-family", SaccharideColors.Orange],
  ["Alt-family", SaccharideColors.Pink],
  ["All-family", SaccharideColors.Purple],
  ["Tal-family", SaccharideColors.LightBlue],
  ["Ido-family", SaccharideColors.Brown],
  ["Fuc-family", SaccharideColors.Red],
  ["Generic/Unknown/Secondary", SaccharideColors.Secondary]
];
var CommonSaccharideNames = {
  // Hexose
  Glc: [
    "GLC",
    "BGC",
    "Z8T",
    "TRE",
    // di-saccharide but homomer
    "MLR"
    // tri-saccharide but homomer
  ],
  Man: ["MAN", "BMA"],
  Gal: ["GLA", "GAL", "GZL", "GXL", "GIV"],
  Gul: ["4GL", "GL0", "GUP", "Z8H"],
  Alt: ["Z6H", "3MK", "SHD"],
  All: ["AFD", "ALL", "WOO", "Z2D"],
  Tal: ["ZEE", "A5C", "SDY"],
  Ido: ["ZCD", "Z0F", "4N2"],
  // HexNAc
  GlcNAc: ["NDG", "NAG", "NGZ"],
  ManNAc: ["BM3", "BM7"],
  GalNAc: ["A2G", "NGA", "YYQ"],
  GulNAc: ["LXB"],
  AltNAc: [],
  AllNAc: ["NAA"],
  TalNAc: [],
  IdoNAc: ["LXZ", "HSQ"],
  // Hexosamine
  GlcN: ["PA1", "GCS"],
  ManN: ["95Z"],
  GalN: ["X6X", "1GN"],
  GulN: [],
  AltN: [],
  AllN: [],
  TalN: [],
  IdoN: [],
  // Hexuronate
  GlcA: ["GCU", "BDP"],
  ManA: ["MAV", "BEM"],
  GalA: ["ADA", "GTR", "GTK"],
  GulA: ["LGU"],
  AltA: [],
  AllA: [],
  TalA: ["X1X", "X0X"],
  IdoA: ["IDR"],
  // Deoxyhexose
  Qui: ["G6D", "YYK"],
  Rha: ["RAM", "RM4", "XXR"],
  "6dGul": ["66O"],
  "6dAlt": [],
  "6dTal": [],
  Fuc: ["FUC", "FUL", "FCA", "FCB", "GYE"],
  // DeoxyhexNAc
  QuiNAc: ["Z9W"],
  RhaNAc: [],
  "6dAltNAc": [],
  "6dTalNAc": [],
  FucNAc: ["49T"],
  // Di-deoxyhexose
  Oli: ["DDA", "RAE", "Z5J"],
  Tyv: ["TYV"],
  Abe: ["ABE"],
  Par: ["PZU"],
  Dig: ["Z3U"],
  Col: [],
  // Pentose
  Ara: ["64K", "ARA", "ARB", "AHR", "FUB", "BXY", "BXX", "SEJ"],
  Lyx: ["LDY", "Z4W"],
  Xyl: ["XYS", "XYP", "XYZ", "HSY", "LXC"],
  Rib: ["YYM", "RIP", "RIB", "BDR", "0MK", "Z6J", "32O"],
  // Deoxynonulosonate
  Kdn: ["KDM", "KDN"],
  Neu5Ac: ["SIA", "SLB"],
  Neu5Gc: ["NGC", "NGE"],
  Neu: [],
  Sia: [],
  // Di-deoxynonulosonate
  Pse: [],
  Leg: [],
  Aci: [],
  "4eLeg": [],
  // Unknown
  Bac: [],
  LDmanHep: ["GMH"],
  Kdo: ["KDO"],
  Dha: [],
  DDmanHep: ["289"],
  MurNAc: ["MUB", "AMU"],
  MurNGc: [],
  Mur: ["1S4", "MUR"],
  // Assigned
  Api: ["XXM"],
  Fru: ["BDF", "Z9N", "FRU", "LFR"],
  Tag: ["T6T"],
  Sor: ["SOE", "UEA"],
  Psi: ["PSV", "SF6", "SF9", "TTV"]
};
var CharmmSaccharideNames = {
  Glc: ["AGLC", "BGLC"],
  GlcNAc: ["AGLCNA", "BGLCNA", "BGLCN0"],
  GlcA: ["AGLCA", "BGLCA", "BGLCA0"],
  Man: ["AMAN", "BMAN"],
  Rha: ["ARHM", "BRHM"],
  Ara: ["AARB", "BARB"],
  Gal: ["AGAL", "BGAL"],
  GalNAc: ["AGALNA", "BGALNA"],
  Gul: ["AGUL", "BGUL"],
  Alt: ["AALT", "BALT"],
  All: ["AALL", "BALL"],
  Tal: ["ATAL", "BTAL"],
  Ido: ["AIDO", "BIDO"],
  IdoA: ["AIDOA", "BIDOA"],
  Fuc: ["AFUC", "BFUC"],
  Lyx: ["ALYF", "BLYF"],
  Xyl: ["AXYL", "BXYL", "AXYF", "BXYF"],
  Rib: ["ARIB", "BRIB"],
  Fru: ["AFRU", "BFRU"],
  Neu5Ac: ["ANE5AC", "BNE5AC"]
};
var GlycamSaccharideNames = {
  Glc: ["0GA", "0GB", "1GA", "1GB", "2GA", "2GB", "3GA", "3GB", "4GA", "4GB", "6GA", "6GB", "ZGA", "ZGB", "YGA", "YGB", "XGA", "XGB", "WGA", "WGB", "VGA", "VGB", "UGA", "UGB", "TGA", "TGB", "SGA", "SGB", "RGA", "RGB", "QGA", "QGB", "PGA", "PGB", "0gA", "0gB", "1gA", "1gB", "2gA", "2gB", "3gA", "3gB", "4gA", "4gB", "6gA", "6gB", "ZgA", "ZgB", "YgA", "YgB", "XgA", "XgB", "WgA", "WgB", "VgA", "VgB", "UgA", "UgB", "TgA", "TgB", "SgA", "SgB", "RgA", "RgB", "QgA", "QgB", "PgA", "PgB"],
  GlcNAc: ["0YA", "0YB", "1YA", "1YB", "3YA", "3YB", "4YA", "4YB", "6YA", "6YB", "WYA", "WYB", "VYA", "VYB", "UYA", "UYB", "QYA", "QYB", "0yA", "0yB", "1yA", "1yB", "3yA", "3yB", "4yA", "4yB", "6yA", "6yB", "WyA", "WyB", "VyA", "VyB", "UyA", "UyB", "QyA", "QyB", "0YS", "0Ys", "3YS", "3Ys", "4YS", "4Ys", "6YS", "6Ys", "QYS", "QYs", "UYS", "UYs", "VYS", "VYs", "WYS", "WYs", "0yS", "0ys", "3yS", "3ys", "4yS", "4ys"],
  GlcA: ["0ZA", "0ZB", "1ZA", "1ZB", "2ZA", "2ZB", "3ZA", "3ZB", "4ZA", "4ZB", "ZZA", "ZZB", "YZA", "YZB", "WZA", "WZB", "TZA", "TZB", "0zA", "0zB", "1zA", "1zB", "2zA", "2zB", "3zA", "3zB", "4zA", "4zB", "ZzA", "ZzB", "YzA", "YzB", "WzA", "WzB", "TzA", "TzB", "0ZBP"],
  GlcN: ["0YN", "3YN", "4YN", "6YN", "WYN", "VYN", "UYN", "QYN", "3Yn", "4Yn", "WYn", "0Yn", "0YP", "3YP", "4YP", "6YP", "WYP", "VYP", "UYP", "QYP", "0Yp", "3Yp", "4Yp", "WYp"],
  Man: ["0MA", "0MB", "1MA", "1MB", "2MA", "2MB", "3MA", "3MB", "4MA", "4MB", "6MA", "6MB", "ZMA", "ZMB", "YMA", "YMB", "XMA", "XMB", "WMA", "WMB", "VMA", "VMB", "UMA", "UMB", "TMA", "TMB", "SMA", "SMB", "RMA", "RMB", "QMA", "QMB", "PMA", "PMB", "0mA", "0mB", "1mA", "1mB", "2mA", "2mB", "3mA", "3mB", "4mA", "4mB", "6mA", "6mB", "ZmA", "ZmB", "YmA", "YmB", "XmA", "XmB", "WmA", "WmB", "VmA", "VmB", "UmA", "UmB", "TmA", "TmB", "SmA", "SmB", "RmA", "RmB", "QmA", "QmB", "PmA", "PmB"],
  ManNAc: ["0WA", "0WB", "1WA", "1WB", "3WA", "3WB", "4WA", "4WB", "6WA", "6WB", "WWA", "WWB", "VWA", "VWB", "UWA", "UWB", "QWA", "QWB", "0wA", "0wB", "1wA", "1wB", "3wA", "3wB", "4wA", "4wB", "6wA", "6wB", "WwA", "WwB", "VwA", "VwB", "UwA", "UwB", "QwA", "QwB"],
  Ara: ["0AA", "0AB", "1AA", "1AB", "2AA", "2AB", "3AA", "3AB", "4AA", "4AB", "ZAA", "ZAB", "YAA", "YAB", "WAA", "WAB", "TAA", "TAB", "0AD", "0AU", "1AD", "1AU", "2AD", "2AU", "3AD", "3AU", "5AD", "5AU", "ZAD", "ZAU", "0aA", "0aB", "1aA", "1aB", "2aA", "2aB", "3aA", "3aB", "4aA", "4aB", "ZaA", "ZaB", "YaA", "YaB", "WaA", "WaB", "TaA", "TaB", "0aD", "0aU", "1aD", "1aU", "2aD", "2aU", "3aD", "3aU", "5aD", "5aU", "ZaD", "ZaU"],
  Gal: ["0LA", "0LB", "1LA", "1LB", "2LA", "2LB", "3LA", "3LB", "4LA", "4LB", "6LA", "6LB", "ZLA", "ZLB", "YLA", "YLB", "XLA", "XLB", "WLA", "WLB", "VLA", "VLB", "ULA", "ULB", "TLA", "TLB", "SLA", "SLB", "RLA", "RLB", "QLA", "QLB", "PLA", "PLB", "0lA", "0lB", "1lA", "1lB", "2lA", "2lB", "3lA", "3lB", "4lA", "4lB", "6lA", "6lB", "ZlA", "ZlB", "YlA", "YlB", "XlA", "XlB", "WlA", "WlB", "VlA", "VlB", "UlA", "UlB", "TlA", "TlB", "SlA", "SlB", "RlA", "RlB", "QlA", "QlB", "PlA", "PlB"],
  GalNAc: ["0VA", "0VB", "1VA", "1VB", "3VA", "3VB", "4VA", "4VB", "6VA", "6VB", "WVA", "WVB", "VVA", "VVB", "UVA", "UVB", "QVA", "QVB", "0vA", "0vB", "1vA", "1vB", "3vA", "3vB", "4vA", "4vB", "6vA", "6vB", "WvA", "WvB", "VvA", "VvB", "UvA", "UvB", "QvA", "QvB"],
  GalA: ["0OA", "0OB", "1OA", "1OB", "2OA", "2OB", "3OA", "3OB", "4OA", "4OB", "ZOA", "ZOB", "YOA", "YOB", "WOA", "WOB", "TOA", "TOB", "0oA", "0oB", "1oA", "1oB", "2oA", "2oB", "3oA", "3oB", "4oA", "4oB", "ZoA", "ZoB", "YoA", "YoB", "WoA", "WoB", "ToA", "ToB"],
  Gul: ["0KA", "0KB", "1KA", "1KB", "2KA", "2KB", "3KA", "3KB", "4KA", "4KB", "6KA", "6KB", "ZKA", "ZKB", "YKA", "YKB", "XKA", "XKB", "WKA", "WKB", "VKA", "VKB", "UKA", "UKB", "TKA", "TKB", "SKA", "SKB", "RKA", "RKB", "QKA", "QKB", "PKA", "PKB", "0kA", "0kB", "1kA", "1kB", "2kA", "2kB", "3kA", "3kB", "4kA", "4kB", "6kA", "6kB", "ZkA", "ZkB", "YkA", "YkB", "XkA", "XkB", "WkA", "WkB", "VkA", "VkB", "UkA", "UkB", "TkA", "TkB", "SkA", "SkB", "RkA", "RkB", "QkA", "QkB", "PkA", "PkB"],
  Alt: ["0EA", "0EB", "1EA", "1EB", "2EA", "2EB", "3EA", "3EB", "4EA", "4EB", "6EA", "6EB", "ZEA", "ZEB", "YEA", "YEB", "XEA", "XEB", "WEA", "WEB", "VEA", "VEB", "UEA", "UEB", "TEA", "TEB", "SEA", "SEB", "REA", "REB", "QEA", "QEB", "PEA", "PEB", "0eA", "0eB", "1eA", "1eB", "2eA", "2eB", "3eA", "3eB", "4eA", "4eB", "6eA", "6eB", "ZeA", "ZeB", "YeA", "YeB", "XeA", "XeB", "WeA", "WeB", "VeA", "VeB", "UeA", "UeB", "TeA", "TeB", "SeA", "SeB", "ReA", "ReB", "QeA", "QeB", "PeA", "PeB"],
  All: ["0NA", "0NB", "1NA", "1NB", "2NA", "2NB", "3NA", "3NB", "4NA", "4NB", "6NA", "6NB", "ZNA", "ZNB", "YNA", "YNB", "XNA", "XNB", "WNA", "WNB", "VNA", "VNB", "UNA", "UNB", "TNA", "TNB", "SNA", "SNB", "RNA", "RNB", "QNA", "QNB", "PNA", "PNB", "0nA", "0nB", "1nA", "1nB", "2nA", "2nB", "3nA", "3nB", "4nA", "4nB", "6nA", "6nB", "ZnA", "ZnB", "YnA", "YnB", "XnA", "XnB", "WnA", "WnB", "VnA", "VnB", "UnA", "UnB", "TnA", "TnB", "SnA", "SnB", "RnA", "RnB", "QnA", "QnB", "PnA", "PnB"],
  Tal: ["0TA", "0TB", "1TA", "1TB", "2TA", "2TB", "3TA", "3TB", "4TA", "4TB", "6TA", "6TB", "ZTA", "ZTB", "YTA", "YTB", "XTA", "XTB", "WTA", "WTB", "VTA", "VTB", "UTA", "UTB", "TTA", "TTB", "STA", "STB", "RTA", "RTB", "QTA", "QTB", "PTA", "PTB", "0tA", "0tB", "1tA", "1tB", "2tA", "2tB", "3tA", "3tB", "4tA", "4tB", "6tA", "6tB", "ZtA", "ZtB", "YtA", "YtB", "XtA", "XtB", "WtA", "WtB", "VtA", "VtB", "UtA", "UtB", "TtA", "TtB", "StA", "StB", "RtA", "RtB", "QtA", "QtB", "PtA", "PtB"],
  Ido: ["0IA", "0IB", "1IA", "1IB", "2IA", "2IB", "3IA", "3IB", "4IA", "4IB", "6IA", "6IB", "ZIA", "ZIB", "YIA", "YIB", "XIA", "XIB", "WIA", "WIB", "VIA", "VIB", "UIA", "UIB", "TIA", "TIB", "SIA", "SIB", "RIA", "RIB", "QIA", "QIB", "PIA", "PIB", "0iA", "0iB", "1iA", "1iB", "2iA", "2iB", "3iA", "3iB", "4iA", "4iB", "6iA", "6iB", "ZiA", "ZiB", "YiA", "YiB", "XiA", "XiB", "WiA", "WiB", "ViA", "ViB", "UiA", "UiB", "TiA", "TiB", "SiA", "SiB", "RiA", "RiB", "QiA", "QiB", "PiA", "PiB"],
  IdoA: ["0UA", "0UB", "1UA", "1UB", "2UA", "2UB", "3UA", "3UB", "4UA", "4UB", "ZUA", "ZUB", "YUA", "YUB", "WUA", "WUB", "TUA", "TUB", "0uA", "0uB", "1uA", "1uB", "2uA", "2uB", "3uA", "3uB", "4uA", "4uB", "ZuA", "ZuB", "YuA", "YuB", "WuA", "WuB", "TuA", "TuB", "YuAP"],
  Fuc: ["0FA", "0FB", "1FA", "1FB", "2FA", "2FB", "3FA", "3FB", "4FA", "4FB", "ZFA", "ZFB", "YFA", "YFB", "WFA", "WFB", "TFA", "TFB", "0fA", "0fB", "1fA", "1fB", "2fA", "2fB", "3fA", "3fB", "4fA", "4fB", "ZfA", "ZfB", "YfA", "YfB", "WfA", "WfB", "TfA", "TfB"],
  Rha: ["0HA", "0HB", "1HA", "1HB", "2HA", "2HB", "3HA", "3HB", "4HA", "4HB", "ZHA", "ZHB", "YHA", "YHB", "WHA", "WHB", "THA", "THB", "0hA", "0hB", "1hA", "1hB", "2hA", "2hB", "3hA", "3hB", "4hA", "4hB", "ZhA", "ZhB", "YhA", "YhB", "WhA", "WhB", "ThA", "ThB"],
  Qui: ["0QA", "0QB", "1QA", "1QB", "2QA", "2QB", "3QA", "3QB", "4QA", "4QB", "ZQA", "ZQB", "YQA", "YQB", "WQA", "WQB", "TQA", "TQB", "0qA", "0qB", "1qA", "1qB", "2qA", "2qB", "3qA", "3qB", "4qA", "4qB", "ZqA", "ZqB", "YqA", "YqB", "WqA", "WqB", "TqA", "TqB"],
  Lyx: ["0DA", "0DB", "1DA", "1DB", "2DA", "2DB", "3DA", "3DB", "4DA", "4DB", "ZDA", "ZDB", "YDA", "YDB", "WDA", "WDB", "TDA", "TDB", "0DD", "0DU", "1DD", "1DU", "2DD", "2DU", "3DD", "3DU", "5DD", "5DU", "ZDD", "ZDU", "0dA", "0dB", "1dA", "1dB", "2dA", "2dB", "3dA", "3dB", "4dA", "4dB", "ZdA", "ZdB", "YdA", "YdB", "WdA", "WdB", "TdA", "TdB", "0dD", "0dU", "1dD", "1dU", "2dD", "2dU", "3dD", "3dU", "5dD", "5dU", "ZdD", "ZdU"],
  Xyl: ["0XA", "0XB", "1XA", "1XB", "2XA", "2XB", "3XA", "3XB", "4XA", "4XB", "ZXA", "ZXB", "YXA", "YXB", "WXA", "WXB", "TXA", "TXB", "0XD", "0XU", "1XD", "1XU", "2XD", "2XU", "3XD", "3XU", "5XD", "5XU", "ZXD", "ZXU", "0xA", "0xB", "1xA", "1xB", "2xA", "2xB", "3xA", "3xB", "4xA", "4xB", "ZxA", "ZxB", "YxA", "YxB", "WxA", "WxB", "TxA", "TxB", "0xD", "0xU", "1xD", "1xU", "2xD", "2xU", "3xD", "3xU", "5xD", "5xU", "ZxD", "ZxU"],
  Rib: ["0RA", "0RB", "1RA", "1RB", "2RA", "2RB", "3RA", "3RB", "4RA", "4RB", "ZRA", "ZRB", "YRA", "YRB", "WRA", "WRB", "TRA", "TRB", "0RD", "0RU", "1RD", "1RU", "2RD", "2RU", "3RD", "3RU", "5RD", "5RU", "ZRD", "ZRU", "0rA", "0rB", "1rA", "1rB", "2rA", "2rB", "3rA", "3rB", "4rA", "4rB", "ZrA", "ZrB", "YrA", "YrB", "WrA", "WrB", "TrA", "TrB", "0rD", "0rU", "1rD", "1rU", "2rD", "2rU", "3rD", "3rU", "5rD", "5rU", "ZrD", "ZrU"],
  Fru: ["0CA", "0CB", "1CA", "1CB", "2CA", "2CB", "3CA", "3CB", "4CA", "4CB", "5CA", "5CB", "WCA", "WCB", "0CD", "0CU", "1CD", "1CU", "2CD", "2CU", "3CD", "3CU", "4CD", "4CU", "6CD", "6CU", "WCD", "WCU", "VCD", "VCU", "UCD", "UCU", "QCD", "QCU", "0cA", "0cB", "1cA", "1cB", "2cA", "2cB", "3cA", "3cB", "4cA", "4cB", "5cA", "5cB", "WcA", "WcB", "0cD", "0cU", "1cD", "1cU", "2cD", "2cU", "3cD", "3cU", "4cD", "4cU", "6cD", "6cU", "WcD", "WcU", "VcD", "VcU", "UcD", "UcU", "QcD", "QcU"],
  Tag: ["0JA", "0JB", "1JA", "1JB", "2JA", "2JB", "3JA", "3JB", "4JA", "4JB", "5JA", "5JB", "WJA", "WJB", "0JD", "0JU", "1JD", "1JU", "2JD", "2JU", "3JD", "3JU", "4JD", "4JU", "6JD", "6JU", "WJD", "WJU", "VJD", "VJU", "UJD", "UJU", "QJD", "QJU", "0jA", "0jB", "1jA", "1jB", "2jA", "2jB", "3jA", "3jB", "4jA", "4jB", "5jA", "5jB", "WjA", "WjB", "0jD", "0jU", "1jD", "1jU", "2jD", "2jU", "3jD", "3jU", "4jD", "4jU", "6jD", "6jU", "WjD", "WjU", "VjD", "VjU", "UjD", "UjU", "QjD", "QjU"],
  Sor: ["0BA", "0BB", "1BA", "1BB", "2BA", "2BB", "3BA", "3BB", "4BA", "4BB", "5BA", "5BB", "WBA", "WBB", "0BD", "0BU", "1BD", "1BU", "2BD", "2BU", "3BD", "3BU", "4BD", "4BU", "6BD", "6BU", "WBD", "WBU", "VBD", "VBU", "UBD", "UBU", "QBD", "QBU", "0bA", "0bB", "1bA", "1bB", "2bA", "2bB", "3bA", "3bB", "4bA", "4bB", "5bA", "5bB", "WbA", "WbB", "0bD", "0bU", "1bD", "1bU", "2bD", "2bU", "3bD", "3bU", "4bD", "4bU", "6bD", "6bU", "WbD", "WbU", "VbD", "VbU", "UbD", "UbU", "QbD", "QbU"],
  Psi: ["0PA", "0PB", "1PA", "1PB", "2PA", "2PB", "3PA", "3PB", "4PA", "4PB", "5PA", "5PB", "WPA", "WPB", "0PD", "0PU", "1PD", "1PU", "2PD", "2PU", "3PD", "3PU", "4PD", "4PU", "6PD", "6PU", "WPD", "WPU", "VPD", "VPU", "UPD", "UPU", "QPD", "QPU", "0pA", "0pB", "1pA", "1pB", "2pA", "2pB", "3pA", "3pB", "4pA", "4pB", "5pA", "5pB", "WpA", "WpB", "0pD", "0pU", "1pD", "1pU", "2pD", "2pU", "3pD", "3pU", "4pD", "4pU", "6pD", "6pU", "WpD", "WpU", "VpD", "VpU", "UpD", "UpU", "QpD", "QpU"],
  Neu5Ac: ["0SA", "0SB", "4SA", "4SB", "7SA", "7SB", "8SA", "8SB", "9SA", "9SB", "ASA", "ASB", "BSA", "BSB", "CSA", "CSB", "DSA", "DSB", "ESA", "ESB", "FSA", "FSB", "GSA", "GSB", "HSA", "HSB", "ISA", "ISB", "JSA", "JSB", "KSA", "KSB", "0sA", "0sB", "4sA", "4sB", "7sA", "7sB", "8sA", "8sB", "9sA", "9sB", "AsA", "AsB", "BsA", "BsB", "CsA", "CsB", "DsA", "DsB", "EsA", "EsB", "FsA", "FsB", "GsA", "GsB", "HsA", "HsB", "IsA", "IsB", "JsA", "JsB", "KsA", "KsB"],
  Neu5Gc: ["0GL", "4GL", "7GL", "8GL", "9GL", "CGL", "DGL", "EGL", "FGL", "GGL", "HGL", "IGL", "JGL", "KGL", "0gL", "4gL", "7gL", "8gL", "9gL", "AgL", "BgL", "CgL", "DgL", "EgL", "FgL", "GgL", "HgL", "IgL", "JgL", "KgL"],
  Tyv: ["0TV", "0Tv", "1TV", "1Tv", "2TV", "2Tv", "4TV", "4Tv", "YTV", "YTv", "0tV", "0tv", "1tV", "1tv", "2tV", "2tv", "4tV", "4tv", "YtV", "Ytv"],
  Abe: ["0AE", "2AE", "4AE", "YGa", "0AF", "2AF", "4AF", "YAF"],
  Bac: ["0BC", "3BC", "0bC", "3bC"],
  Kdn: ["0KN", "4KN", "5KN", "7KN", "8KN", "9KN", "AKN", "BKN", "CKN", "DKN", "EKN", "FKN", "GKN", "HKN", "IKN", "JKN", "KKN", "LKN", "MKN", "NKN", "OKN", "PKN", "QKN", "RKN", "SKN", "TKN", "UKN", "VKN", "WKN", "XKN", "YKN", "0Kn", "4Kn", "5Kn", "7Kn", "8Kn", "9Kn", "AKn", "BKn", "CKn", "DKn", "EKn", "FKn", "GKn", "HKn", "IKn", "JKn", "KKn", "LKn", "MKn", "NKn", "OKn", "PKn", "QKn", "RKn", "SKn", "TKn", "UKn", "VKn", "WKn", "XKn", "YKn"],
  Kdo: ["0KO", "4KO", "5KO", "7KO", "8KO", "AKO", "BKO", "CKO", "DKO", "EKO", "FKO", "GKO", "HKO", "IKO", "JKO", "KKO", "0Ko", "4Ko", "5Ko", "7Ko", "8Ko", "AKo", "BKo", "CKo", "DKo", "EKo", "FKo", "GKo", "HKo", "IKo", "JKo", "KKo"]
};
var DefaultSaccharideCompIdMap = function() {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = 0, il = Monosaccharides.length; i < il; ++i) {
    const saccharide = Monosaccharides[i];
    const common = CommonSaccharideNames[saccharide.abbr];
    if (common) {
      for (let j = 0, jl = common.length; j < jl; ++j) {
        map2.set(common[j], saccharide);
      }
    }
    const charmm = CharmmSaccharideNames[saccharide.abbr];
    if (charmm) {
      for (let j = 0, jl = charmm.length; j < jl; ++j) {
        map2.set(charmm[j], saccharide);
      }
    }
  }
  SaccharideNames.forEach((name) => {
    if (!map2.has(name))
      map2.set(name, UnknownSaccharideComponent);
  });
  return map2;
}();
var GlycamSaccharideCompIdMap = function() {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = 0, il = Monosaccharides.length; i < il; ++i) {
    const saccharide = Monosaccharides[i];
    const common = CommonSaccharideNames[saccharide.abbr];
    if (common) {
      for (let j = 0, jl = common.length; j < jl; ++j) {
        map2.set(common[j], saccharide);
      }
    }
    const charmm = CharmmSaccharideNames[saccharide.abbr];
    if (charmm) {
      for (let j = 0, jl = charmm.length; j < jl; ++j) {
        map2.set(charmm[j], saccharide);
      }
    }
    const glycam = GlycamSaccharideNames[saccharide.abbr];
    if (glycam) {
      for (let j = 0, jl = glycam.length; j < jl; ++j) {
        if (!map2.has(glycam[j])) {
          map2.set(glycam[j], saccharide);
        }
      }
    }
  }
  SaccharideNames.forEach((name) => {
    if (!map2.has(name))
      map2.set(name, UnknownSaccharideComponent);
  });
  return map2;
}();
function setSaccharideCompIdMapType(type3) {
  SaccharideCompIdMap = type3 === "default" ? DefaultSaccharideCompIdMap : GlycamSaccharideCompIdMap;
}
var SaccharideCompIdMap = DefaultSaccharideCompIdMap;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/set.js
var SetUtils;
(function(SetUtils2) {
  function toArray(set2) {
    return Array.from(set2.values());
  }
  SetUtils2.toArray = toArray;
  function isSuperset(setA, setB) {
    if (setA === setB)
      return true;
    if (setA.size < setB.size)
      return false;
    for (const elem of setB) {
      if (!setA.has(elem))
        return false;
    }
    return true;
  }
  SetUtils2.isSuperset = isSuperset;
  function add(out, ...sets) {
    for (let i = 0; i < sets.length; i++) {
      for (const elem of sets[i])
        out.add(elem);
    }
    return out;
  }
  SetUtils2.add = add;
  function union2(setA, setB) {
    const union3 = new Set(setA);
    if (setA === setB)
      return union3;
    for (const elem of setB)
      union3.add(elem);
    return union3;
  }
  SetUtils2.union = union2;
  function unionMany(...sets) {
    if (sets.length === 0)
      return /* @__PURE__ */ new Set();
    const union3 = new Set(sets[0]);
    for (let i = 1, il = sets.length; i < il; i++) {
      for (const elem of sets[i])
        union3.add(elem);
    }
    return union3;
  }
  SetUtils2.unionMany = unionMany;
  function unionManyArrays(arrays) {
    if (arrays.length === 0)
      return /* @__PURE__ */ new Set();
    const union3 = new Set(arrays[0]);
    for (let i = 1; i < arrays.length; i++) {
      for (const elem of arrays[i])
        union3.add(elem);
    }
    return union3;
  }
  SetUtils2.unionManyArrays = unionManyArrays;
  function intersection(setA, setB) {
    if (setA === setB)
      return new Set(setA);
    const intersection2 = /* @__PURE__ */ new Set();
    for (const elem of setB) {
      if (setA.has(elem))
        intersection2.add(elem);
    }
    return intersection2;
  }
  SetUtils2.intersection = intersection;
  function areIntersecting(setA, setB) {
    if (setA === setB)
      return setA.size > 0;
    if (setA.size < setB.size)
      [setA, setB] = [setB, setA];
    for (const elem of setB) {
      if (setA.has(elem))
        return true;
    }
    return false;
  }
  SetUtils2.areIntersecting = areIntersecting;
  function intersectionSize(setA, setB) {
    if (setA === setB)
      return setA.size;
    if (setA.size < setB.size)
      [setA, setB] = [setB, setA];
    let count = 0;
    for (const elem of setB) {
      if (setA.has(elem))
        count += 1;
    }
    return count;
  }
  SetUtils2.intersectionSize = intersectionSize;
  function difference(setA, setB) {
    if (setA === setB)
      return /* @__PURE__ */ new Set();
    const difference2 = new Set(setA);
    for (const elem of setB)
      difference2.delete(elem);
    return difference2;
  }
  SetUtils2.difference = difference;
  function differenceSize(setA, setB) {
    if (setA === setB)
      return 0;
    let count = setA.size;
    for (const elem of setA) {
      if (setB.has(elem))
        count -= 1;
    }
    return count;
  }
  SetUtils2.differenceSize = differenceSize;
  function areEqual(setA, setB) {
    if (setA === setB)
      return true;
    if (setA.size !== setB.size)
      return false;
    for (const elem of setB) {
      if (!setA.has(elem))
        return false;
    }
    return true;
  }
  SetUtils2.areEqual = areEqual;
})(SetUtils || (SetUtils = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/types/lipids.js
var LipidNames = /* @__PURE__ */ new Set(["DAPC", "DBPC", "DFPC", "DGPC", "DIPC", "DLPC", "DNPC", "DOPC", "DPPC", "DRPC", "DTPC", "DVPC", "DXPC", "DYPC", "LPPC", "PAPC", "PEPC", "PGPC", "PIPC", "POPC", "PRPC", "PUPC", "DAPE", "DBPE", "DFPE", "DGPE", "DIPE", "DLPE", "DNPE", "DOPE", "DPPE", "DRPE", "DTPE", "DUPE", "DVPE", "DXPE", "DYPE", "LPPE", "PAPE", "PGPE", "PIPE", "POPE", "PQPE", "PRPE", "PUPE", "DAPS", "DBPS", "DFPS", "DGPS", "DIPS", "DLPS", "DNPS", "DOPS", "DPPS", "DRPS", "DTPS", "DUPS", "DVPS", "DXPS", "DYPS", "LPPS", "PAPS", "PGPS", "PIPS", "POPS", "PQPS", "PRPS", "PUPS", "DAPA", "DBPA", "DFPA", "DGPA", "DIPA", "DLPA", "DNPA", "DOPA", "DPPA", "DRPA", "DTPA", "DVPA", "DXPA", "DYPA", "LPPA", "PAPA", "PGPA", "PIPA", "POPA", "PRPA", "PUPA", "DAPG", "DBPG", "DFPG", "DGPG", "DIPG", "DLPG", "DNPG", "DOPG", "DPPG", "DRPG", "DTPG", "DVPG", "DXPG", "DYPG", "LPPG", "PAPG", "PGPG", "PIPG", "POPG", "PRPG", "DMPC", "DPP", "DPPI", "PAPI", "PIPI", "POP", "POPI", "PUPI", "PVP", "PVPI", "PADG", "PIDG", "PODG", "PUDG", "PVDG", "APC", "CPC", "IPC", "LPC", "OPC", "PPC", "TPC", "UPC", "VPC", "BNSM", "DBSM", "DPSM", "DXSM", "PGSM", "PNSM", "POSM", "PVSM", "XNSM", "DPCE", "DXCE", "PNCE", "XNCE"]);

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/types/ions.js
var IonNames = /* @__PURE__ */ new Set(["118", "119", "543", "1AL", "1CU", "2FK", "2HP", "2OF", "3CO", "3MT", "3NI", "3OF", "3P8", "4MO", "4PU", "4TI", "6MO", "ACT", "AG", "AL", "ALF", "AM", "ATH", "AU", "AU3", "AUC", "AZI", "BA", "BCT", "BEF", "BF4", "BO4", "BR", "BS3", "BSY", "CA", "CAC", "CD", "CD1", "CD3", "CD5", "CE", "CF", "CHT", "CL", "CO", "CO3", "CO5", "CON", "CR", "CS", "CSB", "CU", "CU1", "CU3", "CUA", "CUZ", "CYN", "DME", "DMI", "DSC", "DTI", "DY", "E4N", "EDR", "EMC", "ER3", "EU", "EU3", "F", "FE", "FE2", "FPO", "GA", "GD3", "GEP", "HAI", "HG", "HGC", "IN", "IOD", "IR", "IR3", "IRI", "IUM", "K", "KO4", "LA", "LCO", "LCP", "LI", "LU", "MAC", "MG", "MH2", "MH3", "MLI", "MMC", "MN", "MN3", "MN5", "MN6", "MO1", "MO2", "MO3", "MO4", "MO5", "MO6", "MOO", "MOS", "MOW", "MW1", "MW2", "MW3", "NA", "NA2", "NA5", "NA6", "NAO", "NAW", "ND", "NET", "NH4", "NI", "NI1", "NI2", "NI3", "NO2", "NO3", "NRU", "NT3", "O4M", "OAA", "OC1", "OC2", "OC3", "OC4", "OC5", "OC6", "OC7", "OC8", "OCL", "OCM", "OCN", "OCO", "OF1", "OF2", "OF3", "OH", "OS", "OS4", "OXL", "PB", "PBM", "PD", "PDV", "PER", "PI", "PO3", "PO4", "PR", "PT", "PT4", "PTN", "RB", "RH3", "RHD", "RHF", "RU", "SB", "SCN", "SE4", "SEK", "SM", "SMO", "SO3", "SO4", "SR", "T1A", "TB", "TBA", "TCN", "TEA", "TH", "THE", "TL", "TMA", "TRA", "UNX", "V", "VN3", "VO4", "W", "WO5", "Y1", "YB", "YB2", "YH", "YT3", "ZCM", "ZN", "ZN2", "ZN3", "ZNO", "ZO3", "ZR", "ZTM", "NCO", "OHX"]);

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/types.js
var _esCache = function() {
  const cache = /* @__PURE__ */ Object.create(null);
  const letters = [];
  for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++)
    letters[letters.length] = String.fromCharCode(i);
  for (let i = "a".charCodeAt(0); i <= "z".charCodeAt(0); i++)
    letters[letters.length] = String.fromCharCode(i);
  for (let i = "0".charCodeAt(0); i <= "9".charCodeAt(0); i++)
    letters[letters.length] = String.fromCharCode(i);
  for (const k of letters) {
    cache[k] = k.toUpperCase();
    for (const l of letters) {
      cache[k + l] = (k + l).toUpperCase();
      for (const m of letters) {
        cache[k + l + m] = (k + l + m).toUpperCase();
      }
    }
  }
  return cache;
}();
function ElementSymbol(s) {
  return _esCache[s] || s.toUpperCase();
}
var _elementByAtomicNumber = new Map([[1, "H"], [2, "He"], [3, "Li"], [4, "Be"], [5, "B"], [6, "C"], [7, "N"], [8, "O"], [9, "F"], [10, "Ne"], [11, "Na"], [12, "Mg"], [13, "Al"], [14, "Si"], [15, "P"], [16, "S"], [17, "Cl"], [18, "Ar"], [19, "K"], [20, "Ca"], [21, "Sc"], [22, "Ti"], [23, "V"], [24, "Cr"], [25, "Mn"], [26, "Fe"], [27, "Co"], [28, "Ni"], [29, "Cu"], [30, "Zn"], [31, "Ga"], [32, "Ge"], [33, "As"], [34, "Se"], [35, "Br"], [36, "Kr"], [37, "Rb"], [38, "Sr"], [39, "Y"], [40, "Zr"], [41, "Nb"], [42, "Mo"], [43, "Tc"], [44, "Ru"], [45, "Rh"], [46, "Pd"], [47, "Ag"], [48, "Cd"], [49, "In"], [50, "Sn"], [51, "Sb"], [52, "Te"], [53, "I"], [54, "Xe"], [55, "Cs"], [56, "Ba"], [57, "La"], [58, "Ce"], [59, "Pr"], [60, "Nd"], [61, "Pm"], [62, "Sm"], [63, "Eu"], [64, "Gd"], [65, "Tb"], [66, "Dy"], [67, "Ho"], [68, "Er"], [69, "Tm"], [70, "Yb"], [71, "Lu"], [72, "Hf"], [73, "Ta"], [74, "W"], [75, "Re"], [76, "Os"], [77, "Ir"], [78, "Pt"], [79, "Au"], [80, "Hg"], [81, "Tl"], [82, "Pb"], [83, "Bi"], [84, "Po"], [85, "At"], [86, "Rn"], [87, "Fr"], [88, "Ra"], [89, "Ac"], [90, "Th"], [91, "Pa"], [92, "U"], [93, "Np"], [94, "Pu"], [95, "Am"], [96, "Cm"], [97, "Bk"], [98, "Cf"], [99, "Es"], [100, "Fm"], [101, "Md"], [102, "No"], [103, "Lr"], [104, "Rf"], [105, "Db"], [106, "Sg"], [107, "Bh"], [108, "Hs"], [109, "Mt"], [110, "Ds"], [111, "Rg"], [112, "Cn"], [113, "Uut"], [114, "Fl"], [115, "Uup"], [116, "Lv"], [117, "Uus"], [118, "Uuo"]].map((e) => [e[0], ElementSymbol(e[1])]));
function getElementFromAtomicNumber(n) {
  if (_elementByAtomicNumber.has(n))
    return _elementByAtomicNumber.get(n);
  return ElementSymbol("H");
}
var EntityType;
(function(EntityType2) {
  EntityType2[EntityType2["unknown"] = 0] = "unknown";
  EntityType2[EntityType2["polymer"] = 1] = "polymer";
  EntityType2[EntityType2["non-polymer"] = 2] = "non-polymer";
  EntityType2[EntityType2["macrolide"] = 3] = "macrolide";
  EntityType2[EntityType2["water"] = 4] = "water";
  EntityType2[EntityType2["branched"] = 5] = "branched";
})(EntityType || (EntityType = {}));
var MoleculeType;
(function(MoleculeType2) {
  MoleculeType2[MoleculeType2["Unknown"] = 0] = "Unknown";
  MoleculeType2[MoleculeType2["Other"] = 1] = "Other";
  MoleculeType2[MoleculeType2["Water"] = 2] = "Water";
  MoleculeType2[MoleculeType2["Ion"] = 3] = "Ion";
  MoleculeType2[MoleculeType2["Lipid"] = 4] = "Lipid";
  MoleculeType2[MoleculeType2["Protein"] = 5] = "Protein";
  MoleculeType2[MoleculeType2["RNA"] = 6] = "RNA";
  MoleculeType2[MoleculeType2["DNA"] = 7] = "DNA";
  MoleculeType2[MoleculeType2["PNA"] = 8] = "PNA";
  MoleculeType2[MoleculeType2["Saccharide"] = 9] = "Saccharide";
})(MoleculeType || (MoleculeType = {}));
var PolymerType;
(function(PolymerType2) {
  PolymerType2[PolymerType2["NA"] = 0] = "NA";
  PolymerType2[PolymerType2["Protein"] = 1] = "Protein";
  PolymerType2[PolymerType2["GammaProtein"] = 2] = "GammaProtein";
  PolymerType2[PolymerType2["BetaProtein"] = 3] = "BetaProtein";
  PolymerType2[PolymerType2["RNA"] = 4] = "RNA";
  PolymerType2[PolymerType2["DNA"] = 5] = "DNA";
  PolymerType2[PolymerType2["PNA"] = 6] = "PNA";
})(PolymerType || (PolymerType = {}));
var PolymerTypeAtomRoleId = {
  [PolymerType.NA]: {
    trace: /* @__PURE__ */ new Set(),
    directionFrom: /* @__PURE__ */ new Set(),
    directionTo: /* @__PURE__ */ new Set(),
    backboneStart: /* @__PURE__ */ new Set(),
    backboneEnd: /* @__PURE__ */ new Set(),
    coarseBackbone: /* @__PURE__ */ new Set()
  },
  [PolymerType.Protein]: {
    trace: /* @__PURE__ */ new Set(["CA"]),
    directionFrom: /* @__PURE__ */ new Set(["C"]),
    directionTo: /* @__PURE__ */ new Set(["O", "OC1", "O1", "OX1", "OXT", "OT1"]),
    backboneStart: /* @__PURE__ */ new Set(["N"]),
    backboneEnd: /* @__PURE__ */ new Set(["C"]),
    // CA1 is used e.g. in GFP chromophores
    // BB, BAS are often used for coarse grained models
    coarseBackbone: /* @__PURE__ */ new Set(["CA", "CA1", "BB", "BAS"])
  },
  [PolymerType.GammaProtein]: {
    trace: /* @__PURE__ */ new Set(["CA"]),
    directionFrom: /* @__PURE__ */ new Set(["C"]),
    directionTo: /* @__PURE__ */ new Set(["O"]),
    backboneStart: /* @__PURE__ */ new Set(["N"]),
    backboneEnd: /* @__PURE__ */ new Set(["CD"]),
    coarseBackbone: /* @__PURE__ */ new Set(["CA"])
  },
  [PolymerType.BetaProtein]: {
    trace: /* @__PURE__ */ new Set(["CA"]),
    directionFrom: /* @__PURE__ */ new Set(["C"]),
    directionTo: /* @__PURE__ */ new Set(["O"]),
    backboneStart: /* @__PURE__ */ new Set(["N"]),
    backboneEnd: /* @__PURE__ */ new Set(["CG"]),
    coarseBackbone: /* @__PURE__ */ new Set(["CA"])
  },
  [PolymerType.RNA]: {
    trace: /* @__PURE__ */ new Set(["O3'", "O3*"]),
    directionFrom: /* @__PURE__ */ new Set(["C4'", "C4*"]),
    directionTo: /* @__PURE__ */ new Set(["C3'", "C3*"]),
    backboneStart: /* @__PURE__ */ new Set(["P"]),
    backboneEnd: /* @__PURE__ */ new Set(["O3'", "O3*"]),
    coarseBackbone: /* @__PURE__ */ new Set(["P"])
  },
  [PolymerType.DNA]: {
    trace: /* @__PURE__ */ new Set(["O3'", "O3*"]),
    directionFrom: /* @__PURE__ */ new Set(["C3'", "C3*"]),
    directionTo: /* @__PURE__ */ new Set(["C1'", "C1*"]),
    backboneStart: /* @__PURE__ */ new Set(["P"]),
    backboneEnd: /* @__PURE__ */ new Set(["O3'", "O3*"]),
    coarseBackbone: /* @__PURE__ */ new Set(["P"])
  },
  [PolymerType.PNA]: {
    trace: /* @__PURE__ */ new Set(["N4'", "N4*"]),
    directionFrom: /* @__PURE__ */ new Set(["N4'", "N4*"]),
    directionTo: /* @__PURE__ */ new Set(["C7'", "C7*"]),
    backboneStart: /* @__PURE__ */ new Set(["N1'", "N1*"]),
    backboneEnd: /* @__PURE__ */ new Set(["C'", "C*"]),
    coarseBackbone: /* @__PURE__ */ new Set(["P"])
  }
};
var ProteinBackboneAtoms = /* @__PURE__ */ new Set([
  "CA",
  "C",
  "N",
  "O",
  "O1",
  "O2",
  "OC1",
  "OC2",
  "OT1",
  "OT2",
  "OX1",
  "OXT",
  "H",
  "H1",
  "H2",
  "H3",
  "HA",
  "HN",
  "HXT",
  "BB"
]);
var NucleicBackboneAtoms = /* @__PURE__ */ new Set([
  "P",
  "OP1",
  "OP2",
  "HOP2",
  "HOP3",
  "O2'",
  "O3'",
  "O4'",
  "O5'",
  "C1'",
  "C2'",
  "C3'",
  "C4'",
  "C5'",
  "H1'",
  "H2'",
  "H2''",
  "HO2'",
  "H3'",
  "H4'",
  "H5'",
  "H5''",
  "HO3'",
  "HO5'",
  "O2*",
  "O3*",
  "O4*",
  "O5*",
  "C1*",
  "C2*",
  "C3*",
  "C4*",
  "C5*"
]);
var DProteinComponentTypeNames = /* @__PURE__ */ new Set([
  "d-peptide linking",
  "d-peptide nh3 amino terminus",
  "d-peptide cooh carboxy terminus",
  "d-gamma-peptide, c-delta linking",
  "d-beta-peptide, c-gamma linking"
]);
var LProteinComponentTypeNames = /* @__PURE__ */ new Set([
  "l-peptide linking",
  "l-peptide nh3 amino terminus",
  "l-peptide cooh carboxy terminus",
  "l-gamma-peptide, c-delta linking",
  "l-beta-peptide, c-gamma linking"
]);
var GammaProteinComponentTypeNames = /* @__PURE__ */ new Set([
  "d-gamma-peptide, c-delta linking",
  "l-gamma-peptide, c-delta linking"
]);
var BetaProteinComponentTypeNames = /* @__PURE__ */ new Set([
  "d-beta-peptide, c-gamma linking",
  "l-beta-peptide, c-gamma linking"
]);
var ProteinTerminusComponentTypeNames = /* @__PURE__ */ new Set([
  "d-peptide nh3 amino terminus",
  "d-peptide cooh carboxy terminus",
  "l-peptide nh3 amino terminus",
  "l-peptide cooh carboxy terminus"
]);
var OtherProteinComponentTypeNames = /* @__PURE__ */ new Set([
  "peptide linking",
  "peptide-like"
]);
var ProteinComponentTypeNames = SetUtils.unionMany(DProteinComponentTypeNames, LProteinComponentTypeNames, OtherProteinComponentTypeNames);
var DNAComponentTypeNames = /* @__PURE__ */ new Set([
  "dna linking",
  "l-dna linking",
  "dna oh 5 prime terminus",
  "dna oh 3 prime terminus"
]);
var RNAComponentTypeNames = /* @__PURE__ */ new Set([
  "rna linking",
  "l-rna linking",
  "rna oh 5 prime terminus",
  "rna oh 3 prime terminus"
]);
var SaccharideComponentTypeNames = SetUtils.unionMany(
  /* @__PURE__ */ new Set([
    "d-saccharide, beta linking",
    "l-saccharide, beta linking",
    "d-saccharide, alpha linking",
    "l-saccharide, alpha linking",
    "l-saccharide",
    "d-saccharide",
    "saccharide"
  ]),
  // deprecated in the mmCIF dictionary, kept for backward compatibility
  /* @__PURE__ */ new Set([
    "d-saccharide 1,4 and 1,4 linking",
    "l-saccharide 1,4 and 1,4 linking",
    "d-saccharide 1,4 and 1,6 linking",
    "l-saccharide 1,4 and 1,6 linking"
  ])
);
var OtherComponentTypeNames = /* @__PURE__ */ new Set([
  "non-polymer",
  "other"
]);
var IonComponentTypeNames = /* @__PURE__ */ new Set([
  "ion"
]);
var LipidComponentTypeNames = /* @__PURE__ */ new Set([
  "lipid"
]);
var WaterNames = /* @__PURE__ */ new Set([
  "SOL",
  "WAT",
  "HOH",
  "H2O",
  "W",
  "DOD",
  "D3O",
  "TIP",
  "TIP3",
  "TIP4",
  "SPC"
]);
var AminoAcidNamesL = /* @__PURE__ */ new Set([
  "HIS",
  "ARG",
  "LYS",
  "ILE",
  "PHE",
  "LEU",
  "TRP",
  "ALA",
  "MET",
  "PRO",
  "CYS",
  "ASN",
  "VAL",
  "GLY",
  "SER",
  "GLN",
  "TYR",
  "ASP",
  "GLU",
  "THR",
  "SEC",
  "PYL",
  "UNK",
  // unknown amino acid from CCD
  "MSE",
  "SEP",
  "TPO",
  "PTR",
  "PCA",
  "HYP",
  // common from CCD
  // charmm ff
  "HSD",
  "HSE",
  "HSP",
  "LSN",
  "ASPP",
  "GLUP",
  // amber ff
  "HID",
  "HIE",
  "HIP",
  "LYN",
  "ASH",
  "GLH"
]);
var AminoAcidNamesD = /* @__PURE__ */ new Set([
  "DAL",
  // D-ALANINE
  "DAR",
  // D-ARGININE
  "DSG",
  // D-ASPARAGINE
  "DAS",
  // D-ASPARTIC ACID
  "DCY",
  // D-CYSTEINE
  "DGL",
  // D-GLUTAMIC ACID
  "DGN",
  // D-GLUTAMINE
  "DHI",
  // D-HISTIDINE
  "DIL",
  // D-ISOLEUCINE
  "DLE",
  // D-LEUCINE
  "DLY",
  // D-LYSINE
  "MED",
  // D-METHIONINE
  "DPN",
  // D-PHENYLALANINE
  "DPR",
  // D-PROLINE
  "DSN",
  // D-SERINE
  "DTH",
  // D-THREONINE
  "DTR",
  // D-TRYPTOPHAN
  "DTY",
  // D-TYROSINE
  "DVA",
  // D-VALINE
  "DNE"
  // D-NORLEUCINE
  // ???  // D-SELENOCYSTEINE
]);
var AminoAcidNames = SetUtils.unionMany(AminoAcidNamesL, AminoAcidNamesD);
var CommonProteinCaps = /* @__PURE__ */ new Set([
  "NME",
  "ACE",
  "NH2",
  "FOR",
  "FMT"
  // not including the following
  // 'E1H' GFP backbone fragmentation in 2G16
  // 'HOA' complexes zinc
  // 'NEH' ubiquitine linker
  // 'MOH' part of peptidomimetics
]);
var RnaBaseNames = /* @__PURE__ */ new Set([
  "A",
  "C",
  "T",
  "G",
  "I",
  "U",
  "N"
  // unknown RNA base from CCD
]);
var DnaBaseNames = /* @__PURE__ */ new Set([
  "DA",
  "DC",
  "DT",
  "DG",
  "DI",
  "DU",
  "DN"
  // unknown DNA base from CCD
]);
var PeptideBaseNames = /* @__PURE__ */ new Set(["APN", "CPN", "TPN", "GPN"]);
var PurineBaseNames = /* @__PURE__ */ new Set(["A", "G", "I", "DA", "DG", "DI", "APN", "GPN"]);
var PyrimidineBaseNames = /* @__PURE__ */ new Set(["C", "T", "U", "DC", "DT", "DU", "CPN", "TPN"]);
var BaseNames = SetUtils.unionMany(RnaBaseNames, DnaBaseNames, PeptideBaseNames);
var isPurineBase = (compId2) => PurineBaseNames.has(compId2.toUpperCase());
var isPyrimidineBase = (compId2) => PyrimidineBaseNames.has(compId2.toUpperCase());
var PolymerNames = SetUtils.unionMany(AminoAcidNames, BaseNames);
function getMoleculeType(compType, compId2) {
  compId2 = compId2.toUpperCase();
  if (PeptideBaseNames.has(compId2)) {
    return MoleculeType.PNA;
  } else if (ProteinComponentTypeNames.has(compType)) {
    return MoleculeType.Protein;
  } else if (RNAComponentTypeNames.has(compType)) {
    return MoleculeType.RNA;
  } else if (DNAComponentTypeNames.has(compType)) {
    return MoleculeType.DNA;
  } else if (SaccharideComponentTypeNames.has(compType)) {
    return MoleculeType.Saccharide;
  } else if (WaterNames.has(compId2)) {
    return MoleculeType.Water;
  } else if (IonNames.has(compId2)) {
    return MoleculeType.Ion;
  } else if (LipidNames.has(compId2)) {
    return MoleculeType.Lipid;
  } else if (OtherComponentTypeNames.has(compType)) {
    if (SaccharideCompIdMap.has(compId2)) {
      return MoleculeType.Saccharide;
    } else if (AminoAcidNames.has(compId2)) {
      return MoleculeType.Protein;
    } else if (RnaBaseNames.has(compId2)) {
      return MoleculeType.RNA;
    } else if (DnaBaseNames.has(compId2)) {
      return MoleculeType.DNA;
    } else {
      return MoleculeType.Other;
    }
  } else {
    return MoleculeType.Unknown;
  }
}
function getPolymerType(compType, molType) {
  if (molType === MoleculeType.Protein) {
    if (GammaProteinComponentTypeNames.has(compType)) {
      return PolymerType.GammaProtein;
    } else if (BetaProteinComponentTypeNames.has(compType)) {
      return PolymerType.BetaProtein;
    } else if (ProteinTerminusComponentTypeNames.has(compType)) {
      return PolymerType.NA;
    } else {
      return PolymerType.Protein;
    }
  } else if (molType === MoleculeType.RNA) {
    return PolymerType.RNA;
  } else if (molType === MoleculeType.DNA) {
    return PolymerType.DNA;
  } else if (molType === MoleculeType.PNA) {
    return PolymerType.PNA;
  } else {
    return PolymerType.NA;
  }
}
function getComponentType(compId2) {
  compId2 = compId2.toUpperCase();
  if (AminoAcidNames.has(compId2)) {
    return "peptide linking";
  } else if (RnaBaseNames.has(compId2)) {
    return "rna linking";
  } else if (DnaBaseNames.has(compId2)) {
    return "dna linking";
  } else if (SaccharideCompIdMap.has(compId2)) {
    return "saccharide";
  } else {
    return "other";
  }
}
function getDefaultChemicalComponent(compId2) {
  return {
    formula: "",
    formula_weight: 0,
    id: compId2,
    name: compId2,
    mon_nstd_flag: PolymerNames.has(compId2) ? "y" : "n",
    pdbx_synonyms: [],
    type: getComponentType(compId2)
  };
}
function getEntityType(compId2) {
  compId2 = compId2.toUpperCase();
  if (WaterNames.has(compId2)) {
    return "water";
  } else if (PolymerNames.has(compId2)) {
    return "polymer";
  } else if (SaccharideCompIdMap.has(compId2)) {
    return "branched";
  } else {
    return "non-polymer";
  }
}
function getEntitySubtype(compId2, compType) {
  compId2 = compId2.toUpperCase();
  if (LProteinComponentTypeNames.has(compType)) {
    return "polypeptide(L)";
  } else if (DProteinComponentTypeNames.has(compType)) {
    return "polypeptide(D)";
  } else if (RNAComponentTypeNames.has(compType)) {
    return "polyribonucleotide";
  } else if (DNAComponentTypeNames.has(compType)) {
    return "polydeoxyribonucleotide";
  } else if (SaccharideComponentTypeNames.has(compType)) {
    return "oligosaccharide";
  } else if (SaccharideCompIdMap.has(compId2)) {
    return "oligosaccharide";
  } else if (PeptideBaseNames.has(compId2)) {
    return "peptide nucleic acid";
  } else if (AminoAcidNamesL.has(compId2)) {
    return "polypeptide(L)";
  } else if (AminoAcidNamesD.has(compId2)) {
    return "polypeptide(D)";
  } else if (RnaBaseNames.has(compId2)) {
    return "polyribonucleotide";
  } else if (DnaBaseNames.has(compId2)) {
    return "polydeoxyribonucleotide";
  } else if (IonComponentTypeNames.has(compType) || IonNames.has(compId2)) {
    return "ion";
  } else if (LipidComponentTypeNames.has(compType) || LipidNames.has(compId2)) {
    return "lipid";
  } else if (OtherProteinComponentTypeNames.has(compType)) {
    return "peptide-like";
  } else {
    return "other";
  }
}
function isPolymer(moleculeType) {
  return isNucleic(moleculeType) || isProtein(moleculeType);
}
function isNucleic(moleculeType) {
  return moleculeType === MoleculeType.DNA || moleculeType === MoleculeType.RNA || moleculeType === MoleculeType.PNA;
}
function isProtein(moleculeType) {
  return moleculeType === MoleculeType.Protein;
}
var SecondaryStructureType;
(function(SecondaryStructureType2) {
  SecondaryStructureType2.is = BitFlags.has;
  SecondaryStructureType2.create = BitFlags.create;
  let Flag;
  (function(Flag2) {
    Flag2[Flag2["None"] = 0] = "None";
    Flag2[Flag2["DoubleHelix"] = 1] = "DoubleHelix";
    Flag2[Flag2["Helix"] = 2] = "Helix";
    Flag2[Flag2["Beta"] = 4] = "Beta";
    Flag2[Flag2["Bend"] = 8] = "Bend";
    Flag2[Flag2["Turn"] = 16] = "Turn";
    Flag2[Flag2["LeftHanded"] = 32] = "LeftHanded";
    Flag2[Flag2["RightHanded"] = 64] = "RightHanded";
    Flag2[Flag2["ClassicTurn"] = 128] = "ClassicTurn";
    Flag2[Flag2["InverseTurn"] = 256] = "InverseTurn";
    Flag2[Flag2["HelixOther"] = 512] = "HelixOther";
    Flag2[Flag2["Helix27"] = 1024] = "Helix27";
    Flag2[Flag2["Helix3Ten"] = 2048] = "Helix3Ten";
    Flag2[Flag2["HelixAlpha"] = 4096] = "HelixAlpha";
    Flag2[Flag2["HelixGamma"] = 8192] = "HelixGamma";
    Flag2[Flag2["HelixOmega"] = 16384] = "HelixOmega";
    Flag2[Flag2["HelixPi"] = 32768] = "HelixPi";
    Flag2[Flag2["HelixPolyproline"] = 65536] = "HelixPolyproline";
    Flag2[Flag2["DoubleHelixOther"] = 131072] = "DoubleHelixOther";
    Flag2[Flag2["DoubleHelixZ"] = 262144] = "DoubleHelixZ";
    Flag2[Flag2["DoubleHelixA"] = 524288] = "DoubleHelixA";
    Flag2[Flag2["DoubleHelixB"] = 1048576] = "DoubleHelixB";
    Flag2[Flag2["BetaOther"] = 2097152] = "BetaOther";
    Flag2[Flag2["BetaStrand"] = 4194304] = "BetaStrand";
    Flag2[Flag2["BetaSheet"] = 8388608] = "BetaSheet";
    Flag2[Flag2["BetaBarell"] = 16777216] = "BetaBarell";
    Flag2[Flag2["TurnOther"] = 33554432] = "TurnOther";
    Flag2[Flag2["Turn1"] = 67108864] = "Turn1";
    Flag2[Flag2["Turn2"] = 134217728] = "Turn2";
    Flag2[Flag2["Turn3"] = 268435456] = "Turn3";
    Flag2[Flag2["NA"] = 536870912] = "NA";
  })(Flag = SecondaryStructureType2.Flag || (SecondaryStructureType2.Flag = {}));
  SecondaryStructureType2.SecondaryStructureMmcif = {
    helx_lh_27_p: Flag.Helix | Flag.LeftHanded | Flag.Helix27,
    // left-handed 2-7 helix (protein)
    helx_lh_3t_p: Flag.Helix | Flag.LeftHanded | Flag.Helix3Ten,
    // left-handed 3-10 helix (protein)
    helx_lh_al_p: Flag.Helix | Flag.LeftHanded | Flag.HelixAlpha,
    // left-handed alpha helix (protein)
    helx_lh_a_n: Flag.DoubleHelix | Flag.LeftHanded | Flag.DoubleHelixA,
    // left-handed A helix (nucleic acid)
    helx_lh_b_n: Flag.DoubleHelix | Flag.LeftHanded | Flag.DoubleHelixB,
    // left-handed B helix (nucleic acid)
    helx_lh_ga_p: Flag.Helix | Flag.LeftHanded | Flag.HelixGamma,
    // left-handed gamma helix (protein)
    helx_lh_n: Flag.DoubleHelix | Flag.LeftHanded,
    // left-handed helix with type not specified (nucleic acid)
    helx_lh_om_p: Flag.Helix | Flag.LeftHanded | Flag.HelixOmega,
    // left-handed omega helix (protein)
    helx_lh_ot_n: Flag.DoubleHelix | Flag.LeftHanded | Flag.DoubleHelixOther,
    // left-handed helix with type that does not conform to an accepted category (nucleic acid)
    helx_lh_ot_p: Flag.Helix | Flag.LeftHanded | Flag.HelixOther,
    // left-handed helix with type that does not conform to an accepted category (protein)
    helx_lh_p: Flag.Helix | Flag.LeftHanded,
    // left-handed helix with type not specified (protein)
    helx_lh_pi_p: Flag.Helix | Flag.LeftHanded | Flag.HelixPi,
    // left-handed pi helix (protein)
    helx_lh_pp_p: Flag.Helix | Flag.LeftHanded | Flag.HelixPolyproline,
    // left-handed polyproline helix (protein)
    helx_lh_z_n: Flag.DoubleHelix | Flag.LeftHanded | Flag.DoubleHelixZ,
    // left-handed Z helix (nucleic acid)
    helx_n: Flag.DoubleHelix,
    // helix with handedness and type not specified (nucleic acid)
    helx_ot_n: Flag.DoubleHelix,
    // helix with handedness and type that do not conform to an accepted category (nucleic acid)
    helx_ot_p: Flag.Helix,
    // helix with handedness and type that do not conform to an accepted category (protein)
    helx_p: Flag.Helix,
    // helix with handedness and type not specified (protein)
    helx_rh_27_p: Flag.Helix | Flag.RightHanded | Flag.Helix27,
    // right-handed 2-7 helix (protein)
    helx_rh_3t_p: Flag.Helix | Flag.RightHanded | Flag.Helix3Ten,
    // right-handed 3-10 helix (protein)
    helx_rh_al_p: Flag.Helix | Flag.RightHanded | Flag.HelixAlpha,
    // right-handed alpha helix (protein)
    helx_rh_a_n: Flag.DoubleHelix | Flag.RightHanded | Flag.DoubleHelixA,
    // right-handed A helix (nucleic acid)
    helx_rh_b_n: Flag.DoubleHelix | Flag.RightHanded | Flag.DoubleHelixB,
    // right-handed B helix (nucleic acid)
    helx_rh_ga_p: Flag.Helix | Flag.RightHanded | Flag.HelixGamma,
    // right-handed gamma helix (protein)
    helx_rh_n: Flag.DoubleHelix | Flag.RightHanded,
    // right-handed helix with type not specified (nucleic acid)
    helx_rh_om_p: Flag.Helix | Flag.RightHanded | Flag.HelixOmega,
    // right-handed omega helix (protein)
    helx_rh_ot_n: Flag.DoubleHelix | Flag.RightHanded | Flag.DoubleHelixOther,
    // right-handed helix with type that does not conform to an accepted category (rhcleic acid)
    helx_rh_ot_p: Flag.Helix | Flag.RightHanded | Flag.HelixOther,
    // right-handed helix with type that does not conform to an accepted category (protein)
    helx_rh_p: Flag.Helix | Flag.RightHanded,
    // right-handed helix with type not specified (protein)
    helx_rh_pi_p: Flag.Helix | Flag.RightHanded | Flag.HelixPi,
    // right-handed pi helix (protein)
    helx_rh_pp_p: Flag.Helix | Flag.RightHanded | Flag.HelixPolyproline,
    // right-handed polyproline helix (protein)
    helx_rh_z_n: Flag.DoubleHelix | Flag.RightHanded | Flag.DoubleHelixZ,
    // right-handed Z helix (nucleic acid)
    strn: Flag.Beta | Flag.BetaStrand,
    // beta strand (protein)
    turn_ot_p: Flag.Turn | Flag.TurnOther,
    // turn with type that does not conform to an accepted category (protein)
    turn_p: Flag.Turn,
    // turn with type not specified (protein)
    turn_ty1p_p: Flag.Turn | Flag.InverseTurn | Flag.Turn1,
    // type I prime turn (protein)
    turn_ty1_p: Flag.Turn | Flag.ClassicTurn | Flag.Turn1,
    // type I turn (protein)
    turn_ty2p_p: Flag.Turn | Flag.InverseTurn | Flag.Turn2,
    // type II prime turn (protein)
    turn_ty2_p: Flag.Turn | Flag.ClassicTurn | Flag.Turn2,
    // type II turn (protein)
    turn_ty3p_p: Flag.Turn | Flag.InverseTurn | Flag.Turn3,
    // type III prime turn (protein)
    turn_ty3_p: Flag.Turn | Flag.ClassicTurn | Flag.Turn3,
    // type III turn (protein)
    bend: Flag.Bend,
    // region with high backbone curvature without specific hydrogen bonding, a bend at residue i occurs when the angle between C$\_alpha(i)-C_\alpha(i-2) and C_\alpha(i+2) - C_\alpha(i)$ is greater than 70 degrees (protein)
    other: Flag.None
    // secondary structure type that does not conform to an accepted category, random coil (protein)
  };
  SecondaryStructureType2.SecondaryStructurePdb = {
    1: Flag.Helix | Flag.RightHanded | Flag.HelixAlpha,
    // Right-handed alpha (default)
    2: Flag.Helix | Flag.RightHanded | Flag.HelixOmega,
    // Right-handed omega
    3: Flag.Helix | Flag.RightHanded | Flag.HelixPi,
    // Right-handed pi
    4: Flag.Helix | Flag.RightHanded | Flag.HelixGamma,
    // Right-handed gamma
    5: Flag.Helix | Flag.RightHanded | Flag.Helix3Ten,
    // Right-handed 310
    6: Flag.Helix | Flag.LeftHanded | Flag.HelixAlpha,
    // Left-handed alpha
    7: Flag.Helix | Flag.LeftHanded | Flag.HelixOmega,
    // Left-handed omega
    8: Flag.Helix | Flag.LeftHanded | Flag.HelixGamma,
    // Left-handed gamma
    9: Flag.Helix | Flag.Helix27,
    // 27 ribbon/helix
    10: Flag.Helix | Flag.HelixPolyproline
    // Polyproline
  };
  SecondaryStructureType2.SecondaryStructureStride = {
    H: Flag.Helix | Flag.HelixAlpha,
    // Alpha helix
    G: Flag.Helix | Flag.Helix3Ten,
    // 3-10 helix
    I: Flag.Helix | Flag.HelixPi,
    // PI-helix
    E: Flag.Beta | Flag.BetaSheet,
    // Extended conformation
    B: Flag.Beta | Flag.BetaStrand,
    // Isolated bridge
    T: Flag.Turn,
    // Turn
    C: Flag.NA
    // Coil (none of the above)
  };
  SecondaryStructureType2.SecondaryStructureDssp = {
    H: Flag.Helix | Flag.HelixAlpha,
    // alpha-helix
    B: Flag.Beta | Flag.BetaStrand,
    // residue in isolated beta-bridge
    E: Flag.Beta | Flag.BetaSheet,
    // extended strand, participates in beta ladder
    G: Flag.Helix | Flag.Helix3Ten,
    // 3-helix (310 helix)
    I: Flag.Helix | Flag.HelixPi,
    // 5 helix (pi-helix)
    T: Flag.Turn,
    // hydrogen bonded turn
    S: Flag.Bend
    // bend
  };
})(SecondaryStructureType || (SecondaryStructureType = {}));
var MaxAsa = {
  "ALA": 121,
  "ARG": 265,
  "ASN": 187,
  "ASP": 187,
  "CYS": 148,
  "GLU": 214,
  "GLN": 214,
  "GLY": 97,
  "HIS": 216,
  "ILE": 195,
  "LEU": 191,
  "LYS": 230,
  "MET": 203,
  "PHE": 228,
  "PRO": 154,
  "SER": 143,
  "THR": 163,
  "TRP": 264,
  "TYR": 255,
  "VAL": 165,
  // charmm ff
  "HSD": 216,
  "HSE": 216,
  "HSP": 216,
  // amber ff
  "HID": 216,
  "HIE": 216,
  "HIP": 216,
  "ASH": 187,
  "GLH": 214
};
var DefaultMaxAsa = 121;
var BondType;
(function(BondType2) {
  BondType2.is = BitFlags.has;
  let Flag;
  (function(Flag2) {
    Flag2[Flag2["None"] = 0] = "None";
    Flag2[Flag2["Covalent"] = 1] = "Covalent";
    Flag2[Flag2["MetallicCoordination"] = 2] = "MetallicCoordination";
    Flag2[Flag2["HydrogenBond"] = 4] = "HydrogenBond";
    Flag2[Flag2["Disulfide"] = 8] = "Disulfide";
    Flag2[Flag2["Aromatic"] = 16] = "Aromatic";
    Flag2[Flag2["Computed"] = 32] = "Computed";
  })(Flag = BondType2.Flag || (BondType2.Flag = {}));
  function create(flags2) {
    return BitFlags.create(flags2);
  }
  BondType2.create = create;
  function isCovalent(flags2) {
    return (flags2 & BondType2.Flag.Covalent) !== 0;
  }
  BondType2.isCovalent = isCovalent;
  function isAll(flags2) {
    return flags2 === Math.pow(2, 6) - 1;
  }
  BondType2.isAll = isAll;
  BondType2.Names = {
    "covalent": Flag.Covalent,
    "metal-coordination": Flag.MetallicCoordination,
    "hydrogen-bond": Flag.HydrogenBond,
    "disulfide": Flag.Disulfide,
    "aromatic": Flag.Aromatic,
    "computed": Flag.Computed
  };
  function isName(name) {
    return name in BondType2.Names;
  }
  BondType2.isName = isName;
  function fromName(name) {
    switch (name) {
      case "covalent":
        return Flag.Covalent;
      case "metal-coordination":
        return Flag.MetallicCoordination;
      case "hydrogen-bond":
        return Flag.HydrogenBond;
      case "disulfide":
        return Flag.Disulfide;
      case "aromatic":
        return Flag.Aromatic;
      case "computed":
        return Flag.Computed;
    }
  }
  BondType2.fromName = fromName;
  function fromNames(names) {
    let f = Flag.None;
    for (let i = 0, il = names.length; i < il; ++i) {
      f |= fromName(names[i]);
    }
    return f;
  }
  BondType2.fromNames = fromNames;
})(BondType || (BondType = {}));
var ResidueHydrophobicity = {
  // AA  DGwif   DGwoct  Oct-IF
  "ALA": [0.17, 0.5, 0.33],
  "ARG": [0.81, 1.81, 1],
  "ASN": [0.42, 0.85, 0.43],
  "ASP": [1.23, 3.64, 2.41],
  "ASH": [-0.07, 0.43, 0.5],
  "CYS": [-0.24, -0.02, 0.22],
  "GLN": [0.58, 0.77, 0.19],
  "GLU": [2.02, 3.63, 1.61],
  "GLH": [-0.01, 0.11, 0.12],
  "GLY": [0.01, 1.15, 1.14],
  // "His+": [  0.96,  2.33,  1.37 ],
  "HIS": [0.17, 0.11, -0.06],
  "ILE": [-0.31, -1.12, -0.81],
  "LEU": [-0.56, -1.25, -0.69],
  "LYS": [0.99, 2.8, 1.81],
  "MET": [-0.23, -0.67, -0.44],
  "PHE": [-1.13, -1.71, -0.58],
  "PRO": [0.45, 0.14, -0.31],
  "SER": [0.13, 0.46, 0.33],
  "THR": [0.14, 0.25, 0.11],
  "TRP": [-1.85, -2.09, -0.24],
  "TYR": [-0.94, -0.71, 0.23],
  "VAL": [0.07, -0.46, -0.53],
  // charmm ff
  "HSD": [0.17, 0.11, -0.06],
  "HSE": [0.17, 0.11, -0.06],
  "HSP": [0.96, 2.33, 1.37],
  // amber ff
  "HID": [0.17, 0.11, -0.06],
  "HIE": [0.17, 0.11, -0.06],
  "HIP": [0.96, 2.33, 1.37]
};
var DefaultResidueHydrophobicity = [0, 0, 0];

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/property/bonds/index-pair.js
function getGraph(indexA, indexB, props, count) {
  const builder = new IntAdjacencyGraph.EdgeBuilder(count, indexA, indexB);
  const key = new Int32Array(builder.slotCount);
  const operatorA = new Array(builder.slotCount);
  const operatorB = new Array(builder.slotCount);
  const order = new Int8Array(builder.slotCount);
  const distance = new Array(builder.slotCount);
  const flag = new Array(builder.slotCount);
  for (let i = 0, _i = builder.edgeCount; i < _i; i++) {
    builder.addNextEdge();
    builder.assignProperty(key, props.key ? props.key[i] : -1);
    builder.assignDirectedProperty(operatorA, props.operatorA ? props.operatorA[i] : -1, operatorB, props.operatorB ? props.operatorB[i] : -1);
    builder.assignProperty(order, props.order ? props.order[i] : 1);
    builder.assignProperty(distance, props.distance ? props.distance[i] : -1);
    builder.assignProperty(flag, props.flag ? props.flag[i] : BondType.Flag.Covalent);
  }
  return builder.createGraph({ key, operatorA, operatorB, order, distance, flag });
}
var IndexPairBonds;
(function(IndexPairBonds2) {
  IndexPairBonds2.Descriptor = {
    name: "index_pair_bonds"
  };
  IndexPairBonds2.Provider = FormatPropertyProvider.create(IndexPairBonds2.Descriptor, { asDynamic: true });
  IndexPairBonds2.DefaultProps = {
    /**
     * If negative, test using element-based threshold, otherwise distance in Angstrom.
     *
     * This option exists to handle bonds in periodic cells. For systems that are
     * made from beads (as opposed to atomic elements), set to a specific distance.
     *
     * Note that `Data` has a `distance` field which allows specifying a distance
     * for each bond individually which takes precedence over this option.
     */
    maxDistance: -1,
    /** Can be cached in `ElementSetIntraBondCache` */
    cacheable: true
  };
  function fromData(data, props = {}) {
    const p3 = { ...IndexPairBonds2.DefaultProps, ...props };
    const { pairs, count } = data;
    const indexA = pairs.indexA.toArray();
    const indexB = pairs.indexB.toArray();
    const key = pairs.key && pairs.key.toArray();
    const operatorA = pairs.operatorA && pairs.operatorA.toArray();
    const operatorB = pairs.operatorB && pairs.operatorB.toArray();
    const order = pairs.order && pairs.order.toArray();
    const distance = pairs.distance && pairs.distance.toArray();
    const flag = pairs.flag && pairs.flag.toArray();
    let hasOperators = false;
    if (operatorA && operatorB) {
      hasOperators = true;
      for (let i = 0, il = operatorA.length; i < il; ++i) {
        if (operatorA[i] === -1 || operatorB[i] === -1) {
          hasOperators = false;
          break;
        }
      }
    }
    const bonds = getGraph(indexA, indexB, { key, operatorA, operatorB, order, distance, flag }, count);
    const bySameOperator = /* @__PURE__ */ new Map();
    if (hasOperators) {
      const { operatorA: operatorA2, operatorB: operatorB2 } = bonds.edgeProps;
      for (let i = 0, il = operatorA2.length; i < il; ++i) {
        if (operatorA2[i] === operatorB2[i]) {
          const op = operatorA2[i];
          if (bySameOperator.has(op))
            bySameOperator.get(op).push(i);
          else
            bySameOperator.set(op, [i]);
        }
      }
    }
    return {
      bonds,
      maxDistance: p3.maxDistance,
      cacheable: p3.cacheable,
      hasOperators,
      bySameOperator
    };
  }
  IndexPairBonds2.fromData = fromData;
  function getEdgeIndexForOperators(bonds, i, j, opI, opJ) {
    let a, b, opA, opB;
    if (i < j) {
      a = i;
      b = j;
      opA = opI;
      opB = opJ;
    } else {
      a = j;
      b = i;
      opA = opJ;
      opB = opI;
    }
    for (let t = bonds.offset[a], _t = bonds.offset[a + 1]; t < _t; t++) {
      if (bonds.b[t] === b && bonds.edgeProps.operatorA[t] === opA && bonds.edgeProps.operatorB[t] === opB)
        return t;
    }
    return -1;
  }
  IndexPairBonds2.getEdgeIndexForOperators = getEdgeIndexForOperators;
})(IndexPairBonds || (IndexPairBonds = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/common/text/column/token.js
function TokenColumnProvider(tokens) {
  return function(type3) {
    return TokenColumn(tokens, type3);
  };
}
function TokenColumn(tokens, schema) {
  const { data, indices, count: rowCount } = tokens;
  const { valueType: type3 } = schema;
  const value = type3 === "str" ? (row) => data.substring(indices[2 * row], indices[2 * row + 1]) : type3 === "int" ? (row) => parseInt2(data, indices[2 * row], indices[2 * row + 1]) || 0 : (row) => parseFloat2(data, indices[2 * row], indices[2 * row + 1]) || 0;
  return {
    schema,
    __array: void 0,
    isDefined: true,
    rowCount,
    value,
    valueKind: (row) => Column.ValueKinds.Present,
    toArray: (params) => column_helpers_exports.createAndFillArray(rowCount, value, params),
    areValuesEqual: areValuesEqualProvider(tokens)
  };
}
function areValuesEqualProvider(tokens) {
  const { data, indices } = tokens;
  return function(rowA, rowB) {
    const aS = indices[2 * rowA], bS = indices[2 * rowB];
    const len = indices[2 * rowA + 1] - aS;
    if (len !== indices[2 * rowB + 1] - bS)
      return false;
    for (let i = 0; i < len; i++) {
      if (data.charCodeAt(i + aS) !== data.charCodeAt(i + bS)) {
        return false;
      }
    }
    return true;
  };
}
function areTokensEmpty(tokens) {
  const { count, indices } = tokens;
  for (let i = 0; i < count; ++i) {
    if (indices[2 * i] !== indices[2 * i + 1])
      return false;
  }
  return true;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/data-model.js
function CifFile(blocks, name) {
  return { name, blocks };
}
function CifBlock(categoryNames, categories, header, saveFrames = []) {
  return {
    categoryNames,
    header,
    categories,
    saveFrames,
    getField(name) {
      const [category, field] = name.split(".");
      return categories[category].getField(field || "");
    }
  };
}
function CifSaveFrame(categoryNames, categories, header) {
  return { categoryNames, header, categories };
}
function CifCategory(name, rowCount, fieldNames, fields) {
  return { rowCount, name, fieldNames: [...fieldNames], getField(name2) {
    return fields[name2];
  } };
}
(function(CifCategory5) {
  function empty(name) {
    return { rowCount: 0, name, fieldNames: [], getField(name2) {
      return void 0;
    } };
  }
  CifCategory5.empty = empty;
  ;
  function ofFields(name, fields) {
    const fieldNames = Object.keys(fields);
    return {
      rowCount: fieldNames.length > 0 ? fields[fieldNames[0]].rowCount : 0,
      name,
      fieldNames,
      getField(name2) {
        return fields[name2];
      }
    };
  }
  CifCategory5.ofFields = ofFields;
  function ofTable(name, table) {
    const fields = {};
    for (const name2 of table._columns) {
      fields[name2] = CifField.ofColumn(table[name2]);
    }
    return ofFields(name, fields);
  }
  CifCategory5.ofTable = ofTable;
})(CifCategory || (CifCategory = {}));
var CifField;
(function(CifField4) {
  function ofString(value) {
    return ofStrings([value]);
  }
  CifField4.ofString = ofString;
  function ofStrings(values) {
    const rowCount = values.length;
    const str9 = (row) => {
      const ret = values[row];
      if (!ret || ret === "." || ret === "?")
        return "";
      return ret;
    };
    const int7 = (row) => {
      const v = values[row];
      return parseInt2(v, 0, v.length) || 0;
    };
    const float7 = (row) => {
      const v = values[row];
      return parseFloat2(v, 0, v.length) || 0;
    };
    const valueKind = (row) => {
      const v = values[row], l = v.length;
      if (l > 1)
        return Column.ValueKinds.Present;
      if (l === 0)
        return Column.ValueKinds.NotPresent;
      const c = v.charCodeAt(0);
      if (c === 46)
        return Column.ValueKinds.NotPresent;
      if (c === 63)
        return Column.ValueKinds.Unknown;
      return Column.ValueKinds.Present;
    };
    return {
      __array: void 0,
      binaryEncoding: void 0,
      isDefined: true,
      rowCount,
      str: str9,
      int: int7,
      float: float7,
      valueKind,
      areValuesEqual: (rowA, rowB) => values[rowA] === values[rowB],
      toStringArray: (params) => params ? column_helpers_exports.createAndFillArray(rowCount, str9, params) : values,
      toIntArray: (params) => column_helpers_exports.createAndFillArray(rowCount, int7, params),
      toFloatArray: (params) => column_helpers_exports.createAndFillArray(rowCount, float7, params)
    };
  }
  CifField4.ofStrings = ofStrings;
  function ofNumbers(values) {
    const rowCount = values.length;
    const str9 = (row) => {
      return "" + values[row];
    };
    const float7 = (row) => values[row];
    const valueKind = (row) => Column.ValueKinds.Present;
    const toFloatArray = (params) => {
      if (!params || params.array && values instanceof params.array) {
        return values;
      } else {
        return column_helpers_exports.createAndFillArray(rowCount, float7, params);
      }
    };
    return {
      __array: void 0,
      binaryEncoding: void 0,
      isDefined: true,
      rowCount,
      str: str9,
      int: float7,
      float: float7,
      valueKind,
      areValuesEqual: (rowA, rowB) => values[rowA] === values[rowB],
      toStringArray: (params) => column_helpers_exports.createAndFillArray(rowCount, str9, params),
      toIntArray: toFloatArray,
      toFloatArray
    };
  }
  CifField4.ofNumbers = ofNumbers;
  function ofTokens(tokens) {
    const { data, indices, count: rowCount } = tokens;
    const str9 = (row) => {
      const ret = data.substring(indices[2 * row], indices[2 * row + 1]);
      if (ret === "." || ret === "?")
        return "";
      return ret;
    };
    const int7 = (row) => {
      return parseInt2(data, indices[2 * row], indices[2 * row + 1]) || 0;
    };
    const float7 = (row) => {
      return parseFloat2(data, indices[2 * row], indices[2 * row + 1]) || 0;
    };
    const valueKind = (row) => {
      const s = indices[2 * row], l = indices[2 * row + 1] - s;
      if (l > 1)
        return Column.ValueKinds.Present;
      if (l === 0)
        return Column.ValueKinds.NotPresent;
      const v = data.charCodeAt(s);
      if (v === 46)
        return Column.ValueKinds.NotPresent;
      if (v === 63)
        return Column.ValueKinds.Unknown;
      return Column.ValueKinds.Present;
    };
    return {
      __array: void 0,
      binaryEncoding: void 0,
      isDefined: true,
      rowCount,
      str: str9,
      int: int7,
      float: float7,
      valueKind,
      areValuesEqual: areValuesEqualProvider(tokens),
      toStringArray: (params) => column_helpers_exports.createAndFillArray(rowCount, str9, params),
      toIntArray: (params) => column_helpers_exports.createAndFillArray(rowCount, int7, params),
      toFloatArray: (params) => column_helpers_exports.createAndFillArray(rowCount, float7, params)
    };
  }
  CifField4.ofTokens = ofTokens;
  function ofColumn(column) {
    const { rowCount, valueKind, areValuesEqual, isDefined: isDefined2 } = column;
    let str9;
    let int7;
    let float7;
    switch (column.schema.valueType) {
      case "float":
      case "int":
        str9 = (row) => {
          return "" + column.value(row);
        };
        int7 = column.value;
        float7 = column.value;
        break;
      case "str":
        str9 = column.value;
        int7 = (row) => {
          const v = column.value(row);
          return parseInt2(v, 0, v.length) || 0;
        };
        float7 = (row) => {
          const v = column.value(row);
          return parseFloat2(v, 0, v.length) || 0;
        };
        break;
      case "list":
        const { separator } = column.schema;
        str9 = (row) => column.value(row).join(separator);
        int7 = (row) => NaN;
        float7 = (row) => NaN;
        break;
      default:
        throw new Error(`unsupported valueType '${column.schema.valueType}'`);
    }
    return {
      __array: void 0,
      binaryEncoding: void 0,
      isDefined: isDefined2,
      rowCount,
      str: str9,
      int: int7,
      float: float7,
      valueKind,
      areValuesEqual,
      toStringArray: (params) => column_helpers_exports.createAndFillArray(rowCount, str9, params),
      toIntArray: (params) => column_helpers_exports.createAndFillArray(rowCount, int7, params),
      toFloatArray: (params) => column_helpers_exports.createAndFillArray(rowCount, float7, params)
    };
  }
  CifField4.ofColumn = ofColumn;
  function ofUndefined(rowCount, schema) {
    return ofColumn(Column.Undefined(rowCount, schema));
  }
  CifField4.ofUndefined = ofUndefined;
})(CifField || (CifField = {}));
function tensorFieldNameGetter(field, rank, zeroIndexed, namingVariant) {
  const offset = zeroIndexed ? 0 : 1;
  switch (rank) {
    case 1:
      return namingVariant === "brackets" ? (i) => `${field}[${i + offset}]` : (i) => `${field}_${i + offset}`;
    case 2:
      return namingVariant === "brackets" ? (i, j) => `${field}[${i + offset}][${j + offset}]` : (i, j) => `${field}_${i + offset}${j + offset}`;
    case 3:
      return namingVariant === "brackets" ? (i, j, k) => `${field}[${i + offset}][${j + offset}][${k + offset}]` : (i, j, k) => `${field}_${i + offset}${j + offset}${k + offset}`;
    default:
      throw new Error("Tensors with rank > 3 or rank 0 are currently not supported.");
  }
}
function getTensor(category, space, row, getName) {
  const ret = space.create();
  if (space.rank === 1) {
    const rows = space.dimensions[0];
    for (let i = 0; i < rows; i++) {
      const f = category.getField(getName(i));
      space.set(ret, i, !!f ? f.float(row) : 0);
    }
  } else if (space.rank === 2) {
    const rows = space.dimensions[0], cols = space.dimensions[1];
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        const f = category.getField(getName(i, j));
        space.set(ret, i, j, !!f ? f.float(row) : 0);
      }
    }
  } else if (space.rank === 3) {
    const d0 = space.dimensions[0], d1 = space.dimensions[1], d2 = space.dimensions[2];
    for (let i = 0; i < d0; i++) {
      for (let j = 0; j < d1; j++) {
        for (let k = 0; k < d2; k++) {
          const f = category.getField(getName(i, j, k));
          space.set(ret, i, j, k, !!f ? f.float(row) : 0);
        }
      }
    }
  } else {
    throw new Error("Tensors with rank > 3 or rank 0 are currently not supported.");
  }
  return ret;
}
function getCifFieldType(field) {
  let floatCount = 0, hasStringOrScientific = false, undefinedCount = 0;
  for (let i = 0, _i = field.rowCount; i < _i; i++) {
    const k = field.valueKind(i);
    if (k !== Column.ValueKinds.Present) {
      undefinedCount++;
      continue;
    }
    const type3 = getNumberType(field.str(i));
    if (type3 === NumberTypes.Int)
      continue;
    else if (type3 === NumberTypes.Float)
      floatCount++;
    else {
      hasStringOrScientific = true;
      break;
    }
  }
  if (hasStringOrScientific || undefinedCount === field.rowCount)
    return Column.Schema.str;
  if (floatCount > 0)
    return Column.Schema.float;
  return Column.Schema.int;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/schema.js
var FieldPath;
(function(FieldPath2) {
  function canonical(path) {
    return path.replace(".", "_").replace(/\[/, "_").replace(/(\[|\])/g, "");
  }
  FieldPath2.canonical = canonical;
  function equal(pathA, pathB) {
    return canonical(pathA) === canonical(pathB);
  }
  FieldPath2.equal = equal;
  function create(category, field, asCanonical = false) {
    const p3 = `${category}${field ? `.${field}` : ""}`;
    return asCanonical ? canonical(p3) : p3;
  }
  FieldPath2.create = create;
})(FieldPath || (FieldPath = {}));
function toDatabaseCollection(schema, file, aliases) {
  const dbc = {};
  for (const data of file.blocks) {
    dbc[data.header] = toDatabase(schema, data, aliases);
  }
  return dbc;
}
function toDatabase(schema, frame, aliases) {
  return createDatabase(schema, frame, aliases);
}
function toTable(schema, category) {
  return new CategoryTable(category, schema, true);
}
function getColumnCtor(t) {
  switch (t.valueType) {
    case "str":
      return (f, c, k) => createStringColumn(t, f, f.str, f.toStringArray);
    case "int":
      return (f, c, k) => createColumn(t, f, f.int, f.toIntArray);
    case "float":
      return (f, c, k) => createColumn(t, f, f.float, f.toFloatArray);
    case "list":
      throw new Error("Use createListColumn instead.");
    case "tensor":
      throw new Error("Use createTensorColumn instead.");
  }
}
function createStringColumn(schema, field, value, toArray) {
  return {
    schema,
    __array: field.__array,
    isDefined: field.isDefined,
    rowCount: field.rowCount,
    value: schema.transform === "lowercase" ? (row) => value(row).toLowerCase() : schema.transform === "uppercase" ? (row) => value(row).toUpperCase() : value,
    valueKind: field.valueKind,
    areValuesEqual: field.areValuesEqual,
    toArray: schema.transform === "lowercase" ? (p3) => Array.from(toArray(p3)).map((x) => x.toLowerCase()) : schema.transform === "uppercase" ? (p3) => Array.from(toArray(p3)).map((x) => x.toUpperCase()) : toArray
  };
}
function createColumn(schema, field, value, toArray) {
  return {
    schema,
    __array: field.__array,
    isDefined: field.isDefined,
    rowCount: field.rowCount,
    value,
    valueKind: field.valueKind,
    areValuesEqual: field.areValuesEqual,
    toArray
  };
}
function createListColumn(schema, category, key) {
  const separator = schema.separator;
  const itemParse = schema.itemParse;
  const f = category.getField(key);
  const value = f ? (row) => f.str(row).split(separator).map((x) => itemParse(x.trim())).filter((x) => !!x) : (row) => [];
  const toArray = (params) => column_helpers_exports.createAndFillArray(category.rowCount, value, params);
  return {
    schema,
    __array: void 0,
    isDefined: !!f,
    rowCount: category.rowCount,
    value,
    valueKind: f ? f.valueKind : () => Column.ValueKinds.NotPresent,
    areValuesEqual: (rowA, rowB) => arrayEqual(value(rowA), value(rowB)),
    toArray
  };
}
function createTensorColumn(schema, category, key) {
  const space = schema.space;
  const zeroOffset = category.fieldNames.includes(`${key}[0]`) || category.fieldNames.includes(`${key}[0][0]`) || category.fieldNames.includes(`${key}[0][0][0]`);
  const fst = zeroOffset ? 0 : 1;
  const namingVariant = category.fieldNames.includes(`${key}_1`) || category.fieldNames.includes(`${key}_11`) || category.fieldNames.includes(`${key}_111`) ? "underscore" : "brackets";
  const getName = tensorFieldNameGetter(key, space.rank, zeroOffset, namingVariant);
  const first2 = category.getField(getName(fst, fst, fst)) || Column.Undefined(category.rowCount, schema);
  const value = (row) => getTensor(category, space, row, getName);
  const toArray = (params) => column_helpers_exports.createAndFillArray(category.rowCount, value, params);
  return {
    schema,
    __array: void 0,
    isDefined: first2.isDefined,
    rowCount: category.rowCount,
    value,
    valueKind: first2.valueKind,
    areValuesEqual: (rowA, rowB) => Tensor.areEqualExact(value(rowA), value(rowB)),
    toArray
  };
}
var CategoryTable = class {
  constructor(category, schema, _isDefined) {
    this._isDefined = _isDefined;
    const fieldKeys = Object.keys(schema);
    this._rowCount = category.rowCount;
    this._columns = fieldKeys;
    this._schema = schema;
    const cache = /* @__PURE__ */ Object.create(null);
    for (const k of fieldKeys) {
      Object.defineProperty(this, k, {
        get: function() {
          if (cache[k])
            return cache[k];
          const fType = schema[k];
          if (fType.valueType === "list") {
            cache[k] = createListColumn(fType, category, k);
          } else if (fType.valueType === "tensor") {
            cache[k] = createTensorColumn(fType, category, k);
          } else {
            const ctor = getColumnCtor(fType);
            const field = category.getField(k);
            cache[k] = !!field ? ctor(field, category, k) : Column.Undefined(category.rowCount, fType);
          }
          return cache[k];
        },
        enumerable: true,
        configurable: false
      });
    }
  }
};
function createDatabase(schema, frame, aliases) {
  const tables = /* @__PURE__ */ Object.create(null);
  for (const k of Object.keys(schema)) {
    tables[k] = createTable(k, schema[k], frame, aliases);
  }
  return Database.ofTables(frame.header, schema, tables);
}
function flattenFrame(frame) {
  const flatFrame = /* @__PURE__ */ Object.create(null);
  for (const c of Object.keys(frame.categories)) {
    for (const f of frame.categories[c].fieldNames) {
      const p3 = FieldPath.create(c, f, true);
      flatFrame[p3] = frame.categories[c].getField(f);
    }
  }
  return flatFrame;
}
function getField(field, category, flatFrame, aliases) {
  const path = FieldPath.create(category, field);
  const canonicalPath = FieldPath.canonical(path);
  if (canonicalPath in flatFrame)
    return flatFrame[canonicalPath];
  if (aliases && path in aliases) {
    for (const aliased of aliases[path]) {
      const canonicalAliased = FieldPath.canonical(aliased);
      if (canonicalAliased in flatFrame)
        return flatFrame[canonicalAliased];
    }
  }
}
function createTable(key, schema, frame, aliases) {
  let cat = frame.categories[key];
  if (aliases) {
    const flatFrame = flattenFrame(frame);
    const fields = /* @__PURE__ */ Object.create(null);
    const fieldNames = [];
    let rowCount = 0;
    for (const k of Object.keys(schema)) {
      const field = getField(k, key, flatFrame, aliases);
      if (field) {
        fields[k] = field;
        fieldNames.push(k);
        rowCount = field.rowCount;
      }
    }
    cat = {
      rowCount,
      name: key,
      fieldNames: [...fieldNames],
      getField(name) {
        return fields[name];
      }
    };
  }
  return new CategoryTable(cat || CifCategory.empty(key), schema, !!cat);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/primitives/axes3d.js
function Axes3D() {
  return Axes3D.empty();
}
(function(Axes3D2) {
  function create(origin, dirA, dirB, dirC) {
    return { origin, dirA, dirB, dirC };
  }
  Axes3D2.create = create;
  function empty() {
    return { origin: Vec3(), dirA: Vec3(), dirB: Vec3(), dirC: Vec3() };
  }
  Axes3D2.empty = empty;
  function copy(out, a) {
    Vec3.copy(out.origin, a.origin);
    Vec3.copy(out.dirA, a.dirA);
    Vec3.copy(out.dirB, a.dirB);
    Vec3.copy(out.dirC, a.dirC);
    return out;
  }
  Axes3D2.copy = copy;
  function clone(a) {
    return copy(empty(), a);
  }
  Axes3D2.clone = clone;
  function size(size2, axes) {
    return Vec3.set(size2, Vec3.magnitude(axes.dirA) * 2, Vec3.magnitude(axes.dirB) * 2, Vec3.magnitude(axes.dirC) * 2);
  }
  Axes3D2.size = size;
  const tmpSizeV = Vec3();
  function volume(axes) {
    size(tmpSizeV, axes);
    return tmpSizeV[0] * tmpSizeV[1] * tmpSizeV[2];
  }
  Axes3D2.volume = volume;
  function normalize(out, a) {
    Vec3.copy(out.origin, a.origin);
    Vec3.normalize(out.dirA, a.dirA);
    Vec3.normalize(out.dirB, a.dirB);
    Vec3.normalize(out.dirC, a.dirC);
    return out;
  }
  Axes3D2.normalize = normalize;
  const tmpTransformMat3 = Mat3();
  function transform(out, a, m) {
    Vec3.transformMat4(out.origin, a.origin, m);
    const n = Mat3.directionTransform(tmpTransformMat3, m);
    Vec3.transformMat3(out.dirA, a.dirA, n);
    Vec3.transformMat3(out.dirB, a.dirB, n);
    Vec3.transformMat3(out.dirC, a.dirC, n);
    return out;
  }
  Axes3D2.transform = transform;
  function scale(out, a, scale2) {
    Vec3.scale(out.dirA, a.dirA, scale2);
    Vec3.scale(out.dirB, a.dirB, scale2);
    Vec3.scale(out.dirC, a.dirC, scale2);
    return out;
  }
  Axes3D2.scale = scale;
})(Axes3D || (Axes3D = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/linear-algebra/matrix/matrix.js
var Matrix;
(function(Matrix4) {
  function create(cols, rows, ctor = Float32Array) {
    const size = cols * rows;
    return { data: new ctor(size), size, cols, rows };
  }
  Matrix4.create = create;
  function get(m, i, j) {
    return m.data[m.rows * j + i];
  }
  Matrix4.get = get;
  function set2(m, i, j, value) {
    m.data[m.rows * j + i] = value;
    return m;
  }
  Matrix4.set = set2;
  function add(m, i, j, value) {
    m.data[m.rows * j + i] += value;
    return m;
  }
  Matrix4.add = add;
  function makeZero(m) {
    m.data.fill(0);
    return m;
  }
  Matrix4.makeZero = makeZero;
  function clone(m) {
    return { data: m.data.slice(), size: m.size, cols: m.cols, rows: m.rows };
  }
  Matrix4.clone = clone;
  function fromArray(data, cols, rows) {
    return { data, size: cols * rows, cols, rows };
  }
  Matrix4.fromArray = fromArray;
  function transpose(out, mat) {
    if (out.cols !== mat.rows || out.rows !== mat.cols) {
      throw new Error("transpose: matrix dimensions incompatible");
    }
    if (out.data === mat.data) {
      throw new Error("transpose: matrices share memory");
    }
    const nrows = mat.rows, ncols = mat.cols;
    const md = mat.data, mtd = out.data;
    for (let i = 0, mi = 0, mti = 0; i < nrows; mti += 1, mi += ncols, ++i) {
      let ri = mti;
      for (let j = 0; j < ncols; ri += nrows, j++)
        mtd[ri] = md[mi + j];
    }
    return out;
  }
  Matrix4.transpose = transpose;
  function multiplyABt(out, matA, matB) {
    const ncols = matA.cols, nrows = matA.rows, mrows = matB.rows;
    const ad = matA.data, bd = matB.data, cd = out.data;
    for (let i = 0, matAp = 0, outP = 0; i < nrows; matAp += ncols, i++) {
      for (let pB = 0, j = 0; j < mrows; outP++, j++) {
        let sum = 0;
        let pMatA = matAp;
        for (let k = 0; k < ncols; pMatA++, pB++, k++) {
          sum += ad[pMatA] * bd[pB];
        }
        cd[outP] = sum;
      }
    }
    return out;
  }
  Matrix4.multiplyABt = multiplyABt;
  function meanRows(mat) {
    const nrows = mat.rows, ncols = mat.cols;
    const md = mat.data;
    const mean = new Array(ncols);
    for (let j = 0; j < ncols; ++j)
      mean[j] = 0;
    for (let i = 0, p3 = 0; i < nrows; ++i) {
      for (let j = 0; j < ncols; ++j, ++p3)
        mean[j] += md[p3];
    }
    for (let j = 0; j < ncols; ++j)
      mean[j] /= nrows;
    return mean;
  }
  Matrix4.meanRows = meanRows;
  function subRows(mat, row) {
    const nrows = mat.rows, ncols = mat.cols;
    const md = mat.data;
    for (let i = 0, p3 = 0; i < nrows; ++i) {
      for (let j = 0; j < ncols; ++j, ++p3)
        md[p3] -= row[j];
    }
    return mat;
  }
  Matrix4.subRows = subRows;
})(Matrix || (Matrix = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/linear-algebra/matrix/svd.js
function swap(A, i0, i1, t) {
  t = A[i0];
  A[i0] = A[i1];
  A[i1] = t;
}
function hypot(a, b) {
  a = Math.abs(a);
  b = Math.abs(b);
  if (a > b) {
    b /= a;
    return a * Math.sqrt(1 + b * b);
  }
  if (b > 0) {
    a /= b;
    return b * Math.sqrt(1 + a * a);
  }
  return 0;
}
var EPSILON2 = 1192092896e-16;
var FLT_MIN = 1e-37;
function JacobiSVDImpl(At, astep, _W, Vt, vstep, m, n, n1) {
  const eps = EPSILON2 * 2;
  const minval = FLT_MIN;
  let i = 0;
  let j = 0;
  let k = 0;
  let iter = 0;
  const maxIter = Math.max(m, 30);
  let Ai = 0;
  let Aj = 0;
  let Vi = 0;
  let Vj = 0;
  let changed = 0;
  let c = 0;
  let s = 0;
  let t = 0;
  let t0 = 0;
  let t1 = 0;
  let sd = 0;
  let beta = 0;
  let gamma = 0;
  let delta2 = 0;
  let a = 0;
  let p3 = 0;
  let b = 0;
  let seed = 4660;
  let val = 0;
  let val0 = 0;
  let asum = 0;
  const W = new Float64Array(n << 3);
  for (; i < n; i++) {
    for (k = 0, sd = 0; k < m; k++) {
      t = At[i * astep + k];
      sd += t * t;
    }
    W[i] = sd;
    if (Vt) {
      for (k = 0; k < n; k++) {
        Vt[i * vstep + k] = 0;
      }
      Vt[i * vstep + i] = 1;
    }
  }
  for (; iter < maxIter; iter++) {
    changed = 0;
    for (i = 0; i < n - 1; i++) {
      for (j = i + 1; j < n; j++) {
        Ai = i * astep | 0;
        Aj = j * astep | 0;
        a = W[i];
        p3 = 0;
        b = W[j];
        k = 2;
        p3 += At[Ai] * At[Aj];
        p3 += At[Ai + 1] * At[Aj + 1];
        for (; k < m; k++) {
          p3 += At[Ai + k] * At[Aj + k];
        }
        if (Math.abs(p3) <= eps * Math.sqrt(a * b))
          continue;
        p3 *= 2;
        beta = a - b;
        gamma = hypot(p3, beta);
        if (beta < 0) {
          delta2 = (gamma - beta) * 0.5;
          s = Math.sqrt(delta2 / gamma);
          c = p3 / (gamma * s * 2);
        } else {
          c = Math.sqrt((gamma + beta) / (gamma * 2));
          s = p3 / (gamma * c * 2);
        }
        a = 0;
        b = 0;
        k = 2;
        t0 = c * At[Ai] + s * At[Aj];
        t1 = -s * At[Ai] + c * At[Aj];
        At[Ai] = t0;
        At[Aj] = t1;
        a += t0 * t0;
        b += t1 * t1;
        t0 = c * At[Ai + 1] + s * At[Aj + 1];
        t1 = -s * At[Ai + 1] + c * At[Aj + 1];
        At[Ai + 1] = t0;
        At[Aj + 1] = t1;
        a += t0 * t0;
        b += t1 * t1;
        for (; k < m; k++) {
          t0 = c * At[Ai + k] + s * At[Aj + k];
          t1 = -s * At[Ai + k] + c * At[Aj + k];
          At[Ai + k] = t0;
          At[Aj + k] = t1;
          a += t0 * t0;
          b += t1 * t1;
        }
        W[i] = a;
        W[j] = b;
        changed = 1;
        if (Vt) {
          Vi = i * vstep | 0;
          Vj = j * vstep | 0;
          k = 2;
          t0 = c * Vt[Vi] + s * Vt[Vj];
          t1 = -s * Vt[Vi] + c * Vt[Vj];
          Vt[Vi] = t0;
          Vt[Vj] = t1;
          t0 = c * Vt[Vi + 1] + s * Vt[Vj + 1];
          t1 = -s * Vt[Vi + 1] + c * Vt[Vj + 1];
          Vt[Vi + 1] = t0;
          Vt[Vj + 1] = t1;
          for (; k < n; k++) {
            t0 = c * Vt[Vi + k] + s * Vt[Vj + k];
            t1 = -s * Vt[Vi + k] + c * Vt[Vj + k];
            Vt[Vi + k] = t0;
            Vt[Vj + k] = t1;
          }
        }
      }
    }
    if (changed === 0)
      break;
  }
  for (i = 0; i < n; i++) {
    for (k = 0, sd = 0; k < m; k++) {
      t = At[i * astep + k];
      sd += t * t;
    }
    W[i] = Math.sqrt(sd);
  }
  for (i = 0; i < n - 1; i++) {
    j = i;
    for (k = i + 1; k < n; k++) {
      if (W[j] < W[k]) {
        j = k;
      }
    }
    if (i !== j) {
      swap(W, i, j, sd);
      if (Vt) {
        for (k = 0; k < m; k++) {
          swap(At, i * astep + k, j * astep + k, t);
        }
        for (k = 0; k < n; k++) {
          swap(Vt, i * vstep + k, j * vstep + k, t);
        }
      }
    }
  }
  for (i = 0; i < n; i++) {
    _W[i] = W[i];
  }
  if (!Vt) {
    return;
  }
  for (i = 0; i < n1; i++) {
    sd = i < n ? W[i] : 0;
    while (sd <= minval) {
      val0 = 1 / m;
      for (k = 0; k < m; k++) {
        seed = seed * 214013 + 2531011;
        val = (seed >> 16 & 32767 & 256) !== 0 ? val0 : -val0;
        At[i * astep + k] = val;
      }
      for (iter = 0; iter < 2; iter++) {
        for (j = 0; j < i; j++) {
          sd = 0;
          for (k = 0; k < m; k++) {
            sd += At[i * astep + k] * At[j * astep + k];
          }
          asum = 0;
          for (k = 0; k < m; k++) {
            t = At[i * astep + k] - sd * At[j * astep + k];
            At[i * astep + k] = t;
            asum += Math.abs(t);
          }
          asum = asum ? 1 / asum : 0;
          for (k = 0; k < m; k++) {
            At[i * astep + k] *= asum;
          }
        }
      }
      sd = 0;
      for (k = 0; k < m; k++) {
        t = At[i * astep + k];
        sd += t * t;
      }
      sd = Math.sqrt(sd);
    }
    s = 1 / sd;
    for (k = 0; k < m; k++) {
      At[i * astep + k] *= s;
    }
  }
}
function svd(A, W, U2, V) {
  let at = 0;
  let i = 0;
  const _m = A.rows;
  const _n = A.cols;
  let m = _m;
  let n = _n;
  if (m < n) {
    at = 1;
    i = m;
    m = n;
    n = i;
  }
  const amt = Matrix.create(m, m);
  const wmt = Matrix.create(1, n);
  const vmt = Matrix.create(n, n);
  if (at === 0) {
    Matrix.transpose(amt, A);
  } else {
    for (i = 0; i < _n * _m; i++) {
      amt.data[i] = A.data[i];
    }
    for (; i < n * m; i++) {
      amt.data[i] = 0;
    }
  }
  JacobiSVDImpl(amt.data, m, wmt.data, vmt.data, n, m, n, m);
  if (W) {
    for (i = 0; i < n; i++) {
      W.data[i] = wmt.data[i];
    }
    for (; i < _n; i++) {
      W.data[i] = 0;
    }
  }
  if (at === 0) {
    if (U2)
      Matrix.transpose(U2, amt);
    if (V)
      Matrix.transpose(V, vmt);
  } else {
    if (U2)
      Matrix.transpose(U2, vmt);
    if (V)
      Matrix.transpose(V, amt);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/linear-algebra/matrix/principal-axes.js
var PrincipalAxes;
(function(PrincipalAxes2) {
  function ofPositions(positions) {
    const momentsAxes = calculateMomentsAxes(positions);
    const boxAxes = calculateBoxAxes(positions, momentsAxes);
    return { momentsAxes, boxAxes };
  }
  PrincipalAxes2.ofPositions = ofPositions;
  function calculateMomentsAxes(positions) {
    if (positions.length === 3) {
      return Axes3D.create(Vec3.fromArray(Vec3(), positions, 0), Vec3.create(1, 0, 0), Vec3.create(0, 1, 0), Vec3.create(0, 0, 1));
    }
    const points = Matrix.fromArray(positions, 3, positions.length / 3);
    const n = points.rows;
    const n3 = n / 3;
    const A = Matrix.create(3, 3);
    const W = Matrix.create(1, 3);
    const U2 = Matrix.create(3, 3);
    const V = Matrix.create(3, 3);
    const mean = Matrix.meanRows(points);
    const pointsM = Matrix.subRows(Matrix.clone(points), mean);
    const pointsT = Matrix.transpose(Matrix.create(n, 3), pointsM);
    Matrix.multiplyABt(A, pointsT, pointsT);
    svd(A, W, U2, V);
    const origin = Vec3.create(mean[0], mean[1], mean[2]);
    const dirA = Vec3.create(U2.data[0], U2.data[3], U2.data[6]);
    const dirB = Vec3.create(U2.data[1], U2.data[4], U2.data[7]);
    const dirC = Vec3.create(U2.data[2], U2.data[5], U2.data[8]);
    Vec3.scale(dirA, dirA, Math.sqrt(W.data[0] / n3));
    Vec3.scale(dirB, dirB, Math.sqrt(W.data[1] / n3));
    Vec3.scale(dirC, dirC, Math.sqrt(W.data[2] / n3));
    return Axes3D.create(origin, dirA, dirB, dirC);
  }
  PrincipalAxes2.calculateMomentsAxes = calculateMomentsAxes;
  function calculateNormalizedAxes(momentsAxes) {
    const a = Axes3D.clone(momentsAxes);
    if (Vec3.magnitude(a.dirC) < EPSILON) {
      Vec3.cross(a.dirC, a.dirA, a.dirB);
    }
    return Axes3D.normalize(a, a);
  }
  PrincipalAxes2.calculateNormalizedAxes = calculateNormalizedAxes;
  const tmpBoxVec = Vec3();
  function calculateBoxAxes(positions, momentsAxes) {
    if (positions.length === 3) {
      return Axes3D.clone(momentsAxes);
    }
    let d1a = -Infinity;
    let d1b = -Infinity;
    let d2a = -Infinity;
    let d2b = -Infinity;
    let d3a = -Infinity;
    let d3b = -Infinity;
    const p3 = Vec3();
    const t = Vec3();
    const center = momentsAxes.origin;
    const a = calculateNormalizedAxes(momentsAxes);
    for (let i = 0, il = positions.length; i < il; i += 3) {
      Vec3.projectPointOnVector(p3, Vec3.fromArray(p3, positions, i), a.dirA, center);
      const dp1 = Vec3.dot(a.dirA, Vec3.normalize(t, Vec3.sub(t, p3, center)));
      const dt1 = Vec3.distance(p3, center);
      if (dp1 > 0) {
        if (dt1 > d1a)
          d1a = dt1;
      } else {
        if (dt1 > d1b)
          d1b = dt1;
      }
      Vec3.projectPointOnVector(p3, Vec3.fromArray(p3, positions, i), a.dirB, center);
      const dp2 = Vec3.dot(a.dirB, Vec3.normalize(t, Vec3.sub(t, p3, center)));
      const dt2 = Vec3.distance(p3, center);
      if (dp2 > 0) {
        if (dt2 > d2a)
          d2a = dt2;
      } else {
        if (dt2 > d2b)
          d2b = dt2;
      }
      Vec3.projectPointOnVector(p3, Vec3.fromArray(p3, positions, i), a.dirC, center);
      const dp3 = Vec3.dot(a.dirC, Vec3.normalize(t, Vec3.sub(t, p3, center)));
      const dt3 = Vec3.distance(p3, center);
      if (dp3 > 0) {
        if (dt3 > d3a)
          d3a = dt3;
      } else {
        if (dt3 > d3b)
          d3b = dt3;
      }
    }
    const dirA = Vec3.setMagnitude(Vec3(), a.dirA, (d1a + d1b) / 2);
    const dirB = Vec3.setMagnitude(Vec3(), a.dirB, (d2a + d2b) / 2);
    const dirC = Vec3.setMagnitude(Vec3(), a.dirC, (d3a + d3b) / 2);
    const okDirA = Vec3.isFinite(dirA);
    const okDirB = Vec3.isFinite(dirB);
    const okDirC = Vec3.isFinite(dirC);
    const origin = Vec3();
    const addCornerHelper = function(d1, d2, d3) {
      Vec3.copy(tmpBoxVec, center);
      if (okDirA)
        Vec3.scaleAndAdd(tmpBoxVec, tmpBoxVec, a.dirA, d1);
      if (okDirB)
        Vec3.scaleAndAdd(tmpBoxVec, tmpBoxVec, a.dirB, d2);
      if (okDirC)
        Vec3.scaleAndAdd(tmpBoxVec, tmpBoxVec, a.dirC, d3);
      Vec3.add(origin, origin, tmpBoxVec);
    };
    addCornerHelper(d1a, d2a, d3a);
    addCornerHelper(d1a, d2a, -d3b);
    addCornerHelper(d1a, -d2b, -d3b);
    addCornerHelper(d1a, -d2b, d3a);
    addCornerHelper(-d1b, -d2b, -d3b);
    addCornerHelper(-d1b, -d2b, d3a);
    addCornerHelper(-d1b, d2a, d3a);
    addCornerHelper(-d1b, d2a, -d3b);
    Vec3.scale(origin, origin, 1 / 8);
    return Axes3D.create(origin, dirA, dirB, dirC);
  }
  PrincipalAxes2.calculateBoxAxes = calculateBoxAxes;
})(PrincipalAxes || (PrincipalAxes = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/primitives/sphere3d.js
function Sphere3D() {
  return Sphere3D.zero();
}
(function(Sphere3D2) {
  function hasExtrema(sphere) {
    return sphere.extrema !== void 0;
  }
  Sphere3D2.hasExtrema = hasExtrema;
  function create(center, radius) {
    return { center, radius };
  }
  Sphere3D2.create = create;
  function zero() {
    return { center: Vec3(), radius: 0 };
  }
  Sphere3D2.zero = zero;
  function clone(a) {
    const out = create(Vec3.clone(a.center), a.radius);
    if (hasExtrema(a))
      out.extrema = a.extrema.map((e) => Vec3.clone(e));
    return out;
  }
  Sphere3D2.clone = clone;
  function set2(out, center, radius) {
    Vec3.copy(out.center, center);
    out.radius = radius;
    return out;
  }
  Sphere3D2.set = set2;
  function copy(out, a) {
    Vec3.copy(out.center, a.center);
    out.radius = a.radius;
    if (hasExtrema(a))
      setExtrema(out, a.extrema.map((e) => Vec3.clone(e)));
    return out;
  }
  Sphere3D2.copy = copy;
  function setExtrema(out, extrema) {
    if (out.extrema !== void 0) {
      out.extrema.length = 0;
      out.extrema.push(...extrema);
    } else {
      out.extrema = extrema;
    }
    return out;
  }
  Sphere3D2.setExtrema = setExtrema;
  function computeBounding(data) {
    const { x, y, z, indices } = data;
    let cx = 0, cy = 0, cz = 0;
    let radiusSq = 0;
    const size = OrderedSet.size(indices);
    for (let t = 0; t < size; t++) {
      const i = OrderedSet.getAt(indices, t);
      cx += x[i];
      cy += y[i];
      cz += z[i];
    }
    if (size > 0) {
      cx /= size;
      cy /= size;
      cz /= size;
    }
    for (let t = 0; t < size; t++) {
      const i = OrderedSet.getAt(indices, t);
      const dx = x[i] - cx, dy = y[i] - cy, dz = z[i] - cz;
      const d = dx * dx + dy * dy + dz * dz;
      if (d > radiusSq)
        radiusSq = d;
    }
    return { center: Vec3.create(cx, cy, cz), radius: Math.sqrt(radiusSq) };
  }
  Sphere3D2.computeBounding = computeBounding;
  function transform(out, sphere, m) {
    Vec3.transformMat4(out.center, sphere.center, m);
    out.radius = sphere.radius * Mat4.getMaxScaleOnAxis(m);
    if (hasExtrema(sphere)) {
      setExtrema(out, sphere.extrema.map((e) => Vec3.transformMat4(Vec3(), e, m)));
    }
    return out;
  }
  Sphere3D2.transform = transform;
  function translate(out, sphere, v) {
    Vec3.add(out.center, sphere.center, v);
    if (hasExtrema(sphere)) {
      setExtrema(out, sphere.extrema.map((e) => Vec3.add(Vec3(), e, v)));
    }
    return out;
  }
  Sphere3D2.translate = translate;
  function toArray(s, out, offset) {
    Vec3.toArray(s.center, out, offset);
    out[offset + 3] = s.radius;
    return out;
  }
  Sphere3D2.toArray = toArray;
  function fromArray(out, array2, offset) {
    Vec3.fromArray(out.center, array2, offset);
    out.radius = array2[offset + 3];
    return out;
  }
  Sphere3D2.fromArray = fromArray;
  function fromBox3D(out, box) {
    Vec3.scale(out.center, Vec3.add(out.center, box.max, box.min), 0.5);
    out.radius = Vec3.distance(out.center, box.max);
    Sphere3D2.setExtrema(out, [
      Vec3.create(box.min[0], box.min[1], box.min[2]),
      Vec3.create(box.max[0], box.max[1], box.max[2]),
      Vec3.create(box.max[0], box.min[1], box.min[2]),
      Vec3.create(box.min[0], box.max[1], box.max[2]),
      Vec3.create(box.min[0], box.min[1], box.max[2]),
      Vec3.create(box.max[0], box.min[1], box.max[2]),
      Vec3.create(box.max[0], box.max[1], box.min[2]),
      Vec3.create(box.min[0], box.max[1], box.min[2])
    ]);
    return out;
  }
  Sphere3D2.fromBox3D = fromBox3D;
  function fromAxes3D(out, axes) {
    Vec3.copy(out.center, axes.origin);
    out.radius = Math.max(Vec3.magnitude(axes.dirA), Vec3.magnitude(axes.dirB), Vec3.magnitude(axes.dirC));
    return out;
  }
  Sphere3D2.fromAxes3D = fromAxes3D;
  const tmpCenter = Vec3();
  function fromDimensionsAndTransform(out, dimensions, transform2) {
    const [x, y, z] = dimensions;
    const cpA = Vec3.create(0, 0, 0);
    Vec3.transformMat4(cpA, cpA, transform2);
    const cpB = Vec3.create(x, y, z);
    Vec3.transformMat4(cpB, cpB, transform2);
    const cpC = Vec3.create(x, 0, 0);
    Vec3.transformMat4(cpC, cpC, transform2);
    const cpD = Vec3.create(0, y, z);
    Vec3.transformMat4(cpD, cpD, transform2);
    const cpE = Vec3.create(0, 0, z);
    Vec3.transformMat4(cpE, cpE, transform2);
    const cpF = Vec3.create(x, 0, z);
    Vec3.transformMat4(cpF, cpF, transform2);
    const cpG = Vec3.create(x, y, 0);
    Vec3.transformMat4(cpG, cpG, transform2);
    const cpH = Vec3.create(0, y, 0);
    Vec3.transformMat4(cpH, cpH, transform2);
    Vec3.add(tmpCenter, cpA, cpB);
    Vec3.scale(tmpCenter, tmpCenter, 0.5);
    const d = Math.max(Vec3.distance(cpA, cpB), Vec3.distance(cpC, cpD));
    Sphere3D2.set(out, tmpCenter, d / 2);
    Sphere3D2.setExtrema(out, [cpA, cpB, cpC, cpD, cpE, cpF, cpG, cpH]);
    return out;
  }
  Sphere3D2.fromDimensionsAndTransform = fromDimensionsAndTransform;
  const tmpAddVec3 = Vec3();
  function addVec3(out, s, v) {
    const d = Vec3.distance(s.center, v);
    if (d < s.radius)
      return Sphere3D2.copy(out, s);
    Vec3.sub(tmpAddVec3, s.center, v);
    Vec3.sub(tmpAddVec3, s.center, tmpAddVec3);
    Vec3.setMagnitude(tmpAddVec3, tmpAddVec3, s.radius);
    Vec3.scale(out.center, Vec3.add(tmpAddVec3, tmpAddVec3, v), 0.5);
    out.radius = Vec3.distance(out.center, v);
    return out;
  }
  Sphere3D2.addVec3 = addVec3;
  function expandBySphere(out, sphere, by) {
    Vec3.copy(out.center, sphere.center);
    out.radius = Math.max(sphere.radius, Vec3.distance(sphere.center, by.center) + by.radius);
    if (hasExtrema(sphere) && hasExtrema(by)) {
      setExtrema(out, [
        ...sphere.extrema.map((e) => Vec3.clone(e)),
        ...by.extrema.map((e) => Vec3.clone(e))
      ]);
    }
    return out;
  }
  Sphere3D2.expandBySphere = expandBySphere;
  const tmpDir = Vec3();
  function expand(out, sphere, delta2) {
    var _a, _b;
    Vec3.copy(out.center, sphere.center);
    out.radius = sphere.radius + delta2;
    if (sphere.radius < 1e-12 || ((_b = (_a = sphere.extrema) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) <= 1) {
      out.extrema = void 0;
      return out;
    }
    if (hasExtrema(sphere)) {
      const positions = new Float32Array(sphere.extrema.length * 3);
      for (let i = 0; i < sphere.extrema.length; i++) {
        Vec3.toArray(sphere.extrema[i], positions, i * 3);
      }
      const axes = PrincipalAxes.calculateMomentsAxes(positions);
      Axes3D.scale(axes, Axes3D.normalize(axes, axes), delta2);
      setExtrema(out, sphere.extrema.map((e) => {
        Vec3.normalize(tmpDir, Vec3.sub(tmpDir, e, sphere.center));
        const o = Vec3.clone(e);
        const sA = Vec3.dot(tmpDir, axes.dirA) < 0 ? -1 : 1;
        Vec3.scaleAndAdd(o, o, axes.dirA, sA);
        const sB = Vec3.dot(tmpDir, axes.dirB) < 0 ? -1 : 1;
        Vec3.scaleAndAdd(o, o, axes.dirB, sB);
        const sC = Vec3.dot(tmpDir, axes.dirC) < 0 ? -1 : 1;
        Vec3.scaleAndAdd(o, o, axes.dirC, sC);
        if (Vec3.distance(out.center, o) > out.radius) {
          if (sphere.extrema.length >= 14) {
            Vec3.normalize(tmpDir, Vec3.sub(tmpDir, o, sphere.center));
          }
          Vec3.scaleAndAdd(o, out.center, tmpDir, out.radius);
        }
        return o;
      }));
    }
    return out;
  }
  Sphere3D2.expand = expand;
  function exactEquals(a, b) {
    return a.radius === b.radius && Vec3.exactEquals(a.center, b.center);
  }
  Sphere3D2.exactEquals = exactEquals;
  function equals(a, b) {
    const ar = a.radius;
    const br = b.radius;
    return Math.abs(ar - br) <= EPSILON * Math.max(1, Math.abs(ar), Math.abs(br)) && Vec3.equals(a.center, b.center);
  }
  Sphere3D2.equals = equals;
  function includes(a, b) {
    if (hasExtrema(b)) {
      for (const e of b.extrema) {
        if (Vec3.distance(a.center, e) > a.radius)
          return false;
      }
      return true;
    } else {
      return Vec3.distance(a.center, b.center) + b.radius <= a.radius;
    }
  }
  Sphere3D2.includes = includes;
  function overlaps(a, b) {
    return Vec3.distance(a.center, b.center) <= a.radius + b.radius;
  }
  Sphere3D2.overlaps = overlaps;
  function distance(a, b) {
    return Vec3.distance(a.center, b.center) - a.radius + b.radius;
  }
  Sphere3D2.distance = distance;
  function distanceToVec(sphere, v) {
    const { center, radius } = sphere;
    return Vec3.distance(v, center) - radius;
  }
  Sphere3D2.distanceToVec = distanceToVec;
})(Sphere3D || (Sphere3D = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/primitives/box3d.js
function Box3D() {
  return Box3D.zero();
}
(function(Box3D2) {
  function create(min, max) {
    return { min, max };
  }
  Box3D2.create = create;
  function zero() {
    return { min: Vec3(), max: Vec3() };
  }
  Box3D2.zero = zero;
  function copy(out, a) {
    Vec3.copy(out.min, a.min);
    Vec3.copy(out.max, a.max);
    return out;
  }
  Box3D2.copy = copy;
  function set2(out, min, max) {
    Vec3.copy(out.min, min);
    Vec3.copy(out.max, max);
    return out;
  }
  Box3D2.set = set2;
  function clone(a) {
    return copy(zero(), a);
  }
  Box3D2.clone = clone;
  const tmpV = Vec3();
  function fromSphere3D(out, sphere) {
    if (Sphere3D.hasExtrema(sphere) && sphere.extrema.length >= 14) {
      return fromVec3Array(out, sphere.extrema);
    }
    Vec3.set(tmpV, sphere.radius, sphere.radius, sphere.radius);
    Vec3.sub(out.min, sphere.center, tmpV);
    Vec3.add(out.max, sphere.center, tmpV);
    return out;
  }
  Box3D2.fromSphere3D = fromSphere3D;
  function addVec3Array(out, array2) {
    for (let i = 0, il = array2.length; i < il; i++) {
      add(out, array2[i]);
    }
    return out;
  }
  Box3D2.addVec3Array = addVec3Array;
  function fromVec3Array(out, array2) {
    setEmpty(out);
    addVec3Array(out, array2);
    return out;
  }
  Box3D2.fromVec3Array = fromVec3Array;
  function addSphere3D(out, sphere) {
    if (Sphere3D.hasExtrema(sphere) && sphere.extrema.length >= 14) {
      return addVec3Array(out, sphere.extrema);
    }
    add(out, Vec3.subScalar(tmpV, sphere.center, sphere.radius));
    add(out, Vec3.addScalar(tmpV, sphere.center, sphere.radius));
    return out;
  }
  Box3D2.addSphere3D = addSphere3D;
  function intersectsSphere3D(box, sphere) {
    Vec3.clamp(tmpV, sphere.center, box.min, box.max);
    return Vec3.squaredDistance(tmpV, sphere.center) <= sphere.radius * sphere.radius;
  }
  Box3D2.intersectsSphere3D = intersectsSphere3D;
  function computeBounding(data) {
    const min = Vec3.create(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const max = Vec3.create(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    const { x, y, z, indices } = data;
    for (let t = 0, _t = OrderedSet.size(indices); t < _t; t++) {
      const i = OrderedSet.getAt(indices, t);
      min[0] = Math.min(x[i], min[0]);
      min[1] = Math.min(y[i], min[1]);
      min[2] = Math.min(z[i], min[2]);
      max[0] = Math.max(x[i], max[0]);
      max[1] = Math.max(y[i], max[1]);
      max[2] = Math.max(z[i], max[2]);
    }
    return { min, max };
  }
  Box3D2.computeBounding = computeBounding;
  function size(size2, box) {
    return Vec3.sub(size2, box.max, box.min);
  }
  Box3D2.size = size;
  const tmpSizeV = Vec3();
  function volume(box) {
    size(tmpSizeV, box);
    return tmpSizeV[0] * tmpSizeV[1] * tmpSizeV[2];
  }
  Box3D2.volume = volume;
  function setEmpty(box) {
    Vec3.set(box.min, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    Vec3.set(box.max, -Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    return box;
  }
  Box3D2.setEmpty = setEmpty;
  function add(box, point) {
    Vec3.min(box.min, box.min, point);
    Vec3.max(box.max, box.max, point);
    return box;
  }
  Box3D2.add = add;
  function expand(out, box, delta2) {
    Vec3.sub(out.min, box.min, delta2);
    Vec3.add(out.max, box.max, delta2);
    return out;
  }
  Box3D2.expand = expand;
  function expandUniformly(out, box, delta2) {
    Vec3.subScalar(out.min, box.min, delta2);
    Vec3.addScalar(out.max, box.max, delta2);
    return out;
  }
  Box3D2.expandUniformly = expandUniformly;
  function scale(out, box, scale2) {
    Vec3.scale(out.min, box.min, scale2);
    Vec3.scale(out.max, box.max, scale2);
    return out;
  }
  Box3D2.scale = scale;
  const tmpTransformV = Vec3();
  function transform(out, box, m) {
    const [minX, minY, minZ] = box.min;
    const [maxX, maxY, maxZ] = box.max;
    setEmpty(out);
    add(out, Vec3.transformMat4(tmpTransformV, Vec3.set(tmpTransformV, minX, minY, minZ), m));
    add(out, Vec3.transformMat4(tmpTransformV, Vec3.set(tmpTransformV, minX, minY, maxZ), m));
    add(out, Vec3.transformMat4(tmpTransformV, Vec3.set(tmpTransformV, minX, maxY, minZ), m));
    add(out, Vec3.transformMat4(tmpTransformV, Vec3.set(tmpTransformV, minX, maxY, maxZ), m));
    add(out, Vec3.transformMat4(tmpTransformV, Vec3.set(tmpTransformV, maxX, minY, minZ), m));
    add(out, Vec3.transformMat4(tmpTransformV, Vec3.set(tmpTransformV, maxX, minY, maxZ), m));
    add(out, Vec3.transformMat4(tmpTransformV, Vec3.set(tmpTransformV, maxX, maxY, minZ), m));
    add(out, Vec3.transformMat4(tmpTransformV, Vec3.set(tmpTransformV, maxX, maxY, maxZ), m));
    return out;
  }
  Box3D2.transform = transform;
  function containsVec3(box, v) {
    return !(v[0] < box.min[0] || v[0] > box.max[0] || v[1] < box.min[1] || v[1] > box.max[1] || v[2] < box.min[2] || v[2] > box.max[2]);
  }
  Box3D2.containsVec3 = containsVec3;
  function overlaps(a, b) {
    return !(a.max[0] < b.min[0] || a.min[0] > b.max[0] || a.max[1] < b.min[1] || a.min[1] > b.max[1] || a.max[2] < b.min[2] || a.min[2] > b.max[2]);
  }
  Box3D2.overlaps = overlaps;
  function containsSphere3D(box, s) {
    const c = s.center;
    const r = s.radius;
    return c[0] - r < box.min[0] || c[0] + r > box.max[0] || c[1] - r < box.min[1] || c[1] + r > box.max[1] || c[2] - r < box.min[2] || c[2] + r > box.max[2] ? false : true;
  }
  Box3D2.containsSphere3D = containsSphere3D;
  function nearestIntersectionWithRay(out, box, origin, dir) {
    const [minX, minY, minZ] = box.min;
    const [maxX, maxY, maxZ] = box.max;
    const [x, y, z] = origin;
    const invDirX = 1 / dir[0];
    const invDirY = 1 / dir[1];
    const invDirZ = 1 / dir[2];
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    if (invDirX >= 0) {
      tmin = (minX - x) * invDirX;
      tmax = (maxX - x) * invDirX;
    } else {
      tmin = (maxX - x) * invDirX;
      tmax = (minX - x) * invDirX;
    }
    if (invDirY >= 0) {
      tymin = (minY - y) * invDirY;
      tymax = (maxY - y) * invDirY;
    } else {
      tymin = (maxY - y) * invDirY;
      tymax = (minY - y) * invDirY;
    }
    if (invDirZ >= 0) {
      tzmin = (minZ - z) * invDirZ;
      tzmax = (maxZ - z) * invDirZ;
    } else {
      tzmin = (maxZ - z) * invDirZ;
      tzmax = (minZ - z) * invDirZ;
    }
    if (tymin > tmin)
      tmin = tymin;
    if (tymax < tmax)
      tmax = tymax;
    if (tzmin > tmin)
      tmin = tzmin;
    if (tzmax < tmax)
      tmax = tzmax;
    Vec3.scale(out, dir, tmin);
    return Vec3.set(out, out[0] + x, out[1] + y, out[2] + z);
  }
  Box3D2.nearestIntersectionWithRay = nearestIntersectionWithRay;
  function center(out, box) {
    return Vec3.center(out, box.max, box.min);
  }
  Box3D2.center = center;
  function exactEquals(a, b) {
    return Vec3.exactEquals(a.min, b.min) && Vec3.exactEquals(a.max, b.max);
  }
  Box3D2.exactEquals = exactEquals;
  function equals(a, b) {
    return Vec3.equals(a.min, b.min) && Vec3.equals(a.max, b.max);
  }
  Box3D2.equals = equals;
})(Box3D || (Box3D = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/common.js
function fillGridDim(length, start, step) {
  const a = new Float32Array(length);
  for (let i = 0; i < a.length; i++) {
    a[i] = start + step * i;
  }
  return a;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/symmetry-operator.js
var SymmetryOperator;
(function(SymmetryOperator2) {
  SymmetryOperator2.DefaultName = "1_555";
  SymmetryOperator2.Default = create(SymmetryOperator2.DefaultName, Mat4.identity());
  SymmetryOperator2.RotationTranslationEpsilon = 5e-3;
  function create(name, matrix, info) {
    let { assembly, ncsId, hkl, spgrOp, key } = info || {};
    const _hkl = hkl ? Vec3.clone(hkl) : Vec3();
    spgrOp = spgrOp !== null && spgrOp !== void 0 ? spgrOp : -1;
    key = key !== null && key !== void 0 ? key : -1;
    ncsId = ncsId || -1;
    const isIdentity = Mat4.isIdentity(matrix);
    const suffix = getSuffix(info, isIdentity);
    if (isIdentity)
      return { name, assembly, matrix, inverse: Mat4.identity(), isIdentity: true, hkl: _hkl, spgrOp, ncsId, suffix, key };
    if (!Mat4.isRotationAndTranslation(matrix, SymmetryOperator2.RotationTranslationEpsilon)) {
      console.warn(`Symmetry operator (${name}) should be a composition of rotation and translation.`);
    }
    return { name, assembly, matrix, inverse: Mat4.invert(Mat4(), matrix), isIdentity: false, hkl: _hkl, spgrOp, key, ncsId, suffix };
  }
  SymmetryOperator2.create = create;
  function isSymmetryOperator(x) {
    return !!x && !!x.matrix && !!x.inverse && typeof x.name === "string";
  }
  function getSuffix(info, isIdentity) {
    if (!info)
      return "";
    if (info.assembly) {
      if (isSymmetryOperator(info))
        return info.suffix;
      return isIdentity ? "" : `_${info.assembly.operId}`;
    }
    if (typeof info.spgrOp !== "undefined" && typeof info.hkl !== "undefined" && info.spgrOp !== -1) {
      const [i, j, k] = info.hkl;
      return `-${info.spgrOp + 1}_${5 + i}${5 + j}${5 + k}`;
    }
    if (info.ncsId !== -1) {
      return `_${info.ncsId}`;
    }
    return "";
  }
  const _m = Mat4();
  function checkIfRotationAndTranslation(rot, offset) {
    Mat4.setIdentity(_m);
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        Mat4.setValue(_m, i, j, Mat3.getValue(rot, i, j));
      }
    }
    Mat4.setTranslation(_m, offset);
    return Mat4.isRotationAndTranslation(_m, SymmetryOperator2.RotationTranslationEpsilon);
  }
  SymmetryOperator2.checkIfRotationAndTranslation = checkIfRotationAndTranslation;
  function ofRotationAndOffset(name, rot, offset, ncsId) {
    const t = Mat4.identity();
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        Mat4.setValue(t, i, j, Mat3.getValue(rot, i, j));
      }
    }
    Mat4.setTranslation(t, offset);
    return create(name, t, { ncsId });
  }
  SymmetryOperator2.ofRotationAndOffset = ofRotationAndOffset;
  const _q1 = Quat.identity(), _q2 = Quat(), _q3 = Quat(), _axis = Vec3();
  function lerpFromIdentity(out, op, t) {
    const m = op.inverse;
    if (op.isIdentity)
      return Mat4.copy(out, m);
    const _t = 1 - t;
    Mat4.getRotation(_q2, m);
    Quat.slerp(_q2, _q1, _q2, _t);
    const angle = Quat.getAxisAngle(_axis, _q2);
    Mat4.fromRotation(out, angle, _axis);
    Mat4.setValue(out, 0, 3, _t * Mat4.getValue(m, 0, 3));
    Mat4.setValue(out, 1, 3, _t * Mat4.getValue(m, 1, 3));
    Mat4.setValue(out, 2, 3, _t * Mat4.getValue(m, 2, 3));
    return out;
  }
  SymmetryOperator2.lerpFromIdentity = lerpFromIdentity;
  function slerp(out, src, tar, t) {
    if (Math.abs(t) <= 1e-5)
      return Mat4.copy(out, src);
    if (Math.abs(t - 1) <= 1e-5)
      return Mat4.copy(out, tar);
    Mat4.getRotation(_q2, src);
    Mat4.getRotation(_q3, tar);
    Quat.slerp(_q3, _q2, _q3, t);
    const angle = Quat.getAxisAngle(_axis, _q3);
    Mat4.fromRotation(out, angle, _axis);
    Mat4.setValue(out, 0, 3, lerp(Mat4.getValue(src, 0, 3), Mat4.getValue(tar, 0, 3), t));
    Mat4.setValue(out, 1, 3, lerp(Mat4.getValue(src, 1, 3), Mat4.getValue(tar, 1, 3), t));
    Mat4.setValue(out, 2, 3, lerp(Mat4.getValue(src, 2, 3), Mat4.getValue(tar, 2, 3), t));
    return out;
  }
  SymmetryOperator2.slerp = slerp;
  function compose(first2, second) {
    const matrix = Mat4.mul(Mat4(), second.matrix, first2.matrix);
    return create(second.name, matrix, second);
  }
  SymmetryOperator2.compose = compose;
  class _ArrayMapping {
    constructor(operator, coordinates, r = _zeroRadius) {
      this.operator = operator;
      this.coordinates = coordinates;
      this.r = r;
      this._x = coordinates.x;
      this._y = coordinates.y;
      this._z = coordinates.z;
      this._m = operator.matrix;
    }
    invariantPosition(i, s) {
      s[0] = this._x[i];
      s[1] = this._y[i];
      s[2] = this._z[i];
      return s;
    }
    position(i, s) {
      s[0] = this._x[i];
      s[1] = this._y[i];
      s[2] = this._z[i];
      Vec3.transformMat4(s, s, this._m);
      return s;
    }
    x(i) {
      const m = this._m;
      const xx = m[0], yy = m[4], zz = m[8], tx = m[12];
      const x = this._x[i], y = this._y[i], z = this._z[i], w = m[3] * x + m[7] * y + m[11] * z + m[15] || 1;
      return (xx * x + yy * y + zz * z + tx) / w;
    }
    y(i) {
      const m = this._m;
      const xx = m[1], yy = m[5], zz = m[9], ty = m[13];
      const x = this._x[i], y = this._y[i], z = this._z[i], w = m[3] * x + m[7] * y + m[11] * z + m[15] || 1;
      return (xx * x + yy * y + zz * z + ty) / w;
    }
    z(i) {
      const m = this._m;
      const xx = m[2], yy = m[6], zz = m[10], tz = m[14];
      const x = this._x[i], y = this._y[i], z = this._z[i], w = m[3] * x + m[7] * y + m[11] * z + m[15] || 1;
      return (xx * x + yy * y + zz * z + tz) / w;
    }
  }
  class _ArrayMappingW1 {
    constructor(operator, coordinates, r = _zeroRadius) {
      this.operator = operator;
      this.coordinates = coordinates;
      this.r = r;
      this._x = coordinates.x;
      this._y = coordinates.y;
      this._z = coordinates.z;
      this._m = operator.matrix;
    }
    invariantPosition(i, s) {
      s[0] = this._x[i];
      s[1] = this._y[i];
      s[2] = this._z[i];
      return s;
    }
    position(i, s) {
      s[0] = this.x(i);
      s[1] = this.y(i);
      s[2] = this.z(i);
      return s;
    }
    x(i) {
      const m = this._m;
      return m[0] * this._x[i] + m[4] * this._y[i] + m[8] * this._z[i] + m[12];
    }
    y(i) {
      const m = this._m;
      return m[1] * this._x[i] + m[5] * this._y[i] + m[9] * this._z[i] + m[13];
    }
    z(i) {
      const m = this._m;
      return m[2] * this._x[i] + m[6] * this._y[i] + m[10] * this._z[i] + m[14];
    }
  }
  class _ArrayMappingIdentity {
    constructor(operator, coordinates, r = _zeroRadius) {
      this.operator = operator;
      this.coordinates = coordinates;
      this.r = r;
      this._x = coordinates.x;
      this._y = coordinates.y;
      this._z = coordinates.z;
    }
    invariantPosition(i, s) {
      s[0] = this._x[i];
      s[1] = this._y[i];
      s[2] = this._z[i];
      return s;
    }
    position(i, s) {
      s[0] = this._x[i];
      s[1] = this._y[i];
      s[2] = this._z[i];
      return s;
    }
    x(i) {
      return this._x[i];
    }
    y(i) {
      return this._y[i];
    }
    z(i) {
      return this._z[i];
    }
  }
  function createMapping2(operator, coords, radius = _zeroRadius) {
    return Mat4.isIdentity(operator.matrix) ? new _ArrayMappingIdentity(operator, coords, radius) : isW1(operator.matrix) ? new _ArrayMappingW1(operator, coords, radius) : new _ArrayMapping(operator, coords, radius);
  }
  SymmetryOperator2.createMapping = createMapping2;
})(SymmetryOperator || (SymmetryOperator = {}));
function _zeroRadius(_i) {
  return 0;
}
function isW1(m) {
  return m[3] === 0 && m[7] === 0 && m[11] === 0 && m[15] === 1;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/spacegroup/tables.js
var TransformData = [
  [1, 0, 0, 0],
  [0, 1, 0, 0],
  [0, 0, 1, 0],
  [-1, 0, 0, 0],
  [0, -1, 0, 0],
  [0, 0, -1, 0],
  [0, 1, 0, 0.5],
  [1, 0, 0, 0.5],
  [-1, 0, 0, 0.5],
  [0, 0, 1, 0.5],
  [0, -1, 0, 0.5],
  [0, 0, -1, 0.5],
  [1, 0, 0, 0.25],
  [0, -1, 0, 0.25],
  [0, 0, 1, 0.25],
  [-1, 0, 0, 0.25],
  [0, 1, 0, 0.25],
  [0, -1, 0, 0.75],
  [0, 0, 1, 0.75],
  [0, 1, 0, 0.75],
  [1, 0, 0, 0.75],
  [-1, 0, 0, 0.75],
  [0, 0, -1, 0.25],
  [0, 0, -1, 0.75],
  [1, -1, 0, 0],
  [-1, 1, 0, 0],
  [0, 0, 1, 1 / 3],
  [0, 0, 1, 2 / 3],
  [1, 0, 0, 2 / 3],
  [0, 1, 0, 1 / 3],
  [0, -1, 0, 2 / 3],
  [1, -1, 0, 1 / 3],
  [-1, 1, 0, 2 / 3],
  [-1, 0, 0, 1 / 3],
  [1, 0, 0, 1 / 3],
  [0, 1, 0, 2 / 3],
  [0, -1, 0, 1 / 3],
  [1, -1, 0, 2 / 3],
  [-1, 1, 0, 1 / 3],
  [-1, 0, 0, 2 / 3],
  [0, 0, -1, 1 / 3],
  [0, 0, -1, 2 / 3],
  [0, 0, 1, 5 / 6],
  [0, 0, 1, 1 / 6],
  [0, 0, -1, 5 / 6],
  [0, 0, -1, 1 / 6]
];
var OperatorData = [
  [0, 1, 2],
  [3, 4, 5],
  [3, 1, 5],
  [3, 6, 5],
  [7, 6, 2],
  [8, 6, 5],
  [0, 4, 2],
  [0, 4, 9],
  [7, 10, 2],
  [7, 10, 9],
  [0, 10, 2],
  [8, 10, 5],
  [3, 1, 11],
  [3, 6, 11],
  [0, 10, 9],
  [8, 6, 11],
  [3, 4, 2],
  [0, 4, 5],
  [3, 4, 9],
  [7, 10, 5],
  [8, 4, 9],
  [8, 10, 9],
  [8, 10, 2],
  [0, 6, 9],
  [3, 10, 9],
  [0, 10, 11],
  [7, 1, 9],
  [8, 1, 11],
  [7, 4, 11],
  [7, 6, 9],
  [7, 10, 11],
  [3, 10, 2],
  [8, 1, 5],
  [0, 4, 11],
  [3, 1, 2],
  [3, 1, 9],
  [7, 4, 2],
  [8, 1, 2],
  [8, 1, 9],
  [3, 6, 9],
  [7, 4, 9],
  [8, 6, 2],
  [8, 6, 9],
  [3, 6, 2],
  [12, 13, 14],
  [15, 16, 14],
  [12, 17, 18],
  [15, 19, 18],
  [20, 13, 18],
  [21, 16, 18],
  [20, 17, 14],
  [21, 19, 14],
  [0, 1, 5],
  [8, 10, 11],
  [7, 6, 11],
  [7, 6, 5],
  [8, 4, 2],
  [7, 4, 5],
  [7, 1, 5],
  [7, 1, 11],
  [0, 10, 5],
  [0, 1, 11],
  [0, 6, 11],
  [0, 6, 5],
  [3, 10, 11],
  [8, 4, 11],
  [15, 13, 22],
  [12, 16, 22],
  [15, 17, 23],
  [12, 19, 23],
  [21, 13, 23],
  [20, 16, 23],
  [21, 17, 22],
  [20, 19, 22],
  [4, 0, 2],
  [1, 3, 2],
  [4, 0, 14],
  [1, 3, 18],
  [4, 0, 9],
  [1, 3, 9],
  [4, 0, 18],
  [1, 3, 14],
  [10, 7, 9],
  [6, 8, 9],
  [4, 7, 14],
  [6, 3, 18],
  [10, 0, 18],
  [1, 8, 14],
  [1, 3, 5],
  [4, 0, 5],
  [6, 8, 11],
  [10, 7, 11],
  [1, 3, 11],
  [4, 0, 11],
  [10, 7, 2],
  [6, 8, 2],
  [3, 10, 22],
  [7, 1, 23],
  [8, 4, 23],
  [0, 6, 22],
  [1, 0, 5],
  [4, 3, 5],
  [1, 0, 23],
  [4, 3, 22],
  [10, 7, 14],
  [6, 8, 18],
  [8, 6, 22],
  [7, 10, 23],
  [4, 3, 11],
  [1, 0, 11],
  [1, 0, 22],
  [4, 3, 23],
  [10, 7, 18],
  [6, 8, 14],
  [8, 6, 23],
  [7, 10, 22],
  [6, 7, 11],
  [10, 8, 11],
  [8, 1, 23],
  [0, 10, 22],
  [3, 6, 22],
  [7, 4, 23],
  [4, 3, 2],
  [1, 0, 2],
  [10, 8, 2],
  [6, 7, 2],
  [4, 3, 9],
  [1, 0, 9],
  [10, 8, 9],
  [6, 7, 9],
  [4, 8, 14],
  [6, 0, 18],
  [10, 3, 18],
  [1, 7, 14],
  [4, 8, 18],
  [6, 0, 14],
  [10, 3, 14],
  [1, 7, 18],
  [6, 7, 5],
  [10, 8, 5],
  [6, 8, 5],
  [10, 7, 5],
  [8, 1, 22],
  [0, 10, 23],
  [3, 6, 23],
  [7, 4, 22],
  [4, 24, 2],
  [25, 3, 2],
  [4, 24, 26],
  [25, 3, 27],
  [4, 24, 27],
  [25, 3, 26],
  [28, 29, 26],
  [30, 31, 26],
  [32, 33, 26],
  [34, 35, 27],
  [36, 37, 27],
  [38, 39, 27],
  [2, 0, 1],
  [1, 2, 0],
  [1, 25, 5],
  [24, 0, 5],
  [39, 36, 40],
  [35, 38, 40],
  [37, 34, 40],
  [33, 30, 41],
  [29, 32, 41],
  [31, 28, 41],
  [5, 3, 4],
  [4, 5, 3],
  [25, 1, 5],
  [0, 24, 5],
  [24, 4, 5],
  [3, 25, 5],
  [4, 3, 41],
  [25, 1, 40],
  [24, 4, 41],
  [3, 25, 40],
  [4, 3, 40],
  [25, 1, 41],
  [24, 4, 40],
  [3, 25, 41],
  [35, 34, 40],
  [37, 36, 40],
  [39, 38, 40],
  [29, 28, 41],
  [31, 30, 41],
  [33, 32, 41],
  [3, 5, 4],
  [5, 4, 3],
  [25, 1, 2],
  [0, 24, 2],
  [24, 4, 2],
  [3, 25, 2],
  [25, 1, 9],
  [0, 24, 9],
  [24, 4, 9],
  [3, 25, 9],
  [30, 33, 26],
  [32, 29, 26],
  [28, 31, 26],
  [36, 39, 27],
  [38, 35, 27],
  [34, 37, 27],
  [0, 2, 1],
  [2, 1, 0],
  [30, 33, 42],
  [32, 29, 42],
  [28, 31, 42],
  [36, 39, 43],
  [38, 35, 43],
  [34, 37, 43],
  [7, 9, 6],
  [9, 6, 7],
  [25, 1, 11],
  [0, 24, 11],
  [24, 4, 11],
  [3, 25, 11],
  [35, 34, 44],
  [37, 36, 44],
  [39, 38, 44],
  [29, 28, 45],
  [31, 30, 45],
  [33, 32, 45],
  [8, 11, 10],
  [11, 10, 8],
  [1, 25, 2],
  [24, 0, 2],
  [1, 25, 42],
  [24, 0, 43],
  [1, 25, 43],
  [24, 0, 42],
  [1, 25, 27],
  [24, 0, 26],
  [1, 25, 26],
  [24, 0, 27],
  [1, 25, 9],
  [24, 0, 9],
  [4, 24, 5],
  [25, 3, 5],
  [4, 24, 11],
  [25, 3, 11],
  [1, 0, 40],
  [4, 3, 44],
  [0, 24, 45],
  [1, 0, 41],
  [4, 3, 45],
  [0, 24, 44],
  [0, 24, 40],
  [0, 24, 41],
  [2, 3, 4],
  [5, 3, 1],
  [5, 0, 4],
  [4, 2, 3],
  [1, 5, 3],
  [4, 5, 0],
  [2, 7, 6],
  [2, 8, 10],
  [5, 8, 6],
  [5, 7, 10],
  [1, 9, 7],
  [4, 9, 8],
  [1, 11, 8],
  [4, 11, 7],
  [9, 0, 6],
  [9, 3, 10],
  [11, 3, 6],
  [11, 0, 10],
  [6, 2, 7],
  [10, 2, 8],
  [6, 5, 8],
  [10, 5, 7],
  [9, 7, 1],
  [9, 8, 4],
  [11, 8, 1],
  [11, 7, 4],
  [6, 9, 0],
  [10, 9, 3],
  [6, 11, 3],
  [10, 11, 0],
  [9, 7, 6],
  [9, 8, 10],
  [11, 8, 6],
  [11, 7, 10],
  [6, 9, 7],
  [10, 9, 8],
  [6, 11, 8],
  [10, 11, 7],
  [2, 3, 10],
  [5, 8, 1],
  [11, 0, 4],
  [10, 2, 3],
  [1, 5, 8],
  [4, 11, 0],
  [5, 0, 1],
  [2, 0, 4],
  [2, 3, 1],
  [1, 5, 0],
  [4, 2, 0],
  [1, 2, 3],
  [11, 8, 10],
  [11, 7, 6],
  [9, 7, 10],
  [9, 8, 6],
  [10, 11, 8],
  [6, 11, 7],
  [10, 9, 7],
  [6, 9, 8],
  [5, 8, 10],
  [5, 7, 6],
  [2, 7, 10],
  [2, 8, 6],
  [4, 11, 8],
  [1, 11, 7],
  [4, 9, 7],
  [1, 9, 8],
  [11, 3, 10],
  [11, 0, 6],
  [9, 0, 10],
  [9, 3, 6],
  [10, 5, 8],
  [6, 5, 7],
  [10, 2, 7],
  [6, 2, 8],
  [11, 8, 4],
  [11, 7, 1],
  [9, 7, 4],
  [9, 8, 1],
  [10, 11, 3],
  [6, 11, 0],
  [10, 9, 0],
  [6, 9, 3],
  [22, 15, 13],
  [22, 12, 16],
  [14, 12, 13],
  [14, 15, 16],
  [13, 22, 15],
  [16, 22, 12],
  [13, 14, 12],
  [16, 14, 15],
  [22, 21, 17],
  [22, 20, 19],
  [14, 20, 17],
  [14, 21, 19],
  [13, 23, 21],
  [16, 23, 20],
  [13, 18, 20],
  [16, 18, 21],
  [23, 15, 17],
  [23, 12, 19],
  [18, 12, 17],
  [18, 15, 19],
  [17, 22, 21],
  [19, 22, 20],
  [17, 14, 20],
  [19, 14, 21],
  [23, 21, 13],
  [23, 20, 16],
  [18, 20, 13],
  [18, 21, 16],
  [17, 23, 15],
  [19, 23, 12],
  [17, 18, 12],
  [19, 18, 15],
  [5, 0, 6],
  [2, 7, 4],
  [9, 3, 1],
  [6, 5, 0],
  [4, 2, 7],
  [1, 9, 3],
  [0, 2, 4],
  [3, 2, 1],
  [0, 5, 1],
  [2, 1, 3],
  [2, 4, 0],
  [5, 1, 0],
  [7, 9, 10],
  [8, 9, 6],
  [7, 11, 6],
  [9, 6, 8],
  [9, 10, 7],
  [11, 6, 7],
  [1, 7, 11],
  [4, 8, 11],
  [1, 8, 9],
  [4, 7, 9],
  [0, 9, 10],
  [3, 9, 6],
  [3, 11, 10],
  [0, 11, 6],
  [2, 6, 8],
  [2, 10, 7],
  [5, 6, 7],
  [5, 10, 8],
  [6, 0, 11],
  [10, 3, 11],
  [6, 3, 9],
  [10, 0, 9],
  [7, 2, 10],
  [8, 2, 6],
  [8, 5, 10],
  [7, 5, 6],
  [9, 1, 8],
  [9, 4, 7],
  [11, 1, 7],
  [11, 4, 8],
  [7, 9, 4],
  [8, 9, 1],
  [8, 11, 4],
  [7, 11, 1],
  [9, 6, 3],
  [9, 10, 0],
  [11, 6, 0],
  [11, 10, 3],
  [19, 12, 23],
  [13, 15, 22],
  [16, 21, 18],
  [17, 20, 14],
  [20, 14, 17],
  [21, 18, 16],
  [15, 22, 13],
  [12, 23, 19],
  [18, 16, 21],
  [14, 17, 20],
  [23, 19, 12],
  [22, 13, 15],
  [19, 20, 22],
  [13, 21, 23],
  [16, 15, 14],
  [17, 12, 18],
  [20, 18, 13],
  [21, 14, 19],
  [15, 23, 17],
  [12, 22, 16],
  [18, 19, 15],
  [14, 13, 12],
  [23, 16, 20],
  [22, 17, 21],
  [16, 12, 22],
  [17, 15, 23],
  [19, 21, 14],
  [13, 20, 18],
  [12, 14, 13],
  [15, 18, 19],
  [21, 22, 17],
  [20, 23, 16],
  [14, 16, 15],
  [18, 17, 12],
  [22, 19, 20],
  [23, 13, 21],
  [16, 20, 23],
  [17, 21, 22],
  [19, 15, 18],
  [13, 12, 14],
  [12, 18, 17],
  [15, 14, 16],
  [21, 23, 13],
  [20, 22, 19],
  [14, 19, 21],
  [18, 13, 20],
  [22, 16, 12],
  [23, 17, 15],
  [19, 12, 22],
  [17, 21, 23],
  [16, 15, 18],
  [13, 20, 14],
  [20, 14, 13],
  [15, 18, 16],
  [21, 23, 17],
  [12, 22, 19],
  [18, 16, 15],
  [14, 13, 20],
  [22, 19, 12],
  [23, 17, 21],
  [3, 2, 4],
  [3, 5, 1],
  [0, 5, 4],
  [2, 4, 3],
  [5, 1, 3],
  [5, 4, 0],
  [1, 7, 9],
  [4, 8, 9],
  [1, 8, 11],
  [4, 7, 11],
  [0, 9, 6],
  [3, 9, 10],
  [3, 11, 6],
  [0, 11, 10],
  [2, 6, 7],
  [2, 10, 8],
  [5, 6, 8],
  [5, 10, 7],
  [6, 0, 9],
  [10, 3, 9],
  [6, 3, 11],
  [10, 0, 11],
  [7, 2, 6],
  [8, 2, 10],
  [8, 5, 6],
  [7, 5, 10],
  [9, 1, 7],
  [9, 4, 8],
  [11, 1, 8],
  [11, 4, 7],
  [7, 9, 1],
  [8, 9, 4],
  [8, 11, 1],
  [7, 11, 4],
  [9, 6, 0],
  [9, 10, 3],
  [11, 6, 3],
  [11, 10, 0],
  [8, 9, 10],
  [8, 11, 6],
  [7, 11, 10],
  [9, 10, 8],
  [11, 6, 8],
  [11, 10, 7],
  [6, 0, 2],
  [10, 3, 2],
  [6, 3, 5],
  [10, 0, 5],
  [7, 2, 1],
  [8, 2, 4],
  [8, 5, 1],
  [7, 5, 4],
  [9, 1, 0],
  [9, 4, 3],
  [11, 1, 3],
  [11, 4, 0],
  [1, 7, 2],
  [4, 8, 2],
  [1, 8, 5],
  [4, 7, 5],
  [0, 9, 1],
  [3, 9, 4],
  [3, 11, 1],
  [0, 11, 4],
  [2, 6, 0],
  [2, 10, 3],
  [5, 6, 3],
  [5, 10, 0],
  [0, 2, 6],
  [3, 2, 10],
  [3, 5, 6],
  [0, 5, 10],
  [2, 1, 7],
  [2, 4, 8],
  [5, 1, 8],
  [5, 4, 7],
  [16, 12, 14],
  [13, 21, 18],
  [19, 15, 23],
  [17, 20, 22],
  [12, 14, 16],
  [21, 18, 13],
  [15, 23, 19],
  [20, 22, 17],
  [14, 16, 12],
  [18, 13, 21],
  [23, 19, 15],
  [22, 17, 20],
  [19, 20, 18],
  [17, 15, 14],
  [16, 21, 22],
  [13, 12, 23],
  [20, 18, 19],
  [15, 14, 17],
  [21, 22, 16],
  [12, 23, 13],
  [18, 19, 20],
  [14, 17, 15],
  [22, 16, 21],
  [23, 13, 12],
  [6, 0, 5],
  [10, 3, 5],
  [6, 3, 2],
  [10, 0, 2],
  [7, 2, 4],
  [8, 2, 1],
  [8, 5, 4],
  [7, 5, 1],
  [9, 1, 3],
  [9, 4, 0],
  [11, 1, 0],
  [11, 4, 3],
  [1, 7, 5],
  [4, 8, 5],
  [1, 8, 2],
  [4, 7, 2],
  [0, 9, 4],
  [3, 9, 1],
  [3, 11, 4],
  [0, 11, 1],
  [2, 6, 3],
  [2, 10, 0],
  [5, 6, 0],
  [5, 10, 3],
  [0, 2, 10],
  [3, 2, 6],
  [3, 5, 10],
  [0, 5, 6],
  [2, 1, 8],
  [2, 4, 7],
  [5, 1, 7],
  [5, 4, 8],
  [21, 17, 23],
  [20, 16, 22],
  [12, 13, 18],
  [15, 19, 14],
  [23, 21, 17],
  [22, 20, 16],
  [18, 12, 13],
  [14, 15, 19],
  [17, 23, 21],
  [16, 22, 20],
  [13, 18, 12],
  [19, 14, 15],
  [21, 13, 22],
  [20, 19, 23],
  [12, 17, 14],
  [15, 16, 18],
  [23, 15, 13],
  [22, 12, 19],
  [18, 20, 17],
  [14, 21, 16],
  [17, 22, 15],
  [16, 23, 12],
  [13, 14, 20],
  [19, 18, 21],
  [15, 17, 22],
  [12, 16, 23],
  [20, 13, 14],
  [21, 19, 18],
  [22, 21, 13],
  [23, 20, 19],
  [14, 12, 17],
  [18, 15, 16],
  [13, 23, 15],
  [19, 22, 12],
  [17, 18, 20],
  [16, 14, 21],
  [15, 13, 23],
  [12, 19, 22],
  [20, 17, 18],
  [21, 16, 14],
  [22, 15, 17],
  [23, 12, 16],
  [14, 20, 13],
  [18, 21, 19],
  [13, 22, 21],
  [19, 23, 20],
  [17, 14, 12],
  [16, 18, 15],
  [6, 5, 3],
  [4, 9, 3],
  [9, 3, 4],
  [5, 7, 4],
  [4, 5, 7],
  [5, 3, 6]
];
var GroupData = [
  [0],
  [0, 1],
  [0, 2],
  [0, 3],
  [0, 2, 4, 5],
  [0, 6],
  [0, 7],
  [0, 6, 4, 8],
  [0, 7, 4, 9],
  [0, 6, 2, 1],
  [0, 3, 1, 10],
  [0, 6, 2, 1, 4, 8, 5, 11],
  [0, 12, 1, 7],
  [0, 1, 13, 14],
  [0, 12, 1, 7, 4, 15, 11, 9],
  [0, 16, 2, 17],
  [0, 18, 12, 17],
  [0, 16, 5, 19],
  [0, 20, 13, 19],
  [0, 18, 12, 17, 4, 21, 15, 19],
  [0, 16, 2, 17, 4, 22, 5, 19],
  [0, 16, 2, 17, 23, 24, 13, 25, 26, 20, 27, 28, 4, 22, 5, 19],
  [0, 16, 17, 2, 29, 21, 30, 15],
  [0, 20, 13, 19, 29, 31, 32, 33],
  [0, 16, 6, 34],
  [0, 18, 7, 34],
  [0, 16, 7, 35],
  [0, 16, 36, 37],
  [0, 18, 36, 38],
  [0, 16, 14, 39],
  [0, 20, 40, 34],
  [0, 16, 8, 41],
  [0, 18, 8, 42],
  [0, 16, 9, 42],
  [0, 16, 6, 34, 4, 22, 8, 41],
  [0, 18, 7, 34, 4, 21, 9, 41],
  [0, 16, 7, 35, 4, 22, 9, 42],
  [0, 16, 6, 34, 23, 24, 14, 39],
  [0, 16, 10, 43, 23, 24, 7, 35],
  [0, 16, 36, 37, 23, 24, 9, 42],
  [0, 16, 8, 41, 23, 24, 40, 38],
  [0, 16, 6, 34, 23, 24, 14, 39, 26, 20, 40, 38, 4, 22, 8, 41],
  [0, 16, 44, 45, 23, 24, 46, 47, 26, 20, 48, 49, 4, 22, 50, 51],
  [0, 16, 6, 34, 29, 21, 9, 42],
  [0, 16, 8, 41, 29, 21, 7, 35],
  [0, 16, 36, 37, 29, 21, 14, 39],
  [0, 16, 2, 17, 1, 52, 6, 34],
  [0, 16, 2, 17, 53, 54, 9, 42],
  [0, 16, 12, 33, 1, 52, 7, 35],
  [0, 16, 2, 17, 11, 55, 8, 41],
  [0, 56, 2, 57, 1, 58, 6, 37],
  [0, 56, 15, 25, 1, 58, 9, 39],
  [0, 20, 27, 17, 1, 59, 40, 34],
  [0, 56, 12, 28, 1, 58, 7, 38],
  [0, 16, 5, 19, 1, 52, 8, 41],
  [0, 22, 13, 28, 1, 55, 14, 38],
  [0, 18, 13, 60, 1, 61, 14, 43],
  [0, 16, 15, 30, 1, 52, 9, 42],
  [0, 16, 5, 19, 11, 55, 6, 34],
  [0, 21, 12, 19, 1, 54, 7, 41],
  [0, 20, 13, 19, 1, 59, 14, 41],
  [0, 20, 3, 30, 1, 59, 10, 42],
  [0, 18, 12, 17, 1, 61, 7, 34, 4, 21, 15, 19, 11, 54, 9, 41],
  [0, 24, 13, 17, 1, 62, 14, 34, 4, 20, 27, 19, 11, 59, 40, 41],
  [0, 16, 2, 17, 1, 52, 6, 34, 4, 22, 5, 19, 11, 55, 8, 41],
  [0, 16, 12, 33, 1, 52, 7, 35, 4, 22, 15, 30, 11, 55, 9, 42],
  [0, 31, 3, 17, 1, 63, 10, 34, 4, 56, 32, 19, 11, 58, 36, 41],
  [0, 22, 2, 19, 64, 59, 14, 38, 4, 16, 5, 17, 65, 62, 40, 39],
  [0, 16, 2, 17, 1, 52, 6, 34, 23, 24, 13, 25, 64, 62, 14, 39, 26, 20, 27, 28, 65, 59, 40, 38, 4, 22, 5, 19, 11, 55, 8, 41],
  [0, 16, 2, 17, 66, 67, 44, 45, 23, 24, 13, 25, 68, 69, 46, 47, 26, 20, 27, 28, 70, 71, 48, 49, 4, 22, 5, 19, 72, 73, 50, 51],
  [0, 16, 2, 17, 1, 52, 6, 34, 29, 21, 15, 30, 53, 54, 9, 42],
  [0, 16, 5, 19, 1, 52, 8, 41, 29, 21, 12, 33, 53, 54, 7, 35],
  [0, 20, 13, 19, 1, 59, 14, 41, 29, 31, 32, 33, 53, 63, 36, 35],
  [0, 31, 3, 17, 1, 63, 10, 34, 29, 20, 27, 30, 53, 59, 40, 42],
  [0, 16, 74, 75],
  [0, 18, 76, 77],
  [0, 16, 78, 79],
  [0, 18, 80, 81],
  [0, 16, 74, 75, 29, 21, 82, 83],
  [0, 21, 84, 85, 29, 16, 86, 87],
  [0, 16, 88, 89],
  [0, 16, 88, 89, 29, 21, 90, 91],
  [0, 16, 74, 75, 1, 52, 88, 89],
  [0, 16, 78, 79, 1, 52, 92, 93],
  [0, 16, 94, 95, 11, 55, 88, 89],
  [0, 16, 82, 83, 53, 54, 88, 89],
  [0, 16, 74, 75, 1, 52, 88, 89, 29, 21, 82, 83, 53, 54, 90, 91],
  [0, 21, 84, 85, 96, 97, 88, 91, 29, 16, 86, 87, 98, 99, 90, 89],
  [0, 16, 74, 75, 2, 17, 100, 101],
  [0, 16, 94, 95, 5, 19, 100, 101],
  [0, 18, 76, 77, 2, 33, 102, 103],
  [0, 18, 104, 105, 106, 107, 100, 108],
  [0, 16, 78, 79, 2, 17, 109, 108],
  [0, 16, 82, 83, 15, 30, 100, 101],
  [0, 18, 80, 81, 2, 33, 110, 111],
  [0, 18, 112, 113, 114, 115, 100, 108],
  [0, 16, 74, 75, 2, 17, 100, 101, 29, 21, 82, 83, 15, 30, 116, 117],
  [0, 21, 84, 85, 118, 119, 116, 101, 29, 16, 86, 87, 120, 121, 100, 117],
  [0, 16, 74, 75, 6, 34, 122, 123],
  [0, 16, 74, 75, 8, 41, 124, 125],
  [0, 16, 78, 79, 7, 35, 122, 123],
  [0, 16, 82, 83, 9, 42, 122, 123],
  [0, 16, 74, 75, 7, 35, 126, 127],
  [0, 16, 74, 75, 9, 42, 128, 129],
  [0, 16, 78, 79, 6, 34, 126, 127],
  [0, 16, 78, 79, 8, 41, 128, 129],
  [0, 16, 74, 75, 6, 34, 122, 123, 29, 21, 82, 83, 9, 42, 128, 129],
  [0, 16, 74, 75, 7, 35, 126, 127, 29, 21, 82, 83, 8, 41, 124, 125],
  [0, 21, 84, 85, 6, 42, 130, 131, 29, 16, 86, 87, 9, 34, 132, 133],
  [0, 21, 84, 85, 7, 41, 134, 135, 29, 16, 86, 87, 8, 35, 136, 137],
  [0, 16, 89, 88, 2, 17, 122, 123],
  [0, 16, 89, 88, 12, 33, 126, 127],
  [0, 16, 89, 88, 5, 19, 124, 125],
  [0, 16, 89, 88, 15, 30, 128, 129],
  [0, 16, 88, 89, 6, 34, 100, 101],
  [0, 16, 89, 88, 7, 35, 109, 108],
  [0, 16, 89, 88, 8, 41, 138, 139],
  [0, 16, 89, 88, 9, 42, 116, 117],
  [0, 16, 89, 88, 6, 34, 100, 101, 29, 21, 91, 90, 9, 42, 116, 117],
  [0, 16, 89, 88, 7, 35, 109, 108, 29, 21, 91, 90, 8, 41, 138, 139],
  [0, 16, 89, 88, 2, 17, 122, 123, 29, 21, 91, 90, 15, 30, 128, 129],
  [0, 16, 89, 88, 118, 121, 132, 131, 29, 21, 91, 90, 120, 119, 130, 133],
  [0, 16, 74, 75, 2, 17, 100, 101, 1, 52, 88, 89, 6, 34, 122, 123],
  [0, 16, 74, 75, 12, 33, 109, 108, 1, 52, 88, 89, 7, 35, 126, 127],
  [0, 16, 74, 75, 2, 17, 100, 101, 11, 55, 140, 141, 8, 41, 124, 125],
  [0, 16, 74, 75, 2, 17, 100, 101, 53, 54, 90, 91, 9, 42, 128, 129],
  [0, 16, 74, 75, 5, 19, 138, 139, 1, 52, 88, 89, 8, 41, 124, 125],
  [0, 16, 74, 75, 15, 30, 116, 117, 1, 52, 88, 89, 9, 42, 128, 129],
  [0, 16, 94, 95, 5, 19, 100, 101, 11, 55, 88, 89, 6, 34, 124, 125],
  [0, 16, 94, 95, 15, 30, 109, 108, 11, 55, 88, 89, 7, 35, 128, 129],
  [0, 16, 78, 79, 2, 17, 109, 108, 1, 52, 92, 93, 6, 34, 126, 127],
  [0, 16, 78, 79, 12, 33, 100, 101, 1, 52, 92, 93, 7, 35, 122, 123],
  [0, 16, 82, 83, 12, 33, 138, 139, 53, 54, 88, 89, 8, 41, 126, 127],
  [0, 16, 82, 83, 2, 17, 116, 117, 53, 54, 88, 89, 9, 42, 122, 123],
  [0, 16, 78, 79, 5, 19, 116, 117, 1, 52, 92, 93, 8, 41, 128, 129],
  [0, 16, 82, 83, 15, 30, 100, 101, 1, 52, 90, 91, 9, 42, 122, 123],
  [0, 16, 82, 83, 15, 30, 100, 101, 53, 54, 88, 89, 6, 34, 128, 129],
  [0, 16, 82, 83, 5, 19, 109, 108, 53, 54, 88, 89, 7, 35, 124, 125],
  [0, 16, 74, 75, 2, 17, 100, 101, 1, 52, 88, 89, 6, 34, 122, 123, 29, 21, 82, 83, 15, 30, 116, 117, 53, 54, 90, 91, 9, 42, 128, 129],
  [0, 16, 74, 75, 12, 33, 109, 108, 1, 52, 88, 89, 7, 35, 126, 127, 29, 21, 82, 83, 5, 19, 138, 139, 53, 54, 90, 91, 8, 41, 124, 125],
  [0, 21, 84, 85, 118, 119, 116, 101, 96, 97, 88, 91, 9, 34, 132, 133, 29, 16, 86, 87, 120, 121, 100, 117, 98, 99, 90, 89, 6, 42, 130, 131],
  [0, 21, 84, 85, 142, 143, 138, 108, 96, 97, 88, 91, 8, 35, 136, 137, 29, 16, 86, 87, 144, 145, 109, 139, 98, 99, 90, 89, 7, 41, 134, 135],
  [0, 146, 147],
  [0, 148, 149],
  [0, 150, 151],
  [0, 146, 147, 152, 153, 154, 155, 156, 157],
  [0, 158, 159],
  [0, 146, 147, 1, 160, 161],
  [0, 146, 147, 1, 160, 161, 152, 153, 154, 162, 163, 164, 155, 156, 157, 165, 166, 167],
  [0, 158, 159, 1, 168, 169],
  [0, 146, 147, 101, 170, 171],
  [0, 146, 147, 100, 172, 173],
  [0, 148, 149, 174, 175, 171],
  [0, 148, 149, 100, 176, 177],
  [0, 150, 151, 178, 179, 171],
  [0, 150, 151, 100, 180, 181],
  [0, 146, 147, 100, 172, 173, 152, 153, 154, 182, 183, 184, 155, 156, 157, 185, 186, 187],
  [0, 158, 159, 101, 188, 189],
  [0, 146, 147, 122, 190, 191],
  [0, 146, 147, 123, 192, 193],
  [0, 146, 147, 126, 194, 195],
  [0, 146, 147, 127, 196, 197],
  [0, 146, 147, 122, 190, 191, 152, 153, 154, 198, 199, 200, 155, 156, 157, 201, 202, 203],
  [0, 158, 159, 123, 204, 205],
  [0, 146, 147, 126, 194, 195, 152, 153, 154, 206, 207, 208, 155, 156, 157, 209, 210, 211],
  [0, 158, 159, 129, 212, 213],
  [0, 146, 147, 101, 170, 171, 1, 160, 161, 123, 192, 193],
  [0, 146, 147, 108, 214, 215, 1, 160, 161, 127, 196, 197],
  [0, 146, 147, 100, 172, 173, 1, 160, 161, 122, 190, 191],
  [0, 146, 147, 109, 216, 217, 1, 160, 161, 126, 194, 195],
  [0, 146, 147, 100, 172, 173, 1, 160, 161, 122, 190, 191, 152, 153, 154, 182, 183, 184, 162, 163, 164, 198, 199, 200, 155, 156, 157, 185, 186, 187, 165, 166, 167, 201, 202, 203],
  [0, 158, 159, 101, 188, 189, 1, 168, 169, 123, 204, 205],
  [0, 146, 147, 109, 216, 217, 1, 160, 161, 126, 194, 195, 152, 153, 154, 218, 219, 220, 162, 163, 164, 206, 207, 208, 155, 156, 157, 221, 222, 223, 165, 166, 167, 209, 210, 211],
  [0, 158, 159, 117, 224, 225, 1, 168, 169, 129, 212, 213],
  [0, 146, 147, 16, 226, 227],
  [0, 148, 149, 18, 228, 229],
  [0, 150, 151, 18, 230, 231],
  [0, 150, 151, 16, 232, 233],
  [0, 148, 149, 16, 234, 235],
  [0, 146, 147, 18, 236, 237],
  [0, 146, 147, 52, 238, 239],
  [0, 146, 147, 16, 226, 227, 1, 160, 161, 52, 238, 239],
  [0, 146, 147, 18, 236, 237, 1, 160, 161, 61, 240, 241],
  [0, 146, 147, 16, 226, 227, 100, 172, 173, 101, 170, 171],
  [0, 148, 149, 18, 228, 229, 242, 172, 181, 243, 214, 244],
  [0, 150, 151, 18, 230, 231, 245, 172, 177, 246, 214, 247],
  [0, 150, 151, 16, 232, 233, 245, 172, 177, 174, 170, 248],
  [0, 148, 149, 16, 234, 235, 242, 172, 181, 178, 170, 249],
  [0, 146, 147, 18, 236, 237, 100, 172, 173, 108, 214, 215],
  [0, 146, 147, 16, 226, 227, 122, 190, 191, 123, 192, 193],
  [0, 146, 147, 16, 226, 227, 126, 194, 195, 127, 196, 197],
  [0, 146, 147, 18, 236, 237, 126, 194, 195, 123, 192, 193],
  [0, 146, 147, 18, 236, 237, 122, 190, 191, 127, 196, 197],
  [0, 146, 147, 52, 238, 239, 122, 190, 191, 101, 170, 171],
  [0, 146, 147, 61, 240, 241, 126, 194, 195, 101, 170, 171],
  [0, 146, 147, 52, 238, 239, 100, 172, 173, 123, 192, 193],
  [0, 146, 147, 61, 240, 241, 100, 172, 173, 127, 196, 197],
  [0, 146, 147, 16, 226, 227, 100, 172, 173, 101, 170, 171, 1, 160, 161, 52, 239, 238, 122, 190, 191, 123, 192, 193],
  [0, 146, 147, 16, 226, 227, 109, 216, 217, 108, 214, 215, 1, 160, 161, 52, 239, 238, 126, 194, 195, 127, 196, 197],
  [0, 146, 147, 18, 236, 237, 109, 216, 217, 101, 170, 171, 1, 160, 161, 61, 241, 240, 126, 194, 195, 123, 192, 193],
  [0, 146, 147, 18, 236, 237, 100, 172, 173, 108, 214, 215, 1, 160, 161, 61, 241, 240, 122, 190, 191, 127, 196, 197],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 29, 21, 15, 30, 280, 281, 282, 283, 284, 285, 286, 287],
  [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271],
  [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 29, 31, 32, 33, 280, 288, 289, 290, 284, 291, 292, 293],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 53, 54, 9, 42, 300, 301, 302, 303, 304, 305, 306, 307],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 64, 62, 14, 39, 308, 309, 310, 311, 312, 313, 314, 315, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 65, 59, 40, 38, 316, 317, 318, 319, 320, 321, 322, 323, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 11, 55, 8, 41, 324, 325, 326, 327, 328, 329, 330, 331],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 66, 67, 44, 45, 332, 333, 334, 335, 336, 337, 338, 339, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 68, 69, 46, 47, 340, 341, 342, 343, 344, 345, 346, 347, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 70, 71, 48, 49, 348, 349, 350, 351, 352, 353, 354, 355, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 72, 73, 50, 51, 356, 357, 358, 359, 360, 361, 362, 363],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 29, 21, 15, 30, 280, 281, 282, 283, 284, 285, 286, 287, 53, 54, 9, 42, 300, 301, 302, 303, 304, 305, 306, 307],
  [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 1, 59, 14, 41, 168, 325, 318, 311, 169, 313, 330, 323],
  [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 1, 59, 14, 41, 168, 325, 318, 311, 169, 313, 330, 323, 29, 31, 32, 33, 280, 288, 289, 290, 284, 291, 292, 293, 53, 63, 36, 35, 300, 364, 365, 366, 304, 367, 368, 369],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 138, 139, 95, 94, 406, 407, 408, 409, 410, 411, 412, 413],
  [0, 24, 5, 28, 158, 265, 258, 275, 159, 277, 270, 263, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 23, 16, 27, 19, 256, 273, 251, 267, 260, 269, 278, 255, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 26, 22, 13, 17, 264, 250, 274, 259, 268, 261, 254, 279, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 4, 20, 2, 25, 272, 257, 266, 252, 276, 253, 262, 271, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 29, 21, 15, 30, 280, 281, 282, 283, 284, 285, 286, 287, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225],
  [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 450, 415, 440, 429, 454, 431, 420, 445, 458, 447, 436, 425],
  [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473],
  [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 29, 31, 32, 33, 280, 288, 289, 290, 284, 291, 292, 293, 450, 415, 440, 429, 454, 431, 420, 445, 458, 447, 436, 425],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 123, 122, 88, 89, 204, 474, 475, 476, 205, 477, 478, 479],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 123, 122, 88, 89, 204, 474, 475, 476, 205, 477, 478, 479, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 125, 124, 140, 141, 504, 505, 506, 507, 508, 509, 510, 511],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 123, 122, 88, 89, 204, 474, 475, 476, 205, 477, 478, 479, 29, 21, 15, 30, 280, 281, 282, 283, 284, 285, 286, 287, 129, 128, 90, 91, 212, 512, 513, 514, 213, 515, 516, 517],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 129, 128, 90, 91, 212, 512, 513, 514, 213, 515, 516, 517],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 129, 128, 90, 91, 212, 512, 513, 514, 213, 515, 516, 517, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 127, 126, 92, 93, 542, 543, 544, 545, 546, 547, 548, 549],
  [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 29, 31, 32, 33, 280, 288, 289, 290, 284, 291, 292, 293, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 122, 123, 89, 88, 475, 476, 204, 474, 479, 478, 477, 205],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 53, 54, 9, 42, 300, 301, 302, 303, 304, 305, 306, 307, 128, 129, 91, 90, 513, 514, 212, 512, 517, 516, 515, 213],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 128, 129, 91, 90, 513, 514, 212, 512, 517, 516, 515, 213],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225, 53, 54, 9, 42, 300, 301, 302, 303, 304, 305, 306, 307, 122, 123, 89, 88, 475, 476, 204, 474, 479, 478, 477, 205],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 122, 123, 89, 88, 475, 476, 204, 474, 479, 478, 477, 205, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 64, 62, 14, 39, 308, 309, 310, 311, 312, 313, 314, 315, 481, 480, 483, 482, 486, 487, 484, 485, 491, 490, 489, 488, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 65, 59, 40, 38, 316, 317, 318, 319, 320, 321, 322, 323, 493, 492, 495, 494, 498, 499, 496, 497, 503, 502, 501, 500, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 138, 139, 95, 94, 406, 407, 408, 409, 410, 411, 412, 413, 11, 55, 8, 41, 324, 325, 326, 327, 328, 329, 330, 331, 124, 125, 141, 140, 506, 507, 504, 505, 511, 510, 509, 508],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 128, 129, 91, 90, 513, 514, 212, 512, 517, 516, 515, 213, 23, 24, 13, 25, 256, 257, 258, 259, 260, 261, 262, 263, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 64, 62, 14, 39, 308, 309, 310, 311, 312, 313, 314, 315, 519, 518, 521, 520, 524, 525, 522, 523, 529, 528, 527, 526, 26, 20, 27, 28, 264, 265, 266, 267, 268, 269, 270, 271, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 65, 59, 40, 38, 316, 317, 318, 319, 320, 321, 322, 323, 531, 530, 533, 532, 536, 537, 534, 535, 541, 540, 539, 538, 4, 22, 5, 19, 272, 273, 274, 275, 276, 277, 278, 279, 109, 108, 79, 78, 598, 599, 600, 601, 602, 603, 604, 605, 11, 55, 8, 41, 324, 325, 326, 327, 328, 329, 330, 331, 126, 127, 93, 92, 544, 545, 542, 543, 549, 548, 547, 546],
  [0, 24, 5, 28, 158, 265, 258, 275, 159, 277, 270, 263, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 66, 69, 50, 49, 332, 349, 342, 359, 336, 361, 354, 347, 493, 123, 483, 140, 498, 507, 204, 485, 503, 490, 509, 205, 23, 16, 27, 19, 256, 273, 251, 267, 260, 269, 278, 255, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 68, 67, 48, 51, 340, 357, 334, 351, 344, 353, 362, 339, 124, 480, 89, 494, 506, 499, 484, 474, 511, 478, 501, 488, 26, 22, 13, 17, 264, 250, 274, 259, 268, 261, 254, 279, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 70, 73, 46, 45, 348, 333, 358, 343, 352, 345, 338, 363, 122, 492, 141, 482, 475, 487, 496, 505, 479, 510, 489, 500, 4, 20, 2, 25, 272, 257, 266, 252, 276, 253, 262, 271, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 72, 71, 44, 47, 356, 341, 350, 335, 360, 337, 346, 355, 481, 125, 495, 88, 486, 476, 504, 497, 491, 502, 477, 508],
  [0, 24, 5, 28, 158, 265, 258, 275, 159, 277, 270, 263, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 531, 129, 521, 92, 536, 545, 212, 523, 541, 528, 547, 213, 23, 16, 27, 19, 256, 273, 251, 267, 260, 269, 278, 255, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 126, 518, 91, 532, 544, 537, 522, 512, 549, 516, 539, 526, 26, 22, 13, 17, 264, 250, 274, 259, 268, 261, 254, 279, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 128, 530, 93, 520, 513, 525, 534, 543, 517, 548, 527, 538, 4, 20, 2, 25, 272, 257, 266, 252, 276, 253, 262, 271, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 519, 127, 533, 90, 524, 514, 542, 535, 529, 540, 515, 546],
  [0, 16, 2, 17, 158, 250, 251, 252, 159, 253, 254, 255, 100, 101, 75, 74, 370, 371, 188, 372, 373, 374, 375, 189, 1, 52, 6, 34, 168, 294, 295, 296, 169, 297, 298, 299, 122, 123, 89, 88, 475, 476, 204, 474, 479, 478, 477, 205, 29, 21, 15, 30, 280, 281, 282, 283, 284, 285, 286, 287, 116, 117, 83, 82, 376, 377, 224, 378, 379, 380, 381, 225, 53, 54, 9, 42, 300, 301, 302, 303, 304, 305, 306, 307, 128, 129, 91, 90, 513, 514, 212, 512, 517, 516, 515, 213],
  [0, 20, 13, 19, 158, 273, 266, 259, 159, 261, 278, 271, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 1, 59, 14, 41, 168, 325, 318, 311, 169, 313, 330, 323, 551, 550, 553, 552, 556, 557, 554, 555, 561, 560, 559, 558, 29, 31, 32, 33, 280, 288, 289, 290, 284, 291, 292, 293, 450, 415, 440, 429, 454, 431, 420, 445, 458, 447, 436, 425, 53, 63, 36, 35, 300, 364, 365, 366, 304, 367, 368, 369, 563, 562, 565, 564, 568, 569, 566, 567, 573, 572, 571, 570],
  [0, 16],
  [0, 18],
  [0, 16, 26, 20],
  [0, 2, 23, 13],
  [0, 3, 4, 32],
  [0, 2, 29, 15],
  [0, 3, 29, 27],
  [0, 52],
  [0, 63],
  [0, 52, 26, 59],
  [0, 63, 26, 54],
  [0, 52, 16, 1],
  [0, 18, 1, 61],
  [0, 52, 16, 1, 26, 59, 20, 65],
  [0, 31, 1, 63],
  [0, 1, 24, 62],
  [0, 15, 1, 9],
  // 'P 1 21/n 1'
  // X,Y,Z
  // -X+1/2,Y+1/2,-Z+1/2
  // -X,-Y,-Z
  // X+1/2,-Y+1/2,Z+1/2
  [0, 5, 1, 8],
  // 'P 1 21/a 1'
  // X,Y,Z
  // -X+1/2,Y+1/2,-Z
  // -X,-Y,-Z
  // X+1/2,-Y+1/2,Z
  [0, 31, 1, 63, 26, 21, 65, 54],
  [0, 2, 57, 56],
  [0, 60, 3, 16],
  [0, 22, 57, 3],
  [0, 2, 28, 20],
  [0, 17, 13, 24],
  [0, 20, 19, 13, 4, 24, 17, 27],
  [0, 22, 57, 3, 4, 16, 60, 32],
  [0, 22, 57, 3, 23, 20, 30, 12, 26, 24, 33, 15, 4, 16, 60, 32],
  [0, 22, 57, 3, 29, 18, 27, 25],
  [0, 22, 3, 57, 1, 55, 10, 37],
  [0, 22, 385, 396, 3, 57, 109, 117],
  [0, 22, 57, 3, 159, 279, 654, 655, 158, 274, 656, 657, 29, 18, 25, 27, 284, 658, 262, 269, 280, 659, 257, 267]
];
var SpacegroupNameToIndexMap = {
  "P 1": 0,
  "P -1": 1,
  "P 1 2 1": 2,
  "P 1 21 1": 3,
  "C 1 2 1": 4,
  "P 1 m 1": 5,
  "P 1 c 1": 6,
  "C 1 m 1": 7,
  "C 1 c 1": 8,
  "P 1 2/m 1": 9,
  "P 1 21/m 1": 10,
  "C 1 2/m 1": 11,
  "P 1 2/c 1": 12,
  "P 1 21/c 1": 13,
  "C 1 2/c 1": 14,
  "P 2 2 2": 15,
  "P 2 2 21": 16,
  "P 21 21 2": 17,
  "P 21 21 21": 18,
  "C 2 2 21": 19,
  "C 2 2 2": 20,
  "F 2 2 2": 21,
  "I 2 2 2": 22,
  "I 21 21 21": 23,
  "P m m 2": 24,
  "P m c 21": 25,
  "P c c 2": 26,
  "P m a 2": 27,
  "P c a 21": 28,
  "P n c 2": 29,
  "P m n 21": 30,
  "P b a 2": 31,
  "P n a 21": 32,
  "P n n 2": 33,
  "C m m 2": 34,
  "C m c 21": 35,
  "C c c 2": 36,
  "A m m 2": 37,
  "A b m 2": 38,
  "A m a 2": 39,
  "A b a 2": 40,
  "F m m 2": 41,
  "F d d 2": 42,
  "I m m 2": 43,
  "I b a 2": 44,
  "I m a 2": 45,
  "P 2/m 2/m 2/m": 46,
  "P m m m": 46,
  "P 2/n 2/n 2/n": 47,
  "P n n n": 47,
  "P 2/c 2/c 2/m": 48,
  "P c c m": 48,
  "P 2/b 2/a 2/n": 49,
  "P b a n": 49,
  "P 21/m 2/m 2/a": 50,
  "P m m a": 50,
  "P 2/n 21/n 2/a": 51,
  "P n n a": 51,
  "P 2/m 2/n 21/a": 52,
  "P m n a": 52,
  "P 21/c 2/c 2/a": 53,
  "P c c a": 53,
  "P 21/b 21/a 2/m": 54,
  "P b a m": 54,
  "P 21/c 21/c 2/n": 55,
  "P c c n": 55,
  "P 2/b 21/c 21/m": 56,
  "P b c m": 56,
  "P 21/n 21/n 2/m": 57,
  "P n n m": 57,
  "P 21/m 21/m 2/n": 58,
  "P m m n": 58,
  "P 21/b 2/c 21/n": 59,
  "P b c n": 59,
  "P 21/b 21/c 21/a": 60,
  "P b c a": 60,
  "P 21/n 21/m 21/a": 61,
  "P n m a": 61,
  "C 2/m 2/c 21/m": 62,
  "C m c m": 62,
  "C 2/m 2/c 21/a": 63,
  "C m c a": 63,
  "C 2/m 2/m 2/m": 64,
  "C m m m": 64,
  "C 2/c 2/c 2/m": 65,
  "C c c m": 65,
  "C 2/m 2/m 2/a": 66,
  "C m m a": 66,
  "C 2/c 2/c 2/a": 67,
  "C c c a": 67,
  "F 2/m 2/m 2/m": 68,
  "F m m m": 68,
  "F 2/d 2/d 2/d": 69,
  "F d d d": 69,
  "I 2/m 2/m 2/m": 70,
  "I m m m": 70,
  "I 2/b 2/a 2/m": 71,
  "I b a m": 71,
  "I 21/b 21/c 21/a": 72,
  "I b c a": 72,
  "I 21/m 21/m 21/a": 73,
  "I m m a": 73,
  "P 4": 74,
  "P 41": 75,
  "P 42": 76,
  "P 43": 77,
  "I 4": 78,
  "I 41": 79,
  "P -4": 80,
  "I -4": 81,
  "P 4/m": 82,
  "P 42/m": 83,
  "P 4/n": 84,
  "P 42/n": 85,
  "I 4/m": 86,
  "I 41/a": 87,
  "P 4 2 2": 88,
  "P 4 21 2": 89,
  "P 41 2 2": 90,
  "P 41 21 2": 91,
  "P 42 2 2": 92,
  "P 42 21 2": 93,
  "P 43 2 2": 94,
  "P 43 21 2": 95,
  "I 4 2 2": 96,
  "I 41 2 2": 97,
  "P 4 m m": 98,
  "P 4 b m": 99,
  "P 42 c m": 100,
  "P 42 n m": 101,
  "P 4 c c": 102,
  "P 4 n c": 103,
  "P 42 m c": 104,
  "P 42 b c": 105,
  "I 4 m m": 106,
  "I 4 c m": 107,
  "I 41 m d": 108,
  "I 41 c d": 109,
  "P -4 2 m": 110,
  "P -4 2 c": 111,
  "P -4 21 m": 112,
  "P -4 21 c": 113,
  "P -4 m 2": 114,
  "P -4 c 2": 115,
  "P -4 b 2": 116,
  "P -4 n 2": 117,
  "I -4 m 2": 118,
  "I -4 c 2": 119,
  "I -4 2 m": 120,
  "I -4 2 d": 121,
  "P 4/m 2/m 2/m": 122,
  "P4/m m m": 122,
  "P 4/m 2/c 2/c": 123,
  "P4/m c c": 123,
  "P 4/n 2/b 2/m": 124,
  "P4/n b m": 124,
  "P 4/n 2/n 2/c": 125,
  "P4/n n c": 125,
  "P 4/m 21/b 2/m": 126,
  "P4/m b m": 126,
  "P 4/m 21/n 2/c": 127,
  "P4/m n c": 127,
  "P 4/n 21/m 2/m": 128,
  "P4/n m m": 128,
  "P 4/n 2/c 2/c": 129,
  "P4/n c c": 129,
  "P 42/m 2/m 2/c": 130,
  "P42/m m c": 130,
  "P 42/m 2/c 2/m": 131,
  "P42/m c m": 131,
  "P 42/n 2/b 2/c": 132,
  "P42/n b c": 132,
  "P 42/n 2/n 2/m": 133,
  "P42/n n m": 133,
  "P 42/m 21/b 2/c": 134,
  "P42/m b c": 134,
  "P 42/m 21/n 2/m": 135,
  "P42/m n m": 135,
  "P 42/n 21/m 2/c": 136,
  "P42/n m c": 136,
  "P 42/n 21/c 2/m": 137,
  "P42/n c m": 137,
  "I 4/m 2/m 2/m": 138,
  "I4/m m m": 138,
  "I 4/m 2/c 2/m": 139,
  "I4/m c m": 139,
  "I 41/a 2/m 2/d": 140,
  "I41/a m d": 140,
  "I 41/a 2/c 2/d": 141,
  "I41/a c d": 141,
  "P 3": 142,
  "P 31": 143,
  "P 32": 144,
  "H 3": 145,
  "R 3": 146,
  "P -3": 147,
  "H -3": 148,
  "R -3": 149,
  "P 3 1 2": 150,
  "P 3 2 1": 151,
  "P 31 1 2": 152,
  "P 31 2 1": 153,
  "P 32 1 2": 154,
  "P 32 2 1": 155,
  "H 3 2": 156,
  "R 3 2": 157,
  "P 3 m 1": 158,
  "P 3 1 m": 159,
  "P 3 c 1": 160,
  "P 3 1 c": 161,
  "H 3 m": 162,
  "R 3 m": 163,
  "H 3 c": 164,
  "R 3 c": 165,
  "P -3 1 2/m": 166,
  "P -3 1 m": 166,
  "P -3 1 2/c": 167,
  "P -3 1 c": 167,
  "P -3 2/m 1": 168,
  "P -3 m 1": 168,
  "P -3 2/c 1": 169,
  "P -3 c 1": 169,
  "H -3 2/m": 170,
  "H -3 m": 170,
  "R -3 2/m": 171,
  "R -3 m": 171,
  "H -3 2/c": 172,
  "H -3 c": 172,
  "R -3 2/c": 173,
  "R -3 c": 173,
  "P 6": 174,
  "P 61": 175,
  "P 65": 176,
  "P 62": 177,
  "P 64": 178,
  "P 63": 179,
  "P -6": 180,
  "P 6/m": 181,
  "P 63/m": 182,
  "P 6 2 2": 183,
  "P 61 2 2": 184,
  "P 65 2 2": 185,
  "P 62 2 2": 186,
  "P 64 2 2": 187,
  "P 63 2 2": 188,
  "P 6 m m": 189,
  "P 6 c c": 190,
  "P 63 c m": 191,
  "P 63 m c": 192,
  "P -6 m 2": 193,
  "P -6 c 2": 194,
  "P -6 2 m": 195,
  "P -6 2 c": 196,
  "P 6/m 2/m 2/m": 197,
  "P 6/m m m": 197,
  "P 6/m 2/c 2/c": 198,
  "P 6/m c c": 198,
  "P 63/m 2/c 2/m": 199,
  "P 63/m c m": 199,
  "P 63/m 2/m 2/c": 200,
  "P 63/m m c": 200,
  "P 2 3": 201,
  "F 2 3": 202,
  "I 2 3": 203,
  "P 21 3": 204,
  "I 21 3": 205,
  "P 2/m -3": 206,
  "P m -3": 206,
  "P 2/n -3": 207,
  "P n -3": 207,
  "F 2/m -3": 208,
  "F m -3": 208,
  "F 2/d -3": 209,
  "F d -3": 209,
  "I 2/m -3": 210,
  "I m -3": 210,
  "P 21/a -3": 211,
  "P a -3": 211,
  "I 21/a -3": 212,
  "I a -3": 212,
  "P 4 3 2": 213,
  "P 42 3 2": 214,
  "F 4 3 2": 215,
  "F 41 3 2": 216,
  "I 4 3 2": 217,
  "P 43 3 2": 218,
  "P 41 3 2": 219,
  "I 41 3 2": 220,
  "P -4 3 m": 221,
  "F -4 3 m": 222,
  "I -4 3 m": 223,
  "P -4 3 n": 224,
  "F -4 3 c": 225,
  "I -4 3 d": 226,
  "P 4/m -3 2/m": 227,
  "P m -3 m": 227,
  "P 4/n -3 2/n": 228,
  "P n -3 n": 228,
  "P 42/m -3 2/n": 229,
  "P m -3 n": 229,
  "P 42/n -3 2/m": 230,
  "P n -3 m": 230,
  "F 4/m -3 2/m": 231,
  "F m -3 m": 231,
  "F 4/m -3 2/c": 232,
  "F m -3 c": 232,
  "F 41/d -3 2/m": 233,
  "F d -3 m": 233,
  "F 41/d -3 2/c": 234,
  "F d -3 c": 234,
  "I 4/m -3 2/m": 235,
  "I m -3 m": 235,
  "I 41/a -3 2/d": 236,
  "I a -3 d": 236,
  "P 1 1 2": 237,
  "P 1 1 21": 238,
  "B 1 1 2": 239,
  "B 2": 239,
  "A 1 2 1": 240,
  "C 1 21 1": 241,
  "I 1 2 1": 242,
  "I 2": 242,
  "I 1 21 1": 243,
  "P 1 1 m": 244,
  "P 1 1 b": 245,
  "B 1 1 m": 246,
  "B 1 1 b": 247,
  "P 1 1 2/m": 248,
  "P 1 1 21/m": 249,
  "B 1 1 2/m": 250,
  "P 1 1 2/b": 251,
  "P 1 1 21/b": 252,
  "P 1 21/n 1": 253,
  "P 1 21/a 1": 254,
  "B 1 1 2/b": 255,
  "P 21 2 2": 256,
  "P 2 21 2": 257,
  "P 21 21 2 (a)": 258,
  "P 21 2 21": 259,
  "P 2 21 21": 260,
  "C 2 2 21a)": 261,
  "C 2 2 2a": 262,
  "F 2 2 2a": 263,
  "I 2 2 2a": 264,
  "P 21/m 21/m 2/n a": 265,
  "P 42 21 2a": 266,
  "I 2 3a": 267
};
function getSpacegroupIndexFromNumber(num) {
  switch (num) {
    case 1146:
      return 146;
    case 1148:
      return 149;
    case 1155:
      return 157;
    case 1160:
      return 163;
    case 1161:
      return 165;
    case 1166:
      return 171;
    case 1167:
      return 173;
    case 1003:
      return 237;
    case 1004:
      return 238;
    case 1005:
      return 239;
    case 2005:
      return 240;
    case 3005:
      return 241;
    case 4005:
      return 242;
    case 5005:
      return 243;
    case 1006:
      return 244;
    case 1007:
      return 245;
    case 1008:
      return 246;
    case 1009:
      return 247;
    case 1010:
      return 248;
    case 1011:
      return 249;
    case 1012:
      return 250;
    case 1013:
      return 251;
    case 1014:
      return 252;
    case 2014:
      return 253;
    case 3014:
      return 254;
    case 1015:
      return 255;
    case 1017:
      return 256;
    case 2017:
      return 257;
    case 1018:
      return 258;
    case 2018:
      return 259;
    case 3018:
      return 260;
    case 1020:
      return 261;
    case 1021:
      return 262;
    case 1022:
      return 263;
    case 1023:
      return 264;
    case 1059:
      return 265;
    case 1094:
      return 266;
    case 1197:
      return 267;
  }
  let offset = 0;
  if (num > 146)
    ++offset;
  if (num > 148)
    ++offset;
  if (num > 155)
    ++offset;
  if (num > 160)
    ++offset;
  if (num > 161)
    ++offset;
  if (num > 166)
    ++offset;
  if (num > 167)
    ++offset;
  return num - 1 + offset;
}
function getSpacegroupNumberFromIndex(idx) {
  if (idx < 146)
    return idx + 1;
  if (idx === 146)
    return 1146;
  if (idx < 149)
    return idx + 1 - 1;
  if (idx === 149)
    return 1148;
  if (idx < 157)
    return idx + 1 - 2;
  if (idx === 157)
    return 1155;
  if (idx < 163)
    return idx + 1 - 3;
  if (idx === 163)
    return 1160;
  if (idx < 165)
    return idx + 1 - 4;
  if (idx === 165)
    return 1161;
  if (idx < 171)
    return idx + 1 - 5;
  if (idx === 171)
    return 1166;
  if (idx < 173)
    return idx + 1 - 6;
  if (idx === 173)
    return 1167;
  if (idx < 237)
    return idx + 1 - 7;
  if (idx === 237)
    return 1003;
  if (idx === 238)
    return 1004;
  if (idx === 239)
    return 1005;
  if (idx === 240)
    return 2005;
  if (idx === 241)
    return 3005;
  if (idx === 242)
    return 4005;
  if (idx === 243)
    return 5005;
  if (idx === 244)
    return 1006;
  if (idx === 245)
    return 1007;
  if (idx === 246)
    return 1008;
  if (idx === 247)
    return 1009;
  if (idx === 248)
    return 1010;
  if (idx === 249)
    return 1011;
  if (idx === 250)
    return 1012;
  if (idx === 251)
    return 1013;
  if (idx === 252)
    return 1014;
  if (idx === 253)
    return 2014;
  if (idx === 254)
    return 3014;
  if (idx === 255)
    return 1015;
  if (idx === 256)
    return 1017;
  if (idx === 257)
    return 2017;
  if (idx === 258)
    return 1018;
  if (idx === 259)
    return 2018;
  if (idx === 260)
    return 3018;
  if (idx === 261)
    return 1020;
  if (idx === 262)
    return 1021;
  if (idx === 263)
    return 1022;
  if (idx === 264)
    return 1023;
  if (idx === 265)
    return 1059;
  if (idx === 266)
    return 1094;
  if (idx === 267)
    return 1197;
  throw new Error(`unknown spacegroup index '${idx}'`);
}
var SpacegroupName = function() {
  const names = /* @__PURE__ */ Object.create(null);
  for (const n of Object.keys(SpacegroupNameToIndexMap)) {
    names[SpacegroupNameToIndexMap[n]] = n;
  }
  return names;
}();
var SpacegroupNumber = function() {
  const numbers = /* @__PURE__ */ Object.create(null);
  for (const n of Object.keys(SpacegroupNameToIndexMap)) {
    const idx = SpacegroupNameToIndexMap[n];
    numbers[idx] = getSpacegroupNumberFromIndex(idx);
  }
  return numbers;
}();
function getSpacegroupIndex(nameOrNumber) {
  const index = typeof nameOrNumber === "number" ? getSpacegroupIndexFromNumber(nameOrNumber) : SpacegroupNameToIndexMap[nameOrNumber];
  if (typeof index === "undefined" || typeof SpacegroupName[index] === "undefined")
    return -1;
  return index;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/spacegroup/construction.js
var SpacegroupCell;
(function(SpacegroupCell2) {
  SpacegroupCell2.Zero = create("P 1", Vec3.create(1, 1, 1), Vec3.create(Math.PI / 2, Math.PI / 2, Math.PI / 2));
  function isZero(cell) {
    if (!cell)
      return true;
    return cell.index === 0 && cell.size[0] === 1 && cell.size[1] === 1 && cell.size[1] === 1;
  }
  SpacegroupCell2.isZero = isZero;
  function create(nameOrNumber, size, anglesInRadians) {
    const index = getSpacegroupIndex(nameOrNumber);
    if (index < 0) {
      console.warn(`Unknown spacegroup '${nameOrNumber}', returning a 'P 1' with cellsize [1, 1, 1]`);
      return SpacegroupCell2.Zero;
    }
    const volume = size[0] * size[1] * size[2];
    const alpha = anglesInRadians[0];
    const beta = anglesInRadians[1];
    const gamma = anglesInRadians[2];
    const xScale = size[0], yScale = size[1], zScale = size[2];
    const z1 = Math.cos(beta);
    const z2 = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma);
    const z3 = Math.sqrt(1 - z1 * z1 - z2 * z2);
    const x = [xScale, 0, 0];
    const y = [Math.cos(gamma) * yScale, Math.sin(gamma) * yScale, 0];
    const z = [z1 * zScale, z2 * zScale, z3 * zScale];
    const fromFractional = Mat4.ofRows([
      [x[0], y[0], z[0], 0],
      [0, y[1], z[1], 0],
      [0, 0, z[2], 0],
      [0, 0, 0, 1]
    ]);
    const toFractional = Mat4.invert(Mat4.zero(), fromFractional);
    return { index, size, volume, anglesInRadians, toFractional, fromFractional };
  }
  SpacegroupCell2.create = create;
})(SpacegroupCell || (SpacegroupCell = {}));
var Spacegroup;
(function(Spacegroup2) {
  Spacegroup2.ZeroP1 = create(SpacegroupCell.Zero);
  function create(cell) {
    const operators = GroupData[cell.index].map((i) => getOperatorMatrix(OperatorData[i]));
    const name = SpacegroupName[cell.index];
    const num = SpacegroupNumber[cell.index];
    return { name, num, cell, operators };
  }
  Spacegroup2.create = create;
  const _ijkVec = Vec3();
  const _tempMat = Mat4();
  function setOperatorMatrix(spacegroup, index, i, j, k, target) {
    Vec3.set(_ijkVec, i, j, k);
    Mat4.fromTranslation(_tempMat, _ijkVec);
    return Mat4.mul(target, Mat4.mul(target, Mat4.mul(target, spacegroup.cell.fromFractional, _tempMat), spacegroup.operators[index]), spacegroup.cell.toFractional);
  }
  Spacegroup2.setOperatorMatrix = setOperatorMatrix;
  function getSymmetryOperator(spacegroup, spgrOp, i, j, k) {
    const operator = setOperatorMatrix(spacegroup, spgrOp, i, j, k, Mat4.zero());
    return SymmetryOperator.create(`${spgrOp + 1}_${5 + i}${5 + j}${5 + k}`, operator, { hkl: Vec3.create(i, j, k), spgrOp });
  }
  Spacegroup2.getSymmetryOperator = getSymmetryOperator;
  const _translationRef = Vec3();
  const _translationRefSymop = Vec3();
  const _translationRefOffset = Vec3();
  const _translationSymop = Vec3();
  function getSymmetryOperatorRef(spacegroup, spgrOp, i, j, k, ref) {
    const operator = Mat4.zero();
    Vec3.set(_ijkVec, i, j, k);
    Vec3.floor(_translationRef, ref);
    Mat4.copy(operator, spacegroup.operators[spgrOp]);
    Vec3.floor(_translationRefSymop, Vec3.transformMat4(_translationRefSymop, ref, operator));
    Mat4.getTranslation(_translationSymop, operator);
    Vec3.sub(_translationSymop, _translationSymop, _translationRefSymop);
    Vec3.add(_translationSymop, _translationSymop, _translationRef);
    Vec3.add(_translationSymop, _translationSymop, _ijkVec);
    Mat4.setTranslation(operator, _translationSymop);
    Mat4.mul(operator, spacegroup.cell.fromFractional, operator);
    Mat4.mul(operator, operator, spacegroup.cell.toFractional);
    Vec3.sub(_translationRefOffset, _translationRefSymop, _translationRef);
    const _i = i - _translationRefOffset[0];
    const _j = j - _translationRefOffset[1];
    const _k = k - _translationRefOffset[2];
    return SymmetryOperator.create(`${spgrOp + 1}_${5 + _i}${5 + _j}${5 + _k}`, operator, { hkl: Vec3.create(_i, _j, _k), spgrOp });
  }
  Spacegroup2.getSymmetryOperatorRef = getSymmetryOperatorRef;
  function getOperatorMatrix(ids) {
    const r1 = TransformData[ids[0]];
    const r2 = TransformData[ids[1]];
    const r3 = TransformData[ids[2]];
    return Mat4.ofRows([r1, r2, r3, [0, 0, 0, 1]]);
  }
  function getOperatorXyz(op) {
    return [
      formatElement(getRotation(op[0], op[4], op[8]), getShift(op[12])),
      formatElement(getRotation(op[1], op[5], op[9]), getShift(op[13])),
      formatElement(getRotation(op[2], op[6], op[10]), getShift(op[14]))
    ].join(",");
  }
  Spacegroup2.getOperatorXyz = getOperatorXyz;
  function getRotation(x, y, z) {
    const r = [];
    if (x > 0)
      r.push("+X");
    else if (x < 0)
      r.push("-X");
    if (y > 0)
      r.push("+Y");
    else if (y < 0)
      r.push("-Y");
    if (z > 0)
      r.push("+Z");
    else if (z < 0)
      r.push("-Z");
    if (r.length === 1) {
      return r[0].charAt(0) === "+" ? r[0].substr(1) : r[0];
    }
    if (r.length === 2) {
      const s0 = r[0].charAt(0);
      const s1 = r[1].charAt(0);
      if (s0 === "+")
        return `${r[0].substr(1)}${r[1]}`;
      if (s1 === "+")
        return `${r[1].substr(1)}${r[0]}`;
    }
    throw new Error(`unknown rotation '${r}', ${x} ${y} ${z}`);
  }
  function getShift(s) {
    switch (s) {
      case 1 / 2:
        return "1/2";
      case 1 / 4:
        return "1/4";
      case 3 / 4:
        return "3/4";
      case 1 / 3:
        return "1/3";
      case 2 / 3:
        return "2/3";
      case 1 / 6:
        return "1/6";
      case 5 / 6:
        return "5/6";
    }
    return "";
  }
  function formatElement(rotation, shift) {
    if (shift === "")
      return rotation;
    if (rotation.length > 2)
      return `${rotation}+${shift}`;
    return rotation.charAt(0) === "-" ? `${shift}${rotation}` : `${shift}+${rotation}`;
  }
})(Spacegroup || (Spacegroup = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/lookup3d/common.js
var Result;
(function(Result2) {
  function add(result2, index, distSq) {
    result2.squaredDistances[result2.count] = distSq;
    result2.indices[result2.count++] = index;
  }
  Result2.add = add;
  function reset(result2) {
    result2.count = 0;
  }
  Result2.reset = reset;
  function create() {
    return { count: 0, indices: [], squaredDistances: [] };
  }
  Result2.create = create;
  function copy(out, result2) {
    for (let i = 0; i < result2.count; ++i) {
      out.indices[i] = result2.indices[i];
      out.squaredDistances[i] = result2.squaredDistances[i];
    }
    out.count = result2.count;
    return out;
  }
  Result2.copy = copy;
})(Result || (Result = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/fibonacci-heap.js
var Node = class {
  constructor(key, value) {
    this.parent = null;
    this.child = null;
    this.degree = 0;
    this.isMarked = false;
    this.key = key;
    this.value = value;
    this.prev = this;
    this.next = this;
  }
};
var NodeListIterator = class {
  /**
  * Creates an Iterator used to simplify the consolidate() method. It works by
  * making a shallow copy of the nodes in the root list and iterating over the
  * shallow copy instead of the source as the source will be modified.
  * @param start A node from the root list.
  */
  constructor(start) {
    this._index = -1;
    this._items = [];
    this._len = 0;
    if (start) {
      let current = start, l = 0;
      do {
        this._items[l++] = current;
        current = current.next;
      } while (start !== current);
      this._len = l;
    }
  }
  /**
  * @return Whether there is a next node in the iterator.
  */
  hasNext() {
    return this._index < this._len - 1;
  }
  /**
  * @return The next node.
  */
  next() {
    return this._items[++this._index];
  }
  /**
  * @return Resets iterator to reuse it.
  */
  reset(start) {
    this._index = -1;
    this._len = 0;
    let current = start, l = 0;
    do {
      this._items[l++] = current;
      current = current.next;
    } while (start !== current);
    this._len = l;
  }
};
var tmpIt = new NodeListIterator();
var FibonacciHeap = class {
  constructor(compare) {
    this._minNode = null;
    this._nodeCount = 0;
    this._compare = compare ? compare : this._defaultCompare;
  }
  /**
  * Clears the heap's data, making it an empty heap.
  */
  clear() {
    this._minNode = null;
    this._nodeCount = 0;
  }
  /**
  * Decreases a key of a node.
  * @param node The node to decrease the key of.
  * @param newKey The new key to assign to the node.
  */
  decreaseKey(node, newKey) {
    if (!node) {
      throw new Error("Cannot decrease key of non-existent node");
    }
    if (this._compare({ key: newKey }, { key: node.key }) > 0) {
      throw new Error("New key is larger than old key");
    }
    node.key = newKey;
    const parent = node.parent;
    if (parent && this._compare(node, parent) < 0) {
      this._cut(node, parent, this._minNode);
      this._cascadingCut(parent, this._minNode);
    }
    if (this._compare(node, this._minNode) < 0) {
      this._minNode = node;
    }
  }
  /**
  * Deletes a node.
  * @param node The node to delete.
  */
  delete(node) {
    const parent = node.parent;
    if (parent) {
      this._cut(node, parent, this._minNode);
      this._cascadingCut(parent, this._minNode);
    }
    this._minNode = node;
    this.extractMinimum();
  }
  /**
  * Extracts and returns the minimum node from the heap.
  * @return The heap's minimum node or null if the heap is empty.
  */
  extractMinimum() {
    const extractedMin = this._minNode;
    if (extractedMin) {
      if (extractedMin.child) {
        let child = extractedMin.child;
        do {
          child.parent = null;
          child = child.next;
        } while (child !== extractedMin.child);
      }
      let nextInRootList = null;
      if (extractedMin.next !== extractedMin) {
        nextInRootList = extractedMin.next;
      }
      this._removeNodeFromList(extractedMin);
      this._nodeCount--;
      this._minNode = this._mergeLists(nextInRootList, extractedMin.child);
      if (this._minNode) {
        this._minNode = this._consolidate(this._minNode);
      }
    }
    return extractedMin;
  }
  /**
  * Returns the minimum node from the heap.
  * @return The heap's minimum node or null if the heap is empty.
  */
  findMinimum() {
    return this._minNode;
  }
  /**
  * Inserts a new key-value pair into the heap.
  * @param key The key to insert.
  * @param value The value to insert.
  * @return node The inserted node.
  */
  insert(key, value) {
    const node = new Node(key, value);
    this._minNode = this._mergeLists(this._minNode, node);
    this._nodeCount++;
    return node;
  }
  /**
  * @return Whether the heap is empty.
  */
  isEmpty() {
    return this._minNode === null;
  }
  /**
  * @return The size of the heap.
  */
  size() {
    if (this._minNode === null) {
      return 0;
    }
    return this._getNodeListSize(this._minNode);
  }
  /**
  * Joins another heap to this heap.
  * @param other The other heap.
  */
  union(other) {
    this._minNode = this._mergeLists(this._minNode, other._minNode);
    this._nodeCount += other._nodeCount;
  }
  /**
  * Compares two nodes with each other.
  * @param a The first key to compare.
  * @param b The second key to compare.
  * @return -1, 0 or 1 if a < b, a == b or a > b respectively.
  */
  _defaultCompare(a, b) {
    if (a.key > b.key) {
      return 1;
    }
    if (a.key < b.key) {
      return -1;
    }
    return 0;
  }
  /**
  * Cut the link between a node and its parent, moving the node to the root list.
  * @param node The node being cut.
  * @param parent The parent of the node being cut.
  * @param minNode The minimum node in the root list.
  * @return The heap's new minimum node.
  */
  _cut(node, parent, minNode) {
    node.parent = null;
    parent.degree--;
    if (node.next === node) {
      parent.child = null;
    } else {
      parent.child = node.next;
    }
    this._removeNodeFromList(node);
    const newMinNode = this._mergeLists(minNode, node);
    node.isMarked = false;
    return newMinNode;
  }
  /**
  * Perform a cascading cut on a node; mark the node if it is not marked,
  * otherwise cut the node and perform a cascading cut on its parent.
  * @param node The node being considered to be cut.
  * @param minNode The minimum node in the root list.
  * @return The heap's new minimum node.
  */
  _cascadingCut(node, minNode) {
    const parent = node.parent;
    if (parent) {
      if (node.isMarked) {
        minNode = this._cut(node, parent, minNode);
        minNode = this._cascadingCut(parent, minNode);
      } else {
        node.isMarked = true;
      }
    }
    return minNode;
  }
  /**
  * Merge all trees of the same order together until there are no two trees of
  * the same order.
  * @param minNode The current minimum node.
  * @return The new minimum node.
  */
  _consolidate(minNode) {
    const aux = [];
    tmpIt.reset(minNode);
    while (tmpIt.hasNext()) {
      let current = tmpIt.next();
      let auxCurrent = aux[current.degree];
      while (auxCurrent) {
        if (this._compare(current, auxCurrent) > 0) {
          const temp = current;
          current = auxCurrent;
          auxCurrent = temp;
        }
        this._linkHeaps(auxCurrent, current);
        aux[current.degree] = null;
        current.degree++;
        auxCurrent = aux[current.degree];
      }
      aux[current.degree] = current;
    }
    let newMinNode = null;
    for (let i = 0; i < aux.length; i++) {
      const node = aux[i];
      if (node) {
        node.next = node;
        node.prev = node;
        newMinNode = this._mergeLists(newMinNode, node);
      }
    }
    return newMinNode;
  }
  /**
  * Removes a node from a node list.
  * @param node The node to remove.
  */
  _removeNodeFromList(node) {
    const prev = node.prev;
    const next = node.next;
    prev.next = next;
    next.prev = prev;
    node.next = node;
    node.prev = node;
  }
  /**
  * Links two heaps of the same order together.
  *
  * @private
  * @param max The heap with the larger root.
  * @param min The heap with the smaller root.
  */
  _linkHeaps(max, min) {
    this._removeNodeFromList(max);
    min.child = this._mergeLists(max, min.child);
    max.parent = min;
    max.isMarked = false;
  }
  /**
  * Merge two lists of nodes together.
  *
  * @private
  * @param a The first list to merge.
  * @param b The second list to merge.
  * @return The new minimum node from the two lists.
  */
  _mergeLists(a, b) {
    if (!a) {
      if (!b) {
        return null;
      }
      return b;
    }
    if (!b) {
      return a;
    }
    const temp = a.next;
    a.next = b.next;
    a.next.prev = a;
    b.next = temp;
    b.next.prev = b;
    return this._compare(a, b) < 0 ? a : b;
  }
  /**
  * Gets the size of a node list.
  * @param node A node within the node list.
  * @return The size of the node list.
  */
  _getNodeListSize(node) {
    let count = 0;
    let current = node;
    do {
      count++;
      if (current.child) {
        count += this._getNodeListSize(current.child);
      }
      current = current.next;
    } while (current !== node);
    return count;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/memoize.js
function memoizeLatest(f) {
  let lastArgs = void 0, value = void 0;
  return (...args) => {
    if (!lastArgs || lastArgs.length !== args.length) {
      lastArgs = args;
      value = f.apply(void 0, args);
      return value;
    }
    for (let i = 0, _i = args.length; i < _i; i++) {
      if (args[i] !== lastArgs[i]) {
        lastArgs = args;
        value = f.apply(void 0, args);
        return value;
      }
    }
    return value;
  };
}
function memoize1(f) {
  const cache = /* @__PURE__ */ new Map();
  return (a) => {
    if (cache.has(a))
      return cache.get(a);
    const v = f(a);
    cache.set(a, v);
    return v;
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/lookup3d/grid.js
function GridLookup3D(data, boundary, cellSizeOrCount) {
  return new GridLookup3DImpl(data, boundary, cellSizeOrCount);
}
var GridLookup3DImpl = class {
  find(x, y, z, radius, result2) {
    this.ctx.x = x;
    this.ctx.y = y;
    this.ctx.z = z;
    this.ctx.radius = radius;
    this.ctx.isCheck = false;
    const ret = result2 !== null && result2 !== void 0 ? result2 : this.result;
    query(this.ctx, ret);
    return ret;
  }
  nearest(x, y, z, k = 1, stopIf, result2) {
    this.ctx.x = x;
    this.ctx.y = y;
    this.ctx.z = z;
    this.ctx.k = k;
    this.ctx.stopIf = stopIf;
    const ret = result2 !== null && result2 !== void 0 ? result2 : this.result;
    queryNearest(this.ctx, ret);
    return ret;
  }
  check(x, y, z, radius) {
    this.ctx.x = x;
    this.ctx.y = y;
    this.ctx.z = z;
    this.ctx.radius = radius;
    this.ctx.isCheck = true;
    return query(this.ctx, this.result);
  }
  approxNearest(x, y, z, radius, result2) {
    this.ctx.x = x;
    this.ctx.y = y;
    this.ctx.z = z;
    this.ctx.radius = radius;
    this.ctx.isCheck = false;
    const ret = result2 !== null && result2 !== void 0 ? result2 : this.result;
    approxQueryNearest(this.ctx, ret);
    return ret;
  }
  constructor(data, boundary, cellSizeOrCount) {
    const structure = build(data, boundary, cellSizeOrCount);
    this.ctx = createContext(structure);
    this.boundary = { box: structure.boundingBox, sphere: structure.boundingSphere };
    this.buckets = { offset: structure.bucketOffset, count: structure.bucketCounts, array: structure.bucketArray };
    this.result = Result.create();
  }
};
function _build(state) {
  const { expandedBox, size: [sX, sY, sZ], data: { x: px, y: py, z: pz, radius, indices }, elementCount, delta: delta2 } = state;
  const n = sX * sY * sZ;
  const { min: [minX, minY, minZ] } = expandedBox;
  let maxRadius = 0;
  let bucketCount = 0;
  const grid = new Uint32Array(n);
  const bucketIndex = new Int32Array(elementCount);
  for (let t = 0; t < elementCount; t++) {
    const i = OrderedSet.getAt(indices, t);
    const x = Math.floor((px[i] - minX) / delta2[0]);
    const y = Math.floor((py[i] - minY) / delta2[1]);
    const z = Math.floor((pz[i] - minZ) / delta2[2]);
    const idx = (x * sY + y) * sZ + z;
    if ((grid[idx] += 1) === 1) {
      bucketCount += 1;
    }
    bucketIndex[t] = idx;
  }
  if (radius) {
    for (let t = 0; t < elementCount; t++) {
      const i = OrderedSet.getAt(indices, t);
      if (radius[i] > maxRadius)
        maxRadius = radius[i];
    }
  }
  const bucketCounts = new Int32Array(bucketCount);
  for (let i = 0, j = 0; i < n; i++) {
    const c = grid[i];
    if (c > 0) {
      grid[i] = j + 1;
      bucketCounts[j] = c;
      j += 1;
    }
  }
  const bucketOffset = new Uint32Array(bucketCount);
  for (let i = 1; i < bucketCount; ++i) {
    bucketOffset[i] += bucketOffset[i - 1] + bucketCounts[i - 1];
  }
  const bucketFill = new Int32Array(bucketCount);
  const bucketArray = new Int32Array(elementCount);
  for (let i = 0; i < elementCount; i++) {
    const bucketIdx = grid[bucketIndex[i]];
    if (bucketIdx > 0) {
      const k = bucketIdx - 1;
      bucketArray[bucketOffset[k] + bucketFill[k]] = i;
      bucketFill[k] += 1;
    }
  }
  return {
    size: state.size,
    bucketArray,
    bucketCounts,
    bucketOffset,
    grid,
    delta: delta2,
    min: state.expandedBox.min,
    data: state.data,
    maxRadius,
    expandedBox: state.expandedBox,
    boundingBox: state.boundingBox,
    boundingSphere: state.boundingSphere
  };
}
var MaxVolume = 2 ** 24;
function build(data, boundary, cellSizeOrCount) {
  const expandedBox = Box3D.expand(Box3D(), boundary.box, Vec3.create(0.5, 0.5, 0.5));
  const { indices } = data;
  const S = Box3D.size(Vec3(), expandedBox);
  let delta2, size;
  const elementCount = OrderedSet.size(indices);
  const cellCount = typeof cellSizeOrCount === "number" ? cellSizeOrCount : 32;
  const cellSize = Array.isArray(cellSizeOrCount) && cellSizeOrCount;
  if (cellSize && !Vec3.isZero(cellSize)) {
    size = [Math.ceil(S[0] / cellSize[0]), Math.ceil(S[1] / cellSize[1]), Math.ceil(S[2] / cellSize[2])];
    delta2 = cellSize;
  } else if (elementCount > 0) {
    const V = Math.ceil(elementCount / cellCount);
    const f = Math.pow(V / (S[0] * S[1] * S[2]), 1 / 3);
    size = [Math.ceil(S[0] * f), Math.ceil(S[1] * f), Math.ceil(S[2] * f)];
    delta2 = [S[0] / size[0], S[1] / size[1], S[2] / size[2]];
  } else {
    delta2 = S;
    size = [1, 1, 1];
  }
  const volume = size[0] * size[1] * size[2];
  if (volume > MaxVolume) {
    const f = Math.cbrt(volume / MaxVolume);
    size = [Math.ceil(size[0] / f), Math.ceil(size[1] / f), Math.ceil(size[2] / f)];
    delta2 = [S[0] / size[0], S[1] / size[1], S[2] / size[2]];
  }
  const inputData = {
    x: data.x,
    y: data.y,
    z: data.z,
    indices,
    radius: data.radius
  };
  const state = {
    size,
    data: inputData,
    expandedBox,
    boundingBox: boundary.box,
    boundingSphere: boundary.sphere,
    elementCount,
    delta: delta2
  };
  return _build(state);
}
function createContext(grid) {
  return { grid, x: 0.1, y: 0.1, z: 0.1, k: 1, stopIf: void 0, radius: 0.1, isCheck: false };
}
function query(ctx, result2) {
  const { min, size: [sX, sY, sZ], bucketOffset, bucketCounts, bucketArray, grid, data: { x: px, y: py, z: pz, indices, radius }, delta: delta2, maxRadius } = ctx.grid;
  const { radius: inputRadius, isCheck, x, y, z } = ctx;
  const r = inputRadius + maxRadius;
  const rSq = r * r;
  Result.reset(result2);
  const loX = Math.max(0, Math.floor((x - r - min[0]) / delta2[0]));
  const loY = Math.max(0, Math.floor((y - r - min[1]) / delta2[1]));
  const loZ = Math.max(0, Math.floor((z - r - min[2]) / delta2[2]));
  const hiX = Math.min(sX - 1, Math.floor((x + r - min[0]) / delta2[0]));
  const hiY = Math.min(sY - 1, Math.floor((y + r - min[1]) / delta2[1]));
  const hiZ = Math.min(sZ - 1, Math.floor((z + r - min[2]) / delta2[2]));
  if (loX > hiX || loY > hiY || loZ > hiZ)
    return false;
  for (let ix = loX; ix <= hiX; ix++) {
    for (let iy = loY; iy <= hiY; iy++) {
      for (let iz = loZ; iz <= hiZ; iz++) {
        const bucketIdx = grid[(ix * sY + iy) * sZ + iz];
        if (bucketIdx === 0)
          continue;
        const k = bucketIdx - 1;
        const offset = bucketOffset[k];
        const count = bucketCounts[k];
        const end = offset + count;
        for (let i = offset; i < end; i++) {
          const idx = OrderedSet.getAt(indices, bucketArray[i]);
          const dx = px[idx] - x;
          const dy = py[idx] - y;
          const dz = pz[idx] - z;
          const distSq = dx * dx + dy * dy + dz * dz;
          if (distSq <= rSq) {
            if (maxRadius > 0 && Math.sqrt(distSq) - radius[idx] > inputRadius)
              continue;
            if (isCheck)
              return true;
            Result.add(result2, bucketArray[i], distSq);
          }
        }
      }
    }
  }
  return result2.count > 0;
}
function _insideOut(r) {
  const cells = [];
  const n = r * 2 + 1;
  for (let x = 0; x < n; ++x) {
    for (let y = 0; y < n; ++y) {
      for (let z = 0; z < n; ++z) {
        cells.push(Vec3.create(x - r, y - r, z - r));
      }
    }
  }
  cells.sort((a, b) => Vec3.squaredMagnitude(a) - Vec3.squaredMagnitude(b));
  return cells.flat();
}
var insideOut = memoize1(_insideOut);
function approxQueryNearest(ctx, result2) {
  const { min, size: [sX, sY, sZ], bucketOffset, bucketCounts, bucketArray, grid, data: { x: px, y: py, z: pz, indices }, delta: delta2 } = ctx.grid;
  const { radius, x, y, z } = ctx;
  const rSq = radius * radius;
  Result.reset(result2);
  const loX = Math.max(0, Math.floor((x - radius - min[0]) / delta2[0]));
  const loY = Math.max(0, Math.floor((y - radius - min[1]) / delta2[1]));
  const loZ = Math.max(0, Math.floor((z - radius - min[2]) / delta2[2]));
  const hiX = Math.min(sX - 1, Math.floor((x + radius - min[0]) / delta2[0]));
  const hiY = Math.min(sY - 1, Math.floor((y + radius - min[1]) / delta2[1]));
  const hiZ = Math.min(sZ - 1, Math.floor((z + radius - min[2]) / delta2[2]));
  if (loX > hiX || loY > hiY || loZ > hiZ)
    return false;
  const miX = Math.floor((x - min[0]) / delta2[0]);
  const miY = Math.floor((y - min[1]) / delta2[1]);
  const miZ = Math.floor((z - min[2]) / delta2[2]);
  const cells = insideOut(Math.max(hiX - loX, hiY - loY, hiZ - loZ) + 1);
  for (let i = 0, _i = cells.length; i < _i; i += 3) {
    const ix = miX + cells[i];
    const iy = miY + cells[i + 1];
    const iz = miZ + cells[i + 2];
    if (ix < loX || ix > hiX || iy < loY || iy > hiY || iz < loZ || iz > hiZ)
      continue;
    const bucketIdx = grid[(ix * sY + iy) * sZ + iz];
    if (bucketIdx === 0)
      continue;
    const k = bucketIdx - 1;
    const offset = bucketOffset[k];
    const count = bucketCounts[k];
    const end = offset + count;
    let minDistSq = Number.MAX_VALUE;
    for (let i2 = offset; i2 < end; i2++) {
      const idx = OrderedSet.getAt(indices, bucketArray[i2]);
      const dx = px[idx] - x;
      const dy = py[idx] - y;
      const dz = pz[idx] - z;
      const distSq = dx * dx + dy * dy + dz * dz;
      if (distSq <= rSq && distSq < minDistSq) {
        Result.add(result2, bucketArray[i2], distSq);
        minDistSq = distSq;
      }
    }
    if (minDistSq !== Number.MAX_VALUE)
      return true;
  }
  return result2.count > 0;
}
var tmpDirVec = Vec3();
var tmpVec = Vec3();
var tmpSetG = /* @__PURE__ */ new Set();
var tmpSetG2 = /* @__PURE__ */ new Set();
var tmpArrG1 = [0.1];
var tmpArrG2 = [0.1];
var tmpArrG3 = [0.1];
var tmpHeapG = new FibonacciHeap();
function queryNearest(ctx, result2) {
  const { min, expandedBox: box, boundingSphere: { center }, size: [sX, sY, sZ], bucketOffset, bucketCounts, bucketArray, grid, data: { x: px, y: py, z: pz, indices, radius }, delta: delta2, maxRadius } = ctx.grid;
  const { x, y, z, k, stopIf } = ctx;
  const indicesCount = OrderedSet.size(indices);
  Result.reset(result2);
  if (indicesCount === 0 || k <= 0)
    return false;
  let gX, gY, gZ, stop = false, gCount = 1, expandGrid = true, nextGCount = 0, arrG = tmpArrG1, nextArrG = tmpArrG2, maxRange = 0, expandRange = true, gridId, gridPointsFinished = false;
  const expandedArrG = tmpArrG3, sqMaxRadius = maxRadius * maxRadius;
  arrG.length = 0;
  expandedArrG.length = 0;
  tmpSetG.clear();
  tmpHeapG.clear();
  Vec3.set(tmpVec, x, y, z);
  if (!Box3D.containsVec3(box, tmpVec)) {
    Box3D.nearestIntersectionWithRay(tmpVec, box, tmpVec, Vec3.normalize(tmpDirVec, Vec3.sub(tmpDirVec, center, tmpVec)));
    gX = Math.max(0, Math.min(sX - 1, Math.floor((tmpVec[0] - min[0]) / delta2[0])));
    gY = Math.max(0, Math.min(sY - 1, Math.floor((tmpVec[1] - min[1]) / delta2[1])));
    gZ = Math.max(0, Math.min(sZ - 1, Math.floor((tmpVec[2] - min[2]) / delta2[2])));
  } else {
    gX = Math.floor((x - min[0]) / delta2[0]);
    gY = Math.floor((y - min[1]) / delta2[1]);
    gZ = Math.floor((z - min[2]) / delta2[2]);
  }
  const dX = maxRadius !== 0 ? Math.max(1, Math.min(sX - 1, Math.ceil(maxRadius / delta2[0]))) : 1;
  const dY = maxRadius !== 0 ? Math.max(1, Math.min(sY - 1, Math.ceil(maxRadius / delta2[1]))) : 1;
  const dZ = maxRadius !== 0 ? Math.max(1, Math.min(sZ - 1, Math.ceil(maxRadius / delta2[2]))) : 1;
  arrG.push(gX, gY, gZ, (gX * sY + gY) * sZ + gZ);
  while (result2.count < indicesCount) {
    const arrGLen = gCount * 4;
    for (let ig = 0; ig < arrGLen; ig += 4) {
      gridId = arrG[ig + 3];
      if (!tmpSetG.has(gridId)) {
        tmpSetG.add(gridId);
        gridPointsFinished = tmpSetG.size >= grid.length;
        const bucketIdx = grid[gridId];
        if (bucketIdx !== 0) {
          const _maxRange = maxRange;
          const ki = bucketIdx - 1;
          const offset = bucketOffset[ki];
          const count = bucketCounts[ki];
          const end = offset + count;
          for (let i = offset; i < end; i++) {
            const bIdx = bucketArray[i];
            const idx = OrderedSet.getAt(indices, bIdx);
            const dx = px[idx] - x;
            const dy = py[idx] - y;
            const dz = pz[idx] - z;
            let distSq = dx * dx + dy * dy + dz * dz;
            if (maxRadius !== 0) {
              const r = radius[idx];
              distSq -= r * r;
            }
            if (expandRange && distSq > maxRange) {
              maxRange = distSq;
            }
            tmpHeapG.insert(distSq, bIdx);
          }
          if (_maxRange < maxRange)
            expandRange = false;
        }
      }
    }
    nextArrG.length = 0;
    nextGCount = 0;
    tmpSetG2.clear();
    for (let ig = 0; ig < arrGLen; ig += 4) {
      gX = arrG[ig];
      gY = arrG[ig + 1];
      gZ = arrG[ig + 2];
      for (let ix = -dX; ix <= dX; ix++) {
        const xPos = gX + ix;
        if (xPos < 0 || xPos >= sX)
          continue;
        for (let iy = -dY; iy <= dY; iy++) {
          const yPos = gY + iy;
          if (yPos < 0 || yPos >= sY)
            continue;
          for (let iz = -dZ; iz <= dZ; iz++) {
            const zPos = gZ + iz;
            if (zPos < 0 || zPos >= sZ)
              continue;
            gridId = (xPos * sY + yPos) * sZ + zPos;
            if (tmpSetG2.has(gridId))
              continue;
            tmpSetG2.add(gridId);
            if (tmpSetG.has(gridId))
              continue;
            if (!expandGrid) {
              const xP = min[0] + xPos * delta2[0] - x;
              const yP = min[1] + yPos * delta2[1] - y;
              const zP = min[2] + zPos * delta2[2] - z;
              const distSqG = xP * xP + yP * yP + zP * zP - sqMaxRadius;
              if (distSqG > maxRange) {
                expandedArrG.push(xPos, yPos, zPos, gridId);
                continue;
              }
            }
            nextArrG.push(xPos, yPos, zPos, gridId);
            nextGCount++;
          }
        }
      }
    }
    expandGrid = false;
    if (nextGCount === 0) {
      if (k === 1) {
        const node = tmpHeapG.findMinimum();
        if (node) {
          const { key: squaredDistance, value: index } = node;
          Result.add(result2, index, squaredDistance);
          return true;
        }
      } else {
        while (!tmpHeapG.isEmpty() && (gridPointsFinished || tmpHeapG.findMinimum().key <= maxRange) && result2.count < k) {
          const node = tmpHeapG.extractMinimum();
          const squaredDistance = node.key, index = node.value;
          Result.add(result2, index, squaredDistance);
          if (stopIf && !stop) {
            stop = stopIf(index, squaredDistance);
          }
        }
      }
      if (result2.count >= k || stop || result2.count >= indicesCount)
        return result2.count > 0;
      expandGrid = true;
      expandRange = true;
      if (expandedArrG.length > 0) {
        for (let i = 0, l = expandedArrG.length; i < l; i++) {
          arrG.push(expandedArrG[i]);
        }
        expandedArrG.length = 0;
        gCount = arrG.length;
      }
    } else {
      const tmp = arrG;
      arrG = nextArrG;
      nextArrG = tmp;
      gCount = nextGCount;
    }
  }
  return result2.count > 0;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/element/element.js
var element_exports = {};
__export(element_exports, {
  Bundle: () => Bundle,
  Location: () => Location,
  Loci: () => Loci,
  Schema: () => Schema2,
  Stats: () => Stats,
  atomicProperty: () => atomicProperty,
  chainIndex: () => chainIndex,
  coarseProperty: () => coarseProperty,
  entityIndex: () => entityIndex,
  property: () => property,
  residueIndex: () => residueIndex
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/element/location.js
var Location;
(function(Location2) {
  function create(structure, unit2, element) {
    return {
      kind: "element-location",
      structure,
      unit: unit2,
      element: element || 0
    };
  }
  Location2.create = create;
  function clone(l) {
    return create(l.structure, l.unit, l.element);
  }
  Location2.clone = clone;
  function set2(a, structure, unit2, element) {
    if (structure)
      a.structure = structure;
    if (unit2)
      a.unit = unit2;
    if (element !== void 0)
      a.element = element;
    return a;
  }
  Location2.set = set2;
  function copy(out, a) {
    out.unit = a.unit;
    out.element = a.element;
    return out;
  }
  Location2.copy = copy;
  function is(x) {
    return !!x && x.kind === "element-location";
  }
  Location2.is = is;
  function areEqual(a, b) {
    return a.unit === b.unit && a.element === b.element;
  }
  Location2.areEqual = areEqual;
  const pA = Vec3(), pB = Vec3();
  function distance(a, b) {
    a.unit.conformation.position(a.element, pA);
    b.unit.conformation.position(b.element, pB);
    return Vec3.distance(pA, pB);
  }
  Location2.distance = distance;
  function position(out, l) {
    return l.unit.conformation.position(l.element, out);
  }
  Location2.position = position;
  function residueIndex2(l) {
    return l.unit.model.atomicHierarchy.residueAtomSegments.index[l.element];
  }
  Location2.residueIndex = residueIndex2;
  function chainIndex2(l) {
    return l.unit.model.atomicHierarchy.chainAtomSegments.index[l.element];
  }
  Location2.chainIndex = chainIndex2;
})(Location || (Location = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-data/generic/hash-set.js
var HashSetImpl = class {
  add(a) {
    const hash = this.getHash(a);
    if (this.byHash.has(hash)) {
      const xs = this.byHash.get(hash);
      for (let i = 0, _i = xs.length; i < _i; i++) {
        if (this.areEqual(a, xs[i]))
          return false;
      }
      xs[xs.length] = a;
      this.size++;
      return true;
    } else {
      this.byHash.set(hash, [a]);
      this.size++;
      return true;
    }
  }
  has(v) {
    const hash = this.getHash(v);
    if (!this.byHash.has(hash))
      return false;
    const xs = this.byHash.get(hash);
    for (let i = 0, _i = xs.length; i < _i; i++) {
      if (this.areEqual(v, xs[i]))
        return true;
    }
    return false;
  }
  constructor(getHash, areEqual) {
    this.getHash = getHash;
    this.areEqual = areEqual;
    this.size = 0;
    this.byHash = /* @__PURE__ */ new Map();
  }
};
function HashSet(getHash, areEqual) {
  return new HashSetImpl(getHash, areEqual);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-data/generic/linked-list.js
function LinkedList() {
  return new LinkedListImpl();
}
function createListNode(value) {
  return { previous: null, next: null, inList: true, value };
}
var LinkedListImpl = class {
  constructor() {
    this.count = 0;
    this.first = null;
    this.last = null;
  }
  addFirst(value) {
    const node = createListNode(value);
    node.inList = true;
    if (this.first)
      this.first.previous = node;
    node.next = this.first;
    this.first = node;
    this.count++;
    if (!this.last)
      this.last = node;
    return node;
  }
  addLast(value) {
    const node = createListNode(value);
    if (this.last !== null) {
      this.last.next = node;
    }
    node.previous = this.last;
    this.last = node;
    if (this.first === null) {
      this.first = node;
    }
    node.inList = true;
    this.count++;
    return node;
  }
  removeFirst() {
    const fst = this.first;
    if (fst) {
      this.remove(fst);
      return fst.value;
    }
    return void 0;
  }
  removeLast() {
    const last = this.last;
    if (last) {
      this.remove(last);
      return last.value;
    }
    return void 0;
  }
  remove(node) {
    if (!node.inList)
      return;
    node.inList = false;
    if (node.previous !== null) {
      node.previous.next = node.next;
    } else if (
      /* first == item*/
      node.previous === null
    ) {
      this.first = node.next;
    }
    if (node.next !== null) {
      node.next.previous = node.previous;
    } else if (
      /* last == item*/
      node.next === null
    ) {
      this.last = node.previous;
    }
    node.next = null;
    node.previous = null;
    this.count--;
  }
  find(value) {
    let current = this.first;
    while (current !== null) {
      if (current.value === value)
        return current;
      current = current.next;
    }
    return void 0;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-data/generic/unique-array.js
var UniqueArray;
(function(UniqueArray2) {
  function create() {
    return { keys: /* @__PURE__ */ new Set(), array: [] };
  }
  UniqueArray2.create = create;
  function add({ keys, array: array2 }, key, value) {
    if (keys.has(key))
      return false;
    keys.add(key);
    array2[array2.length] = value;
    return true;
  }
  UniqueArray2.add = add;
  function has({ keys }, key) {
    return keys.has(key);
  }
  UniqueArray2.has = has;
})(UniqueArray || (UniqueArray = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/language/type.js
var Type;
(function(Type2) {
  function Variable(name, type3, isConstraint) {
    return { kind: "variable", name, type: type3, isConstraint };
  }
  Type2.Variable = Variable;
  function Value(namespace, name, parent) {
    return { kind: "value", namespace, name, parent };
  }
  Type2.Value = Value;
  function Container(namespace, name, child, alias) {
    return { kind: "container", namespace, name, child, alias };
  }
  Type2.Container = Container;
  function Union(types) {
    return { kind: "union", types };
  }
  Type2.Union = Union;
  function OneOf(namespace, name, type3, values) {
    const vals = /* @__PURE__ */ Object.create(null);
    for (const v of values)
      vals[v] = true;
    return { kind: "oneof", namespace, name, type: type3, values: vals };
  }
  Type2.OneOf = OneOf;
  Type2.Any = { kind: "any" };
  Type2.AnyValue = { kind: "any-value" };
  Type2.Num = Value("", "Number");
  Type2.Str = Value("", "String");
  Type2.Bool = OneOf("", "Bool", Type2.Str, ["true", "false"]);
  function oneOfValues({ values }) {
    return Object.keys(values).sort();
  }
  Type2.oneOfValues = oneOfValues;
})(Type || (Type = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/language/expression.js
var Expression;
(function(Expression2) {
  function Symbol(name) {
    return { name };
  }
  Expression2.Symbol = Symbol;
  function Apply(head, args) {
    return args ? { head, args } : { head };
  }
  Expression2.Apply = Apply;
  function isArgumentsArray(e) {
    return !!e && Array.isArray(e);
  }
  Expression2.isArgumentsArray = isArgumentsArray;
  function isArgumentsMap(e) {
    return !!e && !Array.isArray(e);
  }
  Expression2.isArgumentsMap = isArgumentsMap;
  function isLiteral(e) {
    return !isApply(e) && !isSymbol2(e);
  }
  Expression2.isLiteral = isLiteral;
  function isApply(e) {
    return !!e && !!e.head && typeof e === "object";
  }
  Expression2.isApply = isApply;
  function isSymbol2(e) {
    return !!e && typeof e.name === "string";
  }
  Expression2.isSymbol = isSymbol2;
})(Expression || (Expression = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/language/symbol.js
function Argument(type3, params) {
  const { description = void 0, isOptional = false, isRest = false, defaultValue = void 0 } = params || {};
  return { type: type3, isOptional, isRest, defaultValue, description };
}
var Arguments;
(function(Arguments2) {
  Arguments2.None = Dictionary({});
  function Dictionary(map2) {
    return { kind: "dictionary", map: map2, "@type": 0 };
  }
  Arguments2.Dictionary = Dictionary;
  function List3(type3, params) {
    const { nonEmpty = false } = params || {};
    return { kind: "list", type: type3, nonEmpty, "@type": 0 };
  }
  Arguments2.List = List3;
})(Arguments || (Arguments = {}));
function MSymbol(name, args, type3, description) {
  const symbol2 = function(args2) {
    return Expression.Apply(Expression.Symbol(symbol2.id), args2);
  };
  symbol2.info = { namespace: "", name, description };
  symbol2.id = "";
  symbol2.args = args;
  symbol2.type = type3;
  return symbol2;
}
function CustomPropSymbol(namespace, name, type3, description) {
  const symbol2 = function(args) {
    return Expression.Apply(Expression.Symbol(symbol2.id), args);
  };
  symbol2.info = { namespace, name, description };
  symbol2.id = `${namespace}.${name}`;
  symbol2.args = Arguments.None;
  symbol2.type = type3;
  return symbol2;
}
function isSymbol(x) {
  const s = x;
  return typeof s === "function" && !!s.info && !!s.args && typeof s.info.namespace === "string" && !!s.type;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/language/helpers.js
function symbol(args, type3, description) {
  return MSymbol("", args, type3, description);
}
function normalizeTable(table) {
  _normalizeTable("", "", table);
}
function symbolList(table) {
  const list2 = [];
  _symbolList(table, list2);
  return list2;
}
function formatKey(key) {
  const regex = /([a-z])([A-Z])([a-z]|$)/g;
  return key.replace(regex, (s, a, b, c) => `${a}-${b.toLocaleLowerCase()}${c}`).replace(regex, (s, a, b, c) => `${a}-${b.toLocaleLowerCase()}${c}`);
}
function _normalizeTable(namespace, key, obj) {
  if (isSymbol(obj)) {
    obj.info.namespace = namespace;
    obj.info.name = obj.info.name || formatKey(key);
    obj.id = `${obj.info.namespace}.${obj.info.name}`;
    return;
  }
  const currentNs = `${obj["@namespace"] || formatKey(key)}`;
  const newNs = namespace ? `${namespace}.${currentNs}` : currentNs;
  for (const childKey of Object.keys(obj)) {
    if (typeof obj[childKey] !== "object" && !isSymbol(obj[childKey]))
      continue;
    _normalizeTable(newNs, childKey, obj[childKey]);
  }
}
function _symbolList(obj, list2) {
  if (isSymbol(obj)) {
    list2.push(obj);
    return;
  }
  for (const childKey of Object.keys(obj)) {
    if (typeof obj[childKey] !== "object" && !isSymbol(obj[childKey]))
      continue;
    _symbolList(obj[childKey], list2);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/language/symbol-table/core.js
var Types;
(function(Types3) {
  Types3.AnyVar = Type.Variable("a", Type.Any);
  Types3.AnyValueVar = Type.Variable("a", Type.Any);
  Types3.ConstrainedVar = Type.Variable("a", Type.Any, true);
  Types3.Regex = Type.Value("Core", "Regex");
  Types3.Set = (t) => Type.Container("Core", "Set", t || Types3.AnyValueVar);
  Types3.List = (t) => Type.Container("Core", "List", t || Types3.AnyVar);
  Types3.Fn = (t, alias) => Type.Container("Core", "Fn", t || Types3.AnyVar, alias);
  Types3.Flags = (t, alias) => Type.Container("Core", "Flags", t, alias);
  Types3.BitFlags = Types3.Flags(Type.Num, "BitFlags");
})(Types || (Types = {}));
function unaryOp(type3, description) {
  return symbol(Arguments.Dictionary({ 0: Argument(type3) }), type3, description);
}
function binOp(type3, description) {
  return symbol(Arguments.List(type3, { nonEmpty: true }), type3, description);
}
function binRel(src, target, description) {
  return symbol(Arguments.Dictionary({
    0: Argument(src),
    1: Argument(src)
  }), target, description);
}
var TTargs = Arguments.Dictionary({
  0: Argument(Type.Num),
  1: Argument(Type.Num)
});
var type = {
  "@header": "Types",
  bool: symbol(Arguments.Dictionary({ 0: Argument(Type.AnyValue) }), Type.Bool, "Convert a value to boolean."),
  num: symbol(Arguments.Dictionary({ 0: Argument(Type.AnyValue) }), Type.Num, "Convert a value to number."),
  str: symbol(Arguments.Dictionary({ 0: Argument(Type.AnyValue) }), Type.Str, "Convert a value to string."),
  regex: symbol(Arguments.Dictionary({
    0: Argument(Type.Str, { description: "Expression" }),
    1: Argument(Type.Str, { isOptional: true, description: `Flags, e.g. 'i' for ignore case` })
  }), Types.Regex, "Creates a regular expression from a string using the ECMAscript syntax."),
  list: symbol(Arguments.List(Types.AnyVar), Types.List()),
  set: symbol(Arguments.List(Types.AnyValueVar), Types.Set()),
  bitflags: symbol(Arguments.Dictionary({ 0: Argument(Type.Num) }), Types.BitFlags, "Interpret a number as bitflags."),
  compositeKey: symbol(Arguments.List(Type.AnyValue), Type.AnyValue)
};
var logic = {
  "@header": "Logic",
  not: unaryOp(Type.Bool),
  and: binOp(Type.Bool),
  or: binOp(Type.Bool)
};
var ctrl = {
  "@header": "Control",
  eval: symbol(Arguments.Dictionary({ 0: Argument(Types.Fn(Types.AnyVar)) }), Types.AnyVar, "Evaluate a function."),
  fn: symbol(Arguments.Dictionary({ 0: Argument(Types.AnyVar) }), Types.Fn(Types.AnyVar), 'Wrap an expression to a "lazy" function.'),
  if: symbol(Arguments.Dictionary({
    0: Argument(Type.Bool, { description: "Condition" }),
    1: Argument(Type.Variable("a", Type.Any), { description: "If true" }),
    2: Argument(Type.Variable("b", Type.Any), { description: "If false" })
  }), Type.Union([Type.Variable("a", Type.Any), Type.Variable("b", Type.Any)])),
  assoc: symbol(Arguments.Dictionary({
    0: Argument(Type.Str, { description: "Name" }),
    1: Argument(Type.Variable("a", Type.Any), { description: "Value to assign" })
  }), Type.Variable("a", Type.Any))
};
var rel = {
  "@header": "Relational",
  eq: binRel(Type.Variable("a", Type.AnyValue, true), Type.Bool),
  neq: binRel(Type.Variable("a", Type.AnyValue, true), Type.Bool),
  lt: binRel(Type.Num, Type.Bool),
  lte: binRel(Type.Num, Type.Bool),
  gr: binRel(Type.Num, Type.Bool),
  gre: binRel(Type.Num, Type.Bool),
  inRange: symbol(Arguments.Dictionary({
    0: Argument(Type.Num, { description: "Value to test" }),
    1: Argument(Type.Num, { description: "Minimum value" }),
    2: Argument(Type.Num, { description: "Maximum value" })
  }), Type.Bool, "Check if the value of the 1st argument is >= 2nd and <= 3rd.")
};
var math = {
  "@header": "Math",
  add: binOp(Type.Num),
  sub: binOp(Type.Num),
  mult: binOp(Type.Num),
  div: binRel(Type.Num, Type.Num),
  pow: binRel(Type.Num, Type.Num),
  mod: binRel(Type.Num, Type.Num),
  min: binOp(Type.Num),
  max: binOp(Type.Num),
  cantorPairing: binRel(Type.Num, Type.Num),
  sortedCantorPairing: binRel(Type.Num, Type.Num),
  invertCantorPairing: symbol(Arguments.Dictionary({ 0: Argument(Type.Num) }), Types.List(Type.Num)),
  floor: unaryOp(Type.Num),
  ceil: unaryOp(Type.Num),
  roundInt: unaryOp(Type.Num),
  trunc: unaryOp(Type.Num),
  abs: unaryOp(Type.Num),
  sign: unaryOp(Type.Num),
  sqrt: unaryOp(Type.Num),
  cbrt: unaryOp(Type.Num),
  sin: unaryOp(Type.Num),
  cos: unaryOp(Type.Num),
  tan: unaryOp(Type.Num),
  asin: unaryOp(Type.Num),
  acos: unaryOp(Type.Num),
  atan: unaryOp(Type.Num),
  sinh: unaryOp(Type.Num),
  cosh: unaryOp(Type.Num),
  tanh: unaryOp(Type.Num),
  exp: unaryOp(Type.Num),
  log: unaryOp(Type.Num),
  log10: unaryOp(Type.Num),
  atan2: binRel(Type.Num, Type.Num)
};
var str = {
  "@header": "Strings",
  concat: binOp(Type.Str),
  match: symbol(Arguments.Dictionary({ 0: Argument(Types.Regex), 1: Argument(Type.Str) }), Type.Bool)
};
var list = {
  "@header": "Lists",
  getAt: symbol(Arguments.Dictionary({ 0: Argument(Types.List()), 1: Argument(Type.Num) }), Types.AnyVar),
  equal: symbol(Arguments.Dictionary({ 0: Argument(Types.List()), 1: Argument(Types.List()) }), Type.Bool)
};
var set = {
  "@header": "Sets",
  has: symbol(Arguments.Dictionary({ 0: Argument(Types.Set(Types.ConstrainedVar)), 1: Argument(Types.ConstrainedVar) }), Type.Bool, "Check if the the 1st argument includes the value of the 2nd."),
  isSubset: symbol(Arguments.Dictionary({ 0: Argument(Types.Set(Types.ConstrainedVar)), 1: Argument(Types.Set(Types.ConstrainedVar)) }), Type.Bool, "Check if the the 1st argument is a subset of the 2nd.")
};
var flags = {
  "@header": "Flags",
  hasAny: symbol(Arguments.Dictionary({
    0: Argument(Types.Flags(Types.ConstrainedVar)),
    1: Argument(Types.Flags(Types.ConstrainedVar))
  }), Type.Bool, "Check if the the 1st argument has at least one of the 2nd one's flags."),
  hasAll: symbol(Arguments.Dictionary({
    0: Argument(Types.Flags(Types.ConstrainedVar)),
    1: Argument(Types.Flags(Types.ConstrainedVar))
  }), Type.Bool, "Check if the the 1st argument has all 2nd one's flags.")
};
var core = {
  "@header": "Language Primitives",
  type,
  logic,
  ctrl,
  rel,
  math,
  str,
  list,
  set,
  flags
};
normalizeTable(core);
var SymbolList = symbolList(core);
var SymbolMap = function() {
  const map2 = /* @__PURE__ */ Object.create(null);
  for (const s of SymbolList)
    map2[s.id] = s;
  return map2;
}();

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/language/symbol-table/structure-query.js
var Types2;
(function(Types3) {
  Types3.ElementSymbol = Type.Value("Structure", "ElementSymbol");
  Types3.AtomName = Type.Value("Structure", "AtomName");
  Types3.BondFlag = Type.OneOf("Structure", "BondFlag", Type.Str, ["covalent", "metallic", "ion", "hydrogen", "sulfide", "computed", "aromatic"]);
  Types3.BondFlags = Types.Flags(Types3.BondFlag, "BondFlags");
  Types3.SecondaryStructureFlag = Type.OneOf("Structure", "SecondaryStructureFlag", Type.Str, ["alpha", "beta", "3-10", "pi", "sheet", "strand", "helix", "turn", "none"]);
  Types3.SecondaryStructureFlags = Types.Flags(Types3.SecondaryStructureFlag, "SecondaryStructureFlag");
  Types3.RingFingerprint = Type.Value("Structure", "RingFingerprint");
  Types3.EntityType = Type.OneOf("Structure", "EntityType", Type.Str, ["polymer", "non-polymer", "water", "branched"]);
  Types3.EntitySubtype = Type.OneOf("Structure", "EntitySubtype", Type.Str, ["other", "polypeptide(D)", "polypeptide(L)", "polydeoxyribonucleotide", "polyribonucleotide", "polydeoxyribonucleotide/polyribonucleotide hybrid", "cyclic-pseudo-peptide", "peptide nucleic acid", "oligosaccharide"]);
  Types3.ObjectPrimitive = Type.OneOf("Structure", "ObjectPrimitive", Type.Str, ["atomistic", "sphere", "gaussian", "other"]);
  Types3.ResidueId = Type.Value("Structure", "ResidueId");
  Types3.ElementSet = Type.Value("Structure", "ElementSet");
  Types3.ElementSelection = Type.Value("Structure", "ElementSelection");
  Types3.ElementReference = Type.Value("Structure", "ElementReference");
  Types3.ElementSelectionQuery = Types.Fn(Types3.ElementSelection, "ElementSelectionQuery");
})(Types2 || (Types2 = {}));
var type2 = {
  "@header": "Types",
  elementSymbol: symbol(Arguments.Dictionary({ 0: Argument(Type.Str) }), Types2.ElementSymbol, "Create element symbol representation from a string value."),
  atomName: symbol(Arguments.Dictionary({ 0: Argument(Type.AnyValue) }), Types2.AtomName, "Convert a value to an atom name."),
  entityType: symbol(Arguments.Dictionary({ 0: Argument(Types2.EntityType) }), Types2.EntityType, `Create normalized representation of entity type: ${Type.oneOfValues(Types2.EntityType).join(", ")}.`),
  bondFlags: symbol(Arguments.List(Types2.BondFlag), Types2.BondFlags, `Create bond flags representation from a list of strings. Allowed flags: ${Type.oneOfValues(Types2.BondFlag).join(", ")}.`),
  ringFingerprint: symbol(Arguments.List(Types2.ElementSymbol, { nonEmpty: true }), Types2.RingFingerprint, "Create ring fingerprint from the supplied atom element list."),
  secondaryStructureFlags: symbol(Arguments.List(Types2.SecondaryStructureFlag), Types2.SecondaryStructureFlags, `Create secondary structure flags representation from a list of strings. Allowed flags: ${Type.oneOfValues(Types2.SecondaryStructureFlag).join(", ")}.`),
  authResidueId: symbol(Arguments.Dictionary({
    0: Argument(Type.Str, { description: "auth_asym_id" }),
    1: Argument(Type.Num, { description: "auth_seq_id" }),
    2: Argument(Type.Str, { description: "pdbx_PDB_ins_code", isOptional: true })
  }), Types2.ResidueId, `Residue identifier based on "auth_" annotation.`),
  labelResidueId: symbol(Arguments.Dictionary({
    0: Argument(Type.Str, { description: "label_entity_id" }),
    1: Argument(Type.Str, { description: "label_asym_id" }),
    2: Argument(Type.Num, { description: "label_seq_id" }),
    3: Argument(Type.Str, { description: "pdbx_PDB_ins_code", isOptional: true })
  }), Types2.ResidueId, `Residue identifier based on mmCIF's "label_" annotation.`)
};
var slot = {
  "@header": "Iteration Slots",
  element: symbol(Arguments.None, Types2.ElementReference, "A reference to the current element."),
  elementSetReduce: symbol(Arguments.None, Type.Variable("a", Type.AnyValue, true), "Current value of the element set reducer.")
};
var generator = {
  "@header": "Generators",
  all: symbol(Arguments.None, Types2.ElementSelectionQuery, "The entire structure."),
  atomGroups: symbol(Arguments.Dictionary({
    "entity-test": Argument(Type.Bool, { isOptional: true, defaultValue: true, description: "Test for the 1st atom of every entity" }),
    "chain-test": Argument(Type.Bool, { isOptional: true, defaultValue: true, description: "Test for the 1st atom of every chain" }),
    "residue-test": Argument(Type.Bool, { isOptional: true, defaultValue: true, description: "Test for the 1st atom every residue" }),
    "atom-test": Argument(Type.Bool, { isOptional: true, defaultValue: true }),
    "group-by": Argument(Type.Any, { isOptional: true, defaultValue: `atom-key`, description: "Group atoms to sets based on this property. Default: each atom has its own set" })
  }), Types2.ElementSelectionQuery, "Return all atoms for which the tests are satisfied, grouped into sets."),
  bondedAtomicPairs: symbol(Arguments.Dictionary({
    0: Argument(Type.Bool, { isOptional: true, defaultValue: "true for covalent bonds", description: "Test each bond with this predicate. Each bond is visited twice with swapped atom order." })
    // TODO: shoud we support this or just use queryEach to get similar behavior
    // 'group-by': Argument(Type.Any, { isOptional: true, defaultValue: ``, description: 'Group the bonds using the privided value' }),
  }), Types2.ElementSelectionQuery, "Return all pairs of atoms for which the test is satisfied."),
  rings: symbol(Arguments.Dictionary({
    "fingerprint": Argument(Types2.RingFingerprint, { isOptional: true }),
    "only-aromatic": Argument(Type.Bool, { isOptional: true, defaultValue: false })
  }), Types2.ElementSelectionQuery, "Return all rings or those with the specified fingerprint and/or only aromatic rings."),
  queryInSelection: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    query: Argument(Types2.ElementSelectionQuery),
    "in-complement": Argument(Type.Bool, { isOptional: true, defaultValue: false })
  }), Types2.ElementSelectionQuery, "Executes query only on atoms that are in the source selection."),
  empty: symbol(Arguments.None, Types2.ElementSelectionQuery, "Nada.")
};
var modifier = {
  "@header": "Selection Modifications",
  queryEach: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    query: Argument(Types2.ElementSelectionQuery)
  }), Types2.ElementSelectionQuery, "Query every atom set in the input selection separately."),
  intersectBy: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    by: Argument(Types2.ElementSelectionQuery)
  }), Types2.ElementSelectionQuery, "Intersect each atom set from the first sequence from atoms in the second one."),
  exceptBy: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    by: Argument(Types2.ElementSelectionQuery)
  }), Types2.ElementSelectionQuery, `Remove all atoms from 'selection' that occur in 'by'.`),
  unionBy: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    by: Argument(Types2.ElementSelectionQuery)
  }), Types2.ElementSelectionQuery, "For each atom set A in the orginal sequence, combine all atoms sets in the target selection that intersect with A."),
  union: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery)
  }), Types2.ElementSelectionQuery, "Collects all atom sets in the sequence into a single atom set."),
  cluster: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    "min-distance": Argument(Type.Num, { isOptional: true, defaultValue: 0 }),
    "max-distance": Argument(Type.Num),
    "min-size": Argument(Type.Num, { description: "Minimal number of sets to merge, must be at least 2", isOptional: true, defaultValue: 2 }),
    "max-size": Argument(Type.Num, { description: "Maximal number of sets to merge, if not set, no limit", isOptional: true })
  }), Types2.ElementSelectionQuery, "Combines atom sets that have mutual distance in the interval [min-radius, max-radius]. Minimum/maximum size determines how many atom sets can be combined."),
  includeSurroundings: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    radius: Argument(Type.Num),
    "atom-radius": Argument(Type.Num, { isOptional: true, defaultValue: 0, description: "Value added to each atom before the distance check, for example VDW radius. Using this argument is computationally demanding." }),
    "as-whole-residues": Argument(Type.Bool, { isOptional: true })
  }), Types2.ElementSelectionQuery, "For each atom set in the selection, include all surrouding atoms/residues that are within the specified radius."),
  surroundingLigands: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    radius: Argument(Type.Num),
    "include-water": Argument(Type.Bool, { isOptional: true, defaultValue: true })
  }), Types2.ElementSelectionQuery, "Find all ligands components around the source query."),
  includeConnected: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    "bond-test": Argument(Type.Bool, { isOptional: true, defaultValue: "true for covalent bonds" }),
    "layer-count": Argument(Type.Num, { isOptional: true, defaultValue: 1, description: "Number of bonded layers to include." }),
    "fixed-point": Argument(Type.Bool, { isOptional: true, defaultValue: false, description: "Continue adding layers as long as new connections exist." }),
    "as-whole-residues": Argument(Type.Bool, { isOptional: true })
  }), Types2.ElementSelectionQuery, "Pick all atom sets that are connected to the target."),
  wholeResidues: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery)
  }), Types2.ElementSelectionQuery, "Expand the selection to whole residues."),
  expandProperty: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    property: Argument(Type.AnyValue)
  }), Types2.ElementSelectionQuery, "To each atom set in the selection, add all atoms that have the same property value that was already present in the set.")
};
var filter = {
  "@header": "Selection Filters",
  pick: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    test: Argument(Type.Bool)
  }), Types2.ElementSelectionQuery, "Pick all atom sets that satisfy the test."),
  first: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery)
  }), Types2.ElementSelectionQuery, "Take the 1st atom set in the sequence."),
  withSameAtomProperties: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    source: Argument(Types2.ElementSelectionQuery),
    property: Argument(Type.Any)
  }), Types2.ElementSelectionQuery, "Pick all atom sets for which the set of given atom properties is a subset of the source properties."),
  intersectedBy: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    by: Argument(Types2.ElementSelectionQuery)
  }), Types2.ElementSelectionQuery, "Pick all atom sets that have non-zero intersection with the target."),
  within: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    target: Argument(Types2.ElementSelectionQuery),
    "min-radius": Argument(Type.Num, { isOptional: true, defaultValue: 0 }),
    "max-radius": Argument(Type.Num),
    "atom-radius": Argument(Type.Num, { isOptional: true, defaultValue: 0, description: "Value added to each atom before the distance check, for example VDW radius. Using this argument is computationally demanding." }),
    invert: Argument(Type.Bool, { isOptional: true, defaultValue: false, description: "If true, pick only atom sets that are further than the specified radius." })
  }), Types2.ElementSelectionQuery, "Pick all atom sets from selection that have any atom within the radius of any atom from target."),
  isConnectedTo: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery),
    target: Argument(Types2.ElementSelectionQuery),
    "bond-test": Argument(Type.Bool, { isOptional: true, defaultValue: "true for covalent bonds" }),
    disjunct: Argument(Type.Bool, { isOptional: true, defaultValue: true, description: "If true, there must exist a bond to an atom that lies outside the given atom set to pass test." }),
    invert: Argument(Type.Bool, { isOptional: true, defaultValue: false, description: "If true, return atom sets that are not connected." })
  }), Types2.ElementSelectionQuery, "Pick all atom sets that are connected to the target.")
};
var combinator = {
  "@header": "Selection Combinators",
  intersect: symbol(Arguments.List(Types2.ElementSelectionQuery), Types2.ElementSelectionQuery, "Return all unique atom sets that appear in all of the source selections."),
  merge: symbol(Arguments.List(Types2.ElementSelectionQuery), Types2.ElementSelectionQuery, "Merges multiple selections into a single one. Only unique atom sets are kept."),
  distanceCluster: symbol(Arguments.Dictionary({
    matrix: Argument(Types.List(Types.List(Type.Num)), { description: "Distance matrix, represented as list of rows (num[][])). Lower triangle is min distance, upper triangle is max distance." }),
    selections: Argument(Types.List(Types2.ElementSelectionQuery), { description: "A list of held selections." })
  }), Types2.ElementSelectionQuery, "Pick combinations of atom sets from the source sequences that are mutually within distances specified by a matrix.")
};
var atomSet = {
  "@header": "Atom Sets",
  atomCount: symbol(Arguments.None, Type.Num),
  countQuery: symbol(Arguments.Dictionary({
    0: Argument(Types2.ElementSelectionQuery)
  }), Type.Num, "Counts the number of occurences of a specific query inside the current atom set."),
  reduce: symbol(Arguments.Dictionary({
    initial: Argument(Type.Variable("a", Type.AnyValue, true), { description: "Initial value assigned to slot.atom-set-reduce. Current atom is set to the 1st atom of the current set for this." }),
    value: Argument(Type.Variable("a", Type.AnyValue, true), { description: "Expression executed for each atom in the set" })
  }), Type.Variable("a", Type.AnyValue, true), "Execute the value expression for each atom in the current atom set and return the result. Works the same way as Array.reduce in JavaScript (``result = value(value(...value(initial)))``)"),
  propertySet: symbol(Arguments.Dictionary({
    0: Argument(Types.ConstrainedVar)
  }), Types.Set(Types.ConstrainedVar), "Returns a set with all values of the given property in the current atom set.")
};
var atomProperty = {
  "@header": "Atom Properties",
  core: {
    "@header": "Core Properties",
    elementSymbol: atomProp(Types2.ElementSymbol),
    vdw: atomProp(Type.Num, "Van der Waals radius"),
    mass: atomProp(Type.Num, "Atomic weight"),
    atomicNumber: atomProp(Type.Num, "Atomic number"),
    x: atomProp(Type.Num, "Cartesian X coordinate"),
    y: atomProp(Type.Num, "Cartesian Y coordinate"),
    z: atomProp(Type.Num, "Cartesian Z coordinate"),
    atomKey: atomProp(Type.AnyValue, "Unique value for each atom. Main use case is grouping of atoms."),
    bondCount: symbol(Arguments.Dictionary({
      0: Argument(Types2.ElementReference, { isOptional: true, defaultValue: "slot.current-atom" }),
      flags: Argument(Types2.BondFlags, { isOptional: true, defaultValue: "covalent" })
    }), Type.Num, "Number of bonds (by default only covalent bonds are counted)."),
    sourceIndex: atomProp(Type.Num, "Index of the atom/element in the input file."),
    operatorName: atomProp(Type.Str, "Name of the symmetry operator applied to this element."),
    operatorKey: atomProp(Type.Num, "Key of the symmetry operator applied to this element."),
    modelIndex: atomProp(Type.Num, "Index of the model in the input file."),
    modelLabel: atomProp(Type.Str, "Label/header of the model in the input file.")
  },
  topology: {
    connectedComponentKey: atomProp(Type.AnyValue, "Unique value for each connected component.")
  },
  macromolecular: {
    "@header": "Macromolecular Properties (derived from the mmCIF format)",
    authResidueId: atomProp(Types2.ResidueId, `type.auth-residue-id symbol executed on current atom's residue`),
    labelResidueId: atomProp(Types2.ResidueId, `type.label-residue-id symbol executed on current atom's residue`),
    residueKey: atomProp(Type.AnyValue, "Unique value for each tuple ``(label_entity_id,auth_asym_id, auth_seq_id, pdbx_PDB_ins_code)``, main use case is grouping of atoms"),
    chainKey: atomProp(Type.AnyValue, "Unique value for each tuple ``(label_entity_id, auth_asym_id)``, main use case is grouping of atoms"),
    entityKey: atomProp(Type.AnyValue, "Unique value for each tuple ``label_entity_id``, main use case is grouping of atoms"),
    isHet: atomProp(Type.Bool, "Equivalent to atom_site.group_PDB !== ATOM"),
    id: atomProp(Type.Num, "_atom_site.id"),
    label_atom_id: atomProp(Types2.AtomName),
    label_alt_id: atomProp(Type.Str),
    label_comp_id: atomProp(Type.Str),
    label_asym_id: atomProp(Type.Str),
    label_entity_id: atomProp(Type.Str),
    label_seq_id: atomProp(Type.Num),
    auth_atom_id: atomProp(Types2.AtomName),
    auth_comp_id: atomProp(Type.Str),
    auth_asym_id: atomProp(Type.Str),
    auth_seq_id: atomProp(Type.Num),
    pdbx_PDB_ins_code: atomProp(Type.Str),
    pdbx_formal_charge: atomProp(Type.Num),
    occupancy: atomProp(Type.Num),
    B_iso_or_equiv: atomProp(Type.Num),
    entityType: atomProp(Types2.EntityType, "Type of the entity as defined in mmCIF (polymer, non-polymer, branched, water)"),
    entitySubtype: atomProp(Types2.EntitySubtype, "Subtype of the entity as defined in mmCIF _entity_poly.type and _pdbx_entity_branch.type (other, polypeptide(D), polypeptide(L), polydeoxyribonucleotide, polyribonucleotide, polydeoxyribonucleotide/polyribonucleotide hybrid, cyclic-pseudo-peptide, peptide nucleic acid, oligosaccharide)"),
    entityPrdId: atomProp(Type.Str, `The PRD ID of the entity.`),
    entityDescription: atomProp(Types.List(Type.Str)),
    objectPrimitive: atomProp(Types2.ObjectPrimitive, "Type of the primitive object used to model this segment as defined in mmCIF/IHM (atomistic, sphere, gaussian, other)"),
    secondaryStructureKey: atomProp(Type.AnyValue, "Unique value for each secondary structure element."),
    secondaryStructureFlags: atomProp(Types2.SecondaryStructureFlags),
    isModified: atomProp(Type.Bool, "True if the atom belongs to modification of a standard residue."),
    modifiedParentName: atomProp(Type.Str, `'3-letter' code of the modifed parent residue.`),
    isNonStandard: atomProp(Type.Bool, "True if this is a non-standard residue."),
    chemCompType: atomProp(Type.Str, `Type of the chemical component as defined in mmCIF.`)
  },
  ihm: {
    hasSeqId: symbol(Arguments.Dictionary({ 0: Argument(Type.Num) }), Type.Bool, "Checks if the current element represents a given sequence id"),
    overlapsSeqIdRange: symbol(Arguments.Dictionary({ beg: Argument(Type.Num), end: Argument(Type.Num) }), Type.Bool, "Checks if the current element overlaps with the specified residue range")
  }
};
var bondProperty = {
  "@header": "Bond Properties",
  flags: bondProp(Types2.BondFlags),
  order: bondProp(Type.Num),
  key: bondProp(Type.Num),
  length: bondProp(Type.Num),
  atomA: bondProp(Types2.ElementReference),
  atomB: bondProp(Types2.ElementReference)
};
function atomProp(type3, description) {
  return symbol(Arguments.Dictionary({ 0: Argument(Types2.ElementReference, { isOptional: true, defaultValue: "slot.current-atom" }) }), type3, description);
}
function bondProp(type3, description) {
  return symbol(Arguments.None, type3, description);
}
var structureQuery = {
  "@header": "Structure Queries",
  type: type2,
  slot,
  generator,
  modifier,
  filter,
  combinator,
  atomSet,
  atomProperty,
  bondProperty
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/language/symbol-table/internal.js
var generator2 = {
  "@header": "Generators",
  bundleElement: symbol(Arguments.Dictionary({
    // TODO: should we use more universal unit keys? (i.e. based on chain and "operator name")
    groupedUnits: Argument(Type.Any),
    // SortedArray<number>[],
    set: Argument(Type.Any),
    // SortedArray<UnitIndex>
    ranges: Argument(Type.Any)
    // SortedArray<UnitIndex>
  }), Type.Any),
  // returns BundleElement
  bundle: symbol(Arguments.Dictionary({
    elements: Argument(Type.Any)
    // BundleElement[]
  }), Types2.ElementSelectionQuery, "A selection with single structure containing represented by the bundle."),
  // Use with caution as this is not "state saveable"
  // This query should never be used in any State Transform!
  current: symbol(Arguments.None, Types2.ElementSelectionQuery, "Current selection provided by the query context. Avoid using this in State Transforms.")
};
var internal = {
  "@header": "Internal Queries",
  generator: generator2
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/language/symbol-table.js
var MolScriptSymbolTable = { core, structureQuery, internal };
normalizeTable(MolScriptSymbolTable);
var SymbolList2 = symbolList(MolScriptSymbolTable);
var SymbolMap2 = function() {
  const map2 = /* @__PURE__ */ Object.create(null);
  for (const s of SymbolList2)
    map2[s.id] = s;
  return map2;
}();

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/language/builder.js
var MolScriptBuilder;
(function(MolScriptBuilder2) {
  MolScriptBuilder2.core = MolScriptSymbolTable.core;
  MolScriptBuilder2.struct = MolScriptSymbolTable.structureQuery;
  MolScriptBuilder2.internal = MolScriptSymbolTable.internal;
  function atomName(s) {
    return MolScriptBuilder2.struct.type.atomName([s]);
  }
  MolScriptBuilder2.atomName = atomName;
  function es(s) {
    return MolScriptBuilder2.struct.type.elementSymbol([s]);
  }
  MolScriptBuilder2.es = es;
  function list2(...xs) {
    return MolScriptBuilder2.core.type.list(xs);
  }
  MolScriptBuilder2.list = list2;
  function set2(...xs) {
    return MolScriptBuilder2.core.type.set(xs);
  }
  MolScriptBuilder2.set = set2;
  function re(pattern, flags2) {
    return MolScriptBuilder2.core.type.regex([pattern, flags2]);
  }
  MolScriptBuilder2.re = re;
  function fn(x) {
    return MolScriptBuilder2.core.ctrl.fn([x]);
  }
  MolScriptBuilder2.fn = fn;
  function evaluate(x) {
    return MolScriptBuilder2.core.ctrl.eval([x]);
  }
  MolScriptBuilder2.evaluate = evaluate;
  const _acp = MolScriptBuilder2.struct.atomProperty.core, _ammp = MolScriptBuilder2.struct.atomProperty.macromolecular, _atp = MolScriptBuilder2.struct.atomProperty.topology;
  function acp(p3) {
    return _acp[p3]();
  }
  MolScriptBuilder2.acp = acp;
  ;
  function atp(p3) {
    return _atp[p3]();
  }
  MolScriptBuilder2.atp = atp;
  ;
  function ammp(p3) {
    return _ammp[p3]();
  }
  MolScriptBuilder2.ammp = ammp;
  ;
  const _aps = MolScriptBuilder2.struct.atomSet.propertySet;
  function acpSet(p3) {
    return _aps([acp(p3)]);
  }
  MolScriptBuilder2.acpSet = acpSet;
  ;
  function atpSet(p3) {
    return _aps([atp(p3)]);
  }
  MolScriptBuilder2.atpSet = atpSet;
  ;
  function ammpSet(p3) {
    return _aps([ammp(p3)]);
  }
  MolScriptBuilder2.ammpSet = ammpSet;
  ;
})(MolScriptBuilder || (MolScriptBuilder = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/centroid-helper.js
var v3add = Vec3.add;
var v3squaredDistance = Vec3.squaredDistance;
var v3distance = Vec3.distance;
var CentroidHelper = class {
  reset() {
    Vec3.set(this.center, 0, 0, 0);
    this.radiusSq = 0;
    this.count = 0;
  }
  includeStep(p3) {
    v3add(this.center, this.center, p3);
    this.count++;
  }
  finishedIncludeStep() {
    if (this.count === 0)
      return;
    Vec3.scale(this.center, this.center, 1 / this.count);
  }
  radiusStep(p3) {
    const d = v3squaredDistance(p3, this.center);
    if (d > this.radiusSq)
      this.radiusSq = d;
  }
  radiusSphereStep(center, radius) {
    const _d = v3distance(center, this.center) + radius;
    const d = _d * _d;
    if (d > this.radiusSq)
      this.radiusSq = d;
  }
  getSphere(sphere) {
    if (!sphere)
      sphere = Sphere3D();
    Vec3.copy(sphere.center, this.center);
    sphere.radius = Math.sqrt(this.radiusSq);
    return sphere;
  }
  getCount() {
    return this.count;
  }
  constructor() {
    this.count = 0;
    this.center = Vec3();
    this.radiusSq = 0;
  }
};
(function(CentroidHelper2) {
  const helper = new CentroidHelper2();
  const posA2 = Vec3();
  const posB2 = Vec3();
  function fromArrays({ x, y, z }, to) {
    helper.reset();
    const n = x.length;
    for (let i = 0; i < n; i++) {
      Vec3.set(posA2, x[i], y[i], z[i]);
      helper.includeStep(posA2);
    }
    helper.finishedIncludeStep();
    for (let i = 0; i < n; i++) {
      Vec3.set(posA2, x[i], y[i], z[i]);
      helper.radiusStep(posA2);
    }
    Vec3.copy(to.center, helper.center);
    to.radius = Math.sqrt(helper.radiusSq);
    return to;
  }
  CentroidHelper2.fromArrays = fromArrays;
  function fromProvider(count, getter, to) {
    helper.reset();
    for (let i = 0; i < count; i++) {
      getter(i, posA2);
      helper.includeStep(posA2);
    }
    helper.finishedIncludeStep();
    for (let i = 0; i < count; i++) {
      getter(i, posA2);
      helper.radiusStep(posA2);
    }
    Vec3.copy(to.center, helper.center);
    to.radius = Math.sqrt(helper.radiusSq);
    return to;
  }
  CentroidHelper2.fromProvider = fromProvider;
  function fromPairProvider(count, getter, to) {
    helper.reset();
    for (let i = 0; i < count; i++) {
      getter(i, posA2, posB2);
      helper.includeStep(posA2);
      helper.includeStep(posB2);
    }
    helper.finishedIncludeStep();
    for (let i = 0; i < count; i++) {
      getter(i, posA2, posB2);
      helper.radiusStep(posA2);
      helper.radiusStep(posB2);
    }
    Vec3.copy(to.center, helper.center);
    to.radius = Math.sqrt(helper.radiusSq);
    return to;
  }
  CentroidHelper2.fromPairProvider = fromPairProvider;
})(CentroidHelper || (CentroidHelper = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/graph/inter-unit-graph.js
var InterUnitGraph = class _InterUnitGraph {
  /** Get an array of unit-pair-edges that are connected to the given unit */
  getConnectedUnits(unit2) {
    if (!this.map.has(unit2))
      return emptyArray;
    return this.map.get(unit2);
  }
  /** Index into this.edges */
  getEdgeIndex(indexA, unitA, indexB, unitB) {
    const indices = this.edgeKeyIndex.get(_InterUnitGraph.getEdgeUnitKey(unitA, unitB));
    if (indices === void 0)
      return -1;
    const index = indices.get(_InterUnitGraph.getEdgeIndexKey(indexA, indexB));
    return index !== void 0 ? index : -1;
  }
  /** Check if edge exists */
  hasEdge(indexA, unitA, indexB, unitB) {
    return this.getEdgeIndex(indexA, unitA, indexB, unitB) !== -1;
  }
  /** Get inter-unit edge given a pair of indices and units */
  getEdge(indexA, unitA, indexB, unitB) {
    const index = this.getEdgeIndex(indexA, unitA, indexB, unitB);
    return index !== -1 ? this.edges[index] : void 0;
  }
  /** Indices into this.edges */
  getEdgeIndices(index, unit2) {
    return this.vertexKeyIndex.get(_InterUnitGraph.getVertexKey(index, unit2)) || [];
  }
  constructor(map2) {
    this.map = map2;
    let count = 0;
    const edges = [];
    const edgeKeyIndex = /* @__PURE__ */ new Map();
    const vertexKeyIndex = /* @__PURE__ */ new Map();
    this.map.forEach((pairEdgesArray) => {
      pairEdgesArray.forEach((pairEdges) => {
        count += pairEdges.edgeCount;
        pairEdges.connectedIndices.forEach((indexA) => {
          pairEdges.getEdges(indexA).forEach((edgeInfo) => {
            const { unitA, unitB } = pairEdges;
            const edgeUnitKey = _InterUnitGraph.getEdgeIndexKey(unitA, unitB);
            const edgeIndexKey = _InterUnitGraph.getEdgeIndexKey(indexA, edgeInfo.indexB);
            const e = edgeKeyIndex.get(edgeUnitKey);
            if (e === void 0)
              edgeKeyIndex.set(edgeUnitKey, /* @__PURE__ */ new Map([[edgeIndexKey, edges.length]]));
            else
              e.set(edgeIndexKey, edges.length);
            const vertexKey = _InterUnitGraph.getVertexKey(indexA, unitA);
            const v = vertexKeyIndex.get(vertexKey);
            if (v === void 0)
              vertexKeyIndex.set(vertexKey, [edges.length]);
            else
              v.push(edges.length);
            edges.push({ ...edgeInfo, indexA, unitA, unitB });
          });
        });
      });
    });
    this.edgeCount = count;
    this.edges = edges;
    this.edgeKeyIndex = edgeKeyIndex;
    this.vertexKeyIndex = vertexKeyIndex;
  }
};
(function(InterUnitGraph2) {
  class UnitPairEdges {
    hasEdges(indexA) {
      return this.edgeMap.has(indexA);
    }
    getEdges(indexA) {
      if (!this.edgeMap.has(indexA))
        return emptyArray;
      return this.edgeMap.get(indexA);
    }
    get areUnitsOrdered() {
      return this.unitA < this.unitB;
    }
    constructor(unitA, unitB, edgeCount, connectedIndices, edgeMap) {
      this.unitA = unitA;
      this.unitB = unitB;
      this.edgeCount = edgeCount;
      this.connectedIndices = connectedIndices;
      this.edgeMap = edgeMap;
    }
  }
  InterUnitGraph2.UnitPairEdges = UnitPairEdges;
  function getEdgeUnitKey(unitA, unitB) {
    return cantorPairing(unitA, unitB);
  }
  InterUnitGraph2.getEdgeUnitKey = getEdgeUnitKey;
  function getEdgeIndexKey(indexA, indexB) {
    return cantorPairing(indexA, indexB);
  }
  InterUnitGraph2.getEdgeIndexKey = getEdgeIndexKey;
  function getVertexKey(index, unit2) {
    return cantorPairing(index, unit2);
  }
  InterUnitGraph2.getVertexKey = getVertexKey;
  function addMapEntry(map2, a, b) {
    if (map2.has(a))
      map2.get(a).push(b);
    else
      map2.set(a, [b]);
  }
  class Builder {
    constructor() {
      this.map = /* @__PURE__ */ new Map();
    }
    startUnitPair(unitA, unitB) {
      this.uA = unitA;
      this.uB = unitB;
      this.mapAB = /* @__PURE__ */ new Map();
      this.mapBA = /* @__PURE__ */ new Map();
      this.linkedA = UniqueArray.create();
      this.linkedB = UniqueArray.create();
      this.linkCount = 0;
    }
    finishUnitPair() {
      if (this.linkCount === 0)
        return;
      addMapEntry(this.map, this.uA, new UnitPairEdges(this.uA, this.uB, this.linkCount, this.linkedA.array, this.mapAB));
      addMapEntry(this.map, this.uB, new UnitPairEdges(this.uB, this.uA, this.linkCount, this.linkedB.array, this.mapBA));
    }
    add(indexA, indexB, props) {
      addMapEntry(this.mapAB, indexA, { indexB, props });
      addMapEntry(this.mapBA, indexB, { indexB: indexA, props });
      UniqueArray.add(this.linkedA, indexA, indexA);
      UniqueArray.add(this.linkedB, indexB, indexB);
      this.linkCount += 1;
    }
    getMap() {
      return this.map;
    }
  }
  InterUnitGraph2.Builder = Builder;
})(InterUnitGraph || (InterUnitGraph = {}));
var emptyArray = [];

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/unit/bonds/data.js
var IntraUnitBonds;
(function(IntraUnitBonds2) {
  IntraUnitBonds2.Empty = IntAdjacencyGraph.create([], [], [], 0, { flags: [], order: [], key: [] });
})(IntraUnitBonds || (IntraUnitBonds = {}));
var InterUnitBonds = class extends InterUnitGraph {
  /** Get inter-unit bond given a bond-location */
  getBondFromLocation(l) {
    return Unit.isAtomic(l.aUnit) && Unit.isAtomic(l.bUnit) ? this.getEdge(l.aIndex, l.aUnit.id, l.bIndex, l.bUnit.id) : void 0;
  }
  /** Get inter-unit bond index given a bond-location */
  getBondIndexFromLocation(l) {
    return Unit.isAtomic(l.aUnit) && Unit.isAtomic(l.bUnit) ? this.getEdgeIndex(l.aIndex, l.aUnit.id, l.bIndex, l.bUnit.id) : -1;
  }
};
(function(InterUnitBonds2) {
  class UnitPairBonds extends InterUnitGraph.UnitPairEdges {
  }
  InterUnitBonds2.UnitPairBonds = UnitPairBonds;
})(InterUnitBonds || (InterUnitBonds = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/unit/bonds/common.js
var DefaultBondMaxRadius = 4;
var DefaultBondComputationProps = {
  forceCompute: false,
  noCompute: false,
  maxRadius: DefaultBondMaxRadius
};
var __ElementIndex = { "H": 0, "h": 0, "D": 0, "d": 0, "T": 0, "t": 0, "He": 2, "HE": 2, "he": 2, "Li": 3, "LI": 3, "li": 3, "Be": 4, "BE": 4, "be": 4, "B": 5, "b": 5, "C": 6, "c": 6, "N": 7, "n": 7, "O": 8, "o": 8, "F": 9, "f": 9, "Ne": 10, "NE": 10, "ne": 10, "Na": 11, "NA": 11, "na": 11, "Mg": 12, "MG": 12, "mg": 12, "Al": 13, "AL": 13, "al": 13, "Si": 14, "SI": 14, "si": 14, "P": 15, "p": 15, "S": 16, "s": 16, "Cl": 17, "CL": 17, "cl": 17, "Ar": 18, "AR": 18, "ar": 18, "K": 19, "k": 19, "Ca": 20, "CA": 20, "ca": 20, "Sc": 21, "SC": 21, "sc": 21, "Ti": 22, "TI": 22, "ti": 22, "V": 23, "v": 23, "Cr": 24, "CR": 24, "cr": 24, "Mn": 25, "MN": 25, "mn": 25, "Fe": 26, "FE": 26, "fe": 26, "Co": 27, "CO": 27, "co": 27, "Ni": 28, "NI": 28, "ni": 28, "Cu": 29, "CU": 29, "cu": 29, "Zn": 30, "ZN": 30, "zn": 30, "Ga": 31, "GA": 31, "ga": 31, "Ge": 32, "GE": 32, "ge": 32, "As": 33, "AS": 33, "as": 33, "Se": 34, "SE": 34, "se": 34, "Br": 35, "BR": 35, "br": 35, "Kr": 36, "KR": 36, "kr": 36, "Rb": 37, "RB": 37, "rb": 37, "Sr": 38, "SR": 38, "sr": 38, "Y": 39, "y": 39, "Zr": 40, "ZR": 40, "zr": 40, "Nb": 41, "NB": 41, "nb": 41, "Mo": 42, "MO": 42, "mo": 42, "Tc": 43, "TC": 43, "tc": 43, "Ru": 44, "RU": 44, "ru": 44, "Rh": 45, "RH": 45, "rh": 45, "Pd": 46, "PD": 46, "pd": 46, "Ag": 47, "AG": 47, "ag": 47, "Cd": 48, "CD": 48, "cd": 48, "In": 49, "IN": 49, "in": 49, "Sn": 50, "SN": 50, "sn": 50, "Sb": 51, "SB": 51, "sb": 51, "Te": 52, "TE": 52, "te": 52, "I": 53, "i": 53, "Xe": 54, "XE": 54, "xe": 54, "Cs": 55, "CS": 55, "cs": 55, "Ba": 56, "BA": 56, "ba": 56, "La": 57, "LA": 57, "la": 57, "Ce": 58, "CE": 58, "ce": 58, "Pr": 59, "PR": 59, "pr": 59, "Nd": 60, "ND": 60, "nd": 60, "Pm": 61, "PM": 61, "pm": 61, "Sm": 62, "SM": 62, "sm": 62, "Eu": 63, "EU": 63, "eu": 63, "Gd": 64, "GD": 64, "gd": 64, "Tb": 65, "TB": 65, "tb": 65, "Dy": 66, "DY": 66, "dy": 66, "Ho": 67, "HO": 67, "ho": 67, "Er": 68, "ER": 68, "er": 68, "Tm": 69, "TM": 69, "tm": 69, "Yb": 70, "YB": 70, "yb": 70, "Lu": 71, "LU": 71, "lu": 71, "Hf": 72, "HF": 72, "hf": 72, "Ta": 73, "TA": 73, "ta": 73, "W": 74, "w": 74, "Re": 75, "RE": 75, "re": 75, "Os": 76, "OS": 76, "os": 76, "Ir": 77, "IR": 77, "ir": 77, "Pt": 78, "PT": 78, "pt": 78, "Au": 79, "AU": 79, "au": 79, "Hg": 80, "HG": 80, "hg": 80, "Tl": 81, "TL": 81, "tl": 81, "Pb": 82, "PB": 82, "pb": 82, "Bi": 83, "BI": 83, "bi": 83, "Po": 84, "PO": 84, "po": 84, "At": 85, "AT": 85, "at": 85, "Rn": 86, "RN": 86, "rn": 86, "Fr": 87, "FR": 87, "fr": 87, "Ra": 88, "RA": 88, "ra": 88, "Ac": 89, "AC": 89, "ac": 89, "Th": 90, "TH": 90, "th": 90, "Pa": 91, "PA": 91, "pa": 91, "U": 92, "u": 92, "Np": 93, "NP": 93, "np": 93, "Pu": 94, "PU": 94, "pu": 94, "Am": 95, "AM": 95, "am": 95, "Cm": 96, "CM": 96, "cm": 96, "Bk": 97, "BK": 97, "bk": 97, "Cf": 98, "CF": 98, "cf": 98, "Es": 99, "ES": 99, "es": 99, "Fm": 100, "FM": 100, "fm": 100, "Md": 101, "MD": 101, "md": 101, "No": 102, "NO": 102, "no": 102, "Lr": 103, "LR": 103, "lr": 103, "Rf": 104, "RF": 104, "rf": 104, "Db": 105, "DB": 105, "db": 105, "Sg": 106, "SG": 106, "sg": 106, "Bh": 107, "BH": 107, "bh": 107, "Hs": 108, "HS": 108, "hs": 108, "Mt": 109, "MT": 109, "mt": 109 };
var __ElementBondThresholds = { 0: 1.42, 1: 1.42, 3: 2.7, 4: 2.7, 6: 1.75, 7: 1.6, 8: 1.52, 11: 2.7, 12: 2.7, 13: 2.7, 14: 1.9, 15: 2, 16: 1.9, 17: 1.8, 19: 2.7, 20: 2.7, 21: 2.7, 22: 2.7, 23: 2.7, 24: 2.7, 25: 2.7, 26: 2.7, 27: 2.7, 28: 2.7, 29: 2.7, 30: 2.7, 31: 2.7, 33: 2.68, 37: 2.7, 38: 2.7, 39: 2.7, 40: 2.7, 41: 2.7, 42: 2.7, 43: 2.7, 44: 2.7, 45: 2.7, 46: 2.7, 47: 2.7, 48: 2.7, 49: 2.7, 50: 2.7, 55: 2.7, 56: 2.7, 57: 2.7, 58: 2.7, 59: 2.7, 60: 2.7, 61: 2.7, 62: 2.7, 63: 2.7, 64: 2.7, 65: 2.7, 66: 2.7, 67: 2.7, 68: 2.7, 69: 2.7, 70: 2.7, 71: 2.7, 72: 2.7, 73: 2.7, 74: 2.7, 75: 2.7, 76: 2.7, 77: 2.7, 78: 2.7, 79: 2.7, 80: 2.7, 81: 2.7, 82: 2.7, 83: 2.7, 87: 2.7, 88: 2.7, 89: 2.7, 90: 2.7, 91: 2.7, 92: 2.7, 93: 2.7, 94: 2.7, 95: 2.7, 96: 2.7, 97: 2.7, 98: 2.7, 99: 2.7, 100: 2.7, 101: 2.7, 102: 2.7, 103: 2.7, 104: 2.7, 105: 2.7, 106: 2.7, 107: 2.7, 108: 2.7, 109: 2.88 };
var __ElementPairThresholds = { 0: 0.8, 20: 1.31, 27: 1.2, 35: 1.15, 44: 1.1, 54: 1, 60: 1.84, 72: 1.88, 84: 1.75, 85: 1.56, 86: 1.76, 98: 1.6, 99: 1.68, 100: 1.63, 112: 1.6, 113: 1.59, 114: 1.36, 129: 1.45, 135: 1.47, 144: 1.6, 152: 1.45, 170: 1.4, 180: 1.55, 202: 2.4, 222: 2.24, 224: 1.91, 225: 1.98, 243: 2.02, 269: 2, 293: 1.9, 316: 1.8, 420: 2.37, 480: 2.3, 512: 2.3, 544: 2.3, 612: 2.1, 629: 1.54, 665: 1, 813: 2.6, 854: 2.27, 894: 1.93, 896: 2.1, 937: 2.05, 938: 2.06, 981: 1.62, 1258: 2.68, 1309: 2.33, 1484: 1, 1763: 2.14, 1823: 2.48, 1882: 2.1, 1944: 1.72, 2380: 2.34, 3367: 2.44, 3733: 2.11, 3819: 2.6, 3821: 2.36, 4736: 2.75, 5724: 2.73, 5959: 2.63, 6519: 2.84, 6750: 2.87, 8991: 2.81 };
var __DefaultBondingRadius = 2.001;
var MetalsSet = function() {
  const metals = ["LI", "NA", "K", "RB", "CS", "FR", "BE", "MG", "CA", "SR", "BA", "RA", "AL", "GA", "IN", "SN", "TL", "PB", "BI", "SC", "TI", "V", "CR", "MN", "FE", "CO", "NI", "CU", "ZN", "Y", "ZR", "NB", "MO", "TC", "RU", "RH", "PD", "AG", "CD", "LA", "HF", "TA", "W", "RE", "OS", "IR", "PT", "AU", "HG", "AC", "RF", "DB", "SG", "BH", "HS", "MT", "CE", "PR", "ND", "PM", "SM", "EU", "GD", "TB", "DY", "HO", "ER", "TM", "YB", "LU", "TH", "PA", "U", "NP", "PU", "AM", "CM", "BK", "CF", "ES", "FM", "MD", "NO", "LR"];
  const set2 = /* @__PURE__ */ new Set();
  for (const m of metals) {
    set2.add(__ElementIndex[m]);
  }
  return set2;
}();
function pair(a, b) {
  if (a < b)
    return (a + b) * (a + b + 1) / 2 + b;
  else
    return (a + b) * (a + b + 1) / 2 + a;
}
function getElementIdx(e) {
  const i = __ElementIndex[e];
  if (i === void 0)
    return -1;
  return i;
}
function getElementPairThreshold(i, j) {
  if (i < 0 || j < 0)
    return -1;
  const r = __ElementPairThresholds[pair(i, j)];
  if (r === void 0)
    return -1;
  return r;
}
function getElementThreshold(i) {
  if (i < 0)
    return __DefaultBondingRadius;
  const r = __ElementBondThresholds[i];
  if (r === void 0)
    return __DefaultBondingRadius;
  return r;
}
function getPairingThreshold(elementIndexA, elementIndexB, thresholdA, thresholdB) {
  const thresholdAB = getElementPairThreshold(elementIndexA, elementIndexB);
  return thresholdAB > 0 ? thresholdAB : elementIndexB < 0 ? thresholdA : (thresholdA + thresholdB) / 1.95;
}
var H_ID = __ElementIndex["H"];
function isHydrogen(i) {
  return i === H_ID;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/atomic/bonds.js
var IntraBondOrderTable = /* @__PURE__ */ new Map([
  ["HIS|CD2|CG", 2],
  ["HIS|CE1|ND1", 2],
  ["ARG|CZ|NH2", 2],
  ["PHE|CE1|CZ", 2],
  ["PHE|CD2|CE2", 2],
  ["PHE|CD1|CG", 2],
  ["TRP|CD1|CG", 2],
  ["TRP|CD2|CE2", 2],
  ["TRP|CE3|CZ3", 2],
  ["TRP|CH2|CZ2", 2],
  ["ASN|CG|OD1", 2],
  ["GLN|CD|OE1", 2],
  ["TYR|CD1|CG", 2],
  ["TYR|CD2|CE2", 2],
  ["TYR|CE1|CZ", 2],
  ["ASP|CG|OD1", 2],
  ["GLU|CD|OE1", 2],
  ["G|C8|N7", 2],
  ["G|C4|C5", 2],
  ["G|C2|N3", 2],
  ["G|C6|O6", 2],
  ["C|C4|N3", 2],
  ["C|C5|C6", 2],
  ["C|C2|O2", 2],
  ["A|C2|N3", 2],
  ["A|C6|N1", 2],
  ["A|C4|C5", 2],
  ["A|C8|N7", 2],
  ["U|C5|C6", 2],
  ["U|C2|O2", 2],
  ["U|C4|O4", 2],
  ["DG|C8|N7", 2],
  ["DG|C4|C5", 2],
  ["DG|C2|N3", 2],
  ["DG|C6|O6", 2],
  ["DC|C4|N3", 2],
  ["DC|C5|C6", 2],
  ["DC|C2|O2", 2],
  ["DA|C2|N3", 2],
  ["DA|C6|N1", 2],
  ["DA|C4|C5", 2],
  ["DA|C8|N7", 2],
  ["DT|C5|C6", 2],
  ["DT|C2|O2", 2],
  ["DT|C4|O4", 2]
]);
function getIntraBondOrderFromTable(compId2, atomId1, atomId2) {
  [atomId1, atomId2] = atomId1 < atomId2 ? [atomId1, atomId2] : [atomId2, atomId1];
  if (AminoAcidNames.has(compId2) && atomId1 === "C" && atomId2 === "O")
    return 2;
  if (BaseNames.has(compId2) && atomId1 === "OP1" && atomId2 === "P")
    return 2;
  return IntraBondOrderTable.get(`${compId2}|${atomId1}|${atomId2}`) || 1;
}
var InterBondOrderTable = /* @__PURE__ */ new Map([
  ["LYS|NZ|RET|C15", 2]
  // Schiff base in Rhodopsin and Bacteriorhodopsin
]);
function getInterBondOrderFromTable(compId1, atomId1, compId2, atomId2) {
  if (compId1 > compId2) {
    [compId1, compId2] = [compId2, compId1];
    [atomId1, atomId2] = [atomId2, atomId1];
  }
  return InterBondOrderTable.get(`${compId1}|${atomId1}|${compId2}|${atomId2}`) || 1;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/schema/mmcif.js
var Schema = Column.Schema;
var str2 = Schema.str;
var int = Schema.int;
var float = Schema.float;
var coord = Schema.coord;
var Aliased = Schema.Aliased;
var Matrix2 = Schema.Matrix;
var Vector = Schema.Vector;
var lstr = Schema.lstr;
var List = Schema.List;
var mmCIF_Schema = {
  /**
   * Data items in the ATOM_SITE category record details about
   * the atom sites in a macromolecular crystal structure, such as
   * the positional coordinates, atomic displacement parameters,
   * magnetic moments and directions.
   *
   * The data items for describing anisotropic atomic
   * displacement factors are only used if the corresponding items
   * are not given in the ATOM_SITE_ANISOTROP category.
   *
   * wwPDB recommends wwPDB-assigned residue number, residue ID,
   * and chain ID, _atom_site.auth_seq_id _atom_site.auth_comp_id, and
   * _atom_site.auth_asym_id, respectively, to be used for publication
   * materials.
   */
  atom_site: {
    /**
     * An alternative identifier for _atom_site.label_asym_id that
     * may be provided by an author in order to match the identification
     * used in the publication that describes the structure.
     */
    auth_asym_id: str2,
    /**
     * An alternative identifier for _atom_site.label_atom_id that
     * may be provided by an author in order to match the identification
     * used in the publication that describes the structure.
     */
    auth_atom_id: str2,
    /**
     * An alternative identifier for _atom_site.label_comp_id that
     * may be provided by an author in order to match the identification
     * used in the publication that describes the structure.
     */
    auth_comp_id: str2,
    /**
     * An alternative identifier for _atom_site.label_seq_id that
     * may be provided by an author in order to match the identification
     * used in the publication that describes the structure.
     *
     * Note that this is not necessarily a number, that the values do
     * not have to be positive, and that the value does not have to
     * correspond to the value of _atom_site.label_seq_id. The value
     * of _atom_site.label_seq_id is required to be a sequential list
     * of positive integers.
     *
     * The author may assign values to _atom_site.auth_seq_id in any
     * desired way. For instance, the values may be used to relate
     * this structure to a numbering scheme in a homologous structure,
     * including sequence gaps or insertion codes. Alternatively, a
     * scheme may be used for a truncated polymer that maintains the
     * numbering scheme of the full length polymer. In all cases, the
     * scheme used here must match the scheme used in the publication
     * that describes the structure.
     */
    auth_seq_id: int,
    /**
     * Isotropic atomic displacement parameter, or equivalent isotropic
     * atomic displacement parameter, B~eq~, calculated from the
     * anisotropic displacement parameters.
     *
     * B~eq~ = (1/3) sum~i~[sum~j~(B^ij^ A~i~ A~j~ a*~i~ a*~j~)]
     *
     * A     = the real space cell lengths
     * a*    = the reciprocal space cell lengths
     * B^ij^ = 8 pi^2^ U^ij^
     *
     * Ref: Fischer, R. X. & Tillmanns, E. (1988). Acta Cryst. C44,
     * 775-776.
     *
     * The IUCr Commission on Nomenclature recommends against the use
     * of B for reporting atomic displacement parameters. U, being
     * directly proportional to B, is preferred.
     *
     * Note -
     *
     * The particular type of ADP stored in this item is qualified
     * by item _refine.pdbx_adp_type.
     */
    B_iso_or_equiv: float,
    /**
     * The x atom-site coordinate in angstroms specified according to
     * a set of orthogonal Cartesian axes related to the cell axes as
     * specified by the description given in
     * _atom_sites.Cartn_transform_axes.
     */
    Cartn_x: coord,
    /**
     * The y atom-site coordinate in angstroms specified according to
     * a set of orthogonal Cartesian axes related to the cell axes as
     * specified by the description given in
     * _atom_sites.Cartn_transform_axes.
     */
    Cartn_y: coord,
    /**
     * The z atom-site coordinate in angstroms specified according to
     * a set of orthogonal Cartesian axes related to the cell axes as
     * specified by the description given in
     * _atom_sites.Cartn_transform_axes.
     */
    Cartn_z: coord,
    /**
     * The group of atoms to which the atom site belongs. This data
     * item is provided for compatibility with the original Protein
     * Data Bank format, and only for that purpose.
     */
    group_PDB: Aliased(str2),
    /**
     * The value of _atom_site.id must uniquely identify a record in the
     * ATOM_SITE list.
     *
     * Note that this item need not be a number; it can be any unique
     * identifier.
     *
     * This data item was introduced to provide compatibility between
     * small-molecule and macromolecular CIFs. In a small-molecule
     * CIF, _atom_site_label is the identifier for the atom. In a
     * macromolecular CIF, the atom identifier is the aggregate of
     * _atom_site.label_alt_id, _atom_site.label_asym_id,
     * _atom_site.label_atom_id, _atom_site.label_comp_id and
     * _atom_site.label_seq_id. For the two types of files to be
     * compatible, a formal identifier for the category had to be
     * introduced that was independent of the different modes of
     * identifying the atoms. For compatibility with older CIFs,
     * _atom_site_label is aliased to _atom_site.id.
     *
     * In general, this aggregate identifier does not uniquely
     * identify an atom site as for non-polymers _atom_site.label_seq_id
     * is '.'.
     */
    id: int,
    /**
     * A place holder to indicate alternate conformation. The alternate conformation
     * can be an entire polymer chain, or several residues or
     * partial residue (several atoms within one residue). If
     * an atom is provided in more than one position, then a
     * non-blank alternate location indicator must be used for
     * each of the atomic positions.
     */
    label_alt_id: str2,
    /**
     * A component of the identifier for this atom site.
     * For further details, see the definition of the STRUCT_ASYM
     * category.
     *
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    label_asym_id: str2,
    /**
     * A component of the identifier for this atom site.
     *
     * This data item is a pointer to _chem_comp_atom.atom_id in the
     * CHEM_COMP_ATOM category.
     */
    label_atom_id: str2,
    /**
     * A component of the identifier for this atom site.
     *
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP
     * category.
     */
    label_comp_id: str2,
    /**
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    label_entity_id: str2,
    /**
     * This data item is a pointer to _entity_poly_seq.num in the
     * ENTITY_POLY_SEQ category.
     */
    label_seq_id: int,
    /**
     * The fraction of the atom type present at this site.
     * The sum of the occupancies of all the atom types at this site
     * may not exceed 1.0 unless it is a dummy site.
     */
    occupancy: float,
    /**
     * This data item is a pointer to _atom_type.symbol in the
     * ATOM_TYPE category.
     */
    type_symbol: str2,
    /**
     * PDB insertion code.
     */
    pdbx_PDB_ins_code: str2,
    /**
     * PDB model number.
     */
    pdbx_PDB_model_num: int,
    /**
     * The net integer charge assigned to this atom. This is the
     * formal charge assignment normally found in chemical diagrams.
     */
    pdbx_formal_charge: int,
    /**
     * This data item is an ordinal which identifies distinct chemical components in the atom_site category, both
     * polymeric and non-polymeric.
     */
    pdbx_label_index: int,
    /**
     * The name of additional external databases with residue level mapping.
     */
    pdbx_sifts_xref_db_name: str2,
    /**
     * The accession code related to the additional external database entry.
     */
    pdbx_sifts_xref_db_acc: str2,
    /**
     * The sequence position of the external database entry that corresponds
     * to the residue mapping defined by the SIFTS process.
     */
    pdbx_sifts_xref_db_num: str2,
    /**
     * Describes the residue type of the given UniProt match
     */
    pdbx_sifts_xref_db_res: str2,
    /**
     * The model id corresponding to the atom site.
     * This data item is a pointer to _ihm_model_list.model_id
     * in the IHM_MODEL_LIST category.
     */
    ihm_model_id: int
  },
  /**
   * Data items in the ATOM_SITE_ANISOTROP category record details
   * about anisotropic displacement parameters.
   * If the ATOM_SITE_ANISOTROP category is used for storing these
   * data, the corresponding ATOM_SITE data items are not used.
   */
  atom_site_anisotrop: {
    /**
     * This data item is a pointer to _atom_site.id in the ATOM_SITE
     * category.
     */
    id: int,
    /**
     * This data item is a pointer to _atom_type.symbol in the
     * ATOM_TYPE category.
     */
    type_symbol: str2,
    /**
     * The elements of the standard anisotropic atomic
     * displacement matrix U, which appears in the structure-factor
     * term as:
     *
     * T = exp{-2 pi^2^ sum~i~[sum~j~(U^ij^ h~i~ h~j~ a*~i~ a*~j~)]}
     *
     * h  = the Miller indices
     * a* = the reciprocal space cell lengths
     *
     * These matrix elements may appear with atomic coordinates
     * in the ATOM_SITE category, or they may appear in the separate
     * ATOM_SITE_ANISOTROP category, but they may not appear in both
     * places. Similarly, anisotropic displacements may appear as
     * either B's or U's, but not as both.
     *
     * The unique elements of the real symmetric matrix are
     * entered by row.
     */
    U: Matrix2(3, 3),
    /**
     * The standard uncertainty (estimated standard deviation)
     * of _atom_site_anisotrop.U.
     */
    U_esd: Matrix2(3, 3),
    /**
     * Pointer to _atom_site.auth_seq_id
     */
    pdbx_auth_seq_id: int,
    /**
     * Pointer to _atom_site.auth_asym_id
     */
    pdbx_auth_asym_id: str2,
    /**
     * Pointer to _atom_site.auth_atom_id
     */
    pdbx_auth_atom_id: str2,
    /**
     * Pointer to _atom_site.auth_comp_id
     */
    pdbx_auth_comp_id: str2,
    /**
     * Pointer to _atom_site.label_seq_id
     */
    pdbx_label_seq_id: int,
    /**
     * Pointer to _atom_site.label_alt_id.
     */
    pdbx_label_alt_id: str2,
    /**
     * Pointer to _atom_site.label_asym_id
     */
    pdbx_label_asym_id: str2,
    /**
     * Pointer to _atom_site.label_atom_id
     */
    pdbx_label_atom_id: str2,
    /**
     * Pointer to _atom_site.label_comp_id
     */
    pdbx_label_comp_id: str2,
    /**
     * Pointer to _atom_site.pdbx_PDB_ins_code
     */
    pdbx_PDB_ins_code: str2
  },
  /**
   * Data items in the ATOM_SITES category record details about
   * the crystallographic cell and cell transformations, which are
   * common to all atom sites.
   */
  atom_sites: {
    /**
     * This data item is a pointer to _entry.id in the ENTRY category.
     */
    entry_id: str2,
    /**
     * The elements of the 3x3 matrix used to transform Cartesian
     * coordinates in the ATOM_SITE category to fractional coordinates
     * in the same category. The axial alignments of this
     * transformation are described in _atom_sites.Cartn_transform_axes.
     * The 3x1 translation is defined in
     * _atom_sites.fract_transf_vector[].
     *
     * |x'|               |11 12 13| |x|              |1|
     * |y'|~fractional~ = |21 22 23| |y|~Cartesian~ + |2|
     * |z'|               |31 32 33| |z|              |3|
     */
    fract_transf_matrix: Matrix2(3, 3),
    /**
     * The elements of the three-element vector used to transform
     * Cartesian coordinates in the ATOM_SITE category to fractional
     * coordinates in the same category. The axial alignments of this
     * transformation are described in _atom_sites.Cartn_transform_axes.
     * The 3x3 rotation is defined in
     * _atom_sites.fract_transf_matrix[][].
     *
     * |x'|               |11 12 13| |x|              |1|
     * |y'|~fractional~ = |21 22 23| |y|~Cartesian~ + |2|
     * |z'|               |31 32 33| |z|              |3|
     */
    fract_transf_vector: Vector(3)
  },
  /**
   * Data items in the AUDIT_AUTHOR category record details about
   * the author(s) of the data block.
   */
  audit_author: {
    /**
     * The name of an author of this data block. If there are multiple
     * authors, _audit_author.name is looped with _audit_author.address.
     * The family name(s), followed by a comma and including any
     * dynastic components, precedes the first name(s) or initial(s).
     */
    name: str2,
    /**
     * This data item defines the order of the author's name in the
     * list of audit authors.
     */
    pdbx_ordinal: int,
    /**
     * The Open Researcher and Contributor ID (ORCID).
     */
    identifier_ORCID: str2
  },
  /**
   * Data items in the AUDIT_CONFORM category describe the
   * dictionary versions against which the data names appearing in
   * the current data block are conformant.
   */
  audit_conform: {
    /**
     * A file name or uniform resource locator (URL) for the
     * dictionary to which the current data block conforms.
     */
    dict_location: str2,
    /**
     * The string identifying the highest-level dictionary defining
     * data names used in this file.
     */
    dict_name: str2,
    /**
     * The version number of the dictionary to which the current
     * data block conforms.
     */
    dict_version: str2
  },
  /**
   * Data items in the CELL category record details about the
   * crystallographic cell parameters.
   */
  cell: {
    /**
     * Unit-cell angle alpha of the reported structure in degrees.
     */
    angle_alpha: float,
    /**
     * Unit-cell angle beta of the reported structure in degrees.
     */
    angle_beta: float,
    /**
     * Unit-cell angle gamma of the reported structure in degrees.
     */
    angle_gamma: float,
    /**
     * This data item is a pointer to _entry.id in the ENTRY category.
     */
    entry_id: str2,
    /**
     * Unit-cell length a corresponding to the structure reported in
     * angstroms.
     */
    length_a: float,
    /**
     * Unit-cell length b corresponding to the structure reported in
     * angstroms.
     */
    length_b: float,
    /**
     * Unit-cell length c corresponding to the structure reported in
     * angstroms.
     */
    length_c: float,
    /**
     * The number of the polymeric chains in a unit cell. In the case
     * of heteropolymers, Z is the number of occurrences of the most
     * populous chain.
     *
     * This data item is provided for compatibility with the original
     * Protein Data Bank format, and only for that purpose.
     */
    Z_PDB: int,
    /**
     * To further identify unique axis if necessary.  E.g., P 21 with
     * an unique C axis will have 'C' in this field.
     */
    pdbx_unique_axis: str2
  },
  /**
   * Data items in the CHEM_COMP category give details about each
   * of the chemical components from which the relevant chemical
   * structures can be constructed, such as name, mass or charge.
   *
   * The related categories CHEM_COMP_ATOM, CHEM_COMP_BOND,
   * CHEM_COMP_ANGLE etc. describe the detailed geometry of these
   * chemical components.
   */
  chem_comp: {
    /**
     * The formula for the chemical component. Formulae are written
     * according to the following rules:
     *
     * (1) Only recognized element symbols may be used.
     *
     * (2) Each element symbol is followed by a 'count' number. A count
     * of '1' may be omitted.
     *
     * (3) A space or parenthesis must separate each cluster of
     * (element symbol + count), but in general parentheses are
     * not used.
     *
     * (4) The order of elements depends on whether carbon is
     * present or not. If carbon is present, the order should be:
     * C, then H, then the other elements in alphabetical order
     * of their symbol. If carbon is not present, the elements
     * are listed purely in alphabetic order of their symbol. This
     * is the 'Hill' system used by Chemical Abstracts.
     */
    formula: str2,
    /**
     * Formula mass in daltons of the chemical component.
     */
    formula_weight: float,
    /**
     * The value of _chem_comp.id must uniquely identify each item in
     * the CHEM_COMP list.
     *
     * For protein polymer entities, this is the three-letter code for
     * the amino acid.
     *
     * For nucleic acid polymer entities, this is the one-letter code
     * for the base.
     */
    id: str2,
    /**
     * 'yes' indicates that this is a 'standard' monomer, 'no'
     * indicates that it is 'nonstandard'. Nonstandard monomers
     * should be described in more detail using the
     * _chem_comp.mon_nstd_parent, _chem_comp.mon_nstd_class and
     * _chem_comp.mon_nstd_details data items.
     */
    mon_nstd_flag: Aliased(lstr),
    /**
     * The full name of the component.
     */
    name: str2,
    /**
     * For standard polymer components, the type of the monomer.
     * Note that monomers that will form polymers are of three types:
     * linking monomers, monomers with some type of N-terminal (or 5')
     * cap and monomers with some type of C-terminal (or 3') cap.
     */
    type: Aliased(lstr),
    /**
     * Synonym list for the component.
     */
    pdbx_synonyms: List(";", (x) => x)
  },
  /**
   * Data items in the CHEM_COMP_BOND category record details about
   * the bonds between atoms in a chemical component. Target values
   * may be specified as bond orders, as a distance between the two
   * atoms, or both.
   */
  chem_comp_bond: {
    /**
     * The ID of the first of the two atoms that define the bond.
     *
     * This data item is a pointer to _chem_comp_atom.atom_id in the
     * CHEM_COMP_ATOM category.
     */
    atom_id_1: str2,
    /**
     * The ID of the second of the two atoms that define the bond.
     *
     * This data item is a pointer to _chem_comp_atom.atom_id in the
     * CHEM_COMP_ATOM category.
     */
    atom_id_2: str2,
    /**
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP
     * category.
     */
    comp_id: str2,
    /**
     * The value that should be taken as the target for the chemical
     * bond associated with the specified atoms, expressed as a bond
     * order.
     */
    value_order: Aliased(lstr),
    /**
     * Ordinal index for the component bond list.
     */
    pdbx_ordinal: int,
    /**
     * Stereochemical configuration across a double bond.
     */
    pdbx_stereo_config: Aliased(lstr),
    /**
     * A flag indicating an aromatic bond.
     */
    pdbx_aromatic_flag: Aliased(lstr)
  },
  /**
   * Data items in the CITATION category record details about the
   * literature cited as being relevant to the contents of the data
   * block.
   */
  citation: {
    /**
     * The name of the publisher of the citation; relevant
     * for books or book chapters.
     */
    book_publisher: str2,
    /**
     * The country/region of publication; relevant for books
     * and book chapters.
     */
    country: str2,
    /**
     * The value of _citation.id must uniquely identify a record in the
     * CITATION list.
     *
     * The _citation.id 'primary' should be used to indicate the
     * citation that the author(s) consider to be the most pertinent to
     * the contents of the data block.
     *
     * Note that this item need not be a number; it can be any unique
     * identifier.
     */
    id: str2,
    /**
     * Abbreviated name of the cited journal as given in the
     * Chemical Abstracts Service Source Index.
     */
    journal_abbrev: str2,
    /**
     * The American Society for Testing and Materials (ASTM) code
     * assigned to the journal cited (also referred to as the CODEN
     * designator of the Chemical Abstracts Service); relevant for
     * journal articles.
     */
    journal_id_ASTM: str2,
    /**
     * The Cambridge Structural Database (CSD) code assigned to the
     * journal cited; relevant for journal articles. This is also the
     * system used at the Protein Data Bank (PDB).
     */
    journal_id_CSD: str2,
    /**
     * The International Standard Serial Number (ISSN) code assigned to
     * the journal cited; relevant for journal articles.
     */
    journal_id_ISSN: str2,
    /**
     * Volume number of the journal cited; relevant for journal
     * articles.
     */
    journal_volume: str2,
    /**
     * The first page of the citation; relevant for journal
     * articles, books and book chapters.
     */
    page_first: str2,
    /**
     * The last page of the citation; relevant for journal
     * articles, books and book chapters.
     */
    page_last: str2,
    /**
     * The title of the citation; relevant for journal articles, books
     * and book chapters.
     */
    title: str2,
    /**
     * The year of the citation; relevant for journal articles, books
     * and book chapters.
     */
    year: int,
    /**
     * Document Object Identifier used by doi.org to uniquely
     * specify bibliographic entry.
     */
    pdbx_database_id_DOI: str2,
    /**
     * Ascession number used by PubMed to categorize a specific
     * bibliographic entry.
     */
    pdbx_database_id_PubMed: int
  },
  /**
   * Data items in the CITATION_AUTHOR category record details
   * about the authors associated with the citations in the
   * CITATION list.
   */
  citation_author: {
    /**
     * This data item is a pointer to _citation.id in the CITATION
     * category.
     */
    citation_id: str2,
    /**
     * Name of an author of the citation; relevant for journal
     * articles, books and book chapters.
     *
     * The family name(s), followed by a comma and including any
     * dynastic components, precedes the first name(s) or initial(s).
     */
    name: str2,
    /**
     * This data item defines the order of the author's name in the
     * list of authors of a citation.
     */
    ordinal: int
  },
  /**
   * Data items in the DATABASE_2 category record details about the
   * database identifiers of the data block.
   *
   * These data items are assigned by database managers and should
   * only appear in a data block if they originate from that source.
   *
   * The name of this category, DATABASE_2, arose because the
   * category name DATABASE was already in use in the core CIF
   * dictionary, but was used differently from the way it needed
   * to be used in the mmCIF dictionary. Since CIF data names
   * cannot be changed once they have been adopted, a new category
   * had to be created.
   */
  database_2: {
    /**
     * An abbreviation that identifies the database.
     */
    database_id: Aliased(lstr),
    /**
     * The code assigned by the database identified in
     * _database_2.database_id.
     */
    database_code: str2
  },
  /**
   * Data items in the ENTITY category record details (such as
   * chemical composition, name and source) about the molecular
   * entities that are present in the crystallographic structure.
   *
   * Items in the various ENTITY subcategories provide a full
   * chemical description of these molecular entities.
   *
   * Entities are of three types:  polymer, non-polymer and water.
   * Note that the water category includes only water;  ordered
   * solvent such as sulfate ion or acetone would be described as
   * individual non-polymer entities.
   *
   * The ENTITY category is specific to macromolecular CIF
   * applications and replaces the function of the CHEMICAL category
   * in the CIF core.
   *
   * It is important to remember that the ENTITY data are not the
   * result of the crystallographic experiment;  those results are
   * represented by the ATOM_SITE data items. ENTITY data items
   * describe the chemistry of the molecules under investigation
   * and can most usefully be thought of as the ideal groups to which
   * the structure is restrained or constrained during refinement.
   *
   * It is also important to remember that entities do not correspond
   * directly to the enumeration of the contents of the asymmetric
   * unit. Entities are described only once, even in those structures
   * that contain multiple observations of an entity. The
   * STRUCT_ASYM data items, which reference the entity list,
   * describe and label the contents of the asymmetric unit.
   */
  entity: {
    /**
     * A description of special aspects of the entity.
     */
    details: str2,
    /**
     * Formula mass in daltons of the entity.
     */
    formula_weight: float,
    /**
     * The value of _entity.id must uniquely identify a record in the
     * ENTITY list.
     *
     * Note that this item need not be a number; it can be any unique
     * identifier.
     */
    id: str2,
    /**
     * The method by which the sample for the entity was produced.
     * Entities isolated directly from natural sources (tissues, soil
     * samples etc.) are expected to have further information in the
     * ENTITY_SRC_NAT category. Entities isolated from genetically
     * manipulated sources are expected to have further information in
     * the ENTITY_SRC_GEN category.
     */
    src_method: Aliased(lstr),
    /**
     * Defines the type of the entity.
     *
     * Polymer entities are expected to have corresponding
     * ENTITY_POLY and associated entries.
     *
     * Non-polymer entities are expected to have corresponding
     * CHEM_COMP and associated entries.
     *
     * Water entities are not expected to have corresponding
     * entries in the ENTITY category.
     */
    type: Aliased(lstr),
    /**
     * A description of the entity.
     *
     * Corresponds to the compound name in the PDB format.
     */
    pdbx_description: List(",", (x) => x),
    /**
     * A place holder for the number of molecules of the entity in
     * the entry.
     */
    pdbx_number_of_molecules: int,
    /**
     * An identifier for the parent entity if this entity
     * is part of a complex entity.  For instance a chimeric
     * entity may be decomposed into several independent
     * chemical entities where each component entity was
     * obtained from a different source.
     */
    pdbx_parent_entity_id: str2,
    /**
     * Details about any entity mutation(s).
     */
    pdbx_mutation: str2,
    /**
     * Entity fragment description(s).
     */
    pdbx_fragment: str2,
    /**
     * Enzyme Commission (EC) number(s)
     */
    pdbx_ec: List(",", (x) => x)
  },
  /**
   * Data items in the ENTITY_POLY category record details about the
   * polymer, such as the type of the polymer, the number of
   * monomers and whether it has nonstandard features.
   */
  entity_poly: {
    /**
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * A flag to indicate whether the polymer contains at least
     * one monomer-to-monomer link different from that implied by
     * _entity_poly.type.
     */
    nstd_linkage: Aliased(lstr),
    /**
     * A flag to indicate whether the polymer contains at least
     * one monomer that is not considered standard.
     */
    nstd_monomer: Aliased(lstr),
    /**
     * The type of the polymer.
     */
    type: Aliased(str2),
    /**
     * The PDB strand/chain id(s) corresponding to this polymer entity.
     */
    pdbx_strand_id: List(",", (x) => x),
    /**
     * Sequence of protein or nucleic acid polymer in standard one-letter
     * codes of amino acids or nucleotides. Non-standard amino
     * acids/nucleotides are represented by their Chemical
     * Component Dictionary (CCD) codes in
     * parenthesis. Deoxynucleotides are represented by the
     * specially-assigned 2-letter CCD codes in parenthesis,
     * with 'D' prefix added to their ribonucleotide
     * counterparts. For hybrid polymer, each residue is
     * represented by the code of its individual type. A
     * cyclic polymer is represented in linear sequence from
     * the chosen start to end.
     *
     * A for Alanine or Adenosine-5'-monophosphate
     * C for Cysteine or Cytidine-5'-monophosphate
     * D for Aspartic acid
     * E for Glutamic acid
     * F for Phenylalanine
     * G for Glycine or Guanosine-5'-monophosphate
     * H for Histidine
     * I for Isoleucine or Inosinic Acid
     * L for Leucine
     * K for Lysine
     * M for Methionine
     * N for Asparagine  or Unknown ribonucleotide
     * O for Pyrrolysine
     * P for Proline
     * Q for Glutamine
     * R for Arginine
     * S for Serine
     * T for Threonine
     * U for Selenocysteine or Uridine-5'-monophosphate
     * V for Valine
     * W for Tryptophan
     * Y for Tyrosine
     * (DA) for 2'-deoxyadenosine-5'-monophosphate
     * (DC) for 2'-deoxycytidine-5'-monophosphate
     * (DG) for 2'-deoxyguanosine-5'-monophosphate
     * (DT) for Thymidine-5'-monophosphate
     * (MSE) for Selenomethionine
     * (SEP) for Phosphoserine
     * (TPO) for Phosphothreonine
     * (PTR) for Phosphotyrosine
     * (PCA) for Pyroglutamic acid
     * (UNK) for Unknown amino acid
     * (ACE) for Acetylation cap
     * (NH2) for Amidation cap
     */
    pdbx_seq_one_letter_code: str2,
    /**
     * Canonical sequence of protein or nucleic acid polymer in standard
     * one-letter codes of amino acids or nucleotides,
     * corresponding to the sequence in
     * _entity_poly.pdbx_seq_one_letter_code. Non-standard
     * amino acids/nucleotides are represented by the codes of
     * their parents if parent is specified in
     * _chem_comp.mon_nstd_parent_comp_id, or by letter 'X' if
     * parent is not specified. Deoxynucleotides are
     * represented by their canonical one-letter codes of A,
     * C, G, or T.
     *
     * For modifications with several parent amino acids,
     * all corresponding parent amino acid codes will be listed
     * (ex. chromophores).
     */
    pdbx_seq_one_letter_code_can: str2,
    /**
     * For Structural Genomics entries, the sequence's target identifier registered at the TargetTrack database.
     */
    pdbx_target_identifier: str2
  },
  /**
   * Data items in the ENTITY_POLY_SEQ category specify the sequence
   * of monomers in a polymer. Allowance is made for the possibility
   * of microheterogeneity in a sample by allowing a given sequence
   * number to be correlated with more than one monomer ID. The
   * corresponding ATOM_SITE entries should reflect this
   * heterogeneity.
   */
  entity_poly_seq: {
    /**
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * A flag to indicate whether this monomer in the polymer is
     * heterogeneous in sequence.
     */
    hetero: Aliased(lstr),
    /**
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP
     * category.
     */
    mon_id: str2,
    /**
     * The value of _entity_poly_seq.num must uniquely and sequentially
     * identify a record in the ENTITY_POLY_SEQ list.
     *
     * Note that this item must be a number and that the sequence
     * numbers must progress in increasing numerical order.
     */
    num: int
  },
  /**
   * There is only one item in the ENTRY category, _entry.id. This
   * data item gives a name to this entry and is indirectly a key to
   * the categories (such as CELL, GEOM, EXPTL) that describe
   * information pertinent to the entire data block.
   */
  entry: {
    /**
     * The value of _entry.id identifies the data block.
     *
     * Note that this item need not be a number; it can be any unique
     * identifier.
     */
    id: str2
  },
  /**
   * Data items in the EXPTL category record details about the
   * experimental work prior to the intensity measurements and
   * details about the absorption-correction technique employed.
   */
  exptl: {
    /**
     * This data item is a pointer to _entry.id in the ENTRY category.
     */
    entry_id: str2,
    /**
     * The method used in the experiment.
     */
    method: Aliased(str2)
  },
  /**
   * Data items in the SOFTWARE category record details about
   * the software used in the structure analysis, which implies
   * any software used in the generation of any data items
   * associated with the structure determination and
   * structure representation.
   *
   * These data items allow computer programs to be referenced
   * in more detail than data items in the COMPUTING category do.
   */
  software: {
    /**
     * The classification of the program according to its
     * major function.
     */
    classification: str2,
    /**
     * The date the software was released.
     */
    date: str2,
    /**
     * Description of the software.
     */
    description: str2,
    /**
     * The name of the software.
     */
    name: str2,
    /**
     * The classification of the software according to the most
     * common types.
     */
    type: Aliased(lstr),
    /**
     * The version of the software.
     */
    version: str2,
    /**
     * An ordinal index for this category
     */
    pdbx_ordinal: int
  },
  /**
   * Data items in the STRUCT category record details about the
   * description of the crystallographic structure.
   */
  struct: {
    /**
     * This data item is a pointer to _entry.id in the ENTRY category.
     */
    entry_id: str2,
    /**
     * A title for the data block. The author should attempt to convey
     * the essence of the structure archived in the CIF in the title,
     * and to distinguish this structural result from others.
     */
    title: str2,
    /**
     * Indicates if the structure was determined using experimental, computational, or integrative methods
     */
    pdbx_structure_determination_methodology: Aliased(str2),
    /**
     * An automatically generated descriptor for an NDB structure or
     * the unstructured content of the PDB COMPND record.
     */
    pdbx_descriptor: str2
  },
  /**
   * Data items in the STRUCT_ASYM category record details about the
   * structural elements in the asymmetric unit.
   */
  struct_asym: {
    /**
     * A description of special aspects of this portion of the contents
     * of the asymmetric unit.
     */
    details: str2,
    /**
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * The value of _struct_asym.id must uniquely identify a record in
     * the STRUCT_ASYM list.
     *
     * Note that this item need not be a number; it can be any unique
     * identifier.
     */
    id: str2,
    /**
     * This data item indicates whether the structural elements are modified.
     */
    pdbx_modified: str2,
    /**
     * A flag indicating that this entity was originally labeled
     * with a blank PDB chain id.
     */
    pdbx_blank_PDB_chainid_flag: Aliased(str2)
  },
  /**
   * Data items in the STRUCT_CONF category record details about
   * the backbone conformation of a segment of polymer.
   *
   * Data items in the STRUCT_CONF_TYPE category define the
   * criteria used to identify the backbone conformations.
   */
  struct_conf: {
    /**
     * A component of the identifier for the residue at which the
     * conformation segment begins.
     *
     * This data item is a pointer to _atom_site.label_asym_id in the
     * ATOM_SITE category.
     */
    beg_label_asym_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment begins.
     *
     * This data item is a pointer to _atom_site.label_comp_id in
     * the ATOM_SITE category.
     */
    beg_label_comp_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment begins.
     *
     * This data item is a pointer to _atom_site.label_seq_id in the
     * ATOM_SITE category.
     */
    beg_label_seq_id: int,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment begins.
     *
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    beg_auth_asym_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment begins.
     *
     * This data item is a pointer to _atom_site.auth_comp_id in
     * the ATOM_SITE category.
     */
    beg_auth_comp_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment begins.
     *
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    beg_auth_seq_id: int,
    /**
     * This data item is a pointer to _struct_conf_type.id in the
     * STRUCT_CONF_TYPE category.
     */
    conf_type_id: Aliased(lstr),
    /**
     * A description of special aspects of the conformation assignment.
     */
    details: str2,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment ends.
     *
     * This data item is a pointer to _atom_site.label_asym_id in the
     * ATOM_SITE category.
     */
    end_label_asym_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment ends.
     *
     * This data item is a pointer to _atom_site.label_comp_id in the
     * ATOM_SITE category.
     */
    end_label_comp_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment ends.
     *
     * This data item is a pointer to _atom_site.label_seq_id in the
     * ATOM_SITE category.
     */
    end_label_seq_id: int,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment ends.
     *
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    end_auth_asym_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment ends.
     *
     * This data item is a pointer to _atom_site.auth_comp_id in the
     * ATOM_SITE category.
     */
    end_auth_comp_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment ends.
     *
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    end_auth_seq_id: int,
    /**
     * The value of _struct_conf.id must uniquely identify a record in
     * the STRUCT_CONF list.
     *
     * Note that this item need not be a number; it can be any unique
     * identifier.
     */
    id: str2,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment starts.
     */
    pdbx_beg_PDB_ins_code: str2,
    /**
     * A component of the identifier for the residue at which the
     * conformation segment ends.
     */
    pdbx_end_PDB_ins_code: str2,
    /**
     * This item is a place holder for the helix class used in the PDB
     * HELIX record.
     */
    pdbx_PDB_helix_class: str2,
    /**
     * A placeholder for the lengths of the helix of the PDB
     * HELIX record.
     */
    pdbx_PDB_helix_length: int,
    /**
     * A placeholder for the helix identifier of the PDB
     * HELIX record.
     */
    pdbx_PDB_helix_id: str2
  },
  /**
   * Data items in the STRUCT_CONN category record details about
   * the connections between portions of the structure. These can be
   * hydrogen bonds, salt bridges, disulfide bridges and so on.
   *
   * The STRUCT_CONN_TYPE records define the criteria used to
   * identify these connections.
   */
  struct_conn: {
    /**
     * This data item is a pointer to _struct_conn_type.id in the
     * STRUCT_CONN_TYPE category.
     */
    conn_type_id: Aliased(lstr),
    /**
     * A description of special aspects of the connection.
     */
    details: str2,
    /**
     * The value of _struct_conn.id must uniquely identify a record in
     * the STRUCT_CONN list.
     *
     * Note that this item need not be a number; it can be any unique
     * identifier.
     */
    id: str2,
    /**
     * A component of the identifier for partner 1 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.label_asym_id in the
     * ATOM_SITE category.
     */
    ptnr1_label_asym_id: str2,
    /**
     * A component of the identifier for partner 1 of the structure
     * connection.
     *
     * This data item is a pointer to _chem_comp_atom.atom_id in the
     * CHEM_COMP_ATOM category.
     */
    ptnr1_label_atom_id: str2,
    /**
     * A component of the identifier for partner 1 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.label_comp_id in the
     * ATOM_SITE category.
     */
    ptnr1_label_comp_id: str2,
    /**
     * A component of the identifier for partner 1 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.label_seq_id in the
     * ATOM_SITE category.
     */
    ptnr1_label_seq_id: int,
    /**
     * A component of the identifier for partner 1 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    ptnr1_auth_asym_id: str2,
    /**
     * A component of the identifier for partner 1 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.auth_comp_id in the
     * ATOM_SITE category.
     */
    ptnr1_auth_comp_id: str2,
    /**
     * A component of the identifier for partner 1 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    ptnr1_auth_seq_id: int,
    /**
     * Describes the symmetry operation that should be applied to the
     * atom set specified by _struct_conn.ptnr1_label* to generate the
     * first partner in the structure connection.
     */
    ptnr1_symmetry: str2,
    /**
     * A component of the identifier for partner 2 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.label_asym_id in the
     * ATOM_SITE category.
     */
    ptnr2_label_asym_id: str2,
    /**
     * A component of the identifier for partner 2 of the structure
     * connection.
     *
     * This data item is a pointer to _chem_comp_atom.atom_id in the
     * CHEM_COMP_ATOM category.
     */
    ptnr2_label_atom_id: str2,
    /**
     * A component of the identifier for partner 2 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.label_comp_id in the
     * ATOM_SITE category.
     */
    ptnr2_label_comp_id: str2,
    /**
     * A component of the identifier for partner 2 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.label_seq_id in the
     * ATOM_SITE category.
     */
    ptnr2_label_seq_id: int,
    /**
     * A component of the identifier for partner 2 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    ptnr2_auth_asym_id: str2,
    /**
     * A component of the identifier for partner 2 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.auth_comp_id in the
     * ATOM_SITE category.
     */
    ptnr2_auth_comp_id: str2,
    /**
     * A component of the identifier for partner 2 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    ptnr2_auth_seq_id: int,
    /**
     * Describes the symmetry operation that should be applied to the
     * atom set specified by _struct_conn.ptnr2_label* to generate the
     * second partner in the structure connection.
     */
    ptnr2_symmetry: str2,
    /**
     * A component of the identifier for partner 1 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.pdbx_PDB_ins_code in the
     * ATOM_SITE category.
     */
    pdbx_ptnr1_PDB_ins_code: str2,
    /**
     * A component of the identifier for partner 1 of the
     * structure connection. This data item is a pointer to
     * _atom_site.label_alt_id in the ATOM_SITE category.
     */
    pdbx_ptnr1_label_alt_id: str2,
    /**
     * A placeholder for the standard residue name found in
     * the MODRES record of a PDB file.
     */
    pdbx_ptnr1_standard_comp_id: str2,
    /**
     * A component of the identifier for partner 1 of the structure
     * connection.
     *
     * This data item is a pointer to _atom_site.pdbx_PDB_ins_code in the
     * ATOM_SITE category.
     */
    pdbx_ptnr2_PDB_ins_code: str2,
    /**
     * A component of the identifier for partner 2 of the
     * structure connection. This data item is a pointer to
     * _atom_site.label_alt_id in the ATOM_SITE category.
     */
    pdbx_ptnr2_label_alt_id: str2,
    /**
     * A component of the identifier for partner 3 of the
     * structure connection. This data item is a pointer to
     * _atom_site.pdbx_PDB_ins_code in the ATOM_SITE category.
     */
    pdbx_ptnr3_PDB_ins_code: str2,
    /**
     * A component of the identifier for partner 3 of the
     * structure connection. This data item is a pointer to
     * _atom_site.label_alt_id in the ATOM_SITE category.
     */
    pdbx_ptnr3_label_alt_id: str2,
    /**
     * A component of the identifier for partner 3 of the
     * structure connection. This data item is a pointer to
     * _atom_site.label_asym_id in the ATOM_SITE category.
     */
    pdbx_ptnr3_label_asym_id: str2,
    /**
     * A component of the identifier for partner 3 of the
     * structure connection. This data item is a pointer to
     * _atom_site.label_atom_id in the ATOM_SITE category.
     */
    pdbx_ptnr3_label_atom_id: str2,
    /**
     * A component of the identifier for partner 3 of the
     * structure connection. This data item is a pointer to
     * _atom_site.label_comp_id in the ATOM_SITE category.
     */
    pdbx_ptnr3_label_comp_id: str2,
    /**
     * A component of the identifier for partner 1 of the
     * structure connection. This data item is a pointer to
     * _atom_site.label_seq_id in the ATOM_SITE category.
     */
    pdbx_ptnr3_label_seq_id: int,
    /**
     * A placeholder for the PDB id in the case the category
     * is used to hold the information of the MODRES record of
     * a PDB file.
     */
    pdbx_PDB_id: str2,
    /**
     * Distance value for this contact.
     */
    pdbx_dist_value: float,
    /**
     * The chemical bond order associated with the specified atoms in
     * this contact.
     */
    pdbx_value_order: Aliased(lstr)
  },
  /**
   * Data items in the STRUCT_CONN_TYPE category record details
   * about the criteria used to identify interactions between
   * portions of the structure.
   */
  struct_conn_type: {
    /**
     * The criteria used to define the interaction.
     */
    criteria: str2,
    /**
     * The chemical or structural type of the interaction.
     */
    id: Aliased(lstr),
    /**
     * A reference that specifies the criteria used to define the
     * interaction.
     */
    reference: str2
  },
  /**
   * Data items in the STRUCT_KEYWORDS category specify keywords
   * that describe the chemical structure in this entry.
   */
  struct_keywords: {
    /**
     * This data item is a pointer to _entry.id in the ENTRY category.
     */
    entry_id: str2,
    /**
     * Keywords describing this structure.
     */
    text: List(",", (x) => x),
    /**
     * Terms characterizing the macromolecular structure.
     */
    pdbx_keywords: str2
  },
  /**
   * Data items in the STRUCT_MON_PROT_CIS category identify
   * monomers that have been found to have the peptide bond in the cis
   * conformation. The criterion used to select residues to be
   * designated as containing cis peptide bonds is given in
   * _struct_mon_details.prot_cis.
   */
  struct_mon_prot_cis: {
    /**
     * A component of the identifier for the monomer.
     *
     * This data item is a pointer to _atom_sites_alt.id in the
     * ATOM_SITES_ALT category.
     */
    label_alt_id: str2,
    /**
     * A component of the identifier for the monomer.
     *
     * This data item is a pointer to _atom_site.label_asym_id in the
     * ATOM_SITE category.
     */
    label_asym_id: str2,
    /**
     * A component of the identifier for the monomer.
     *
     * This data item is a pointer to _atom_site.label_comp_id in the
     * ATOM_SITE category.
     */
    label_comp_id: str2,
    /**
     * A component of the identifier for the monomer.
     *
     * This data item is a pointer to _atom_site.label_seq_id in the
     * ATOM_SITE category.
     */
    label_seq_id: int,
    /**
     * A component of the identifier for the monomer.
     *
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    auth_asym_id: str2,
    /**
     * A component of the identifier for the monomer.
     *
     * This data item is a pointer to _atom_site.auth_comp_id in the
     * ATOM_SITE category.
     */
    auth_comp_id: str2,
    /**
     * A component of the identifier for the monomer.
     *
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    auth_seq_id: int,
    /**
     * Pointer to _atom_site.auth_asym_id.
     */
    pdbx_auth_asym_id_2: str2,
    /**
     * Pointer to _atom_site.auth_comp_id.
     */
    pdbx_auth_comp_id_2: str2,
    /**
     * Pointer to _atom_site.auth_seq_id
     */
    pdbx_auth_seq_id_2: int,
    /**
     * Pointer to _atom_site.label_asym_id.
     */
    pdbx_label_asym_id_2: str2,
    /**
     * Pointer to _atom_site.label_comp_id.
     */
    pdbx_label_comp_id_2: str2,
    /**
     * Pointer to _atom_site.label_seq_id
     */
    pdbx_label_seq_id_2: int,
    /**
     * Pointer to _atom_site.pdbx_PDB_ins_code
     */
    pdbx_PDB_ins_code: str2,
    /**
     * Pointer to _atom_site.pdbx_PDB_ins_code
     */
    pdbx_PDB_ins_code_2: str2,
    /**
     * Pointer to _atom_site.pdbx_PDB_model_num
     */
    pdbx_PDB_model_num: int,
    /**
     * omega torsion angle
     */
    pdbx_omega_angle: str2,
    /**
     * ordinal index
     */
    pdbx_id: str2,
    /**
     * PDB Insertion code
     */
    pdbx_auth_ins_code: str2,
    /**
     * PDB Insertion code
     */
    pdbx_auth_ins_code_2: str2
  },
  /**
   * Data items in the STRUCT_NCS_OPER category describe the
   * noncrystallographic symmetry operations.
   *
   * Each operator is specified as a matrix and a subsequent
   * translation vector. Operators need not represent proper
   * rotations.
   */
  struct_ncs_oper: {
    /**
     * A code to indicate whether this operator describes a
     * relationship between coordinates all of which are given in the
     * data block (in which case the value of code is 'given'), or
     * whether the operator is used to generate new coordinates from
     * those that are given in the data block (in which case the value
     * of code is 'generate').
     */
    code: Aliased(str2),
    /**
     * A description of special aspects of the noncrystallographic
     * symmetry operator.
     */
    details: str2,
    /**
     * The value of _struct_ncs_oper.id must uniquely identify a
     * record in the STRUCT_NCS_OPER list.
     *
     * Note that for PDB _struct_ncs_oper.id must be a number.
     */
    id: int,
    /**
     * The elements of the 3x3 matrix component of a
     * noncrystallographic symmetry operation.
     */
    matrix: Matrix2(3, 3),
    /**
     * The elements of the three-element vector component of a
     * noncrystallographic symmetry operation.
     */
    vector: Vector(3)
  },
  /**
   * Data items in the STRUCT_SHEET_RANGE category record details
   * about the residue ranges that form a beta-sheet. Residues are
   * included in a range if they made beta-sheet-type hydrogen-bonding
   * interactions with at least one adjacent strand and if there are
   * at least two residues in the range.
   */
  struct_sheet_range: {
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range begins.
     *
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    beg_label_asym_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range begins.
     *
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP
     * category.
     */
    beg_label_comp_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range begins.
     *
     * This data item is a pointer to _atom_site.label_seq_id in the
     * ATOM_SITE category.
     */
    beg_label_seq_id: int,
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range ends.
     *
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    end_label_asym_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range ends.
     *
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP
     * category.
     */
    end_label_comp_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range ends.
     *
     * This data item is a pointer to _atom_site.label_seq_id in the
     * ATOM_SITE category.
     */
    end_label_seq_id: int,
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range begins.
     *
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    beg_auth_asym_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range begins.
     *
     * This data item is a pointer to _atom_site.auth_comp_id in
     * the ATOM_SITE category.
     */
    beg_auth_comp_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range begins.
     *
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    beg_auth_seq_id: int,
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range ends.
     *
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    end_auth_asym_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range ends.
     *
     * This data item is a pointer to _atom_site.auth_comp_id in the
     * ATOM_SITE category.
     */
    end_auth_comp_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * beta-sheet range ends.
     *
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    end_auth_seq_id: int,
    /**
     * The value of _struct_sheet_range.id must uniquely identify a
     * range in a given sheet in the STRUCT_SHEET_RANGE list.
     *
     * Note that this item need not be a number; it can be any unique
     * identifier.
     */
    id: str2,
    /**
     * This data item is a pointer to _struct_sheet.id in the
     * STRUCT_SHEET category.
     */
    sheet_id: str2,
    /**
     * A component of the identifier for the residue at which the
     * beta sheet range begins.  Insertion code.
     */
    pdbx_beg_PDB_ins_code: str2,
    /**
     * A component of the identifier for the residue at which the
     * beta sheet range ends. Insertion code.
     */
    pdbx_end_PDB_ins_code: str2
  },
  /**
   * Data items in the STRUCT_SITE category record details about
   * portions of the structure that contribute to structurally
   * relevant sites (e.g. active sites, substrate-binding subsites,
   * metal-coordination sites).
   */
  struct_site: {
    /**
     * A description of special aspects of the site.
     */
    details: str2,
    /**
     * The value of _struct_site.id must uniquely identify a record in
     * the STRUCT_SITE list.
     *
     * Note that this item need not be a number; it can be any unique
     * identifier.
     */
    id: str2,
    /**
     * Number of residues in the site.
     */
    pdbx_num_residues: int,
    /**
     * Source of evidence supporting the assignment of this site.
     */
    pdbx_evidence_code: str2,
    /**
     * A component of the identifier for the ligand in the site.
     *
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    pdbx_auth_asym_id: str2,
    /**
     * A component of the identifier for the ligand in the site.
     *
     * This data item is a pointer to _atom_site.auth_comp_id in the
     * ATOM_SITE category.
     */
    pdbx_auth_comp_id: str2,
    /**
     * A component of the identifier for the ligand in the site.
     *
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    pdbx_auth_seq_id: int,
    /**
     * PDB insertion code for the ligand in the site.
     */
    pdbx_auth_ins_code: str2
  },
  /**
   * Data items in the STRUCT_SITE_GEN category record details about
   * the generation of portions of the structure that contribute to
   * structurally relevant sites.
   */
  struct_site_gen: {
    /**
     * A description of special aspects of the symmetry generation of
     * this portion of the structural site.
     */
    details: str2,
    /**
     * The value of _struct_site_gen.id must uniquely identify a record
     * in the STRUCT_SITE_GEN list.
     *
     * Note that this item need not be a number; it can be any unique
     * identifier.
     */
    id: str2,
    /**
     * A component of the identifier for participants in the site.
     *
     * This data item is a pointer to _atom_sites_alt.id in the
     * ATOM_SITES_ALT category.
     */
    label_alt_id: str2,
    /**
     * A component of the identifier for participants in the site.
     *
     * This data item is a pointer to _atom_site.label_asym_id in the
     * ATOM_SITE category.
     */
    label_asym_id: str2,
    /**
     * A component of the identifier for participants in the site.
     *
     * This data item is a pointer to _chem_comp_atom.atom_id in the
     * CHEM_COMP_ATOM category.
     */
    label_atom_id: str2,
    /**
     * A component of the identifier for participants in the site.
     *
     * This data item is a pointer to _atom_site.label_comp_id in the
     * ATOM_SITE category.
     */
    label_comp_id: str2,
    /**
     * A component of the identifier for participants in the site.
     *
     * This data item is a pointer to _atom_site.label_seq_id in the
     * ATOM_SITE category.
     */
    label_seq_id: int,
    /**
     * A component of the identifier for participants in the site.
     *
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    auth_asym_id: str2,
    /**
     * A component of the identifier for participants in the site.
     *
     * This data item is a pointer to _atom_site.auth_atom_id in the
     * ATOM_SITE category.
     */
    auth_atom_id: str2,
    /**
     * A component of the identifier for participants in the site.
     *
     * This data item is a pointer to _atom_site.auth_comp_id in the
     * ATOM_SITE category.
     */
    auth_comp_id: str2,
    /**
     * A component of the identifier for participants in the site.
     *
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    auth_seq_id: int,
    /**
     * This data item is a pointer to _struct_site.id in the STRUCT_SITE
     * category.
     */
    site_id: str2,
    /**
     * Describes the symmetry operation that should be applied to the
     * atom set specified by _struct_site_gen.label* to generate a
     * portion of the site.
     */
    symmetry: str2,
    /**
     * PDB insertion code.
     */
    pdbx_auth_ins_code: str2,
    /**
     * Number of residues in the site.
     */
    pdbx_num_res: int
  },
  /**
   * Data items in the STRUCT_SITE_KEYWORDS category record
   * keywords describing the site.
   */
  struct_site_keywords: {
    /**
     * This data item is a pointer to _struct_site.id in the STRUCT_SITE
     * category.
     */
    site_id: str2,
    /**
     * Keywords describing this site.
     */
    text: str2
  },
  /**
   * Data items in the SYMMETRY category record details about the
   * space-group symmetry.
   */
  symmetry: {
    /**
     * This data item is a pointer to _entry.id in the ENTRY category.
     */
    entry_id: str2,
    /**
     * The cell settings for this space-group symmetry.
     */
    cell_setting: Aliased(lstr),
    /**
     * Space-group number from International Tables for Crystallography
     * Vol. A (2002).
     */
    Int_Tables_number: int,
    /**
     * Space-group symbol as described by Hall (1981). This symbol
     * gives the space-group setting explicitly. Leave spaces between
     * the separate components of the symbol.
     *
     * Ref: Hall, S. R. (1981). Acta Cryst. A37, 517-525; erratum
     * (1981) A37, 921.
     */
    space_group_name_Hall: str2,
    /**
     * Hermann-Mauguin space-group symbol. Note that the
     * Hermann-Mauguin symbol does not necessarily contain complete
     * information about the symmetry and the space-group origin. If
     * used, always supply the FULL symbol from International Tables
     * for Crystallography Vol. A (2002) and indicate the origin and
     * the setting if it is not implicit. If there is any doubt that
     * the equivalent positions can be uniquely deduced from this
     * symbol, specify the  _symmetry_equiv.pos_as_xyz or
     * _symmetry.space_group_name_Hall  data items as well. Leave
     * spaces between symbols referring to
     * different axes.
     */
    "space_group_name_H-M": str2
  },
  /**
   * These are internal RCSB records to keep track of data processing
   * and status of the entry.
   */
  pdbx_database_status: {
    /**
     * Code for status of file.
     */
    status_code: Aliased(str2),
    /**
     * Code for status of structure factor file.
     */
    status_code_sf: Aliased(str2),
    /**
     * Code for status of NMR constraints file.
     */
    status_code_mr: Aliased(str2),
    /**
     * The value of _pdbx_database_status.entry_id identifies the data block.
     */
    entry_id: str2,
    /**
     * The date of initial deposition.  (The first message for
     * deposition has been received.)
     */
    recvd_initial_deposition_date: str2,
    /**
     * This code indicates whether the entry belongs to
     * Structural Genomics Project.
     */
    SG_entry: Aliased(lstr),
    /**
     * The site where the file was deposited.
     */
    deposit_site: Aliased(str2),
    /**
     * The site where the file was deposited.
     */
    process_site: Aliased(str2),
    /**
     * Code for status of chemical shift data file.
     */
    status_code_cs: Aliased(str2),
    /**
     * The methods development category in which this
     * entry has been placed.
     */
    methods_development_category: Aliased(str2),
    /**
     * A flag indicating that the entry is compatible with the PDB format.
     *
     * A value of 'N' indicates that the no PDB format data file is
     * corresponding to this entry is available in the PDB archive.
     */
    pdb_format_compatible: Aliased(lstr)
  },
  /**
   * The PDBX_NONPOLY_SCHEME category provides residue level nomenclature
   * mapping for non-polymer entities.
   */
  pdbx_nonpoly_scheme: {
    /**
     * Pointer to _atom_site.label_asym_id.
     */
    asym_id: str2,
    /**
     * Pointer to _atom_site.label_entity_id.
     */
    entity_id: str2,
    /**
     * Pointer to _atom_site.label_comp_id.
     */
    mon_id: str2,
    /**
     * PDB strand/chain id.
     */
    pdb_strand_id: str2,
    /**
     * NDB/RCSB residue number.
     */
    ndb_seq_num: str2,
    /**
     * PDB residue number.
     */
    pdb_seq_num: str2,
    /**
     * Author provided residue numbering.   This value may differ from the PDB residue
     * number and may not correspond to residue numbering within the coordinate records.
     */
    auth_seq_num: str2,
    /**
     * PDB residue identifier.
     */
    pdb_mon_id: str2,
    /**
     * Author provided residue identifier.   This value may differ from the PDB residue
     * identifier and may not correspond to residue identification within the coordinate records.
     */
    auth_mon_id: str2,
    /**
     * PDB insertion code.
     */
    pdb_ins_code: str2
  },
  /**
   * Data items in PDBX_DATABASE_RELATED contain references to entries
   * that are related to the this entry.
   */
  pdbx_database_related: {
    /**
     * The name of the database containing the related entry.
     */
    db_name: Aliased(str2),
    /**
     * A description of the related entry.
     */
    details: str2,
    /**
     * The identifying code in the related database.
     */
    db_id: str2,
    /**
     * The identifying content type of the related entry.
     */
    content_type: Aliased(str2)
  },
  /**
   * The PDBX_ENTITY_NONPOLY category provides a mapping between
   * entity and the nonpolymer component
   */
  pdbx_entity_nonpoly: {
    /**
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP category.
     */
    comp_id: str2,
    /**
     * A name for the non-polymer entity
     */
    name: str2
  },
  /**
   * PDBX_CHEM_COMP_SYNONYMS holds chemical name and synonym correspondences.
   */
  pdbx_chem_comp_synonyms: {
    /**
     * The synonym of this particular chemical component.
     */
    name: str2,
    /**
     * The chemical component for which this synonym applies.
     */
    comp_id: str2,
    /**
     * The provenance of this synonym.
     */
    provenance: Aliased(str2)
  },
  /**
   * Data items in the CHEM_COMP_IDENTIFIER category provide
   * identifiers for chemical components.
   */
  pdbx_chem_comp_identifier: {
    /**
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP
     * category.
     */
    comp_id: str2,
    /**
     * This data item contains the identifier value for this
     * component.
     */
    identifier: str2,
    /**
     * This data item contains the identifier type.
     */
    type: Aliased(str2),
    /**
     * This data item contains the name of the program
     * or library used to compute the identifier.
     */
    program: str2,
    /**
     * This data item contains the version of the program
     * or library used to compute the identifier.
     */
    program_version: str2
  },
  /**
   * Data items in the PDBX_UNOBS_OR_ZERO_OCC_RESIDUES category list the
   * residues within the entry that are not observed or have zero occupancy.
   */
  pdbx_unobs_or_zero_occ_residues: {
    /**
     * The value of _pdbx_unobs_or_zero_occ_residues.id must uniquely identify
     * each item in the PDBX_UNOBS_OR_ZERO_OCC_RESIDUES list.
     *
     * This is an integer serial number.
     */
    id: int,
    /**
     * The value of polymer flag indicates whether the unobserved or
     * zero occupancy residue is part of a polymer chain or not
     */
    polymer_flag: Aliased(lstr),
    /**
     * The value of occupancy flag indicates whether the residue
     * is unobserved (= 1) or the coordinates have an occupancy of zero (=0)
     */
    occupancy_flag: Aliased(int),
    /**
     * Part of the identifier for the unobserved or zero occupancy residue.
     *
     * This data item is a pointer to _atom_site.pdbx_PDB_model_num in the
     * ATOM_SITE category.
     */
    PDB_model_num: int,
    /**
     * Part of the identifier for the unobserved or zero occupancy residue.
     *
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    auth_asym_id: str2,
    /**
     * Part of the identifier for the unobserved or zero occupancy residue.
     *
     * This data item is a pointer to _atom_site.auth_comp_id in the
     * ATOM_SITE category.
     */
    auth_comp_id: str2,
    /**
     * Part of the identifier for the unobserved or zero occupancy residue.
     *
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    auth_seq_id: int,
    /**
     * Part of the identifier for the unobserved or zero occupancy residue.
     *
     * This data item is a pointer to _atom_site.pdbx_PDB_ins_code in the
     * ATOM_SITE category.
     */
    PDB_ins_code: str2,
    /**
     * Part of the identifier for the unobserved or zero occupancy residue.
     *
     * This data item is a pointer to _atom_site.label_asym_id in the
     * ATOM_SITE category.
     */
    label_asym_id: str2,
    /**
     * Part of the identifier for the unobserved or zero occupancy residue.
     *
     * This data item is a pointer to _atom_site.label_comp_id in the
     * ATOM_SITE category.
     */
    label_comp_id: str2,
    /**
     * Part of the identifier for the unobserved or zero occupancy residue.
     *
     * This data item is a pointer to _atom_site.label_seq_id in the
     * ATOM_SITE category.
     */
    label_seq_id: int
  },
  /**
   * Data items in the PDBX_STRUCT_MOD_RESIDUE category list the
   * modified polymer components in the entry and provide some
   * details describing the nature of the modification.
   */
  pdbx_struct_mod_residue: {
    /**
     * The value of _pdbx_struct_mod_residue.id must uniquely identify
     * each item in the PDBX_STRUCT_MOD_RESIDUE list.
     *
     * This is an integer serial number.
     */
    id: int,
    /**
     * Part of the identifier for the modified polymer component.
     *
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    auth_asym_id: str2,
    /**
     * Part of the identifier for the modified polymer component.
     *
     * This data item is a pointer to _atom_site.auth_comp_id in the
     * ATOM_SITE category.
     */
    auth_comp_id: str2,
    /**
     * Part of the identifier for the modified polymer component.
     *
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    auth_seq_id: int,
    /**
     * Part of the identifier for the modified polymer component.
     *
     * This data item is a pointer to _atom_site.pdbx_PDB_ins_code in the
     * ATOM_SITE category.
     */
    PDB_ins_code: str2,
    /**
     * Part of the identifier for the modified polymer component.
     *
     * This data item is a pointer to _atom_site.label_asym_id in the
     * ATOM_SITE category.
     */
    label_asym_id: str2,
    /**
     * Part of the identifier for the modified polymer component.
     *
     * This data item is a pointer to _atom_site.label_comp_id in the
     * ATOM_SITE category.
     */
    label_comp_id: str2,
    /**
     * Part of the identifier for the unobserved or zero occupancy residue.
     *
     * This data item is a pointer to _atom_site.label_seq_id in the
     * ATOM_SITE category.
     */
    label_seq_id: int,
    /**
     * The parent component identifier for this modified polymer component.
     */
    parent_comp_id: str2,
    /**
     * Details of the modification for this polymer component.
     */
    details: str2
  },
  /**
   * Data items in the PDBX_STRUCT_OPER_LIST category describe
   * Cartesian rotation and translation operations required to
   * generate or transform the coordinates deposited with this entry.
   */
  pdbx_struct_oper_list: {
    /**
     * This identifier code must uniquely identify a
     * record in the PDBX_STRUCT_OPER_LIST list.
     */
    id: str2,
    /**
     * A code to indicate the type of operator.
     */
    type: Aliased(str2),
    /**
     * A descriptive name for the transformation operation.
     */
    name: str2,
    /**
     * The symmetry operation corresponding to the transformation operation.
     */
    symmetry_operation: str2,
    /**
     * The elements of the 3x3 matrix component of the
     * transformation operation.
     */
    matrix: Matrix2(3, 3),
    /**
     * The elements of the three-element vector component of the
     * transformation operation.
     */
    vector: Vector(3)
  },
  /**
   * Data items in the PDBX_STRUCT_ASSEMBLY category record details about
   * the structural elements that form macromolecular assemblies.
   */
  pdbx_struct_assembly: {
    /**
     * Provides details of the method used to determine or
     * compute the assembly.
     */
    method_details: str2,
    /**
     * Provides the details of the oligomeric state of the assembly.
     */
    oligomeric_details: str2,
    /**
     * The number of polymer molecules in the assembly.
     */
    oligomeric_count: int,
    /**
     * A description of special aspects of the macromolecular assembly.
     *
     * In the PDB, 'representative helical assembly', 'complete point assembly',
     * 'complete icosahedral assembly', 'software_defined_assembly', 'author_defined_assembly',
     * and 'author_and_software_defined_assembly' are considered "biologically relevant assemblies.
     */
    details: str2,
    /**
     * The value of _pdbx_struct_assembly.id must uniquely identify a record in
     * the PDBX_STRUCT_ASSEMBLY list.
     */
    id: str2
  },
  /**
   * Data items in the PDBX_STRUCT_ASSEMBLY_GEN category record details about
   * the generation of each macromolecular assemblies. The PDBX_STRUCT_ASSEMBLY_GEN
   * data items provide the specifications of the components that
   * constitute that assembly in terms of cartesian transformations.
   */
  pdbx_struct_assembly_gen: {
    /**
     * This data item is a pointer to _struct_asym.id in
     * the STRUCT_ASYM category.
     *
     * This item may be expressed as a comma separated list of identifiers.
     */
    asym_id_list: List(",", (x) => x),
    /**
     * This data item is a pointer to _pdbx_struct_assembly.id in the
     * PDBX_STRUCT_ASSEMBLY category.
     */
    assembly_id: str2,
    /**
     * Identifies the operation of collection of operations
     * from category PDBX_STRUCT_OPER_LIST.
     *
     * Operation expressions may have the forms:
     *
     * (1)        the single operation 1
     * (1,2,5)    the operations 1, 2, 5
     * (1-4)      the operations 1,2,3 and 4
     * (1,2)(3,4) the combinations of operations
     * 3 and 4 followed by 1 and 2 (i.e.
     * the cartesian product of parenthetical
     * groups applied from right to left)
     */
    oper_expression: str2
  },
  /**
   * Data items in the PDBX_REFERENCE_ENTITY_LIST category record
   * the list of entities within each reference molecule.
   */
  pdbx_reference_entity_list: {
    /**
     * The value of _pdbx_reference_entity_list.prd_id is a reference
     * _pdbx_reference_molecule.prd_id in the PDBX_REFERENCE_MOLECULE category.
     */
    prd_id: str2,
    /**
     * The value of _pdbx_reference_entity_list.ref_entity_id is a unique identifier
     * the a constituent entity within this reference molecule.
     */
    ref_entity_id: str2,
    /**
     * Defines the polymer characteristic of the entity.
     */
    type: Aliased(lstr),
    /**
     * Additional details about this entity.
     */
    details: str2,
    /**
     * The component number of this entity within the molecule.
     */
    component_id: int
  },
  /**
   * Data items in the PDBX_REFERENCE_ENTITY_LINK category give details about
   * the linkages between entities within reference molecules.
   */
  pdbx_reference_entity_link: {
    /**
     * The value of _pdbx_reference_entity_link.link_id uniquely identifies
     * linkages between entities with a molecule.
     */
    link_id: int,
    /**
     * The value of _pdbx_reference_entity_link.prd_id is a reference
     * _pdbx_reference_entity_list.prd_id in the PDBX_REFERENCE_ENTITY_LIST category.
     */
    prd_id: str2,
    /**
     * A description of special aspects of a linkage between
     * chemical components in the structure.
     */
    details: str2,
    /**
     * The reference entity id of the first of the two entities joined by the
     * linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_list.ref_entity_id
     * in the PDBX_REFERENCE_ENTITY_LIST category.
     */
    ref_entity_id_1: str2,
    /**
     * The reference entity id of the second of the two entities joined by the
     * linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_list.ref_entity_id
     * in the PDBX_REFERENCE_ENTITY_LIST category.
     */
    ref_entity_id_2: str2,
    /**
     * For a polymer entity, the sequence number in the first of
     * the two entities containing the linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.num
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    entity_seq_num_1: int,
    /**
     * For a polymer entity, the sequence number in the second of
     * the two entities containing the linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.num
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    entity_seq_num_2: int,
    /**
     * The component identifier in the first of the two entities containing the linkage.
     *
     * For polymer entities, this data item is a pointer to _pdbx_reference_entity_poly_seq.mon_id
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     *
     * For non-polymer entities, this data item is a pointer to
     * _pdbx_reference_entity_nonpoly.chem_comp_id in the
     * PDBX_REFERENCE_ENTITY_NONPOLY category.
     */
    comp_id_1: str2,
    /**
     * The component identifier in the second of the two entities containing the linkage.
     *
     * For polymer entities, this data item is a pointer to _pdbx_reference_entity_poly_seq.mon_id
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     *
     * For non-polymer entities, this data item is a pointer to
     * _pdbx_reference_entity_nonpoly.chem_comp_id in the
     * PDBX_REFERENCE_ENTITY_NONPOLY category.
     */
    comp_id_2: str2,
    /**
     * The atom identifier/name in the first of the two entities containing the linkage.
     */
    atom_id_1: str2,
    /**
     * The atom identifier/name in the second of the two entities containing the linkage.
     */
    atom_id_2: str2,
    /**
     * The bond order target for the chemical linkage.
     */
    value_order: Aliased(lstr),
    /**
     * The entity component identifier for the first of two entities containing the linkage.
     */
    component_1: int,
    /**
     * The entity component identifier for the second of two entities containing the linkage.
     */
    component_2: int,
    /**
     * A code indicating the entity types involved in the linkage.
     */
    link_class: Aliased(str2)
  },
  /**
   * Data items in the PDBX_REFERENCE_ENTITY_POLY_LINK category give details about
   * polymer linkages including both standard and non-standard linkages between
   * polymer componnents.
   */
  pdbx_reference_entity_poly_link: {
    /**
     * The value of _pdbx_reference_entity_poly_link.link_id uniquely identifies
     * a linkage within a polymer entity.
     */
    link_id: int,
    /**
     * The value of _pdbx_reference_entity_poly_link.prd_id is a reference
     * _pdbx_reference_entity_list.prd_id in the PDBX_REFERENCE_ENTITY_POLY category.
     */
    prd_id: str2,
    /**
     * The reference entity id of the polymer entity containing the linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly.ref_entity_id
     * in the PDBX_REFERENCE_ENTITY_POLY category.
     */
    ref_entity_id: str2,
    /**
     * The entity component identifier entity containing the linkage.
     */
    component_id: int,
    /**
     * For a polymer entity, the sequence number in the first of
     * the two components making the linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.num
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    entity_seq_num_1: int,
    /**
     * For a polymer entity, the sequence number in the second of
     * the two components making the linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.num
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    entity_seq_num_2: int,
    /**
     * The component identifier in the first of the two components making the
     * linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.mon_id
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    comp_id_1: str2,
    /**
     * The component identifier in the second of the two components making the
     * linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.mon_id
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    comp_id_2: str2,
    /**
     * The atom identifier/name in the first of the two components making
     * the linkage.
     */
    atom_id_1: str2,
    /**
     * The atom identifier/name in the second of the two components making
     * the linkage.
     */
    atom_id_2: str2,
    /**
     * The bond order target for the non-standard linkage.
     */
    value_order: Aliased(lstr)
  },
  /**
   * Data items in the PDBX_MOLECULE category identify reference molecules
   * within a PDB entry.
   */
  pdbx_molecule: {
    /**
     * The value of _pdbx_molecule.prd_id is the PDB accession code for this
     * reference molecule.
     */
    prd_id: str2,
    /**
     * The value of _pdbx_molecule.instance_id is identifies a particular molecule
     * in the molecule list.
     */
    instance_id: int,
    /**
     * A reference to _struct_asym.id in the STRUCT_ASYM category.
     */
    asym_id: str2
  },
  /**
   * Data items in the PDBX_MOLECULE_FEATURES category record features of molecules
   * within a PDB entry.
   */
  pdbx_molecule_features: {
    /**
     * The value of _pdbx_molecule_features.prd_id is the accession code for this
     * reference molecule.
     */
    prd_id: str2,
    /**
     * Broadly defines the function of the molecule.
     */
    class: Aliased(lstr),
    /**
     * Defines the structural classification of the molecule.
     */
    type: Aliased(lstr),
    /**
     * A name of the molecule.
     */
    name: str2,
    /**
     * Additional details describing the molecule.
     */
    details: str2
  },
  /**
   * Data items in the ENTITY_SRC_NAT category record details of
   * the source from which the entity was obtained in cases
   * where the entity was isolated directly from a natural tissue.
   */
  entity_src_nat: {
    /**
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * Scientific name of the organism of the natural source.
     */
    pdbx_organism_scientific: str2,
    /**
     * The plasmid containing the gene.
     */
    pdbx_plasmid_name: str2,
    /**
     * This data item is an ordinal identifier for entity_src_nat data records.
     */
    pdbx_src_id: int,
    /**
     * The beginning polymer sequence position for the polymer section corresponding
     * to this source.
     *
     * A reference to the sequence position in the entity_poly category.
     */
    pdbx_beg_seq_num: int,
    /**
     * The ending polymer sequence position for the polymer section corresponding
     * to this source.
     *
     * A reference to the sequence position in the entity_poly category.
     */
    pdbx_end_seq_num: int
  },
  /**
   * Data items in the ENTITY_SRC_GEN category record details of
   * the source from which the entity was obtained in cases
   * where the source was genetically manipulated.  The
   * following are treated separately:  items pertaining to the tissue
   * from which the gene was obtained, items pertaining to the host
   * organism for gene expression and items pertaining to the actual
   * producing organism (plasmid).
   */
  entity_src_gen: {
    /**
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * Identifies the gene.
     */
    pdbx_gene_src_gene: List(",", (x) => x),
    /**
     * Scientific name of the organism.
     */
    pdbx_gene_src_scientific_name: str2,
    /**
     * The name of the plasmid that produced the entity in the host
     * organism. Where full details of the protein production are available
     * it would be expected that this item would be derived from
     * _pdbx_construct.name of the construct pointed to from
     * _entity_src_gen_express.plasmid_id.
     */
    plasmid_name: str2,
    /**
     * This data item is an ordinal identifier for entity_src_gen data records.
     */
    pdbx_src_id: int,
    /**
     * The beginning polymer sequence position for the polymer section corresponding
     * to this source.
     *
     * A reference to the sequence position in the entity_poly category.
     */
    pdbx_beg_seq_num: int,
    /**
     * The ending polymer sequence position for the polymer section corresponding
     * to this source.
     *
     * A reference to the sequence position in the entity_poly category.
     */
    pdbx_end_seq_num: int
  },
  /**
   * The data items in category PDBX_ENTITY_SRC_SYN record the source details
   * about chemically synthesized molecules.
   */
  pdbx_entity_src_syn: {
    /**
     * The scientific name of the organism from which the sequence of
     * the synthetic entity was derived.
     */
    organism_scientific: str2,
    /**
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * This data item is an ordinal identifier for pdbx_entity_src_syn data records.
     */
    pdbx_src_id: int,
    /**
     * The beginning polymer sequence position for the polymer section corresponding
     * to this source.
     *
     * A reference to the sequence position in the entity_poly category.
     */
    pdbx_beg_seq_num: int,
    /**
     * The ending polymer sequence position for the polymer section corresponding
     * to this source.
     *
     * A reference to the sequence position in the entity_poly category.
     */
    pdbx_end_seq_num: int
  },
  /**
   * Data items in the PDBX_ENTITY_BRANCH_DESCRIPTOR category provide
   * string descriptors of entity chemical structure.
   */
  pdbx_entity_branch_descriptor: {
    /**
     * This data item is a pointer to _entity_poly.entity_id in the ENTITY
     * category.
     */
    entity_id: str2,
    /**
     * This data item contains the descriptor value for this
     * entity.
     */
    descriptor: str2,
    /**
     * This data item contains the descriptor type.
     */
    type: Aliased(lstr),
    /**
     * This data item contains the name of the program
     * or library used to compute the descriptor.
     */
    program: str2,
    /**
     * This data item contains the version of the program
     * or library used to compute the descriptor.
     */
    program_version: str2,
    /**
     * Ordinal index for this category.
     */
    ordinal: int
  },
  /**
   * Data items in the pdbx_entity_instance_feature category records
   * special features of selected entity instances.
   */
  pdbx_entity_instance_feature: {
    /**
     * Special structural details about this entity instance.
     */
    details: str2,
    /**
     * A feature type associated with entity instance.
     */
    feature_type: Aliased(str2),
    /**
     * Author instance identifier (formerly PDB Chain ID)
     */
    auth_asym_id: str2,
    /**
     * Instance identifier for this entity.
     */
    asym_id: str2,
    /**
     * Author provided residue number.
     */
    auth_seq_num: str2,
    /**
     * Position in the sequence.
     */
    seq_num: int,
    /**
     * Chemical component identifier
     */
    comp_id: str2,
    /**
     * The author provided chemical component identifier
     */
    auth_comp_id: str2,
    /**
     * An ordinal index for this category
     */
    ordinal: int
  },
  /**
   * Data items in the PDBX_ENTITY_BRANCH_LIST category specify the list
   * of monomers in a branched entity.  Allowance is made for the possibility
   * of microheterogeneity in a sample by allowing a given sequence
   * number to be correlated with more than one monomer ID. The
   * corresponding ATOM_SITE entries should reflect this
   * heterogeneity.
   */
  pdbx_entity_branch_list: {
    /**
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * A flag to indicate whether this monomer in the entity is
     * heterogeneous in sequence.
     */
    hetero: Aliased(lstr),
    /**
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP
     * category.
     */
    comp_id: str2,
    /**
     * The value pair  _pdbx_entity_branch_list.num and _pdbx_entity_branch_list.comp_id
     * must uniquely identify a record in the PDBX_ENTITY_BRANCH_LIST list.
     */
    num: int
  },
  /**
   * Data items in the PDBX_ENTITY_BRANCH_LINK category give details about
   * the linkages between components within a branched entity.
   */
  pdbx_entity_branch_link: {
    /**
     * The value of _pdbx_entity_branch_link.link_id uniquely identifies
     * linkages within the branched entity.
     */
    link_id: int,
    /**
     * A description of special aspects of this linkage.
     */
    details: str2,
    /**
     * The entity id for this branched entity.
     *
     * This data item is a pointer to _pdbx_entity_branch_list.entity_id
     * in the PDBX_ENTITY_BRANCH_LIST category.
     */
    entity_id: str2,
    /**
     * The component number for the first component making the linkage.
     *
     * This data item is a pointer to _pdbx_entity_branch_list.num
     * in the PDBX_ENTITY_BRANCH_LIST category.
     */
    entity_branch_list_num_1: int,
    /**
     * The component number for the second component making the linkage.
     *
     * This data item is a pointer to _pdbx_entity_branch_list.num
     * in the PDBX_ENTITY_BRANCH_LIST category.
     */
    entity_branch_list_num_2: int,
    /**
     * The component identifier for the first component making the linkage.
     *
     * This data item is a pointer to _pdbx_entity_branch_list.comp_id
     * in the PDBX_ENTITY_BRANCH_LIST category.
     */
    comp_id_1: str2,
    /**
     * The component identifier for the second component making the linkage.
     *
     * This data item is a pointer to _pdbx_entity_branch_list.comp_id
     * in the PDBX_ENTITY_BRANCH_LIST category.
     */
    comp_id_2: str2,
    /**
     * The atom identifier/name for the first atom making the linkage.
     */
    atom_id_1: str2,
    /**
     * The leaving atom identifier/name bonded to the first atom making the linkage.
     */
    leaving_atom_id_1: str2,
    /**
     * The chiral configuration of the first atom making the linkage.
     */
    atom_stereo_config_1: Aliased(lstr),
    /**
     * The atom identifier/name for the second atom making the linkage.
     */
    atom_id_2: str2,
    /**
     * The leaving atom identifier/name bonded to the second atom making the linkage.
     */
    leaving_atom_id_2: str2,
    /**
     * The chiral configuration of the second atom making the linkage.
     */
    atom_stereo_config_2: Aliased(lstr),
    /**
     * The bond order target for the chemical linkage.
     */
    value_order: Aliased(lstr)
  },
  /**
   * Data items in the PDBX_ENTITY_BRANCH category specify the list
   * of branched entities and the type.
   */
  pdbx_entity_branch: {
    /**
     * The entity id for this branched entity.
     *
     * This data item is a pointer to _entity.id
     */
    entity_id: str2,
    /**
     * The type of this branched oligosaccharide.
     */
    type: Aliased(str2)
  },
  /**
   * The PDBX_BRANCH_SCHEME category provides residue level nomenclature
   * mapping for branch chain entities.
   */
  pdbx_branch_scheme: {
    /**
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * A flag to indicate whether this monomer in the entity is
     * heterogeneous in sequence.
     */
    hetero: Aliased(lstr),
    /**
     * Pointer to _atom_site.label_asym_id.
     */
    asym_id: str2,
    /**
     * This data item is a pointer to _atom_site.label_comp_id in the
     * PDBX_ENTITY_BRANCH_LIST category.
     */
    mon_id: str2,
    /**
     * This data item is a pointer to _pdbx_entity_branch_list.num in the
     * PDBX_ENTITY_BRANCH_LIST category.
     */
    num: int,
    /**
     * This data item is a pointer to _atom_site.auth_asym_id in the
     * ATOM_SITE category.
     */
    pdb_asym_id: str2,
    /**
     * This data item is a pointer to _atom_site.auth_seq_id in the
     * ATOM_SITE category.
     */
    pdb_seq_num: str2,
    /**
     * This data item is a pointer to _atom_site.auth_comp_id in the
     * ATOM_SITE category.
     */
    pdb_mon_id: str2,
    /**
     * This data item is a pointer to _atom_site.pdbx_auth_asym_id in the
     * ATOM_SITE category.
     */
    auth_asym_id: str2,
    /**
     * This data item is a pointer to _atom_site.pdbx_auth_seq_id in the
     * ATOM_SITE category.
     */
    auth_seq_num: str2,
    /**
     * This data item is a pointer to _atom_site.pdbx_auth_comp_id in the
     * ATOM_SITE category.
     */
    auth_mon_id: str2
  },
  /**
   * PDBX_CHEM_COMP_RELATED describes the relationship between two chemical components.
   */
  pdbx_chem_comp_related: {
    /**
     * The chemical component for which this relationship applies.
     */
    comp_id: str2,
    /**
     * The related chemical component for which this chemical component is based.
     */
    related_comp_id: str2,
    /**
     * Describes the type of relationship
     */
    relationship_type: Aliased(str2),
    /**
     * Describes the type of relationship
     */
    details: str2
  },
  /**
   * Data items in the IHM_STARTING_MODEL_DETAILS category records the
   * details about structural models used as starting inputs in
   * the integrative model building process.
   */
  ihm_starting_model_details: {
    /**
     * A unique identifier for the starting structural model.
     */
    starting_model_id: str2,
    /**
     * A unique identifier for the distinct molecular entities.
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * A text description of the molecular entity
     */
    entity_description: str2,
    /**
     * An asym/strand identifier for the entity molecule.
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    asym_id: str2,
    /**
     * The identifier for the polymeric segment modeled using this starting model.
     * This data item is a pointer to _ihm_entity_poly_segment.id in the
     * IHM_ENTITY_POLY_SEGMENT category.
     */
    entity_poly_segment_id: int,
    /**
     * The source of the starting model.
     */
    starting_model_source: Aliased(str2),
    /**
     * The author assigned chainId/auth_asym_id corresponding to this starting model.
     * This corresponds to the chainId/auth_asym_id of the experimental models in the
     * PDB or comparative models in the Model Archive or the starting models referenced
     * via a DOI. If starting models are included in IHM_STARTING_MODEL_COORD, then
     * this will be the same as _ihm_starting_model_details.asym_id.
     */
    starting_model_auth_asym_id: str2,
    /**
     * The offset in residue numbering between the starting model and the deposited I/H model, if applicable.
     * I/H model residue number = Starting model residue number + offset
     */
    starting_model_sequence_offset: int,
    /**
     * Identifier to the starting model (comparative, experimental or integrative)
     * used as input in the integrative modeling.
     * This data item is a pointer to the _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     */
    dataset_list_id: int
  },
  /**
   * Data items in the IHM_STARTING_COMPARATIVE_MODELS category records
   * additional details about comparative models used as starting inputs in
   * the integrative model building process.
   */
  ihm_starting_comparative_models: {
    /**
     * A unique identifier for the starting comparative model.
     */
    id: int,
    /**
     * The identifier for the starting structural model.
     * This data item is a pointer to _ihm_starting_model_details.starting_model_id
     * in the IHM_STARTING_MODEL_DETAILS category.
     */
    starting_model_id: str2,
    /**
     * The chainId/auth_asym_id corresponding to the starting model.
     */
    starting_model_auth_asym_id: str2,
    /**
     * The starting residue index of the starting model.
     */
    starting_model_seq_id_begin: int,
    /**
     * The ending residue index of the starting model.
     */
    starting_model_seq_id_end: int,
    /**
     * The chainId/auth_asym_id corresponding to the template.
     */
    template_auth_asym_id: str2,
    /**
     * The starting residue index of the template.
     */
    template_seq_id_begin: int,
    /**
     * The ending residue index of the template.
     */
    template_seq_id_end: int,
    /**
     * The percentage sequence identity between the template sequence and the comparative model sequence.
     */
    template_sequence_identity: float,
    /**
     * The denominator used while calculating the sequence identity provided in
     * _ihm_starting_comparative_models.template_sequence_identity.
     */
    template_sequence_identity_denominator: Aliased(int),
    /**
     * The dataset list id corresponding to the template used to obtain the comparative model.
     * This data item is a pointer to _ihm_dataset_list.id in the IHM_DATASET_LIST category.
     */
    template_dataset_list_id: int,
    /**
     * The file id corresponding to the sequence alignment of the template sequence and the comparative model sequence.
     * This data item is a pointer to _ihm_external_files.id in the IHM_EXTERNAL_FILES category.
     */
    alignment_file_id: int
  },
  /**
   * Data items in the IHM_STARTING_MODEL_SEQ_DIF category provide a
   * mechanism for indicating and annotating point differences
   * between the sequence of the entity or biological unit described
   * in the data block and the sequence of the starting model used in
   * the integrative modeling referenced from a database. The point
   * differences may be due to point mutations introduced in the
   * starting model or the presence of modified amino acid residues.
   */
  ihm_starting_model_seq_dif: {
    /**
     * A unique identifier for the entry.
     */
    id: int,
    /**
     * A unique identifier for the distinct molecular entities.
     * This data item is a pointer to _entity_poly_seq.entity_id in the ENTITY_POLY category.
     */
    entity_id: str2,
    /**
     * An asym/strand identifier for the entity molecule.
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    asym_id: str2,
    /**
     * The residue index.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id: int,
    /**
     * The component identifier for the residue.
     * This data item is a pointer to _entity_poly_seq.mon_id in the ENTITY_POLY_SEQ category.
     */
    comp_id: str2,
    /**
     * Unique identifier for the starting model record.
     * This data item is a pointer to _ihm_starting_model_details.starting_model_id in the
     * IHM_STARTING_MODEL_DETAILS category.
     */
    starting_model_id: str2,
    /**
     * The asym/strand identifier for the entity molecule of the database starting model.
     */
    db_asym_id: str2,
    /**
     * The corresponding residue index of the database starting model.
     */
    db_seq_id: int,
    /**
     * The correspinding component identifier for the residue in the database starting model.
     */
    db_comp_id: str2,
    /**
     * A description of special aspects of the point differences
     * between the sequence of the entity or biological unit described
     * in the data block and that in the starting model referenced
     * from a database.
     */
    details: str2
  },
  /**
   * Data items in the IHM_MODEL_REPRESENTATION category lists the
   * various mono or multi-scale model representations used in the
   * integrative modeling study.
   */
  ihm_model_representation: {
    /**
     * A unique identifier for the model representation.
     */
    id: int,
    /**
     * Name/brief description for the model representation.
     */
    name: str2,
    /**
     * Additional details about the model representation.
     */
    details: str2
  },
  /**
   * Data items in the IHM_MODEL_REPRESENTATION_DETAILS category records the
   * details about the architecture and representation of structural
   * models involved in the integrative modeling study.
   */
  ihm_model_representation_details: {
    /**
     * A unique identifier for the category.
     */
    id: int,
    /**
     * An identifier that collects or groups together a set of representations.
     * This data item is a pointer to _ihm_model_representation.id in the
     * IHM_MODEL_REPRESENTATION category.
     */
    representation_id: int,
    /**
     * The identifier for the polymeric segment in the representation.
     * This data item is a pointer to _ihm_entity_poly_segment.id in the
     * IHM_ENTITY_POLY_SEGMENT category.
     */
    entity_poly_segment_id: int,
    /**
     * A unique identifier distinct molecular entities.
     * This data item is a pointer to _entity.id in the
     * ENTITY category.
     */
    entity_id: str2,
    /**
     * A text description of the molecular entity
     */
    entity_description: str2,
    /**
     * An asym/strand identifier for the entity molecule.
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    entity_asym_id: str2,
    /**
     * The primitive object used to model this segment.
     */
    model_object_primitive: Aliased(str2),
    /**
     * The identifier for the starting structural model.
     * This data item is a pointer to _ihm_starting_model_details.starting_model_id
     * in the IHM_STARTING_MODEL_DETAILS category.
     */
    starting_model_id: str2,
    /**
     * The manner in which the segment is modeled.
     */
    model_mode: Aliased(str2),
    /**
     * The level of detail at which model primitive objects are applied to the structure.
     */
    model_granularity: Aliased(str2),
    /**
     * The number of primitive objects used to model a feature in the case of 'by-feature' granularity.
     */
    model_object_count: int
  },
  /**
   * Data items in the IHM_STRUCT_ASSEMBLY_DETAILS category records
   * the details of the structural assemblies and used in the
   * integrative modeling.
   */
  ihm_struct_assembly_details: {
    /**
     * A unique identifier for the structural assembly description.
     */
    id: int,
    /**
     * An identifier for the structural assembly.
     * This data item will remain the same for all components
     * of an assembly.
     * This data item is a pointer to _ihm_struct_assembly.id
     * in the IHM_STRUCT_ASSEMBLY category.
     */
    assembly_id: int,
    /**
     * The parent of this assembly in a hierarchy.
     * This data item is a pointer to _ihm_struct_assembly.id in the
     * IHM_STRUCT_ASSEMBLY category.
     * This data item should point to the assembly id of the immediate
     * parent in a hierarchy.
     * By convention, the full assembly (top of hierarchy) is assigned parent id 0 (zero).
     * In case of assemblies that do not conform to a hierarchy,
     * _ihm_struct_assembly_details.parent_assembly_id is the same as
     * _ihm_struct_assembly_details.assembly_id indicating a self-parent.
     */
    parent_assembly_id: int,
    /**
     * A text description of the molecular entity
     */
    entity_description: str2,
    /**
     * A unique identifier for distinct molecular entities.
     * This data item is a pointer to _entity.id in the
     * ENTITY category.
     */
    entity_id: str2,
    /**
     * An asym/strand identifier for the component in the assembly.
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    asym_id: str2,
    /**
     * The identifier for the polymeric segment in the assembly.
     * This data item is a pointer to _ihm_entity_poly_segment.id in the
     * IHM_ENTITY_POLY_SEGMENT category.
     */
    entity_poly_segment_id: int
  },
  /**
   * Data items in the IHM_STRUCT_ASSEMBLY category lists
   * all the structural assemblies used in the integrative
   * modeling study.
   */
  ihm_struct_assembly: {
    /**
     * A unique identifier for the structural assembly.
     */
    id: int,
    /**
     * A name for the structural assembly.
     */
    name: str2,
    /**
     * Description of the structural assembly.
     */
    description: str2
  },
  /**
   * Data items in the IHM_MODELING_PROTOCOL category lists all
   * modeling protocols used in the integrative modeling study.
   */
  ihm_modeling_protocol: {
    /**
     * A unique identifier for the modeling protocol.
     */
    id: int,
    /**
     * Number of independent steps in the modeling protocol.
     */
    num_steps: int,
    /**
     * The name for the modeling protocol.
     */
    protocol_name: str2
  },
  /**
   * Data items in the IHM_MODELING_PROTOCOL_DETAILS category records the
   * step-wise details of the integrative modeling workflow.
   */
  ihm_modeling_protocol_details: {
    /**
     * A unique identifier for the modeling protocol/step combination.
     */
    id: int,
    /**
     * An index for the modeling protocol carried out.
     * This data item is a pointer to _ihm_modeling_protocol.id in the
     * IHM_MODELING_PROTOCOL category.
     */
    protocol_id: int,
    /**
     * An index for a particular step within the modeling protocol.
     */
    step_id: int,
    /**
     * An index for the structural assembly being modeled.
     * This is an indicator to whether the whole assembly is modeled
     * or if only a subset of the structural assembly is modeled.
     * This data item is a pointer to _ihm_struct_assembly.id in the
     * IHM_STRUCT_ASSEMBLY category. The IHM_STRUCT_ASSEMBLY category provides the
     * details regarding the different structural assemblies used in the modeling.
     * The default value for this data item is "1", indicating that the entire
     * assembly is being modeled.
     */
    struct_assembly_id: int,
    /**
     * An index for the dataset group being used in the modeling protocol.
     * This data item is a pointer to the _ihm_dataset_group.id in the
     * IHM_DATASET_GROUP category.
     */
    dataset_group_id: int,
    /**
     * A textual description of the structural assembly being modeled.
     */
    struct_assembly_description: str2,
    /**
     * The name or type of the modeling step.
     */
    step_name: str2,
    /**
     * Description of the method involved in the modeling step.
     */
    step_method: str2,
    /**
     * The number of models in the beginning of the step.
     */
    num_models_begin: int,
    /**
     * The number of models at the end of the step.
     */
    num_models_end: int,
    /**
     * A flag to indicate if the modeling is multi scale.
     */
    multi_scale_flag: Aliased(lstr),
    /**
     * A flag to indicate if the modeling is multi state.
     */
    multi_state_flag: Aliased(lstr),
    /**
     * A flag to indicate if the modeling involves an ensemble ordered by time or other order.
     */
    ordered_flag: Aliased(lstr),
    /**
     * The file id corresponding to the script used in the modeling protocol step.
     * This data item is a pointer to _ihm_external_files.id in the IHM_EXTERNAL_FILES category.
     */
    script_file_id: int,
    /**
     * Identifier to the software used in the modeling protocol step.
     * This data item is a pointer to the _software.pdbx_ordinal in the
     * SOFTWARE category.
     */
    software_id: int
  },
  /**
   * Data items in the IHM_MULTI_STATE_MODELING category records the
   * details of the multi-state modeling protocol, if applicable.
   */
  ihm_multi_state_modeling: {
    /**
     * A unique identifier for a particular state in the multi-state modeling.
     */
    state_id: int,
    /**
     * An identifier for a collections of states in the multi-state modeling.
     * This data item can be used when structural models belong to diffent
     * multi-state modeling types.
     */
    state_group_id: int,
    /**
     * A fraction representing the population of the particular state.
     */
    population_fraction: float,
    /**
     * The standard deviation of the population fraction.
     */
    population_fraction_sd: float,
    /**
     * The type that the multiple states being modeled belong to.
     */
    state_type: str2,
    /**
     * A descriptive name for the state.
     */
    state_name: str2,
    /**
     * The type of multi-state modeling experiment carried out.
     */
    experiment_type: Aliased(str2),
    /**
     * Additional textual details of the multi-state modeling, if required.
     */
    details: str2
  },
  /**
   * Data items in the IHM_MODELING_POST_PROCESS category records
   * the details of the post processing of the models/results of
   * the modeling protocol.
   */
  ihm_modeling_post_process: {
    /**
     * A unique identifier for the post modeling analysis/step combination.
     */
    id: int,
    /**
     * An identifier for the modeling protocol, whose post modeling analysis
     * is being carried out.
     * This data item is a pointer to the _ihm_modeling_protocol.id
     * in the IHM_MODELING_PROTOCOL category.
     */
    protocol_id: int,
    /**
     * An identifier for the post modeling analysis. This data item accounts for
     * multiple post-modeling analyses that can be carried out.
     */
    analysis_id: int,
    /**
     * In a multi-step process, this identifier denotes the particular
     * step in the post modeling analysis.
     */
    step_id: int,
    /**
     * The type of post modeling analysis being carried out.
     */
    type: Aliased(str2),
    /**
     * The parameter/feature used in the post modeling analysis.
     */
    feature: Aliased(str2),
    /**
     * The number of models at the beginning of the post processing step.
     */
    num_models_begin: int,
    /**
     * The number of models the the end of the post processing step.
     */
    num_models_end: int
  },
  /**
   * Data items in the IHM_ENSEMBLE_INFO category records the
   * details of the model clusters or ensembles obtained after
   * sampling.
   */
  ihm_ensemble_info: {
    /**
     * A unique id for the ensemble.
     */
    ensemble_id: int,
    /**
     * An optional name for the cluster or ensemble for better description.
     */
    ensemble_name: str2,
    /**
     * An identifier for the post modeling analyses carried out.
     * This data item is a pointer to _ihm_modeling_post_process.id in
     * the IHM_MODELING_POST_PROCESS category.
     */
    post_process_id: int,
    /**
     * An identifier for the cluster or group of models being deposited.
     * This data item is a pointer to the _ihm_model_group.id
     * in the IHM_MODEL_GROUP category.
     */
    model_group_id: int,
    /**
     * The clustering method used to obtain the ensemble, if applicable.
     */
    ensemble_clustering_method: Aliased(str2),
    /**
     * The parameter/feature used for clustering the models, if applicable.
     */
    ensemble_clustering_feature: Aliased(str2),
    /**
     * The number of models in the current ensemble being described.
     */
    num_ensemble_models: int,
    /**
     * The number of models from the current ensemble that is deposited.
     */
    num_ensemble_models_deposited: int,
    /**
     * The precision of each cluster or ensemble is calculated as dRMSD, which
     * is the average C-alpha distance root mean square deviation (dRMSD)
     * between the individual models in the cluster and the cluster centroid.
     * The cluster centroid is defined as the model with the minimal sum of
     * dRMSDs to the other models in the cluster or ensemble.
     */
    ensemble_precision_value: float,
    /**
     * A reference to the external file containing the structural models
     * in the ensemble. The number of models in the external file should
     * correspond to the number of models in the ensemble. This data item
     * is a pointer to _ihm_external_files.id in the IHM_EXTERNAL_FILES
     * category.
     * It is recommended that the large ensemble files be stored as separate
     * zip files within the same DOI. It is also recommended that large sphere
     * model ensembles be in binary format, which facilitates faster access.
     * Currently, a binary dump of co-ordinates in dcd format is suggested.
     * The topology can be inferred from the IHM_SPHERE_OBJ_SITE and the
     * ATOM_SITE categories in the corresponding mmCIF file.
     */
    ensemble_file_id: int
  },
  /**
   * Data items in the IHM_MODEL_LIST category record the
   * details of the structure models being deposited.
   */
  ihm_model_list: {
    /**
     * A unique identifier for the structural model being deposited.
     */
    model_id: int,
    /**
     * A decsriptive name for the model.
     */
    model_name: str2,
    /**
     * An identifier to the structure assembly corresponding to the model.
     * This data item is a pointer to the _ihm_struct_assembly.id
     * in the IHM_STRUCT_ASSEMBLY category.
     */
    assembly_id: int,
    /**
     * An identifier to the modeling protocol that produced the model.
     * This data item is a pointer to the _ihm_modeling_protocol.id
     * in the IHM_MODELING_PROTOCOL category.
     */
    protocol_id: int,
    /**
     * An identifier to the multi-scale model representation id of the model.
     * This data item is a pointer to the _ihm_model_representation.id
     * in the IHM_MODEL_REPRESENTATION category.
     */
    representation_id: int
  },
  /**
   * IHM_MODEL_GROUP category defines collections or groups of integrative
   * structure models.
   */
  ihm_model_group: {
    /**
     * A unique identifier for a collection or group of structural models.
     * This data item can be used to group models into structural clusters
     * or using other criteria based on experimental data or other
     * relationships such as those belonging to the same state or time stamp.
     * An ensemble of models and its representative can either be grouped together
     * or can be separate groups in the ihm_model_group table. The choice between
     * the two options should be decided based on how the modeling was carried out
     * and how the representative was chosen. If the representative is a member of
     * the ensemble (i.e., best scoring model), then it is recommended that the
     * representative and the ensemble belong to the same model group. If the
     * representative is calculated from the ensemble (i.e., centroid), then it is
     * recommended that the representative be separated into a different group.
     */
    id: int,
    /**
     * A name for the collection of models.
     */
    name: str2,
    /**
     * Additional details about the collection of models.
     */
    details: str2
  },
  /**
   * IHM_MODEL_GROUP_LINK category provides the list of structure models present in
   * a particular structure model group.
   */
  ihm_model_group_link: {
    /**
     * An identifier for the structural model.
     * This data item is a pointer to _ihm_model_list.model_id in the
     * IHM_MODEL_LIST category.
     */
    model_id: int,
    /**
     * An identifier for the structural model group.
     * This data item is a pointer to _ihm_model_group.id in the
     * IHM_MODEL_GROUP category.
     */
    group_id: int
  },
  /**
   * Data items in the IHM_MODEL_REPRESENTATIVE category record the
   * details of the representative structure model in an ensemble or cluster.
   */
  ihm_model_representative: {
    /**
     * A unique identifier for the representative of the model group.
     */
    id: int,
    /**
     * The model group identifier corresponding to the representative model.
     * This data item is a pointer to _ihm_model_group.id in the
     * IHM_MODEL_GROUP category.
     */
    model_group_id: int,
    /**
     * The model identifier corresponding to the representative model.
     * This data item is a pointer to _ihm_model_list.model_id in the
     * IHM_MODEL_LIST category.
     */
    model_id: int,
    /**
     * The selection criteria based on which the representative is chosen.
     */
    selection_criteria: Aliased(str2)
  },
  /**
   * Category holds the list of all datasets used in the IHM modeling.
   * These can be datasets archived in other related databases such as
   * BMRB, EMDB, EMPIAR, SASBDB, PRIDE etc., or can be hosted in other
   * places such as the authors website, github etc. These datasets are
   * elaborated in detail in the IHM_DATASET_RELATED_DB_REFERENCE and/or
   * the IHM_DATASET_EXTERNAL_REFERENCE categories. This category
   * holds the list of all datasets used.
   */
  ihm_dataset_list: {
    /**
     * A unique identifier for the dataset.
     */
    id: int,
    /**
     * The type of data held in the dataset.
     */
    data_type: Aliased(str2),
    /**
     * A flag that indicates whether the dataset is archived in
     * an IHM related database or elsewhere.
     */
    database_hosted: Aliased(lstr)
  },
  /**
   * Category to define groups or collections of input datasets.
   */
  ihm_dataset_group: {
    /**
     * A unique identifier for the dataset group.
     */
    id: int,
    /**
     * A name for the dataset group.
     */
    name: str2,
    /**
     * The application / utilization of the dataset group in modeling.
     */
    application: Aliased(str2),
    /**
     * Additional details regarding the dataset group.
     */
    details: str2
  },
  /**
   * IHM_DATASET_GROUP_LINK category provides the list of datasets present in
   * a particular group.
   */
  ihm_dataset_group_link: {
    /**
     * An identifier for the dataset.
     * This data item is a pointer to _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     */
    dataset_list_id: int,
    /**
     * An identifier for the dataset group.
     * This data item is a pointer to _ihm_dataset_group.id in the
     * IHM_DATASET_GROUP category.
     */
    group_id: int
  },
  /**
   * Category holds information about related datasets, where one is derived from the other.
   */
  ihm_related_datasets: {
    /**
     * The dataset list id corresponding to the derived dataset.
     * This data item is a pointer to _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     */
    dataset_list_id_derived: int,
    /**
     * The primary dataset list id from which the corresponding derived dataset is obtained.
     * This data item is a pointer to _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     */
    dataset_list_id_primary: int
  },
  /**
   * Category holds information related to data sources for the entry.
   * These can be datasets archived in other related databases such as
   * BMRB, EMDB, EMPIAR, SASBDB, PRIDE etc.
   */
  ihm_dataset_related_db_reference: {
    /**
     * A unique identifier for the related database entry.
     */
    id: int,
    /**
     * Identifier to the dataset list used in the IHM modeling.
     * This data item is a pointer to the _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     */
    dataset_list_id: int,
    /**
     * The name of the database containing the dataset entry.
     */
    db_name: Aliased(str2),
    /**
     * The accession code for the database entry.
     */
    accession_code: str2,
    /**
     * Version of the database entry, if the database allows versioning.
     */
    version: str2,
    /**
     * Details regarding the dataset entry.
     */
    details: str2
  },
  /**
   * Category holds links to other external data sources for the I/H model entry.
   * Input datasets held in other databases such as EMDB, BMRB, SASBDB etc.
   * are referenced in the IHM_DATASET_RELATED_DB_REFERENCE category.
   * This data category, along with IHM_EXTERNAL_FILES category, holds information
   * regarding other non-database external data sources, such as  DOIs (digital
   * object identifiers) or supplementary files stored locally. The DOIs can either
   * lead to the external data file(s) directly (as in case of DOIs provided by the PDB)
   * or might lead to an HTML landing page (as provided by Zenodo). In the latter case,
   * additional URL (Uniform Resource Locator) information is required to retrieve
   * the external data file(s).
   */
  ihm_external_reference_info: {
    /**
     * A unique identifier for the external reference.
     */
    reference_id: int,
    /**
     * The name of the reference provider.
     */
    reference_provider: str2,
    /**
     * The type of external reference.
     * Currently, only Digital Object Identifiers (DOIs) and supplementary files
     * stored locally are supported.
     */
    reference_type: Aliased(str2),
    /**
     * The external reference or the Digital Object Identifier (DOI).
     * This field is not relevant for local files.
     */
    reference: str2,
    /**
     * The type of object that the external reference points to, usually
     * a single file or an archive.
     */
    refers_to: Aliased(str2),
    /**
     * The Uniform Resource Locator (URL) corresponding to the external reference (DOI).
     * This URL should link to the corresponding downloadable file or archive and is provided
     * to enable automated software to download the referenced file or archive.
     */
    associated_url: str2
  },
  /**
   * Category provides details regarding external files. The IHM_EXTERNAL_REFERENCE_INFO
   * category captures the top-level details regarding external data sources.
   * This category captures the specific details regarding externally stored files
   * related to the particular I/H model entry.
   */
  ihm_external_files: {
    /**
     * A unique identifier for each external file.
     */
    id: int,
    /**
     * A pointer to the source of the external file - either DOI or locally stored.
     * This data item is a pointer to _ihm_external_reference_info.reference_id in the
     * IHM_EXTERNAL_REFERENCE_INFO category.
     */
    reference_id: int,
    /**
     * The relative path (including filename) for each external file.
     * Absolute paths (starting with "/") are not permitted.
     * This is required for identifying individual files from within
     * a tar-zipped archive file or for identifying supplementary local
     * files organized within a directory structure.
     * This data item assumes a POSIX-like directory structure or file path.
     */
    file_path: str2,
    /**
     * The type of content in the file.
     */
    content_type: Aliased(str2),
    /**
     * Storage size of the external file in bytes.
     */
    file_size_bytes: float,
    /**
     * Additional textual details regarding the external file.
     */
    details: str2
  },
  /**
   * Category provides additional details regarding input data hosted externally
   * at other resources.
   */
  ihm_dataset_external_reference: {
    /**
     * A unique identifier for the external data.
     */
    id: int,
    /**
     * Identifier to the dataset list used in the I/H modeling.
     * This data item is a pointer to the _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     */
    dataset_list_id: int,
    /**
     * The file id corresponding to this external data file.
     * This data item is a pointer to _ihm_external_files.id
     * in the IHM_EXTERNAL_FILES category.
     */
    file_id: int
  },
  /**
   * Data items in the IHM_LOCALIZATION_DENSITY_FILES category records the
   * details of files that provide information regarding localization densities
   * of ensembles. These may be stored externally as local files or linked via
   * DOI and can be in any accepted format that provides volume information
   * (CCP4, MRC, etc.).
   */
  ihm_localization_density_files: {
    /**
     * A unique identifier.
     */
    id: int,
    /**
     * The file id for the externally stored localization density file.
     * This data item is a pointer to _ihm_external_files.id
     * in the IHM_EXTERNAL_FILES category.
     */
    file_id: int,
    /**
     * The ensemble identifier for the ensemble, for which the localization density is provided.
     * This data item is a pointer to _ihm_ensemble_info.ensemble_id in the IHM_ENSEMBLE_INFO category.
     */
    ensemble_id: int,
    /**
     * The entity identifier corresponding to this localization density.
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * The identifier for the polymeric segment corresponding to this
     * localization density.
     * This data item is a pointer to _ihm_entity_poly_segment.id in the
     * IHM_ENTITY_POLY_SEGMENT category.
     */
    entity_poly_segment_id: int,
    /**
     * An asym/strand identifier corresponding to this localization density.
     * This data item is a pointer to _struct_asym.id in the STRUCT_ASYM category.
     */
    asym_id: str2
  },
  /**
   * Data items in the IHM_PREDICTED_CONTACT_RESTRAINT category records the
   * list of predicted contacts used in the integrative modeling experiment.
   * This has been adapted from the widely used CASP RR format
   * (http://www.predictioncenter.org/casp8/index.cgi?page=format#RR).
   * These contacts may be derived from various computational tools.
   * The software information can be provided in the SOFTWARE category.
   */
  ihm_predicted_contact_restraint: {
    /**
     * A unique identifier for the predicted contact restraint.
     */
    id: int,
    /**
     * An identifier to group the predicted contacts.
     */
    group_id: int,
    /**
     * The entity identifier for the first monomer partner in the predicted contact.
     * This data item is a pointer to _entity_poly_seq.entity_id in the ENTITY_POLY_SEQ category.
     */
    entity_id_1: str2,
    /**
     * The entity identifier for the second monomer partner in the predicted contact.
     * This data item is a pointer to _entity_poly_seq.entity_id in the ENTITY_POLY_SEQ category.
     */
    entity_id_2: str2,
    /**
     * An asym/strand identifier for the first monomer partner in the predicted contact.
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    asym_id_1: str2,
    /**
     * An asym/strand identifier for the second monomer partner in the predicted contact.
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    asym_id_2: str2,
    /**
     * The component identifier for the first monomer partner in the predicted contact.
     * This data item is a pointer to _entity_poly_seq.mon_id in the ENTITY_POLY_SEQ category.
     */
    comp_id_1: str2,
    /**
     * The component identifier for the second monomer partner in the predicted contact.
     * This data item is a pointer to _entity_poly_seq.mon_id in the ENTITY_POLY_SEQ category.
     */
    comp_id_2: str2,
    /**
     * The sequence index for the first monomer partner in the predicted contact.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_1: int,
    /**
     * The sequence index for the second monomer partner in the predicted contact.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_2: int,
    /**
     * If _ihm_predicted_contact_restraint.model_granularity is by-residue, then indicate the atom
     * used to represent the first monomer partner in three-dimension. Default is the C-alpha atom.
     */
    rep_atom_1: Aliased(str2),
    /**
     * If _ihm_predicted_contact_restraint.model_granularity is by-residue, then indicate the atom
     * used to represent the second monomer partner in three-dimension. Default is the C-alpha atom.
     */
    rep_atom_2: Aliased(str2),
    /**
     * The lower limit to the distance threshold applied to this predicted contact restraint
     * in the integrative modeling task.
     */
    distance_lower_limit: float,
    /**
     * The upper limit to the distance threshold applied to this predicted contact restraint
     * in the integrative modeling task.
     */
    distance_upper_limit: float,
    /**
     * The real number that indicates the probability that the predicted distance restraint
     * is correct. This number should fall between 0.0 and 1.0.
     */
    probability: float,
    /**
     * The type of distance restraint applied.
     */
    restraint_type: Aliased(str2),
    /**
     * The granularity of the predicted contact as applied to the multi-scale model.
     */
    model_granularity: Aliased(str2),
    /**
     * Identifier to the predicted contacts dataset.
     * This data item is a pointer to the _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     */
    dataset_list_id: int,
    /**
     * Identifier to the software used to obtain the predicted contacts dataset.
     * This data item is a pointer to the _software.pdbx_ordinal in the
     * SOFTWARE category.
     */
    software_id: int
  },
  /**
   * Data items in the IHM_CROSS_LINK_LIST category records the
   * list of spatial restraints derived from chemical crosslinking
   * experiment.
   */
  ihm_cross_link_list: {
    /**
     * A unique identifier for the cross link restraint.
     */
    id: int,
    /**
     * An identifier for a set of ambiguous crosslink restraints.
     * Handles experimental uncertainties in the identities of
     * crosslinked residues.
     */
    group_id: int,
    /**
     * A text description of molecular entity 1.
     */
    entity_description_1: str2,
    /**
     * A text description of molecular entity 2.
     */
    entity_description_2: str2,
    /**
     * The entity identifier for the first monomer partner in the cross link
     * This data item is a pointer to _entity_poly_seq.entity_id in the ENTITY_POLY_SEQ category.
     */
    entity_id_1: str2,
    /**
     * The entity identifier for the second monomer partner in the cross link
     *
     * This data item is a pointer to _entity_poly_seq.entity_id in the ENTITY_POLY_SEQ category.
     */
    entity_id_2: str2,
    /**
     * The component identifier for the first monomer partner in the cross link.
     *
     * This data item is a pointer to _entity_poly_seq.mon_id in the ENTITY_POLY_SEQ category.
     */
    comp_id_1: str2,
    /**
     * The component identifier for the second monomer partner in the cross link.
     *
     * This data item is a pointer to _entity_poly_seq.mon_id in the ENTITY_POLY_SEQ category.
     */
    comp_id_2: str2,
    /**
     * The sequence index for the first monomer partner in the cross link.
     *
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_1: int,
    /**
     * The sequence index for the second monomer partner in the cross link.
     *
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_2: int,
    /**
     * The type of crosslinker used.
     */
    linker_type: Aliased(str2),
    /**
     * Identifier to the crosslinking dataset.
     * This data item is a pointer to the _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     */
    dataset_list_id: int
  },
  /**
   * Data items in the IHM_CROSS_LINK_RESTRAINT category enumerates the
   * implementation details of the chemical crosslinking restraints in
   * the integrative modeling. This category holds the details of how
   * the experimentally derived crosslinks are applied in the modeling.
   */
  ihm_cross_link_restraint: {
    /**
     * A unique identifier for the cross link record.
     */
    id: int,
    /**
     * An identifier for a set of ambiguous cross-links.
     * Handles implementation uncertainties related to multiple copies of subunit.
     * This data item is a pointer to _ihm_cross_link_list.id in the
     * IHM_CROSS_LINK_LIST category.
     */
    group_id: int,
    /**
     * The entity identifier for the first monomer partner in the cross link
     *
     * This data item is a pointer to _entity_poly_seq.entity_id in the ENTITY_POLY_SEQ category
     * and the _ihm_cross_link_restraint.entity_id_1 in the IHM_CROSS_LINK_RESTRAINT category.
     */
    entity_id_1: str2,
    /**
     * The entity identifier for the second monomer partner in the cross link
     *
     * This data item is a pointer to _entity_poly_seq.entity_id in the ENTITY_POLY_SEQ category
     * and the _ihm_cross_link_restraint.entity_id_2 in the IHM_CROSS_LINK_RESTRAINT category.
     */
    entity_id_2: str2,
    /**
     * An asym/strand identifier for the first monomer partner in the cross-link.
     *
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    asym_id_1: str2,
    /**
     * An asym/strand identifier for the second monomer partner in the cross-link.
     *
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    asym_id_2: str2,
    /**
     * The component identifier for the first monomer partner in the cross link.
     *
     * This data item is a pointer to _entity_poly_seq.mon_id in the ENTITY_POLY_SEQ category
     * and the _ihm_cross_link_restraint.comp_id_1 in the IHM_CROSS_LINK_RESTRAINT category.
     */
    comp_id_1: str2,
    /**
     * The component identifier for the second monomer partner in the cross link.
     *
     * This data item is a pointer to _entity_poly_seq.mon_id in the ENTITY_POLY_SEQ category
     * and the _ihm_cross_link_restraint.comp_id_2 in the IHM_CROSS_LINK_RESTRAINT category.
     */
    comp_id_2: str2,
    /**
     * The sequence index for the first monomer partner in the cross link.
     *
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category
     * and the _ihm_cross_link_restraint.seq_id_1 in the IHM_CROSS_LINK_RESTRAINT category.
     */
    seq_id_1: int,
    /**
     * The sequence index for the second monomer partner in the cross link.
     *
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category
     * and the _ihm_cross_link_restraint.seq_id_2 in the IHM_CROSS_LINK_RESTRAINT category.
     */
    seq_id_2: int,
    /**
     * The atom identifier for the first monomer partner in the cross link.
     * This data item is a pointer to _chem_comp_atom.atom_id in the
     * CHEM_COMP_ATOM category.
     */
    atom_id_1: str2,
    /**
     * The atom identifier for the second monomer partner in the cross link.
     * This data item is a pointer to _chem_comp_atom.atom_id in the
     * CHEM_COMP_ATOM category.
     */
    atom_id_2: str2,
    /**
     * The type of the cross link restraint applied.
     */
    restraint_type: Aliased(str2),
    /**
     * The cross link conditionality.
     */
    conditional_crosslink_flag: Aliased(str2),
    /**
     * The coarse-graining information for the crosslink implementation.
     */
    model_granularity: Aliased(str2),
    /**
     * The distance threshold applied to this crosslink in the integrative modeling task.
     */
    distance_threshold: float,
    /**
     * The uncertainty in the crosslinking experimental data;
     * may be approximated to the false positive rate.
     */
    psi: float,
    /**
     * The uncertainty in the position of residue 1 in the crosslink
     * arising due to the multi-scale nature of the model represention.
     */
    sigma_1: float,
    /**
     * The uncertainty in the position of residue 2 in the crosslink
     * arising due to the multi-scale nature of the model represention.
     */
    sigma_2: float
  },
  /**
   * Data items in the IHM_CROSS_LINK_RESULT_PARAMETERS category records the
   * results of the crosslinking restraint parameters in the IHM modeling.
   */
  ihm_cross_link_result_parameters: {
    /**
     * A unique identifier for the restraint/model combination.
     */
    id: int,
    /**
     * An identifier for the crosslink restraint between a pair of residues.
     * This data item is a pointer to _ihm_cross_link_restraint.id in the
     * IHM_CROSS_LINK_RESTRAINT category.
     */
    restraint_id: int,
    /**
     * The model number corresponding to the cross link result presented.
     * This data item is a pointer to _ihm_model_list.model_id in the
     * IHM_MODEL_LIST category.
     */
    model_id: int,
    /**
     * The uncertainty in the crosslinking experimental data;
     * May be approximated to the false positive rate.
     */
    psi: float,
    /**
     * The uncertainty in the position of residue 1 in the crosslink
     * arising due to the multi-scale nature of the model represention.
     */
    sigma_1: float,
    /**
     * The uncertainty in the position of residue 2 in the crosslink
     * arising due to the multi-scale nature of the model represention.
     */
    sigma_2: float
  },
  /**
   * Data items in the IHM_2DEM_CLASS_AVERAGE_RESTRAINT category records the
   * details of the 2DEM class averages used in the IHM modeling.
   */
  ihm_2dem_class_average_restraint: {
    /**
     * A unique identifier for the 2dem class average.
     */
    id: int,
    /**
     * Identifier to the 2dem class average dataset.
     * This data item is a pointer to the _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     */
    dataset_list_id: int,
    /**
     * The number of raw micrographs used to obtain the class average.
     */
    number_raw_micrographs: int,
    /**
     * Pixel size width of the 2dem class average image.
     * While fitting the model to the image, _ihm_2dem_class_average_restraint.pixel_size_width
     * is used along with _ihm_2dem_class_average_restraint.pixel_size_height to scale the image.
     */
    pixel_size_width: float,
    /**
     * Pixel size height of the 2dem class average image.
     * While fitting the model to the image, _ihm_2dem_class_average_restraint.pixel_size_height
     * is used along with _ihm_2dem_class_average_restraint.pixel_size_width to scale the image.
     */
    pixel_size_height: float,
    /**
     * Resolution of the 2dem class average.
     */
    image_resolution: float,
    /**
     * A flag that indicates whether or not the 2DEM class average image is segmented i.e.,
     * whether the whole image is used or only a portion of it is used (by masking
     * or by other means) as restraint in the modeling.
     */
    image_segment_flag: Aliased(lstr),
    /**
     * Number of 2D projections of the model used in the fitting.
     */
    number_of_projections: int,
    /**
     * An indicator to whether the whole assembly that is modeled is fit into the image
     * or if only a subset of the structural assembly is fit into the image.
     * This data item is a pointer to _ihm_struct_assembly.id in the
     * IHM_STRUCT_ASSEMBLY category. The IHM_STRUCT_ASSEMBLY category provides the
     * details regarding the different structural assemblies used in the modeling.
     * The default value for this data item is "1" indicating that the entire assembly
     * being modeled is fit into the EM data.
     */
    struct_assembly_id: int,
    /**
     * Details of how the 2DEM restraint is applied in the modeling algorithm.
     */
    details: str2
  },
  /**
   * Data items in the IHM_2DEM_CLASS_AVERAGE_FITTING category records the
   * details of the fitting of the model to the 2DEM class averages
   * used in the IHM modeling. The following conventions are recommended
   * while generating the rotation matrix and translation vector for
   * transformation.
   *
   * - The model is rotated and translated to fit to the 2DEM image.
   * - The 2DEM image should be in the XY plane.
   * - The lower left image corner (image pixel index 0,0) should be at x,y,z = (0,0,0).
   * - The 2D image is scaled by the _ihm_2dem_class_average_restraint.pixel_size_width
   * and _ihm_2dem_class_average_restraint.pixel_size_height from the
   * IHM_2DEM_CLASS_AVERAGE_RESTRAINT table.
   * - The transformation is applied after the scaling and hence the translation vector
   * should account for the scaling.
   * - There are no specifications for Z translations i.e., how far the image should be
   * from the model while projecting. It may be set to zero.
   */
  ihm_2dem_class_average_fitting: {
    /**
     * A unique identifier for the 2dem class average fitting data.
     */
    id: int,
    /**
     * Identifier to the 2dem class average restraint.
     * This data item is a pointer to the _ihm_2dem_class_average_restraint.id in the
     * IHM_2DEM_CLASS_AVERAGE_RESTRAINT category.
     */
    restraint_id: int,
    /**
     * The model number corresponding to the 2DEM fitting result presented.
     * This data item is a pointer to _ihm_model_list.model_id in the
     * IHM_MODEL_LIST category.
     */
    model_id: int,
    /**
     * The cross correlation coefficient corresponding to the model to image fitting.
     */
    cross_correlation_coefficient: float,
    /**
     * Data item  of the rotation matrix used in the fitting of the model to the image.
     */
    rot_matrix: Matrix2(3, 3),
    /**
     * Data item  of the tranlation vector used in the fitting of the model to the image.
     */
    tr_vector: Vector(3)
  },
  /**
   * Data items in the IHM_3DEM_RESTRAINT category records the
   * details of the 3DEM maps used as restraints in the
   * IHM modeling.
   */
  ihm_3dem_restraint: {
    /**
     * A unique identifier for the 3DEM restraint description.
     */
    id: int,
    /**
     * Identifier to the 3DEM map used.
     * This data item is a pointer to the _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     */
    dataset_list_id: int,
    /**
     * The model number corresponding to the 3DEM fitting result presented.
     * This data item is a pointer to _ihm_model_list.model_id in the
     * IHM_MODEL_LIST category.
     */
    model_id: int,
    /**
     * An indicator to whether the whole assembly that is modeled is fit into the 3DEM map
     * or if only a subset of the structural assembly is fit into the map.
     * This data item is a pointer to _ihm_struct_assembly.id in the
     * IHM_STRUCT_ASSEMBLY category. The IHM_STRUCT_ASSEMBLY category provides the
     * details regarding the different structural assemblies used in the modeling.
     * The default value for this data item is "1" indicating that the entire assembly
     * being modeled is fit into the EM map.
     */
    struct_assembly_id: int,
    /**
     * Method used to fit the model to the 3DEM map.
     */
    fitting_method: str2,
    /**
     * In case of Gaussian mixture models, the number of gaussians
     * is a parameter used to covert the 3DEM maps and models into
     * GMMs. This captures the level of granularity used in
     * representing the maps and/or models as 3D Gaussians.
     */
    number_of_gaussians: int,
    /**
     * The cross correlation coefficient corresponding to the model to map fitting.
     */
    cross_correlation_coefficient: float
  },
  /**
   * Data items in the IHM_SAS_RESTRAINT category records the
   * details of the SAS data used as restraints in the
   * IHM modeling.
   */
  ihm_sas_restraint: {
    /**
     * A unique identifier for the SAS restraint description.
     */
    id: int,
    /**
     * Identifier to the SAS data used.
     * This data item is a pointer to the _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     */
    dataset_list_id: int,
    /**
     * The model number corresponding to the SAS fitting result presented.
     * This data item is a pointer to _ihm_model_list.model_id in the
     * IHM_MODEL_LIST category.
     */
    model_id: int,
    /**
     * An indicator to whether the whole assembly that is modeled is fit into the SAS data
     * or if only a subset of the structural assembly is fit into the data.
     * This data item is a pointer to _ihm_struct_assembly.id in the
     * IHM_STRUCT_ASSEMBLY category. The IHM_STRUCT_ASSEMBLY category provides the
     * details regarding the different structural assemblies used in the modeling.
     * The default value for this data item is "1" indicating that the entire assembly
     * being modeled is fit into the SAS data.
     */
    struct_assembly_id: int,
    /**
     * A flag that indicates whether or not the SAS profile is segmented i.e.,
     * whether the whole SAS profile is used or only a portion of it is used
     * (by masking or by other means) as restraint in the modeling.
     */
    profile_segment_flag: Aliased(lstr),
    /**
     * The type of atoms in the model fit to the SAS data.
     */
    fitting_atom_type: str2,
    /**
     * The method used for fitting the model to the SAS data.
     */
    fitting_method: str2,
    /**
     * An indicator to single or multiple state fitting.
     */
    fitting_state: Aliased(str2),
    /**
     * Radius of gyration obtained from the SAS profile, if used as input restraint.
     */
    radius_of_gyration: float,
    /**
     * The chi value resulting from fitting the model to the SAS data.
     */
    chi_value: float,
    /**
     * Additional details regarding the SAS restraint used.
     */
    details: str2
  },
  /**
   * Data items in the IHM_STARTING_MODEL_COORD category records the coordinates
   * for structural templates used as starting inputs in the integrative model
   * building tasks.
   */
  ihm_starting_model_coord: {
    /**
     * A unique identifier for this coordinate position.
     */
    ordinal_id: int,
    /**
     * The identifier for the starting structural model.
     * This data item is a pointer to _ihm_starting_model_details.starting_model_id
     * in the IHM_STARTING_MODEL_DETAILS category.
     */
    starting_model_id: str2,
    /**
     * The group of atoms to which the atom site in the starting model belongs. This data
     * item is provided for compatibility with the original Protein Data Bank format,
     * and only for that purpose.
     */
    group_PDB: Aliased(str2),
    /**
     * The serial number for this coordinate position.
     */
    id: int,
    /**
     * The atom type symbol(element symbol) corresponding to this coordinate position.
     */
    type_symbol: str2,
    /**
     * The entity identifier corresponding to this coordinate position.
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * The atom identifier/name corresponding to this coordinate position.
     * This data item is a pointer to _chem_comp_atom.atom_id in the
     * CHEM_COMP_ATOM category.
     */
    atom_id: str2,
    /**
     * The component identifier corresponding to this coordinate position.
     * This data item is a pointer to _chem_comp.id in the
     * CHEM_COMP category.
     */
    comp_id: str2,
    /**
     * The sequence index corresponding this to coordinate position.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id: int,
    /**
     * The asym/strand id corresponding to this coordinate position.
     *
     * This data item is a pointer to _struct_asym.id in the STRUCT_ASYM category.
     */
    asym_id: str2,
    /**
     * The Cartesian X component corresponding to this coordinate position.
     */
    Cartn_x: float,
    /**
     * The Cartesian Y component corresponding to this coordinate position.
     */
    Cartn_y: float,
    /**
     * The Cartesian Z component corresponding to this coordinate position.
     */
    Cartn_z: float,
    /**
     * The isotropic temperature factor corresponding to this coordinate position.
     */
    B_iso_or_equiv: float
  },
  /**
   * Data items in the IHM_SPHERE_OBJ_SITE category records the details
   * of the spherical objects modeled in the integrative structural model.
   */
  ihm_sphere_obj_site: {
    /**
     * A unique identifier for this pseudo atom / sphere object.
     */
    id: int,
    /**
     * The entity identifier corresponding to this sphere object.
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * The leading sequence index corresponding to this sphere object.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_begin: int,
    /**
     * The trailing sequence index corresponding to this sphere object.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_end: int,
    /**
     * An asym/strand identifier corresponding to this sphere object.
     * This data item is a pointer to _struct_asym.id in the STRUCT_ASYM category.
     */
    asym_id: str2,
    /**
     * The Cartesian X component corresponding to this sphere object.
     */
    Cartn_x: float,
    /**
     * The Cartesian Y component corresponding to this sphere object.
     */
    Cartn_y: float,
    /**
     * The Cartesian Z component corresponding to this sphere object.
     */
    Cartn_z: float,
    /**
     * The radius associated with the primitive sphere object at this position.
     */
    object_radius: float,
    /**
     * The Root Mean Square Fluctuation (RMSF) observed in the primitive
     * sphere object at this position.
     */
    rmsf: float,
    /**
     * The model id corresponding to the sphere object.
     * This data item is a pointer to _ihm_model_list.model_id
     * in the IHM_MODEL_LIST category.
     */
    model_id: int
  },
  /**
   * Data items in the IHM_GAUSSIAN_OBJ_SITE category records the details
   * of the gaussian objects modeled in the integrative structural model.
   */
  ihm_gaussian_obj_site: {
    /**
     * A unique identifier for this gaussian object in the model.
     */
    id: int,
    /**
     * The entity identifier corresponding to this gaussian object.
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * The leading sequence index corresponding to this gaussian object.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_begin: int,
    /**
     * The trailing sequence index corresponding to this gaussian object.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_end: int,
    /**
     * An asym/strand identifier corresponding to this gaussian object.
     * This data item is a pointer to _struct_asym.id in the STRUCT_ASYM category.
     */
    asym_id: str2,
    /**
     * The mean Cartesian X component corresponding to this gaussian object.
     */
    mean_Cartn_x: float,
    /**
     * The mean Cartesian Y component corresponding to this gaussian object.
     */
    mean_Cartn_y: float,
    /**
     * The mean Cartesian Z component corresponding to this gaussian object.
     */
    mean_Cartn_z: float,
    /**
     * The weight of the gaussian object.
     */
    weight: float,
    /**
     * Data item  of the covariance matrix representing the Gaussian object.
     */
    covariance_matrix: Matrix2(3, 3),
    /**
     * The model id corresponding to the gaussian object.
     * This data item is a pointer to _ihm_model_list.model_id
     * in the IHM_MODEL_LIST category.
     */
    model_id: int
  },
  /**
   * Data items in the IHM_GAUSSIAN_OBJ_ENSEMBLE category records the details
   * of the gaussian objects representing an ensemble or cluster of models.
   */
  ihm_gaussian_obj_ensemble: {
    /**
     * A unique identifier for this gaussian object.
     */
    id: int,
    /**
     * The entity identifier corresponding to this gaussian object.
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * The leading sequence index corresponding to this gaussian object.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_begin: int,
    /**
     * The trailing sequence index corresponding to this gaussian object.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_end: int,
    /**
     * An asym/strand identifier corresponding to this gaussian object.
     * This data item is a pointer to _struct_asym.id in the STRUCT_ASYM category.
     */
    asym_id: str2,
    /**
     * The mean Cartesian X component corresponding to this gaussian object.
     */
    mean_Cartn_x: float,
    /**
     * The mean Cartesian Y component corresponding to this gaussian object.
     */
    mean_Cartn_y: float,
    /**
     * The mean Cartesian Z component corresponding to this gaussian object.
     */
    mean_Cartn_z: float,
    /**
     * The weight of the gaussian object.
     */
    weight: float,
    /**
     * Data item  of the covariance matrix representing the Gaussian object.
     */
    covariance_matrix: Matrix2(3, 3),
    /**
     * The ensemble id corresponding to the gaussian object.
     * This data item is a pointer to _ihm_ensemble_info.ensemble_id
     * in the IHM_ENSEMBLE_INFO category.
     */
    ensemble_id: int
  },
  /**
   * IHM_FEATURE_LIST is the high level category that provides defintions
   * to select atoms/residues from polymeric and non-polymeric entities.
   */
  ihm_feature_list: {
    /**
     * A unique identifier for the feature.
     */
    feature_id: int,
    /**
     * The type of feature.
     */
    feature_type: Aliased(str2),
    /**
     * The type of entity.
     */
    entity_type: Aliased(str2)
  },
  /**
   * Data items in the IHM_POLY_RESIDUE_FEATURE category provides the defintions
   * required to select a specific residue or a set of residues that may or may not be
   * in a contiguous range.
   */
  ihm_poly_residue_feature: {
    /**
     * A unique identifier for the category.
     */
    ordinal_id: int,
    /**
     * An identifier for the selected residue / residue range feature.
     * This data item is a pointer to _ihm_feature_list.feature_id in the
     * IHM_FEATURE_LIST category.
     */
    feature_id: int,
    /**
     * The entity identifier for residue / residue range.
     * This data item is a pointer to _entity_poly_seq.entity_id in the
     * ENTITY_POLY_SEQ category.
     */
    entity_id: str2,
    /**
     * An asym/strand identifier for the residue / residue range, if applicable.
     * This data item is a pointer to _struct_asym.id in the
     * STRUCT_ASYM category.
     */
    asym_id: str2,
    /**
     * The component identifier of the beginning residue / residue range.
     * This data item is a pointer to _entity_poly_seq.mon_id in the ENTITY_POLY_SEQ category.
     */
    comp_id_begin: str2,
    /**
     * The component identifier of the ending residue / residue range.
     * This data item is a pointer to _entity_poly_seq.mon_id in the ENTITY_POLY_SEQ category.
     */
    comp_id_end: str2,
    /**
     * The sequence index of the beginning residue / residue range.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_begin: int,
    /**
     * The sequence index of the ending residue / residue range.
     * This data item is a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category.
     */
    seq_id_end: int
  },
  /**
   * Data items in the IHM_DERIVED_DISTANCE_RESTRAINT category records the
   * list of distance restraints used in the integrative modeling experiment.
   * These distance redistance restraints may be derived from various kinds of experiments.
   */
  ihm_derived_distance_restraint: {
    /**
     * A unique identifier for the derived distance restraint.
     */
    id: int,
    /**
     * An identifier to group the distance restraints.
     * This can be the same as the _ihm_derived_distance_restraint.id in case
     * the some of the restraints are not grouped.
     */
    group_id: int,
    /**
     * The feature identifier for the first partner in the distance restraint.
     * This data item is a pointer to _ihm_feature_list.feature_id in the
     * IHM_FEATURE_LIST category.
     */
    feature_id_1: int,
    /**
     * The feature identifier for the second partner in the distance restraint.
     * This data item is a pointer to _ihm_feature_list.feature_id in the
     * IHM_FEATURE_LIST category.
     */
    feature_id_2: int,
    /**
     * If a group of atoms or residues are restrained, this data item defines
     * the conditionality based on which the restraint is applied in the modeling.
     */
    group_conditionality: Aliased(str2),
    /**
     * The fraction of randomly excluded distance restraints during modeling.
     * In HADDOCK, this is used along with ambiguous interface restraints (AIRs)
     * to account for uncertainties in AIRs.
     */
    random_exclusion_fraction: float,
    /**
     * The upper limit to the distance threshold applied to this distance restraint
     * in the integrative modeling task.
     */
    distance_upper_limit: float,
    /**
     * The type of distance restraint applied.
     */
    restraint_type: Aliased(str2),
    /**
     * Identifier to the input data from which the distance restraint is derived.
     * This data item is a pointer to the _ihm_dataset_list.id in the
     * IHM_DATASET_LIST category.
     * This data item may not be applicable for all cases. For example, in case of
     * ambiguous interface restraints where the interface residues are identified
     * from multiple experiments, the reference to the _ihm_dataset_list.id is
     * handled in the IHM_INTERFACE_RESIDUE_FEATURE category rather than here.
     */
    dataset_list_id: int
  },
  /**
   * Data items in the MA_MODEL_LIST category record the
   * details of the models being deposited.
   */
  ma_model_list: {
    /**
     * A unique identifier for the structural model being deposited.
     */
    ordinal_id: int,
    /**
     * A unique identifier for the structural model being deposited.
     * This data item was practically a duplicate of _ma_model_list.ordinal_id
     * and has been deprecated with dictionary version 1.4.7.
     */
    model_id: int,
    /**
     * An identifier to group structural models into collections or sets.
     * This data item has been deprecated with dictionary version 1.4.7.
     * See ma_model_group category.
     */
    model_group_id: int,
    /**
     * A decsriptive name for the model.
     */
    model_name: str2,
    /**
     * A decsriptive name for the model group.
     * This data item has been deprecated with dictionary version 1.4.7.
     * See ma_model_group category.
     */
    model_group_name: str2,
    /**
     * The type of model.
     */
    model_type: Aliased(str2),
    /**
     * The data_id identifier. This data item is a pointer to
     * _ma_data.id in the MA_DATA category.
     */
    data_id: int
  },
  /**
   * Data items in the MA_TARGET_ENTITY category record details about
   * the target entities. The details are provided for each entity
   * being modeled.
   */
  ma_target_entity: {
    /**
     * A unique identifier for the distinct molecular entity of the target.
     * This data item is a pointer to _entity.id in the ENTITY category.
     */
    entity_id: str2,
    /**
     * The data_id identifier. This data item is a pointer to
     * _ma_data.id in the MA_DATA category.
     */
    data_id: int,
    /**
     * The origin of the target entity.
     */
    origin: Aliased(str2)
  },
  /**
   * Data items in the MA_TARGET_ENTITY_INSTANCE category record details about
   * the instances of target entities modeled.
   */
  ma_target_entity_instance: {
    /**
     * A unique identifier for the instance of the entity.
     */
    asym_id: str2,
    /**
     * A unique identifier for the distinct molecular entity of the target.
     * This data item is a pointer to _ma_target_entity.entity_id in the
     * MA_TARGET_ENTITY category.
     */
    entity_id: str2,
    /**
     * Additional details about the entity instance.
     */
    details: str2
  },
  /**
   * Data items in the MA_TARGET_REF_DB_DETAILS category record details about
   * the reference databases for the target sequences.
   */
  ma_target_ref_db_details: {
    /**
     * An identifier for the target entity.
     */
    target_entity_id: str2,
    /**
     * The name of the database containing reference information about
     * this entity or biological unit.
     */
    db_name: Aliased(str2),
    /**
     * The code for this entity or biological unit or for a closely
     * related entity or biological unit in the named database.
     * This can include the version number.
     */
    db_code: str2,
    /**
     * Accession code assigned by the reference database.
     */
    db_accession: str2,
    /**
     * Database code assigned by the reference database for a sequence isoform.   An isoform sequence is an
     * alternative protein sequence that can be generated from the same gene by a single or by a combination of
     * biological events such as: alternative promoter usage, alternative splicing, alternative initiation
     * and ribosomal frameshifting.
     */
    seq_db_isoform: str2,
    /**
     * Beginning index in the chemical sequence from the
     * reference database.
     */
    seq_db_align_begin: str2,
    /**
     * Ending index in the chemical sequence from the
     * reference database.
     */
    seq_db_align_end: str2,
    /**
     * Taxonomy identifier provided by NCBI.
     */
    ncbi_taxonomy_id: str2,
    /**
     * Scientific name of the organism.
     */
    organism_scientific: str2
  },
  /**
   * Data items in the MA_DATA category capture the different kinds of
   * data used in the modeling. These can be multiple sequence
   * alignments, spatial restraints, template structures etc.
   */
  ma_data: {
    /**
     * A unique identifier for the data.
     */
    id: int,
    /**
     * The type of data held in the dataset.
     */
    content_type: Aliased(str2),
    /**
     * Details for other content types.
     */
    content_type_other_details: str2,
    /**
     * An author-given name for the content held in the dataset.
     */
    name: str2
  },
  /**
   * Data items in the MA_SOFTWARE_GROUP category describes the
   * collection of software into groups so that they can be used
   * efficiently in the MA_PROTOCOL_STEP category.
   */
  ma_software_group: {
    /**
     * A unique identifier for the category.
     */
    ordinal_id: int,
    /**
     * An identifier for the group entry.
     * If data does not need to be grouped, then _ma_software_group.group_id
     * is the same as _ma_software_group.software_id.
     */
    group_id: int,
    /**
     * The identifier for the software.
     * This data item is a pointer to _software.pdbx_ordinal
     * in the SOFTWARE category.
     */
    software_id: int
  },
  /**
   * Data items in the MA_QA_METRIC category record the
   * details of the metrics use to assess model quality.
   */
  ma_qa_metric: {
    /**
     * An identifier for the QA metric.
     */
    id: int,
    /**
     * Name of the QA metric.
     */
    name: str2,
    /**
     * The type of QA metric.
     */
    type: Aliased(str2),
    /**
     * The mode of calculation of the QA metric.
     */
    mode: Aliased(str2),
    /**
     * Identifier to the set of software used to calculate the QA metric.
     * This data item is a pointer to the _ma_software_group.group_id in the
     * MA_SOFTWARE_GROUP category.
     */
    software_group_id: int
  },
  /**
   * Data items in the MA_QA_METRIC_GLOBAL category captures the
   * details of the global QA metrics, calculated at the model-level.
   */
  ma_qa_metric_global: {
    /**
     * A unique identifier for the category.
     */
    ordinal_id: int,
    /**
     * The identifier for the structural model, for which global QA metric is provided.
     * This data item is a pointer to _ma_model_list.ordinal_id
     * in the MA_MODEL_LIST category.
     */
    model_id: int,
    /**
     * The identifier for the QA metric.
     * This data item is a pointer to _ma_qa_metric.id in the
     * MA_QA_METRIC category.
     */
    metric_id: int,
    /**
     * The value of the global QA metric.
     */
    metric_value: float
  },
  /**
   * Data items in the MA_QA_METRIC_LOCAL category captures the
   * details of the local QA metrics, calculated at the residue-level.
   * Data in this category can be extracted into a separate file which
   * is linked to the main file using the categories
   * ma_associated_archive_file_details or ma_entry_associated_files
   * with file_content set to "QA metrics".
   */
  ma_qa_metric_local: {
    /**
     * A unique identifier for the category.
     */
    ordinal_id: int,
    /**
     * The identifier for the structural model, for which local QA metric is provided.
     * This data item is a pointer to _ma_model_list.ordinal_id
     * in the MA_MODEL_LIST category.
     */
    model_id: int,
    /**
     * The identifier for the asym id of the residue in the
     * structural model, for which local QA metric is provided.
     * This data item is a pointer to _atom_site.label_asym_id
     * in the ATOM_SITE category.
     */
    label_asym_id: str2,
    /**
     * The identifier for the sequence index of the residue
     * in the structural model, for which local QA metric is provided.
     * This data item is a pointer to _atom_site.label_seq_id
     * in the ATOM_SITE category.
     */
    label_seq_id: int,
    /**
     * The component identifier for the residue in the
     * structural model, for which local QA metric is provided.
     * This data item is a pointer to _atom_site.label_comp_id
     * in the ATOM_SITE category.
     */
    label_comp_id: str2,
    /**
     * The identifier for the QA metric.
     * This data item is a pointer to _ma_qa_metric.id in the
     * MA_QA_METRIC category.
     */
    metric_id: int,
    /**
     * The value of the local QA metric.
     */
    metric_value: float
  },
  /**
   * Data items in the MA_QA_METRIC_LOCAL_PAIRWISE category captures the
   * details of the local QA metrics, calculated at the pairwise residue level.
   * In cases where the metric is symmetric, it is enough to store just one value per pair.
   * For asymmetric metrics, the order of residues is expected to be meaningful
   * (e.g. PAE where PAE_ij is defined by aligning residue i (label_*_1) and measuring
   * the error on residue j (label_*_2)).
   * In all cases, it is perfectly valid to only provide values for a subset of residue pairs.
   * Data in this category is expected to be very large and can be extracted into a
   * separate file which is linked to the main file using the categories
   * ma_associated_archive_file_details or ma_entry_associated_files with file_content
   * set to "QA metrics".
   */
  ma_qa_metric_local_pairwise: {
    /**
     * A unique identifier for the category.
     */
    ordinal_id: int,
    /**
     * The identifier for the structural model, for which local QA metric is provided.
     * This data item is a pointer to _ma_model_list.ordinal_id
     * in the MA_MODEL_LIST category.
     */
    model_id: int,
    /**
     * The identifier for the asym id of the first residue in the
     * pair, for which local QA metric is provided.
     * This data item is a pointer to _atom_site.label_asym_id
     * in the ATOM_SITE category.
     */
    label_asym_id_1: str2,
    /**
     * The identifier for the sequence index of the first residue
     * in the pair, for which local QA metric is provided.
     * This data item is a pointer to _atom_site.label_seq_id
     * in the ATOM_SITE category.
     */
    label_seq_id_1: int,
    /**
     * The component identifier for the first residue in the
     * pair, for which local QA metric is provided.
     * This data item is a pointer to _atom_site.label_comp_id
     * in the ATOM_SITE category.
     */
    label_comp_id_1: str2,
    /**
     * The identifier for the asym id of the second residue in the
     * pair, for which local QA metric is provided.
     * This data item is a pointer to _atom_site.label_asym_id
     * in the ATOM_SITE category.
     */
    label_asym_id_2: str2,
    /**
     * The identifier for the sequence index of the second residue
     * in the pair, for which local QA metric is provided.
     * This data item is a pointer to _atom_site.label_seq_id
     * in the ATOM_SITE category.
     */
    label_seq_id_2: int,
    /**
     * The component identifier for the second residue in the
     * pair, for which local QA metric is provided.
     * This data item is a pointer to _atom_site.label_comp_id
     * in the ATOM_SITE category.
     */
    label_comp_id_2: str2,
    /**
     * The identifier for the QA metric.
     * This data item is a pointer to _ma_qa_metric.id in the
     * MA_QA_METRIC category.
     */
    metric_id: int,
    /**
     * The value of the local QA metric.
     */
    metric_value: float
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/binary-cif/encoding.js
var VERSION = "0.3.0";
var Encoding;
(function(Encoding2) {
  let IntDataType;
  (function(IntDataType2) {
    IntDataType2[IntDataType2["Int8"] = 1] = "Int8";
    IntDataType2[IntDataType2["Int16"] = 2] = "Int16";
    IntDataType2[IntDataType2["Int32"] = 3] = "Int32";
    IntDataType2[IntDataType2["Uint8"] = 4] = "Uint8";
    IntDataType2[IntDataType2["Uint16"] = 5] = "Uint16";
    IntDataType2[IntDataType2["Uint32"] = 6] = "Uint32";
  })(IntDataType = Encoding2.IntDataType || (Encoding2.IntDataType = {}));
  let FloatDataType;
  (function(FloatDataType2) {
    FloatDataType2[FloatDataType2["Float32"] = 32] = "Float32";
    FloatDataType2[FloatDataType2["Float64"] = 33] = "Float64";
  })(FloatDataType = Encoding2.FloatDataType || (Encoding2.FloatDataType = {}));
  function getDataType(data) {
    let srcType;
    if (data instanceof Int8Array)
      srcType = Encoding2.IntDataType.Int8;
    else if (data instanceof Int16Array)
      srcType = Encoding2.IntDataType.Int16;
    else if (data instanceof Int32Array)
      srcType = Encoding2.IntDataType.Int32;
    else if (data instanceof Uint8Array)
      srcType = Encoding2.IntDataType.Uint8;
    else if (data instanceof Uint16Array)
      srcType = Encoding2.IntDataType.Uint16;
    else if (data instanceof Uint32Array)
      srcType = Encoding2.IntDataType.Uint32;
    else if (data instanceof Float32Array)
      srcType = Encoding2.FloatDataType.Float32;
    else if (data instanceof Float64Array)
      srcType = Encoding2.FloatDataType.Float64;
    else
      srcType = Encoding2.IntDataType.Int32;
    return srcType;
  }
  Encoding2.getDataType = getDataType;
  function isSignedIntegerDataType(data) {
    if (data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array)
      return true;
    for (let i = 0, _i = data.length; i < _i; i++) {
      if (i < 0)
        return false;
    }
    return true;
  }
  Encoding2.isSignedIntegerDataType = isSignedIntegerDataType;
})(Encoding || (Encoding = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/binary.js
var IsNativeEndianLittle = new Uint16Array(new Uint8Array([18, 52]).buffer)[0] === 13330;
function flipByteOrder(data, bytes) {
  const buffer = new ArrayBuffer(data.length);
  const ret = new Uint8Array(buffer);
  for (let i = 0, n = data.length; i < n; i += bytes) {
    for (let j = 0; j < bytes; j++) {
      ret[i + bytes - j - 1] = data[i + j];
    }
  }
  return buffer;
}
var ChunkSize = 28672;
function uint8ToString(array2) {
  if (array2.length > ChunkSize) {
    const c = [];
    for (let i = 0; i < array2.length; i += ChunkSize) {
      c.push(String.fromCharCode.apply(null, array2.subarray(i, i + ChunkSize)));
    }
    return c.join("");
  } else {
    return String.fromCharCode.apply(null, array2);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/binary-cif/decoder.js
function decode(data) {
  let current = data.data;
  for (let i = data.encoding.length - 1; i >= 0; i--) {
    current = decodeStep(current, data.encoding[i]);
  }
  return current;
}
function decodeStep(data, encoding) {
  switch (encoding.kind) {
    case "ByteArray": {
      switch (encoding.type) {
        case Encoding.IntDataType.Uint8:
          return data;
        case Encoding.IntDataType.Int8:
          return int8(data);
        case Encoding.IntDataType.Int16:
          return int16(data);
        case Encoding.IntDataType.Uint16:
          return uint16(data);
        case Encoding.IntDataType.Int32:
          return int32(data);
        case Encoding.IntDataType.Uint32:
          return uint32(data);
        case Encoding.FloatDataType.Float32:
          return float32(data);
        case Encoding.FloatDataType.Float64:
          return float64(data);
        default:
          assertUnreachable(encoding.type);
      }
    }
    case "FixedPoint":
      return fixedPoint(data, encoding);
    case "IntervalQuantization":
      return intervalQuantization(data, encoding);
    case "RunLength":
      return runLength(data, encoding);
    case "Delta":
      return delta(data, encoding);
    case "IntegerPacking":
      return integerPacking(data, encoding);
    case "StringArray":
      return stringArray(data, encoding);
  }
}
function getIntArray(type3, size) {
  switch (type3) {
    case Encoding.IntDataType.Int8:
      return new Int8Array(size);
    case Encoding.IntDataType.Int16:
      return new Int16Array(size);
    case Encoding.IntDataType.Int32:
      return new Int32Array(size);
    case Encoding.IntDataType.Uint8:
      return new Uint8Array(size);
    case Encoding.IntDataType.Uint16:
      return new Uint16Array(size);
    case Encoding.IntDataType.Uint32:
      return new Uint32Array(size);
    default:
      return new Int32Array(size);
  }
}
function getFloatArray(type3, size) {
  switch (type3) {
    case Encoding.FloatDataType.Float32:
      return new Float32Array(size);
    case Encoding.FloatDataType.Float64:
      return new Float64Array(size);
    default:
      return new Float64Array(size);
  }
}
function int8(data) {
  return new Int8Array(data.buffer, data.byteOffset);
}
function view(data, byteSize, c) {
  if (IsNativeEndianLittle)
    return new c(data.buffer);
  return new c(flipByteOrder(data, byteSize));
}
function int16(data) {
  return view(data, 2, Int16Array);
}
function uint16(data) {
  return view(data, 2, Uint16Array);
}
function int32(data) {
  return view(data, 4, Int32Array);
}
function uint32(data) {
  return view(data, 4, Uint32Array);
}
function float32(data) {
  return view(data, 4, Float32Array);
}
function float64(data) {
  return view(data, 8, Float64Array);
}
function fixedPoint(data, encoding) {
  const n = data.length;
  const output = getFloatArray(encoding.srcType, n);
  const f = 1 / encoding.factor;
  for (let i = 0; i < n; i++) {
    output[i] = f * data[i];
  }
  return output;
}
function intervalQuantization(data, encoding) {
  const n = data.length;
  const output = getFloatArray(encoding.srcType, n);
  const delta2 = (encoding.max - encoding.min) / (encoding.numSteps - 1);
  const min = encoding.min;
  for (let i = 0; i < n; i++) {
    output[i] = min + delta2 * data[i];
  }
  return output;
}
function runLength(data, encoding) {
  const output = getIntArray(encoding.srcType, encoding.srcSize);
  let dataOffset = 0;
  for (let i = 0, il = data.length; i < il; i += 2) {
    const value = data[i];
    const length = data[i + 1];
    for (let j = 0; j < length; ++j) {
      output[dataOffset++] = value;
    }
  }
  return output;
}
function delta(data, encoding) {
  const n = data.length;
  const output = getIntArray(encoding.srcType, n);
  if (!n)
    return data;
  output[0] = data[0] + (encoding.origin | 0);
  for (let i = 1; i < n; ++i) {
    output[i] = data[i] + output[i - 1];
  }
  return output;
}
function integerPackingSigned(data, encoding) {
  const upperLimit = encoding.byteCount === 1 ? 127 : 32767;
  const lowerLimit = -upperLimit - 1;
  const n = data.length;
  const output = new Int32Array(encoding.srcSize);
  let i = 0;
  let j = 0;
  while (i < n) {
    let value = 0, t = data[i];
    while (t === upperLimit || t === lowerLimit) {
      value += t;
      i++;
      t = data[i];
    }
    value += t;
    output[j] = value;
    i++;
    j++;
  }
  return output;
}
function integerPackingUnsigned(data, encoding) {
  const upperLimit = encoding.byteCount === 1 ? 255 : 65535;
  const n = data.length;
  const output = new Int32Array(encoding.srcSize);
  let i = 0;
  let j = 0;
  while (i < n) {
    let value = 0, t = data[i];
    while (t === upperLimit) {
      value += t;
      i++;
      t = data[i];
    }
    value += t;
    output[j] = value;
    i++;
    j++;
  }
  return output;
}
function integerPacking(data, encoding) {
  if (data.length === encoding.srcSize)
    return data;
  return encoding.isUnsigned ? integerPackingUnsigned(data, encoding) : integerPackingSigned(data, encoding);
}
function stringArray(data, encoding) {
  const offsets = decode({ encoding: encoding.offsetEncoding, data: encoding.offsets });
  const indices = decode({ encoding: encoding.dataEncoding, data });
  const str9 = encoding.stringData;
  const strings = new Array(offsets.length);
  strings[0] = "";
  for (let i = 1, _i = offsets.length; i < _i; i++) {
    strings[i] = str9.substring(offsets[i - 1], offsets[i]);
  }
  let offset = 0;
  const result2 = new Array(indices.length);
  for (let i = 0, _i = indices.length; i < _i; i++) {
    result2[offset++] = strings[indices[i] + 1];
  }
  return result2;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/number.js
function getMantissaMultiplier(v, maxDigits, delta2) {
  let m = 1, i;
  for (i = 0; i < maxDigits; i++) {
    const mv = m * v;
    if (Math.abs(Math.round(mv) - mv) <= delta2)
      return i;
    m *= 10;
  }
  return -1;
}
function integerDigitCount(v, delta2) {
  const f = Math.abs(v);
  if (f < delta2)
    return 0;
  return Math.floor(Math.log10(Math.abs(v))) + 1;
}
function getArrayDigitCount(xs, maxDigits, delta2) {
  let mantissaDigits = 1;
  let integerDigits = 0;
  for (let i = 0, _i = xs.length; i < _i; i++) {
    if (mantissaDigits >= 0) {
      const t = getMantissaMultiplier(xs[i], maxDigits, delta2);
      if (t < 0)
        mantissaDigits = -1;
      else if (t > mantissaDigits)
        mantissaDigits = t;
    }
    const abs = Math.abs(xs[i]);
    if (abs > delta2) {
      const d = Math.floor(Math.log10(Math.abs(abs))) + 1;
      if (d > integerDigits)
        integerDigits = d;
    }
  }
  return { mantissaDigits, integerDigits };
}
function isInteger(s) {
  s = s.trim();
  const n = parseInt(s, 10);
  return isNaN(n) ? false : n.toString() === s;
}
function getPrecision(v) {
  if (!isFinite(v))
    return 0;
  let e = 1;
  let p3 = 0;
  while (Math.round(v * e) / e !== v) {
    e *= 10;
    ++p3;
  }
  return p3;
}
function toPrecision(v, precision) {
  return parseFloat(v.toPrecision(precision));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/binary-cif/classifier.js
function classifyIntArray(xs) {
  return IntClassifier.classify(xs);
}
function classifyFloatArray(xs) {
  return FloatClassifier.classify(xs);
}
var IntClassifier;
(function(IntClassifier2) {
  function packSize(value, upperLimit) {
    return value >= 0 ? Math.ceil((value + 1) / upperLimit) : Math.ceil((value + 1) / (-upperLimit - 1));
  }
  function getInfo(data) {
    let signed = false;
    for (let i = 0, n = data.length; i < n; i++) {
      if (data[i] < 0) {
        signed = true;
        break;
      }
    }
    return signed ? { signed, limit8: 127, limit16: 32767 } : { signed, limit8: 255, limit16: 65535 };
  }
  function SizeInfo() {
    return { pack8: 0, pack16: 0, count: 0 };
  }
  ;
  function incSize({ limit8, limit16 }, info, value) {
    info.pack8 += packSize(value, limit8);
    info.pack16 += packSize(value, limit16);
    info.count += 1;
  }
  function incSizeSigned(info, value) {
    info.pack8 += packSize(value, 127);
    info.pack16 += packSize(value, 32767);
    info.count += 1;
  }
  function byteSize(info) {
    if (info.count * 4 < info.pack16 * 2)
      return { length: info.count * 4, elem: 4 };
    if (info.pack16 * 2 < info.pack8)
      return { length: info.pack16 * 2, elem: 2 };
    return { length: info.pack8, elem: 1 };
  }
  function packingSize(data, info) {
    const size = SizeInfo();
    for (let i = 0, n = data.length; i < n; i++) {
      incSize(info, size, data[i]);
    }
    return { ...byteSize(size), kind: "pack" };
  }
  function deltaSize(data, info) {
    const size = SizeInfo();
    let prev = data[0];
    for (let i = 1, n = data.length; i < n; i++) {
      incSizeSigned(size, data[i] - prev);
      prev = data[i];
    }
    return { ...byteSize(size), kind: "delta" };
  }
  function rleSize(data, info) {
    const size = SizeInfo();
    let run = 1;
    for (let i = 1, n = data.length; i < n; i++) {
      if (data[i - 1] !== data[i]) {
        incSize(info, size, data[i - 1]);
        incSize(info, size, run);
        run = 1;
      } else {
        run++;
      }
    }
    incSize(info, size, data[data.length - 1]);
    incSize(info, size, run);
    return { ...byteSize(size), kind: "rle" };
  }
  function deltaRleSize(data, info) {
    const size = SizeInfo();
    let run = 1, prev = 0, prevValue = 0;
    for (let i = 1, n = data.length; i < n; i++) {
      const v = data[i] - prev;
      if (prevValue !== v) {
        incSizeSigned(size, prevValue);
        incSizeSigned(size, run);
        run = 1;
      } else {
        run++;
      }
      prevValue = v;
      prev = data[i];
    }
    incSizeSigned(size, prevValue);
    incSizeSigned(size, run);
    return { ...byteSize(size), kind: "delta-rle" };
  }
  function getSize(data) {
    const info = getInfo(data);
    const sizes = [packingSize(data, info), rleSize(data, info), deltaSize(data, info), deltaRleSize(data, info)];
    sizes.sort((a, b) => a.length - b.length);
    return sizes;
  }
  IntClassifier2.getSize = getSize;
  function classify2(data) {
    if (data.length < 2)
      return ArrayEncoding.by(ArrayEncoding.byteArray);
    const sizes = getSize(data);
    const size = sizes[0];
    switch (size.kind) {
      case "pack":
        return ArrayEncoding.by(ArrayEncoding.integerPacking);
      case "rle":
        return ArrayEncoding.by(ArrayEncoding.runLength).and(ArrayEncoding.integerPacking);
      case "delta":
        return ArrayEncoding.by(ArrayEncoding.delta).and(ArrayEncoding.integerPacking);
      case "delta-rle":
        return ArrayEncoding.by(ArrayEncoding.delta).and(ArrayEncoding.runLength).and(ArrayEncoding.integerPacking);
      default:
        assertUnreachable(size);
    }
  }
  IntClassifier2.classify = classify2;
})(IntClassifier || (IntClassifier = {}));
var FloatClassifier;
(function(FloatClassifier2) {
  const delta2 = 1e-6;
  function classify2(data) {
    const maxDigits = 4;
    const { mantissaDigits, integerDigits } = getArrayDigitCount(data, maxDigits, delta2);
    if (mantissaDigits < 0 || mantissaDigits + integerDigits > 10)
      return ArrayEncoding.by(ArrayEncoding.byteArray);
    if (mantissaDigits === 0)
      return IntClassifier.classify(data);
    const multiplier = getMultiplier(mantissaDigits);
    const intArray = new Int32Array(data.length);
    for (let i = 0, n = data.length; i < n; i++) {
      intArray[i] = Math.round(multiplier * data[i]);
    }
    const sizes = IntClassifier.getSize(intArray);
    const size = sizes[0];
    const fp = ArrayEncoding.by(ArrayEncoding.fixedPoint(multiplier));
    switch (size.kind) {
      case "pack":
        return fp.and(ArrayEncoding.integerPacking);
      case "rle":
        return fp.and(ArrayEncoding.runLength).and(ArrayEncoding.integerPacking);
      case "delta":
        return fp.and(ArrayEncoding.delta).and(ArrayEncoding.integerPacking);
      case "delta-rle":
        return fp.and(ArrayEncoding.delta).and(ArrayEncoding.runLength).and(ArrayEncoding.integerPacking);
      default:
        assertUnreachable(size);
    }
  }
  FloatClassifier2.classify = classify2;
  function getMultiplier(mantissaDigits) {
    let m = 1;
    for (let i = 0; i < mantissaDigits; i++)
      m *= 10;
    return m;
  }
})(FloatClassifier || (FloatClassifier = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/binary-cif/array-encoder.js
var ArrayEncoderImpl = class _ArrayEncoderImpl {
  and(f) {
    return new _ArrayEncoderImpl(this.providers.concat([f]));
  }
  encode(data) {
    const encoding = [];
    for (const p3 of this.providers) {
      const t = p3(data);
      if (!t.encodings.length) {
        throw new Error("Encodings must be non-empty.");
      }
      data = t.data;
      for (const e of t.encodings) {
        encoding.push(e);
      }
    }
    if (!(data instanceof Uint8Array)) {
      throw new Error("The encoding must result in a Uint8Array. Fix your encoding chain.");
    }
    return {
      encoding,
      data
    };
  }
  constructor(providers) {
    this.providers = providers;
  }
};
var ArrayEncoder;
(function(ArrayEncoder2) {
  function by(f) {
    return new ArrayEncoderImpl([f]);
  }
  ArrayEncoder2.by = by;
  function fromEncoding(encoding) {
    let e = by(getProvider(encoding[0]));
    for (let i = 1; i < encoding.length; i++) {
      if (encoding[i - 1].kind === "IntegerPacking")
        break;
      e = e.and(getProvider(encoding[i]));
    }
    return e;
  }
  ArrayEncoder2.fromEncoding = fromEncoding;
  function getProvider(e) {
    switch (e.kind) {
      case "ByteArray":
        return ArrayEncoding.byteArray;
      case "FixedPoint":
        return ArrayEncoding.fixedPoint(e.factor);
      case "IntervalQuantization":
        return ArrayEncoding.intervalQuantizaiton(e.min, e.max, e.numSteps);
      case "RunLength":
        return ArrayEncoding.runLength;
      case "Delta":
        return ArrayEncoding.delta;
      case "IntegerPacking":
        return ArrayEncoding.integerPacking;
      case "StringArray":
        return ArrayEncoding.stringArray;
    }
  }
})(ArrayEncoder || (ArrayEncoder = {}));
var ArrayEncoding;
(function(ArrayEncoding2) {
  function by(f) {
    return new ArrayEncoderImpl([f]);
  }
  ArrayEncoding2.by = by;
  function uint8(data) {
    return {
      encodings: [{ kind: "ByteArray", type: Encoding.IntDataType.Uint8 }],
      data
    };
  }
  function int82(data) {
    return {
      encodings: [{ kind: "ByteArray", type: Encoding.IntDataType.Int8 }],
      data: new Uint8Array(data.buffer, data.byteOffset)
    };
  }
  const writers = {
    [Encoding.IntDataType.Int16]: function(v, i, a) {
      v.setInt16(2 * i, a, true);
    },
    [Encoding.IntDataType.Uint16]: function(v, i, a) {
      v.setUint16(2 * i, a, true);
    },
    [Encoding.IntDataType.Int32]: function(v, i, a) {
      v.setInt32(4 * i, a, true);
    },
    [Encoding.IntDataType.Uint32]: function(v, i, a) {
      v.setUint32(4 * i, a, true);
    },
    [Encoding.FloatDataType.Float32]: function(v, i, a) {
      v.setFloat32(4 * i, a, true);
    },
    [Encoding.FloatDataType.Float64]: function(v, i, a) {
      v.setFloat64(8 * i, a, true);
    }
  };
  const byteSizes = {
    [Encoding.IntDataType.Int16]: 2,
    [Encoding.IntDataType.Uint16]: 2,
    [Encoding.IntDataType.Int32]: 4,
    [Encoding.IntDataType.Uint32]: 4,
    [Encoding.FloatDataType.Float32]: 4,
    [Encoding.FloatDataType.Float64]: 8
  };
  function byteArray(data) {
    const type3 = Encoding.getDataType(data);
    if (type3 === Encoding.IntDataType.Int8)
      return int82(data);
    else if (type3 === Encoding.IntDataType.Uint8)
      return uint8(data);
    const result2 = new Uint8Array(data.length * byteSizes[type3]);
    const w = writers[type3];
    const view2 = new DataView(result2.buffer);
    for (let i = 0, n = data.length; i < n; i++) {
      w(view2, i, data[i]);
    }
    return {
      encodings: [{ kind: "ByteArray", type: type3 }],
      data: result2
    };
  }
  ArrayEncoding2.byteArray = byteArray;
  function _fixedPoint(data, factor) {
    const srcType = Encoding.getDataType(data);
    const result2 = new Int32Array(data.length);
    for (let i = 0, n = data.length; i < n; i++) {
      result2[i] = Math.round(data[i] * factor);
    }
    return {
      encodings: [{ kind: "FixedPoint", factor, srcType }],
      data: result2
    };
  }
  function fixedPoint2(factor) {
    return (data) => _fixedPoint(data, factor);
  }
  ArrayEncoding2.fixedPoint = fixedPoint2;
  function _intervalQuantizaiton(data, min, max, numSteps, arrayType) {
    const srcType = Encoding.getDataType(data);
    if (!data.length) {
      return {
        encodings: [{ kind: "IntervalQuantization", min, max, numSteps, srcType }],
        data: new Int32Array(0)
      };
    }
    if (max < min) {
      const t = min;
      min = max;
      max = t;
    }
    const delta3 = (max - min) / (numSteps - 1);
    const output = new arrayType(data.length);
    for (let i = 0, n = data.length; i < n; i++) {
      const v = data[i];
      if (v <= min)
        output[i] = 0;
      else if (v >= max)
        output[i] = numSteps - 1;
      else
        output[i] = Math.round((v - min) / delta3) | 0;
    }
    return {
      encodings: [{ kind: "IntervalQuantization", min, max, numSteps, srcType }],
      data: output
    };
  }
  function intervalQuantizaiton(min, max, numSteps, arrayType = Int32Array) {
    return (data) => _intervalQuantizaiton(data, min, max, numSteps, arrayType);
  }
  ArrayEncoding2.intervalQuantizaiton = intervalQuantizaiton;
  function runLength2(data) {
    let srcType = Encoding.getDataType(data);
    if (srcType === void 0) {
      data = new Int32Array(data);
      srcType = Encoding.IntDataType.Int32;
    }
    if (!data.length) {
      return {
        encodings: [{ kind: "RunLength", srcType, srcSize: 0 }],
        data: new Int32Array(0)
      };
    }
    let fullLength = 2;
    for (let i = 1, il = data.length; i < il; i++) {
      if (data[i - 1] !== data[i]) {
        fullLength += 2;
      }
    }
    const output = new Int32Array(fullLength);
    let offset = 0;
    let runLength3 = 1;
    for (let i = 1, il = data.length; i < il; i++) {
      if (data[i - 1] !== data[i]) {
        output[offset] = data[i - 1];
        output[offset + 1] = runLength3;
        runLength3 = 1;
        offset += 2;
      } else {
        ++runLength3;
      }
    }
    output[offset] = data[data.length - 1];
    output[offset + 1] = runLength3;
    return {
      encodings: [{ kind: "RunLength", srcType, srcSize: data.length }],
      data: output
    };
  }
  ArrayEncoding2.runLength = runLength2;
  function delta2(data) {
    if (!Encoding.isSignedIntegerDataType(data)) {
      throw new Error("Only signed integer types can be encoded using delta encoding.");
    }
    let srcType = Encoding.getDataType(data);
    if (srcType === void 0) {
      data = new Int32Array(data);
      srcType = Encoding.IntDataType.Int32;
    }
    if (!data.length) {
      return {
        encodings: [{ kind: "Delta", origin: 0, srcType }],
        data: new data.constructor(0)
      };
    }
    const output = new data.constructor(data.length);
    const origin = data[0];
    output[0] = data[0];
    for (let i = 1, n = data.length; i < n; i++) {
      output[i] = data[i] - data[i - 1];
    }
    output[0] = 0;
    return {
      encodings: [{ kind: "Delta", origin, srcType }],
      data: output
    };
  }
  ArrayEncoding2.delta = delta2;
  function isSigned(data) {
    for (let i = 0, n = data.length; i < n; i++) {
      if (data[i] < 0)
        return true;
    }
    return false;
  }
  function packingSizeUnsigned(data, upperLimit) {
    let size = 0;
    for (let i = 0, n = data.length; i < n; i++) {
      size += data[i] / upperLimit | 0;
    }
    size += data.length;
    return size;
  }
  function packingSizeSigned(data, upperLimit) {
    const lowerLimit = -upperLimit - 1;
    let size = 0;
    for (let i = 0, n = data.length; i < n; i++) {
      const value = data[i];
      if (value >= 0) {
        size += value / upperLimit | 0;
      } else {
        size += value / lowerLimit | 0;
      }
    }
    size += data.length;
    return size;
  }
  function determinePacking(data) {
    const signed = isSigned(data);
    const size8 = signed ? packingSizeSigned(data, 127) : packingSizeUnsigned(data, 255);
    const size16 = signed ? packingSizeSigned(data, 32767) : packingSizeUnsigned(data, 65535);
    if (data.length * 4 < size16 * 2) {
      return {
        isSigned: signed,
        size: data.length,
        bytesPerElement: 4
      };
    } else if (size16 * 2 < size8) {
      return {
        isSigned: signed,
        size: size16,
        bytesPerElement: 2
      };
    } else {
      return {
        isSigned: signed,
        size: size8,
        bytesPerElement: 1
      };
    }
    ;
  }
  function _integerPacking(data, packing) {
    const upperLimit = packing.isSigned ? packing.bytesPerElement === 1 ? 127 : 32767 : packing.bytesPerElement === 1 ? 255 : 65535;
    const lowerLimit = -upperLimit - 1;
    const n = data.length;
    const packed = packing.isSigned ? packing.bytesPerElement === 1 ? new Int8Array(packing.size) : new Int16Array(packing.size) : packing.bytesPerElement === 1 ? new Uint8Array(packing.size) : new Uint16Array(packing.size);
    let j = 0;
    for (let i = 0; i < n; i++) {
      let value = data[i];
      if (value >= 0) {
        while (value >= upperLimit) {
          packed[j] = upperLimit;
          ++j;
          value -= upperLimit;
        }
      } else {
        while (value <= lowerLimit) {
          packed[j] = lowerLimit;
          ++j;
          value -= lowerLimit;
        }
      }
      packed[j] = value;
      ++j;
    }
    const result2 = byteArray(packed);
    return {
      encodings: [
        {
          kind: "IntegerPacking",
          byteCount: packing.bytesPerElement,
          isUnsigned: !packing.isSigned,
          srcSize: n
        },
        result2.encodings[0]
      ],
      data: result2.data
    };
  }
  function integerPacking2(data) {
    const packing = determinePacking(data);
    if (packing.bytesPerElement === 4) {
      return byteArray(data);
    }
    return _integerPacking(data, packing);
  }
  ArrayEncoding2.integerPacking = integerPacking2;
  function stringArray2(data) {
    const map2 = /* @__PURE__ */ Object.create(null);
    const strings = [];
    const output = new Int32Array(data.length);
    const offsets = ChunkedArray.create(Int32Array, 1, Math.min(1024, data.length < 32 ? data.length + 1 : Math.round(data.length / 8) + 1));
    ChunkedArray.add(offsets, 0);
    let accLength = 0;
    let i = 0;
    for (const s of data) {
      if (s === null || s === void 0) {
        output[i++] = -1;
        continue;
      }
      let index = map2[s];
      if (index === void 0) {
        accLength += s.length;
        index = strings.length;
        strings[index] = s;
        map2[s] = index;
        ChunkedArray.add(offsets, accLength);
      }
      output[i++] = index;
    }
    const offsetArray = ChunkedArray.compact(offsets);
    const offsetEncoding = classifyIntArray(offsetArray);
    const encodedOddsets = offsetEncoding.encode(offsetArray);
    const dataEncoding = classifyIntArray(output);
    const encodedData = dataEncoding.encode(output);
    return {
      encodings: [{ kind: "StringArray", dataEncoding: encodedData.encoding, stringData: strings.join(""), offsetEncoding: encodedOddsets.encoding, offsets: encodedOddsets.data }],
      data: encodedData.data
    };
  }
  ArrayEncoding2.stringArray = stringArray2;
})(ArrayEncoding || (ArrayEncoding = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/writer/cif/encoder.js
var Field;
(function(Field3) {
  let Type2;
  (function(Type3) {
    Type3[Type3["Str"] = 0] = "Str";
    Type3[Type3["Int"] = 1] = "Int";
    Type3[Type3["Float"] = 2] = "Float";
  })(Type2 = Field3.Type || (Field3.Type = {}));
  function str9(name, value, params) {
    return { name, type: Type2.Str, value, valueKind: params && params.valueKind, defaultFormat: params && params.encoder ? { encoder: params.encoder } : void 0, shouldInclude: params && params.shouldInclude };
  }
  Field3.str = str9;
  function int7(name, value, params) {
    return {
      name,
      type: Type2.Int,
      value,
      valueKind: params && params.valueKind,
      defaultFormat: params ? { encoder: params.encoder, typedArray: params.typedArray } : void 0,
      shouldInclude: params && params.shouldInclude
    };
  }
  Field3.int = int7;
  function float7(name, value, params) {
    return {
      name,
      type: Type2.Float,
      value,
      valueKind: params && params.valueKind,
      defaultFormat: params ? { encoder: params.encoder, typedArray: params.typedArray, digitCount: typeof params.digitCount !== "undefined" ? params.digitCount : void 0 } : void 0,
      shouldInclude: params && params.shouldInclude
    };
  }
  Field3.float = float7;
  function index(name) {
    return int7(name, (e, d, i) => i + 1, { typedArray: Int32Array, encoder: ArrayEncoding.by(ArrayEncoding.delta).and(ArrayEncoding.runLength).and(ArrayEncoding.integerPacking) });
  }
  Field3.index = index;
  class Builder {
    constructor() {
      this.fields = [];
    }
    index(name) {
      this.fields.push(Field3.index(name));
      return this;
    }
    str(name, value, params) {
      this.fields.push(Field3.str(name, value, params));
      return this;
    }
    int(name, value, params) {
      this.fields.push(Field3.int(name, value, params));
      return this;
    }
    vec(name, values, params) {
      for (let i = 0; i < values.length; i++) {
        this.fields.push(Field3.int(`${name}[${i + 1}]`, values[i], params));
      }
      return this;
    }
    float(name, value, params) {
      this.fields.push(Field3.float(name, value, params));
      return this;
    }
    many(fields) {
      for (let i = 0; i < fields.length; i++)
        this.fields.push(fields[i]);
      return this;
    }
    add(field) {
      this.fields.push(field);
      return this;
    }
    getFields() {
      return this.fields;
    }
  }
  Field3.Builder = Builder;
  function build2() {
    return new Builder();
  }
  Field3.build = build2;
})(Field || (Field = {}));
var Category;
(function(Category5) {
  Category5.Empty = { fields: [], source: [] };
  function filterOf(directives) {
    const cat_whitelist = [];
    const cat_blacklist = [];
    const field_whitelist = [];
    const field_blacklist = [];
    for (let d of directives.split(/[\r\n]+/)) {
      d = d.trim();
      if (d.length === 0)
        continue;
      const blacklist = /^!/.test(d);
      if (blacklist)
        d = d.substr(1);
      const split = d.split(/\./);
      const field = split[1];
      const list2 = blacklist ? field ? field_blacklist : cat_blacklist : field ? field_whitelist : cat_whitelist;
      list2[list2.length] = d;
      if (field && !cat_whitelist.includes(split[0])) {
        cat_whitelist[cat_whitelist.length] = split[0];
      }
    }
    const wlcatcol = field_whitelist.map((it) => it.split(".")[0]);
    return {
      includeCategory(cat) {
        if (cat_blacklist.includes(cat)) {
          return false;
        } else {
          return cat_whitelist.length <= 0 || // otherwise include if whitelist contains category
          cat_whitelist.indexOf(cat) !== -1;
        }
      },
      includeField(cat, field) {
        const full = cat + "." + field;
        if (field_blacklist.includes(full)) {
          return false;
        } else {
          return !wlcatcol.includes(cat) || // otherwise must be specifically allowed
          field_whitelist.includes(full);
        }
      }
    };
  }
  Category5.filterOf = filterOf;
  Category5.DefaultFilter = {
    includeCategory(cat) {
      return true;
    },
    includeField(cat, field) {
      return true;
    }
  };
  Category5.DefaultFormatter = {
    getFormat(cat, field) {
      return void 0;
    }
  };
  function ofTable(table, indices) {
    if (indices) {
      return {
        fields: cifFieldsFromTableSchema(table._schema),
        source: [{ data: table, rowCount: indices.length, keys: () => Iterator.Array(indices) }]
      };
    }
    return {
      fields: cifFieldsFromTableSchema(table._schema),
      source: [{ data: table, rowCount: table._rowCount }]
    };
  }
  Category5.ofTable = ofTable;
})(Category || (Category = {}));
var Encoder;
(function(Encoder2) {
  function writeDatabase(encoder, name, database) {
    encoder.startDataBlock(name);
    for (const table of database._tableNames) {
      encoder.writeCategory({ name: table, instance: () => Category.ofTable(database[table]) });
    }
  }
  Encoder2.writeDatabase = writeDatabase;
  function writeDatabaseCollection(encoder, collection) {
    for (const name of Object.keys(collection)) {
      writeDatabase(encoder, name, collection[name]);
    }
  }
  Encoder2.writeDatabaseCollection = writeDatabaseCollection;
})(Encoder || (Encoder = {}));
function columnValue(k) {
  return (i, d) => d[k].value(i);
}
function columnListValue(k) {
  return (i, d) => d[k].value(i).join(d[k].schema.separator);
}
function columnTensorValue(k, ...coords) {
  return (i, d) => d[k].schema.space.get(d[k].value(i), ...coords);
}
function columnValueKind(k) {
  return (i, d) => d[k].valueKind(i);
}
function getTensorDefinitions(field, space) {
  const fieldDefinitions = [];
  const type3 = Field.Type.Float;
  const valueKind = columnValueKind(field);
  if (space.rank === 1) {
    const rows = space.dimensions[0];
    for (let i = 0; i < rows; i++) {
      const name = `${field}[${i + 1}]`;
      fieldDefinitions.push({ name, type: type3, value: columnTensorValue(field, i), valueKind });
    }
  } else if (space.rank === 2) {
    const rows = space.dimensions[0], cols = space.dimensions[1];
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        const name = `${field}[${i + 1}][${j + 1}]`;
        fieldDefinitions.push({ name, type: type3, value: columnTensorValue(field, i, j), valueKind });
      }
    }
  } else if (space.rank === 3) {
    const d0 = space.dimensions[0], d1 = space.dimensions[1], d2 = space.dimensions[2];
    for (let i = 0; i < d0; i++) {
      for (let j = 0; j < d1; j++) {
        for (let k = 0; k < d2; k++) {
          const name = `${field}[${i + 1}][${j + 1}][${k + 1}]`;
          fieldDefinitions.push({ name, type: type3, value: columnTensorValue(field, i, j, k), valueKind });
        }
      }
    }
  } else {
    throw new Error("Tensors with rank > 3 or rank 0 are currently not supported.");
  }
  return fieldDefinitions;
}
function cifFieldsFromTableSchema(schema) {
  const fields = [];
  for (const k of Object.keys(schema)) {
    const t = schema[k];
    if (t.valueType === "int") {
      fields.push({ name: k, type: Field.Type.Int, value: columnValue(k), valueKind: columnValueKind(k) });
    } else if (t.valueType === "float") {
      fields.push({ name: k, type: Field.Type.Float, value: columnValue(k), valueKind: columnValueKind(k) });
    } else if (t.valueType === "str") {
      fields.push({ name: k, type: Field.Type.Str, value: columnValue(k), valueKind: columnValueKind(k) });
    } else if (t.valueType === "list") {
      fields.push({ name: k, type: Field.Type.Str, value: columnListValue(k), valueKind: columnValueKind(k) });
    } else if (t.valueType === "tensor") {
      fields.push(...getTensorDefinitions(k, t.space));
    } else {
      assertUnreachable(t.valueType);
    }
  }
  return fields;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/writer/cif/encoder/util.js
function getFieldDigitCount(field) {
  if (field.defaultFormat && typeof field.defaultFormat.digitCount !== "undefined")
    return Math.max(0, Math.min(field.defaultFormat.digitCount, 16));
  return 6;
}
function getIncludedFields(category) {
  return category.fields.some((f) => !!f.shouldInclude) ? category.fields.filter((f) => !f.shouldInclude || category.source.some((src) => f.shouldInclude(src.data))) : category.fields;
}
function getCategoryInstanceData(category, ctx) {
  const instance = category.instance(ctx);
  const sources = instance.source.filter((s) => s.rowCount > 0);
  if (!sources.length)
    return { instance, rowCount: 0, source: [] };
  const rowCount = sources.reduce((a, c) => a + c.rowCount, 0);
  const source = sources.map((c) => ({
    data: c.data,
    keys: () => c.keys ? c.keys() : Iterator.Range(0, c.rowCount - 1),
    rowCount: c.rowCount
  }));
  return { instance, rowCount, source };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/writer/cif/encoder/text.js
var TextEncoder = class {
  constructor() {
    this.builder = StringBuilder.create();
    this.encoded = false;
    this.dataBlockCreated = false;
    this.filter = Category.DefaultFilter;
    this.formatter = Category.DefaultFormatter;
    this.isBinary = false;
    this.binaryEncodingProvider = void 0;
  }
  setFilter(filter2) {
    this.filter = filter2 || Category.DefaultFilter;
  }
  isCategoryIncluded(name) {
    return this.filter.includeCategory(name);
  }
  setFormatter(formatter) {
    this.formatter = formatter || Category.DefaultFormatter;
  }
  startDataBlock(header) {
    this.dataBlockCreated = true;
    StringBuilder.write(this.builder, `data_${(header || "").replace(/[ \n\t]/g, "").toUpperCase()}
#
`);
  }
  writeCategory(category, context, options) {
    if (this.encoded) {
      throw new Error("The writer contents have already been encoded, no more writing.");
    }
    if (!this.dataBlockCreated) {
      throw new Error("No data block created.");
    }
    if (!(options === null || options === void 0 ? void 0 : options.ignoreFilter) && !this.filter.includeCategory(category.name))
      return;
    const { instance, rowCount, source } = getCategoryInstanceData(category, context);
    if (!rowCount)
      return;
    if (rowCount === 1) {
      writeCifSingleRecord(category, instance, source, this.builder, this.filter, this.formatter);
    } else {
      writeCifLoop(category, instance, source, this.builder, this.filter, this.formatter);
    }
  }
  encode() {
    this.encoded = true;
  }
  writeTo(stream) {
    const chunks = StringBuilder.getChunks(this.builder);
    for (let i = 0, _i = chunks.length; i < _i; i++) {
      stream.writeString(chunks[i]);
    }
  }
  getSize() {
    return StringBuilder.getSize(this.builder);
  }
  getData() {
    return StringBuilder.getString(this.builder);
  }
};
function writeValue(builder, data, key, f, floatPrecision, index) {
  const kind = f.valueKind;
  const p3 = kind ? kind(key, data) : Column.ValueKinds.Present;
  if (p3 !== Column.ValueKinds.Present) {
    if (p3 === Column.ValueKinds.NotPresent)
      writeNotPresent(builder);
    else
      writeUnknown(builder);
  } else {
    const val = f.value(key, data, index);
    const t = f.type;
    if (t === Field.Type.Str) {
      if (isMultiline(val)) {
        writeMultiline(builder, val);
        return true;
      } else {
        return writeChecked(builder, val);
      }
    } else if (t === Field.Type.Int) {
      writeInteger(builder, val);
    } else {
      writeFloat(builder, val, floatPrecision);
    }
  }
  return false;
}
function getFloatPrecisions(categoryName, fields, formatter) {
  const ret = [];
  for (const f of fields) {
    const format = formatter.getFormat(categoryName, f.name);
    if (format && typeof format.digitCount !== "undefined")
      ret[ret.length] = f.type === Field.Type.Float ? Math.pow(10, Math.max(0, Math.min(format.digitCount, 15))) : 0;
    else
      ret[ret.length] = f.type === Field.Type.Float ? Math.pow(10, getFieldDigitCount(f)) : 0;
  }
  return ret;
}
function writeCifSingleRecord(category, instance, source, builder, filter2, formatter) {
  const fields = getIncludedFields(instance);
  const src = source[0];
  const data = src.data;
  let width = fields.reduce((w, f) => filter2.includeField(category.name, f.name) ? Math.max(w, f.name.length) : 0, 0);
  if (width === 0)
    return;
  width += category.name.length + 6;
  const it = src.keys();
  const key = it.move();
  const precisions = getFloatPrecisions(category.name, instance.fields, formatter);
  for (let _f = 0; _f < fields.length; _f++) {
    const f = fields[_f];
    if (!filter2.includeField(category.name, f.name))
      continue;
    StringBuilder.writePadRight(builder, `_${category.name}.${f.name}`, width);
    const multiline = writeValue(builder, data, key, f, precisions[_f], 0);
    if (!multiline)
      StringBuilder.newline(builder);
  }
  StringBuilder.write(builder, "#\n");
}
function writeCifLoop(category, instance, source, builder, filter2, formatter) {
  const fieldSource = getIncludedFields(instance);
  const fields = filter2 === Category.DefaultFilter ? fieldSource : fieldSource.filter((f) => filter2.includeField(category.name, f.name));
  const fieldCount = fields.length;
  if (fieldCount === 0)
    return;
  const precisions = getFloatPrecisions(category.name, fields, formatter);
  writeLine(builder, "loop_");
  for (let i = 0; i < fieldCount; i++) {
    writeLine(builder, `_${category.name}.${fields[i].name}`);
  }
  let index = 0;
  for (let _c = 0; _c < source.length; _c++) {
    const src = source[_c];
    const data = src.data;
    if (src.rowCount === 0)
      continue;
    const it = src.keys();
    while (it.hasNext) {
      const key = it.move();
      let multiline = false;
      for (let _f = 0; _f < fieldCount; _f++) {
        multiline = writeValue(builder, data, key, fields[_f], precisions[_f], index);
      }
      if (!multiline)
        StringBuilder.newline(builder);
      index++;
    }
  }
  StringBuilder.write(builder, "#\n");
}
function isMultiline(value) {
  return typeof value === "string" && value.indexOf("\n") >= 0;
}
function writeLine(builder, val) {
  StringBuilder.write(builder, val);
  StringBuilder.newline(builder);
}
function writeInteger(builder, val) {
  StringBuilder.writeInteger(builder, val);
  StringBuilder.whitespace1(builder);
}
function writeFloat(builder, val, precisionMultiplier) {
  StringBuilder.writeFloat(builder, val, precisionMultiplier);
  StringBuilder.whitespace1(builder);
}
function writeNotPresent(builder) {
  StringBuilder.writeSafe(builder, ". ");
}
function writeUnknown(builder) {
  StringBuilder.writeSafe(builder, "? ");
}
function writeChecked(builder, val) {
  if (!val) {
    StringBuilder.writeSafe(builder, ". ");
    return false;
  }
  const fst = val.charCodeAt(0);
  let escape = false;
  let escapeKind = 0;
  let hasSingleQuote = false, hasDoubleQuote = false;
  for (let i = 0, _l = val.length - 1; i <= _l; i++) {
    const c = val.charCodeAt(i);
    switch (c) {
      case 9:
        escape = true;
        break;
      case 10:
        writeMultiline(builder, val);
        return true;
      case 32:
        escape = true;
        break;
      case 34:
        if (i && i === _l)
          break;
        if (hasSingleQuote) {
          writeMultiline(builder, val);
          return true;
        }
        hasDoubleQuote = true;
        escape = true;
        escapeKind = 0;
        break;
      case 39:
        if (i && i === _l)
          break;
        if (hasDoubleQuote) {
          writeMultiline(builder, val);
          return true;
        }
        hasSingleQuote = true;
        escape = true;
        escapeKind = 1;
        break;
    }
  }
  if (!escape && (fst === 35 || fst === 36 || fst === 59 || fst === 91 || fst === 93 || fst === 95)) {
    escape = true;
  }
  if (escape) {
    StringBuilder.writeSafe(builder, escapeKind ? '"' : "'");
    StringBuilder.writeSafe(builder, val);
    StringBuilder.writeSafe(builder, escapeKind ? '" ' : "' ");
  } else {
    StringBuilder.writeSafe(builder, val);
    StringBuilder.writeSafe(builder, " ");
  }
  return false;
}
function writeMultiline(builder, val) {
  StringBuilder.writeSafe(builder, "\n;" + val);
  StringBuilder.writeSafe(builder, "\n;\n");
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/string-like.js
var StringLike = {
  /** Return true if `obj` is instance of `StringLike` */
  is(obj) {
    return typeof obj.charCodeAt === "function";
  },
  /** Try to convert `StringLike` to a primitive `string`. Might fail if the content is longer that max allowed string length. */
  toString(str9) {
    try {
      return str9.toString();
    } catch (err) {
      throw new Error(`Failed to convert StringLike object into string. This might be because the length ${str9.length} exceeds maximum allowed string length ${MAX_STRING_LENGTH}. (${err})`);
    }
  }
};
var MAX_STRING_LENGTH = 536870888;
var DEFAULT_LOG_STRING_CHUNK_SIZE = 28;
var ChunkedBigString = class _ChunkedBigString {
  get length() {
    return this._length;
  }
  constructor(logStringChunkSize = DEFAULT_LOG_STRING_CHUNK_SIZE) {
    this._chunks = [];
    this._length = 0;
    this._tmpArray = [];
    this.STRING_CHUNK_SIZE = 2 ** logStringChunkSize;
    this.STRING_CHUNK_SHIFT = logStringChunkSize;
    this.STRING_CHUNK_MASK = 2 ** logStringChunkSize - 1;
  }
  static fromString(content, logStringChunkSize = DEFAULT_LOG_STRING_CHUNK_SIZE) {
    const out = new _ChunkedBigString(logStringChunkSize);
    out._append(content);
    return out;
  }
  static fromStrings(content, logStringChunkSize = DEFAULT_LOG_STRING_CHUNK_SIZE) {
    const out = new _ChunkedBigString(logStringChunkSize);
    for (const inputChunk of content) {
      out._append(inputChunk);
    }
    return out;
  }
  /** Create instance from UTF8 data. (Do not call directly, prefer `utf8ReadLong` in utf8.ts.) */
  static fromUtf8Data(data, start = 0, end = data.length, logStringChunkSize = DEFAULT_LOG_STRING_CHUNK_SIZE) {
    const bufferChunkSize = 2 ** logStringChunkSize;
    const stringChunks = [];
    let readStart = start;
    while (readStart < end) {
      let readEnd = Math.min(readStart + bufferChunkSize, end);
      if (readEnd < end) {
        while ((data[readEnd] & 192) === 128) {
          readEnd--;
          if (readEnd === readStart)
            throw new Error("Input is rubbish, no UTF-8 character start found in a chunk");
        }
      }
      const stringChunk = utf8Read(data, readStart, readEnd - readStart);
      stringChunks.push(stringChunk);
      readStart = readEnd;
    }
    return _ChunkedBigString.fromStrings(stringChunks, logStringChunkSize);
  }
  _append(inputChunk) {
    const chunkSize = this.STRING_CHUNK_SIZE;
    const tail = this._chunks.length === 0 || this._chunks[this._chunks.length - 1].length === chunkSize ? "" : this._chunks.pop();
    let inputPtr = chunkSize - tail.length;
    this._chunks.push(tail + inputChunk.substring(0, inputPtr));
    while (inputPtr < inputChunk.length) {
      this._chunks.push(inputChunk.substring(inputPtr, inputPtr + chunkSize));
      inputPtr += chunkSize;
    }
    this._length += inputChunk.length;
  }
  _getChunkIndex(index) {
    return index >>> this.STRING_CHUNK_SHIFT;
  }
  _getIndexInChunk(index) {
    return index & this.STRING_CHUNK_MASK;
  }
  _isOutOfRange(index) {
    return index < 0 || index >= this.length;
  }
  at(index) {
    if (-this.length <= index && index < 0) {
      return this.at(index + this.length);
    }
    return this.charAt(index) || void 0;
  }
  charAt(index) {
    if (this._isOutOfRange(index))
      return "";
    const iChunk = this._getChunkIndex(index);
    const indexInChunk = this._getIndexInChunk(index);
    return this._chunks[iChunk][indexInChunk];
  }
  charCodeAt(index) {
    if (this._isOutOfRange(index))
      return NaN;
    const iChunk = this._getChunkIndex(index);
    const indexInChunk = this._getIndexInChunk(index);
    return this._chunks[iChunk].charCodeAt(indexInChunk);
  }
  substring(start, end) {
    const start_ = Math.min(Math.max(start !== null && start !== void 0 ? start : 0, 0), this.length);
    const end_ = Math.min(Math.max(end !== null && end !== void 0 ? end : this.length, 0), this.length);
    if (start_ > end_) {
      return this.substring(end_, start_);
    }
    if (start_ === end_) {
      return "";
    }
    if (end_ - start_ > MAX_STRING_LENGTH) {
      throw new Error(`Trying to create get a substring longer (${end_ - start_}) than maximum allowed string length (${MAX_STRING_LENGTH}).`);
    }
    const iFirstChunk = this._getChunkIndex(start_);
    const indexInChunkFrom = this._getIndexInChunk(start_);
    const iLastChunk = this._getChunkIndex(end_);
    const indexInChunkTo = this._getIndexInChunk(end_);
    if (iFirstChunk === iLastChunk) {
      return this._chunks[iFirstChunk].substring(indexInChunkFrom, indexInChunkTo);
    } else {
      const out = this._getTmpArray();
      out.push(this._chunks[iFirstChunk].substring(indexInChunkFrom, this.STRING_CHUNK_SIZE));
      for (let iChunk = iFirstChunk + 1; iChunk < iLastChunk; iChunk++) {
        out.push(this._chunks[iChunk]);
      }
      out.push(this._chunks[iLastChunk].substring(0, indexInChunkTo));
      return out.join("");
    }
  }
  _getTmpArray() {
    while (this._tmpArray.length)
      this._tmpArray.pop();
    return this._tmpArray;
  }
  indexOf(searchString, position = 0) {
    if (searchString.length > this.STRING_CHUNK_SIZE) {
      throw new Error("NotImplementedError: indexOf is only implemented for searchString shorter than STRING_CHUNK_SIZE");
    }
    if (position < 0)
      position = 0;
    const iFirstChunk = this._getChunkIndex(position);
    for (let iChunk = iFirstChunk; iChunk < this._chunks.length; iChunk++) {
      const chunk = this._chunks[iChunk];
      const positionInChunk = iChunk === iFirstChunk ? this._getIndexInChunk(position) : 0;
      const found = chunk.indexOf(searchString, positionInChunk);
      if (found >= 0)
        return iChunk * this.STRING_CHUNK_SIZE + found;
      if (iChunk !== this._chunks.length - 1) {
        const start = Math.max(this.STRING_CHUNK_SIZE - searchString.length + 1, positionInChunk);
        const aroundBoundary = chunk.substring(start, void 0) + this._chunks[iChunk + 1].substring(0, searchString.length - 1);
        const found2 = aroundBoundary.indexOf(searchString);
        if (found2 >= 0)
          return iChunk * this.STRING_CHUNK_SIZE + start + found2;
      }
    }
    return -1;
  }
  includes(searchString, position = 0) {
    return this.indexOf(searchString, position) >= 0;
  }
  startsWith(searchString, position = 0) {
    if (searchString.length > this.STRING_CHUNK_SIZE) {
      throw new Error("NotImplementedError: startsWith is only implemented for searchString shorter than STRING_CHUNK_SIZE");
    }
    return this.substring(position, position + searchString.length) === searchString;
  }
  toString() {
    try {
      return this._chunks.join("");
    } catch (err) {
      throw new Error(`Failed to convert StringLike object into string. This might be because the length ${this.length} exceeds maximum allowed string length ${MAX_STRING_LENGTH}. (${err})`);
    }
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/utf8.js
function utf8Write(data, offset, str9) {
  for (let i = 0, l = str9.length; i < l; i++) {
    const codePoint = str9.charCodeAt(i);
    if (codePoint < 128) {
      data[offset++] = codePoint >>> 0 & 127 | 0;
      continue;
    }
    if (codePoint < 2048) {
      data[offset++] = codePoint >>> 6 & 31 | 192;
      data[offset++] = codePoint >>> 0 & 63 | 128;
      continue;
    }
    if (codePoint < 65536) {
      data[offset++] = codePoint >>> 12 & 15 | 224;
      data[offset++] = codePoint >>> 6 & 63 | 128;
      data[offset++] = codePoint >>> 0 & 63 | 128;
      continue;
    }
    if (codePoint < 1114112) {
      data[offset++] = codePoint >>> 18 & 7 | 240;
      data[offset++] = codePoint >>> 12 & 63 | 128;
      data[offset++] = codePoint >>> 6 & 63 | 128;
      data[offset++] = codePoint >>> 0 & 63 | 128;
      continue;
    }
    throw new Error("bad codepoint " + codePoint);
  }
}
var __chars = function() {
  const data = [];
  for (let i = 0; i < 1024; i++)
    data[i] = String.fromCharCode(i);
  return data;
}();
function throwError(err) {
  throw new Error(err);
}
function _utf8Read(data, offset, length) {
  const chars = __chars;
  let str9 = void 0, chunkOffset = 0;
  const chunk = [], chunkSize = 512;
  for (let i = offset, end = offset + length; i < end; i++) {
    const byte = data[i];
    if ((byte & 128) === 0) {
      chunk[chunkOffset++] = chars[byte];
    } else if ((byte & 224) === 192) {
      chunk[chunkOffset++] = chars[(byte & 15) << 6 | data[++i] & 63];
    } else if ((byte & 240) === 224) {
      chunk[chunkOffset++] = String.fromCharCode((byte & 15) << 12 | (data[++i] & 63) << 6 | (data[++i] & 63) << 0);
    } else if ((byte & 248) === 240) {
      chunk[chunkOffset++] = String.fromCharCode((byte & 7) << 18 | (data[++i] & 63) << 12 | (data[++i] & 63) << 6 | (data[++i] & 63) << 0);
    } else
      throwError("Invalid byte " + byte.toString(16));
    if (chunkOffset === chunkSize) {
      str9 = str9 || [];
      str9[str9.length] = chunk.join("");
      chunkOffset = 0;
    }
  }
  if (!str9)
    return chunk.slice(0, chunkOffset).join("");
  if (chunkOffset > 0) {
    str9[str9.length] = chunk.slice(0, chunkOffset).join("");
  }
  return str9.join("");
}
var utf8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder() : void 0;
function utf8Read(data, offset = 0, length = data.length) {
  if (utf8Decoder) {
    const input = offset || length !== data.length ? data.subarray(offset, offset + length) : data;
    return utf8Decoder.decode(input);
  } else {
    return _utf8Read(data, offset, length);
  }
}
function utf8ReadLong(data, offset = 0, length = data.length) {
  if (length <= MAX_STRING_LENGTH) {
    return utf8Read(data, offset, length);
  }
  const out = ChunkedBigString.fromUtf8Data(data, offset, offset + length);
  return out.length <= MAX_STRING_LENGTH ? out.toString() : out;
}
function utf8ByteCount(str9) {
  let count = 0;
  for (let i = 0, l = str9.length; i < l; i++) {
    const codePoint = str9.charCodeAt(i);
    if (codePoint < 128) {
      count += 1;
      continue;
    }
    if (codePoint < 2048) {
      count += 2;
      continue;
    }
    if (codePoint < 65536) {
      count += 3;
      continue;
    }
    if (codePoint < 1114112) {
      count += 4;
      continue;
    }
    throwError("bad codepoint " + codePoint);
  }
  return count;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/msgpack/encode.js
function encodeMsgPack(value) {
  const buffer = new ArrayBuffer(encodedSize(value));
  const view2 = new DataView(buffer);
  const bytes = new Uint8Array(buffer);
  encodeInternal(value, view2, bytes, 0);
  return bytes;
}
function encodedSize(value) {
  const type3 = typeof value;
  if (type3 === "string") {
    const length = utf8ByteCount(value);
    if (length < 32) {
      return 1 + length;
    }
    if (length < 256) {
      return 2 + length;
    }
    if (length < 65536) {
      return 3 + length;
    }
    if (length < 4294967296) {
      return 5 + length;
    }
  }
  if (value instanceof Uint8Array) {
    const length = value.byteLength;
    if (length < 256) {
      return 2 + length;
    }
    if (length < 65536) {
      return 3 + length;
    }
    if (length < 4294967296) {
      return 5 + length;
    }
  }
  if (type3 === "number") {
    if (Math.floor(value) !== value)
      return 9;
    if (value >= 0) {
      if (value < 128)
        return 1;
      if (value < 256)
        return 2;
      if (value < 65536)
        return 3;
      if (value < 4294967296)
        return 5;
      throw new Error("Number too big 0x" + value.toString(16));
    }
    if (value >= -32)
      return 1;
    if (value >= -128)
      return 2;
    if (value >= -32768)
      return 3;
    if (value >= -2147483648)
      return 5;
    throw new Error("Number too small -0x" + value.toString(16).substr(1));
  }
  if (type3 === "boolean" || value === null || value === void 0)
    return 1;
  if (type3 === "object") {
    let length, size = 0;
    if (Array.isArray(value)) {
      length = value.length;
      for (let i = 0; i < length; i++) {
        size += encodedSize(value[i]);
      }
    } else {
      const keys = Object.keys(value);
      length = keys.length;
      for (let i = 0; i < length; i++) {
        const key = keys[i];
        size += encodedSize(key) + encodedSize(value[key]);
      }
    }
    if (length < 16) {
      return 1 + size;
    }
    if (length < 65536) {
      return 3 + size;
    }
    if (length < 4294967296) {
      return 5 + size;
    }
    throw new Error("Array or object too long 0x" + length.toString(16));
  }
  throw new Error("Unknown type " + type3);
}
function encodeInternal(value, view2, bytes, offset) {
  const type3 = typeof value;
  if (type3 === "string") {
    const length = utf8ByteCount(value);
    if (length < 32) {
      view2.setUint8(offset, length | 160);
      utf8Write(bytes, offset + 1, value);
      return 1 + length;
    }
    if (length < 256) {
      view2.setUint8(offset, 217);
      view2.setUint8(offset + 1, length);
      utf8Write(bytes, offset + 2, value);
      return 2 + length;
    }
    if (length < 65536) {
      view2.setUint8(offset, 218);
      view2.setUint16(offset + 1, length);
      utf8Write(bytes, offset + 3, value);
      return 3 + length;
    }
    if (length < 4294967296) {
      view2.setUint8(offset, 219);
      view2.setUint32(offset + 1, length);
      utf8Write(bytes, offset + 5, value);
      return 5 + length;
    }
  }
  if (value instanceof Uint8Array) {
    const length = value.byteLength;
    const bytes2 = new Uint8Array(view2.buffer);
    if (length < 256) {
      view2.setUint8(offset, 196);
      view2.setUint8(offset + 1, length);
      bytes2.set(value, offset + 2);
      return 2 + length;
    }
    if (length < 65536) {
      view2.setUint8(offset, 197);
      view2.setUint16(offset + 1, length);
      bytes2.set(value, offset + 3);
      return 3 + length;
    }
    if (length < 4294967296) {
      view2.setUint8(offset, 198);
      view2.setUint32(offset + 1, length);
      bytes2.set(value, offset + 5);
      return 5 + length;
    }
  }
  if (type3 === "number") {
    if (!isFinite(value)) {
      throw new Error("Number not finite: " + value);
    }
    if (Math.floor(value) !== value) {
      view2.setUint8(offset, 203);
      view2.setFloat64(offset + 1, value);
      return 9;
    }
    if (value >= 0) {
      if (value < 128) {
        view2.setUint8(offset, value);
        return 1;
      }
      if (value < 256) {
        view2.setUint8(offset, 204);
        view2.setUint8(offset + 1, value);
        return 2;
      }
      if (value < 65536) {
        view2.setUint8(offset, 205);
        view2.setUint16(offset + 1, value);
        return 3;
      }
      if (value < 4294967296) {
        view2.setUint8(offset, 206);
        view2.setUint32(offset + 1, value);
        return 5;
      }
      throw new Error("Number too big 0x" + value.toString(16));
    }
    if (value >= -32) {
      view2.setInt8(offset, value);
      return 1;
    }
    if (value >= -128) {
      view2.setUint8(offset, 208);
      view2.setInt8(offset + 1, value);
      return 2;
    }
    if (value >= -32768) {
      view2.setUint8(offset, 209);
      view2.setInt16(offset + 1, value);
      return 3;
    }
    if (value >= -2147483648) {
      view2.setUint8(offset, 210);
      view2.setInt32(offset + 1, value);
      return 5;
    }
    throw new Error("Number too small -0x" + (-value).toString(16).substr(1));
  }
  if (value === null || value === void 0) {
    view2.setUint8(offset, 192);
    return 1;
  }
  if (type3 === "boolean") {
    view2.setUint8(offset, value ? 195 : 194);
    return 1;
  }
  if (type3 === "object") {
    let length, size = 0;
    const isArray = Array.isArray(value);
    let keys;
    if (isArray) {
      length = value.length;
    } else {
      keys = Object.keys(value);
      length = keys.length;
    }
    if (length < 16) {
      view2.setUint8(offset, length | (isArray ? 144 : 128));
      size = 1;
    } else if (length < 65536) {
      view2.setUint8(offset, isArray ? 220 : 222);
      view2.setUint16(offset + 1, length);
      size = 3;
    } else if (length < 4294967296) {
      view2.setUint8(offset, isArray ? 221 : 223);
      view2.setUint32(offset + 1, length);
      size = 5;
    }
    if (isArray) {
      for (let i = 0; i < length; i++) {
        size += encodeInternal(value[i], view2, bytes, offset + size);
      }
    } else {
      for (let i = 0, _i = keys.length; i < _i; i++) {
        const key = keys[i];
        size += encodeInternal(key, view2, bytes, offset + size);
        size += encodeInternal(value[key], view2, bytes, offset + size);
      }
    }
    return size;
  }
  throw new Error("Unknown type " + type3);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/writer/cif/encoder/binary.js
var BinaryEncoder = class {
  setFilter(filter2) {
    this.filter = filter2 || Category.DefaultFilter;
  }
  isCategoryIncluded(name) {
    return this.filter.includeCategory(name);
  }
  setFormatter(formatter) {
    this.formatter = formatter || Category.DefaultFormatter;
  }
  startDataBlock(header) {
    this.dataBlocks.push({
      header: (header || "").replace(/[ \n\t]/g, "").toUpperCase(),
      categories: []
    });
  }
  writeCategory(category, context, options) {
    if (!this.data) {
      throw new Error("The writer contents have already been encoded, no more writing.");
    }
    if (!this.dataBlocks.length) {
      throw new Error("No data block created.");
    }
    if (!(options === null || options === void 0 ? void 0 : options.ignoreFilter) && !this.filter.includeCategory(category.name))
      return;
    const { instance, rowCount, source } = getCategoryInstanceData(category, context);
    if (!rowCount)
      return;
    const cat = { name: "_" + category.name, columns: [], rowCount };
    const fields = getIncludedFields(instance);
    for (const f of fields) {
      if (!this.filter.includeField(category.name, f.name))
        continue;
      const format = this.formatter.getFormat(category.name, f.name);
      cat.columns.push(encodeField(category.name, f, source, rowCount, format, this.binaryEncodingProvider, this.autoClassify));
    }
    if (!cat.columns.length)
      return;
    this.dataBlocks[this.dataBlocks.length - 1].categories.push(cat);
  }
  encode() {
    if (this.encodedData)
      return;
    this.encodedData = encodeMsgPack(this.data);
    this.data = null;
    this.dataBlocks = null;
  }
  writeTo(writer) {
    writer.writeBinary(this.encodedData);
  }
  getData() {
    this.encode();
    return this.encodedData;
  }
  getSize() {
    return this.encodedData.length;
  }
  constructor(encoder, encodingProvider, autoClassify) {
    this.autoClassify = autoClassify;
    this.dataBlocks = [];
    this.filter = Category.DefaultFilter;
    this.formatter = Category.DefaultFormatter;
    this.isBinary = true;
    this.binaryEncodingProvider = void 0;
    this.binaryEncodingProvider = encodingProvider;
    this.data = {
      encoder,
      version: VERSION,
      dataBlocks: this.dataBlocks
    };
  }
};
function getArrayCtor(field, format) {
  if (format && format.typedArray)
    return format.typedArray;
  if (field.defaultFormat && field.defaultFormat.typedArray)
    return field.defaultFormat.typedArray;
  if (field.type === Field.Type.Str)
    return Array;
  if (field.type === Field.Type.Int)
    return Int32Array;
  return Float64Array;
}
function getDefaultEncoder(type3) {
  if (type3 === Field.Type.Str)
    return ArrayEncoder.by(ArrayEncoding.stringArray);
  return ArrayEncoder.by(ArrayEncoding.byteArray);
}
function tryGetEncoder(categoryName, field, format, provider) {
  if (format && format.encoder) {
    return format.encoder;
  } else if (field.defaultFormat && field.defaultFormat.encoder) {
    return field.defaultFormat.encoder;
  } else if (provider) {
    return provider.get(categoryName, field.name);
  } else {
    return void 0;
  }
}
function classify(type3, data) {
  if (type3 === Field.Type.Str)
    return ArrayEncoder.by(ArrayEncoding.stringArray);
  if (type3 === Field.Type.Int)
    return classifyIntArray(data);
  return classifyFloatArray(data);
}
function encodeField(categoryName, field, data, totalCount, format, encoderProvider, autoClassify) {
  const { array: array2, allPresent, mask } = getFieldData(field, getArrayCtor(field, format), totalCount, data);
  let encoder;
  if (field.type === Field.Type.Str) {
    encoder = ArrayEncoder.by(ArrayEncoding.stringArray);
  } else {
    encoder = tryGetEncoder(categoryName, field, format, encoderProvider);
  }
  if (!encoder) {
    if (autoClassify)
      encoder = classify(field.type, array2);
    else
      encoder = getDefaultEncoder(field.type);
  }
  const encoded = encoder.encode(array2);
  let maskData = void 0;
  if (!allPresent) {
    const maskRLE = ArrayEncoder.by(ArrayEncoding.runLength).and(ArrayEncoding.byteArray).encode(mask);
    if (maskRLE.data.length < mask.length) {
      maskData = maskRLE;
    } else {
      maskData = ArrayEncoder.by(ArrayEncoding.byteArray).encode(mask);
    }
  }
  return {
    name: field.name,
    data: encoded,
    mask: maskData
  };
}
function getFieldData(field, arrayCtor, totalCount, data) {
  const isStr = field.type === Field.Type.Str;
  const array2 = new arrayCtor(totalCount);
  const mask = new Uint8Array(totalCount);
  const valueKind = field.valueKind;
  const getter = field.value;
  let allPresent = true;
  let offset = 0;
  for (let _d = 0; _d < data.length; _d++) {
    const d = data[_d].data;
    const keys = data[_d].keys();
    while (keys.hasNext) {
      const key = keys.move();
      const p3 = valueKind ? valueKind(key, d) : Column.ValueKinds.Present;
      if (p3 !== Column.ValueKinds.Present) {
        mask[offset] = p3;
        if (isStr)
          array2[offset] = "";
        allPresent = false;
      } else {
        const value = getter(key, d, offset);
        if (typeof value === "string" && !value) {
          mask[offset] = Column.ValueKinds.NotPresent;
          allPresent = false;
        } else {
          mask[offset] = Column.ValueKinds.Present;
        }
        array2[offset] = value;
      }
      offset++;
    }
  }
  return { array: array2, allPresent, mask };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/writer/cif.js
var CifWriter;
(function(CifWriter2) {
  CifWriter2.Encoder = Encoder;
  CifWriter2.Category = Category;
  CifWriter2.Field = Field;
  CifWriter2.Encoding = ArrayEncoding;
  function createEncoder(params) {
    const { binary = false, encoderName = "mol*" } = params || {};
    return binary ? new BinaryEncoder(encoderName, params ? params.binaryEncodingPovider : void 0, params ? !!params.binaryAutoClassifyEncoding : false) : new TextEncoder();
  }
  CifWriter2.createEncoder = createEncoder;
  function fields() {
    return CifWriter2.Field.build();
  }
  CifWriter2.fields = fields;
  var E2 = CifWriter2.Encoding;
  CifWriter2.Encodings = {
    deltaRLE: E2.by(E2.delta).and(E2.runLength).and(E2.integerPacking),
    fixedPoint2: E2.by(E2.fixedPoint(100)).and(E2.delta).and(E2.integerPacking),
    fixedPoint3: E2.by(E2.fixedPoint(1e3)).and(E2.delta).and(E2.integerPacking)
  };
  function categoryInstance(fields2, source) {
    return { fields: fields2, source: [source] };
  }
  CifWriter2.categoryInstance = categoryInstance;
  function createEncodingProviderFromCifFrame(frame) {
    return {
      get(c, f) {
        const cat = frame.categories[c];
        if (!cat)
          return void 0;
        const ff = cat.getField(f);
        return ff && ff.binaryEncoding ? ArrayEncoder.fromEncoding(ff.binaryEncoding) : void 0;
      }
    };
  }
  CifWriter2.createEncodingProviderFromCifFrame = createEncodingProviderFromCifFrame;
  ;
  function createEncodingProviderFromJsonConfig(hints) {
    return {
      get(c, f) {
        for (let i = 0; i < hints.length; i++) {
          const hint = hints[i];
          if (hint.categoryName === c && hint.columnName === f) {
            return resolveEncoding(hint);
          }
        }
      }
    };
  }
  CifWriter2.createEncodingProviderFromJsonConfig = createEncodingProviderFromJsonConfig;
  function resolveEncoding(hint) {
    const precision = hint.precision;
    if (precision !== void 0) {
      const multiplier = Math.pow(10, precision);
      const fixedPoint2 = E2.by(E2.fixedPoint(multiplier));
      switch (hint.encoding) {
        case "pack":
          return fixedPoint2.and(E2.integerPacking);
        case "rle":
          return fixedPoint2.and(E2.runLength).and(E2.integerPacking);
        case "delta":
          return fixedPoint2.and(E2.delta).and(E2.integerPacking);
        case "delta-rle":
          return fixedPoint2.and(E2.delta).and(E2.runLength).and(E2.integerPacking);
      }
      ;
    } else {
      switch (hint.encoding) {
        case "pack":
          return E2.by(E2.integerPacking);
        case "rle":
          return E2.by(E2.runLength).and(E2.integerPacking);
        case "delta":
          return E2.by(E2.delta).and(E2.integerPacking);
        case "delta-rle":
          return E2.by(E2.delta).and(E2.runLength).and(E2.integerPacking);
      }
    }
    throw new Error("cannot be reached");
  }
})(CifWriter || (CifWriter = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/property/bonds/chem_comp.js
var ComponentBond;
(function(ComponentBond2) {
  ComponentBond2.Descriptor = {
    name: "chem_comp_bond",
    cifExport: {
      prefix: "",
      categories: [{
        name: "chem_comp_bond",
        instance(ctx) {
          const p3 = ComponentBond2.Provider.get(ctx.firstModel);
          if (!p3)
            return CifWriter.Category.Empty;
          const chem_comp_bond = p3.data;
          if (!chem_comp_bond)
            return CifWriter.Category.Empty;
          const comp_names = ctx.structures[0].uniqueResidueNames;
          const { comp_id, _rowCount } = chem_comp_bond;
          const indices = [];
          for (let i = 0; i < _rowCount; i++) {
            if (comp_names.has(comp_id.value(i)))
              indices[indices.length] = i;
          }
          return CifWriter.Category.ofTable(chem_comp_bond, indices);
        }
      }]
    }
  };
  ComponentBond2.Provider = FormatPropertyProvider.create(ComponentBond2.Descriptor);
  function chemCompBondFromTable(model, table) {
    return Table.pick(table, mmCIF_Schema.chem_comp_bond, (i) => {
      return model.properties.chemicalComponentMap.has(table.comp_id.value(i));
    });
  }
  ComponentBond2.chemCompBondFromTable = chemCompBondFromTable;
  function getEntriesFromChemCompBond(data) {
    const entries = /* @__PURE__ */ new Map();
    function addEntry(id) {
      if (entries.has(id))
        return entries.get(id);
      const e = new Entry(id);
      entries.set(id, e);
      return e;
    }
    const { comp_id, atom_id_1, atom_id_2, value_order, pdbx_aromatic_flag, _rowCount, pdbx_ordinal } = data;
    let entry = addEntry(comp_id.value(0));
    for (let i = 0; i < _rowCount; i++) {
      const id = comp_id.value(i);
      const nameA = atom_id_1.value(i);
      const nameB = atom_id_2.value(i);
      const order = value_order.value(i);
      const aromatic = pdbx_aromatic_flag.value(i) === "y";
      const key = pdbx_ordinal.value(i);
      if (entry.id !== id) {
        entry = addEntry(id);
      }
      let flags2 = BondType.Flag.Covalent;
      let ord = 1;
      if (aromatic)
        flags2 |= BondType.Flag.Aromatic;
      switch (order.toLowerCase()) {
        case "delo":
          flags2 |= BondType.Flag.Aromatic;
          break;
        case "doub":
          ord = 2;
          break;
        case "trip":
          ord = 3;
          break;
        case "quad":
          ord = 4;
          break;
      }
      entry.add(nameA, nameB, ord, flags2, key);
    }
    return entries;
  }
  ComponentBond2.getEntriesFromChemCompBond = getEntriesFromChemCompBond;
  class Entry {
    add(a, b, order, flags2, key, swap2 = true) {
      const e = this.map.get(a);
      if (e !== void 0) {
        const f = e.get(b);
        if (f === void 0) {
          e.set(b, { order, flags: flags2, key });
        }
      } else {
        const map2 = /* @__PURE__ */ new Map();
        map2.set(b, { order, flags: flags2, key });
        this.map.set(a, map2);
      }
      if (swap2)
        this.add(b, a, order, flags2, key, false);
    }
    constructor(id) {
      this.id = id;
      this.map = /* @__PURE__ */ new Map();
    }
  }
  ComponentBond2.Entry = Entry;
})(ComponentBond || (ComponentBond = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/property/bonds/struct_conn.js
var StructConn;
(function(StructConn2) {
  StructConn2.Descriptor = {
    name: "struct_conn",
    cifExport: {
      prefix: "",
      categories: [{
        name: "struct_conn",
        instance(ctx) {
          const p3 = StructConn2.Provider.get(ctx.firstModel);
          if (!p3 || p3.entries.length === 0)
            return CifWriter.Category.Empty;
          const structure = ctx.structures[0];
          const indices = [];
          for (const e of p3.entries) {
            if (hasAtom(structure, e.partnerA.atomIndex) && hasAtom(structure, e.partnerB.atomIndex)) {
              indices[indices.length] = e.rowIndex;
            }
          }
          return CifWriter.Category.ofTable(p3.data, indices);
        }
      }]
    }
  };
  StructConn2.Provider = FormatPropertyProvider.create(StructConn2.Descriptor);
  function isExhaustive(model) {
    const structConn = StructConn2.Provider.get(model);
    return !!structConn && structConn.entries.length / model.atomicConformation.atomId.rowCount > 0.95;
  }
  StructConn2.isExhaustive = isExhaustive;
  function hasAtom({ units }, element) {
    for (let i = 0, _i = units.length; i < _i; i++) {
      if (SortedArray.indexOf(units[i].elements, element) >= 0)
        return true;
    }
    return false;
  }
  function getAtomIndexFromEntries(entries) {
    const m = /* @__PURE__ */ new Map();
    for (const e of entries) {
      const { partnerA: { atomIndex: iA }, partnerB: { atomIndex: iB } } = e;
      if (m.has(iA))
        m.get(iA).push(e);
      else
        m.set(iA, [e]);
      if (m.has(iB))
        m.get(iB).push(e);
      else
        m.set(iB, [e]);
    }
    return m;
  }
  StructConn2.getAtomIndexFromEntries = getAtomIndexFromEntries;
  function getEntriesFromStructConn(struct_conn, model) {
    const { conn_type_id, pdbx_dist_value, pdbx_value_order } = struct_conn;
    const p1 = {
      label_asym_id: struct_conn.ptnr1_label_asym_id,
      label_seq_id: struct_conn.ptnr1_label_seq_id,
      auth_seq_id: struct_conn.ptnr1_auth_seq_id,
      label_atom_id: struct_conn.ptnr1_label_atom_id,
      label_alt_id: struct_conn.pdbx_ptnr1_label_alt_id,
      ins_code: struct_conn.pdbx_ptnr1_PDB_ins_code,
      symmetry: struct_conn.ptnr1_symmetry
    };
    const p22 = {
      label_asym_id: struct_conn.ptnr2_label_asym_id,
      label_seq_id: struct_conn.ptnr2_label_seq_id,
      auth_seq_id: struct_conn.ptnr2_auth_seq_id,
      label_atom_id: struct_conn.ptnr2_label_atom_id,
      label_alt_id: struct_conn.pdbx_ptnr2_label_alt_id,
      ins_code: struct_conn.pdbx_ptnr2_PDB_ins_code,
      symmetry: struct_conn.ptnr2_symmetry
    };
    const entityIds = Array.from(model.entities.data.id.toArray());
    const _p = (row, ps) => {
      if (ps.label_asym_id.valueKind(row) !== Column.ValueKinds.Present)
        return void 0;
      const asymId = ps.label_asym_id.value(row);
      const atomName = ps.label_atom_id.value(row);
      if (!atomName)
        return void 0;
      const resId = ps.auth_seq_id.valueKind(row) === Column.ValueKind.Present ? ps.auth_seq_id.value(row) : ps.label_seq_id.value(row);
      const resInsCode = ps.ins_code.value(row);
      const altId = ps.label_alt_id.value(row);
      for (const eId of entityIds) {
        const residueIndex2 = model.atomicHierarchy.index.findResidue(eId, asymId, resId, resInsCode);
        if (residueIndex2 < 0)
          continue;
        const atomIndex = model.atomicHierarchy.index.findAtomOnResidue(residueIndex2, atomName, altId);
        if (atomIndex < 0)
          continue;
        return { residueIndex: residueIndex2, atomIndex, symmetry: ps.symmetry.value(row) };
      }
      return void 0;
    };
    const entries = [];
    for (let i = 0; i < struct_conn._rowCount; i++) {
      const partnerA = _p(i, p1);
      const partnerB = _p(i, p22);
      if (partnerA === void 0 || partnerB === void 0)
        continue;
      const type3 = conn_type_id.value(i);
      const orderType = pdbx_value_order.value(i) || "";
      let flags2 = BondType.Flag.None;
      let order = 1;
      switch (orderType) {
        case "sing":
          order = 1;
          break;
        case "doub":
          order = 2;
          break;
        case "trip":
          order = 3;
          break;
        case "quad":
          order = 4;
          break;
        default:
          order = getInterBondOrderFromTable(struct_conn.ptnr1_label_comp_id.value(i), struct_conn.ptnr1_label_atom_id.value(i), struct_conn.ptnr2_label_comp_id.value(i), struct_conn.ptnr2_label_atom_id.value(i));
      }
      switch (type3) {
        case "covale":
          flags2 = BondType.Flag.Covalent;
          break;
        case "disulf":
          flags2 = BondType.Flag.Covalent | BondType.Flag.Disulfide;
          break;
        case "hydrog":
          flags2 = BondType.Flag.HydrogenBond;
          break;
        case "metalc":
          flags2 = BondType.Flag.MetallicCoordination;
          break;
      }
      entries.push({
        rowIndex: i,
        flags: flags2,
        order,
        distance: pdbx_dist_value.value(i),
        partnerA,
        partnerB
      });
    }
    return entries;
  }
  StructConn2.getEntriesFromStructConn = getEntriesFromStructConn;
})(StructConn || (StructConn = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/unit/bonds/intra-compute.js
var v3distance2 = Vec3.distance;
var CoarseGrainedBondMaxRadius = 6;
var CoarseGrainedIntraResidueBondMaxDistance = 5.5;
var CoarseGrainedInterResidueBondMaxDistance = 3.9;
function getGraph2(atomA, atomB, _order, _flags, _key, atomCount2, props) {
  const builder = new IntAdjacencyGraph.EdgeBuilder(atomCount2, atomA, atomB);
  const flags2 = new Uint16Array(builder.slotCount);
  const order = new Int8Array(builder.slotCount);
  const key = new Uint32Array(builder.slotCount);
  for (let i = 0, _i = builder.edgeCount; i < _i; i++) {
    builder.addNextEdge();
    builder.assignProperty(flags2, _flags[i]);
    builder.assignProperty(order, _order[i]);
    builder.assignProperty(key, _key[i]);
  }
  return builder.createGraph({ flags: flags2, order, key }, props);
}
var tmpDistVecA = Vec3();
var tmpDistVecB = Vec3();
function getDistance(unit2, indexA, indexB) {
  unit2.conformation.position(indexA, tmpDistVecA);
  unit2.conformation.position(indexB, tmpDistVecB);
  return v3distance2(tmpDistVecA, tmpDistVecB);
}
var __structConnAdded = /* @__PURE__ */ new Set();
function findIndexPairBonds(unit2) {
  const indexPairs = IndexPairBonds.Provider.get(unit2.model);
  const { elements: atoms2 } = unit2;
  const { type_symbol } = unit2.model.atomicHierarchy.atoms;
  const atomCount2 = unit2.elements.length;
  const { maxDistance } = indexPairs;
  const { offset, b, edgeProps: { order, distance, flag, key, operatorA, operatorB } } = indexPairs.bonds;
  const { atomSourceIndex: sourceIndex } = unit2.model.atomicHierarchy;
  const { invertedIndex } = Model.getInvertedAtomSourceIndex(unit2.model);
  const atomA = [];
  const atomB = [];
  const flags2 = [];
  const orders = [];
  const keys = [];
  const opKey = unit2.conformation.operator.key;
  for (let _aI = 0; _aI < atomCount2; _aI++) {
    const aI = atoms2[_aI];
    const aeI = getElementIdx(type_symbol.value(aI));
    const isHa = isHydrogen(aeI);
    const srcA = sourceIndex.value(aI);
    for (let i = offset[srcA], il = offset[srcA + 1]; i < il; ++i) {
      const bI = invertedIndex[b[i]];
      if (aI >= bI)
        continue;
      const _bI = SortedArray.indexOf(unit2.elements, bI);
      if (_bI < 0)
        continue;
      const opA = operatorA[i];
      const opB = operatorB[i];
      if (opA >= 0 && opA !== opKey || opB >= 0 && opB !== opKey)
        continue;
      const beI = getElementIdx(type_symbol.value(bI));
      const d = distance[i];
      const dist = getDistance(unit2, aI, bI);
      let add = false;
      if (d >= 0) {
        add = equalEps(dist, d, 0.3);
      } else if (maxDistance >= 0) {
        add = dist < maxDistance;
      } else {
        const pairingThreshold = getPairingThreshold(aeI, beI, getElementThreshold(aeI), getElementThreshold(beI));
        add = dist < pairingThreshold;
        if (isHa && isHydrogen(beI)) {
          add = false;
        }
      }
      if (add) {
        atomA[atomA.length] = _aI;
        atomB[atomB.length] = _bI;
        orders[orders.length] = order[i];
        flags2[flags2.length] = flag[i];
        keys[keys.length] = key[i];
      }
    }
  }
  return getGraph2(atomA, atomB, orders, flags2, keys, atomCount2, {
    canRemap: false,
    cacheable: indexPairs.cacheable
  });
}
function findBonds(unit2, props) {
  const isCoarseGrained = Model.isCoarseGrained(unit2.model);
  const maxRadius = isCoarseGrained ? CoarseGrainedBondMaxRadius : props.maxRadius;
  const { x, y, z } = unit2.model.atomicConformation;
  const atomCount2 = unit2.elements.length;
  const { elements: atoms2, residueIndex: residueIndex2, chainIndex: chainIndex2 } = unit2;
  const { type_symbol, label_atom_id, label_alt_id, label_comp_id } = unit2.model.atomicHierarchy.atoms;
  const { label_seq_id } = unit2.model.atomicHierarchy.residues;
  const { traceElementIndex } = unit2.model.atomicHierarchy.derived.residue;
  const { index } = unit2.model.atomicHierarchy;
  const { byEntityKey } = unit2.model.sequence;
  const query3d = unit2.lookup3d;
  const structConn = StructConn.Provider.get(unit2.model);
  const component = ComponentBond.Provider.get(unit2.model);
  const structConnExhaustive = StructConn.isExhaustive(unit2.model);
  const atomA = [];
  const atomB = [];
  const flags2 = [];
  const order = [];
  const key = [];
  let lastResidue = -1;
  let componentMap = void 0;
  let isWatery = true, isDictionaryBased = true, isSequenced = true;
  const structConnAdded = __structConnAdded;
  const hasStructConnEntries = !!(structConn === null || structConn === void 0 ? void 0 : structConn.residueCantorPairs.size);
  for (let _aI = 0; _aI < atomCount2; _aI++) {
    const aI = atoms2[_aI];
    const elemA = type_symbol.value(aI);
    if (isWatery && (elemA !== "H" && elemA !== "O"))
      isWatery = false;
    const structConnEntries = props.forceCompute ? void 0 : structConn && structConn.byAtomIndex.get(aI);
    let hasStructConn = false;
    if (structConnEntries) {
      for (const se of structConnEntries) {
        const { partnerA, partnerB } = se;
        if (partnerA.symmetry !== partnerB.symmetry)
          continue;
        const p3 = partnerA.atomIndex === aI ? partnerB : partnerA;
        const _bI = SortedArray.indexOf(unit2.elements, p3.atomIndex);
        if (_bI < 0 || atoms2[_bI] < aI)
          continue;
        atomA[atomA.length] = _aI;
        atomB[atomB.length] = _bI;
        flags2[flags2.length] = se.flags;
        order[order.length] = se.order;
        key[key.length] = se.rowIndex;
        if (!hasStructConn)
          structConnAdded.clear();
        hasStructConn = true;
        structConnAdded.add(_bI);
      }
    }
    if (structConnExhaustive)
      continue;
    const raI = residueIndex2[aI];
    const seqIdA = label_seq_id.value(raI);
    const compId2 = label_comp_id.value(aI);
    if (!props.forceCompute && raI !== lastResidue) {
      if (!!component && component.entries.has(compId2)) {
        const entitySeq = byEntityKey[index.getEntityFromChain(chainIndex2[aI])];
        if (entitySeq && entitySeq.sequence.microHet.has(seqIdA)) {
          componentMap = void 0;
        } else {
          componentMap = component.entries.get(compId2).map;
        }
      } else {
        componentMap = void 0;
      }
    }
    lastResidue = raI;
    const aeI = getElementIdx(elemA);
    const atomIdA = label_atom_id.value(aI);
    const componentPairs = componentMap ? componentMap.get(atomIdA) : void 0;
    const { indices, count, squaredDistances } = query3d.find(x[aI], y[aI], z[aI], maxRadius);
    const isHa = isHydrogen(aeI);
    const thresholdA = getElementThreshold(aeI);
    const altA = label_alt_id.value(aI);
    const metalA = MetalsSet.has(aeI);
    for (let ni = 0; ni < count; ni++) {
      const _bI = indices[ni];
      if (hasStructConn && structConnAdded.has(_bI))
        continue;
      const bI = atoms2[_bI];
      if (bI <= aI)
        continue;
      const altB = label_alt_id.value(bI);
      if (altA && altB && altA !== altB)
        continue;
      if (hasStructConnEntries) {
        const residuePair = sortedCantorPairing(residueIndex2[aI], residueIndex2[bI]);
        if (structConn.residueCantorPairs.has(residuePair))
          continue;
      }
      const beI = getElementIdx(type_symbol.value(bI));
      const isHb = isHydrogen(beI);
      if (isHa && isHb)
        continue;
      const isMetal2 = (metalA || MetalsSet.has(beI)) && !(isHa || isHb);
      const rbI = residueIndex2[bI];
      if (raI === rbI && componentPairs) {
        const e = componentPairs.get(label_atom_id.value(bI));
        if (e) {
          atomA[atomA.length] = _aI;
          atomB[atomB.length] = _bI;
          order[order.length] = e.order;
          let flag2 = e.flags;
          if (isMetal2) {
            if (flag2 | BondType.Flag.Covalent)
              flag2 ^= BondType.Flag.Covalent;
            flag2 |= BondType.Flag.MetallicCoordination;
          }
          flags2[flags2.length] = flag2;
          key[key.length] = e.key;
        }
        continue;
      }
      const dist = Math.sqrt(squaredDistances[ni]);
      if (dist === 0)
        continue;
      let flag = false;
      if (isCoarseGrained) {
        if (raI === rbI) {
          flag = dist <= CoarseGrainedIntraResidueBondMaxDistance;
        } else {
          flag = dist <= CoarseGrainedInterResidueBondMaxDistance && traceElementIndex[raI] === aI && traceElementIndex[rbI] === bI;
        }
      } else {
        const pairingThreshold = getPairingThreshold(aeI, beI, thresholdA, getElementThreshold(beI));
        flag = dist <= pairingThreshold;
      }
      if (flag) {
        atomA[atomA.length] = _aI;
        atomB[atomB.length] = _bI;
        order[order.length] = getIntraBondOrderFromTable(compId2, atomIdA, label_atom_id.value(bI));
        flags2[flags2.length] = (isMetal2 ? BondType.Flag.MetallicCoordination : BondType.Flag.Covalent) | BondType.Flag.Computed;
        key[key.length] = -1;
        const seqIdB = label_seq_id.value(rbI);
        if (seqIdA === seqIdB)
          isDictionaryBased = false;
        if (Math.abs(seqIdA - seqIdB) > 1)
          isSequenced = false;
      }
    }
  }
  return getGraph2(atomA, atomB, order, flags2, key, atomCount2, {
    canRemap: isWatery || isDictionaryBased && isSequenced
  });
}
function canGetFromIndexPairBonds(unit2) {
  if (unit2.conformation.operator.key === -1)
    return false;
  const indexPairs = IndexPairBonds.Provider.get(unit2.model);
  return !!(indexPairs === null || indexPairs === void 0 ? void 0 : indexPairs.hasOperators);
}
function getIndexPairBonds(unit2) {
  const indexPairs = IndexPairBonds.Provider.get(unit2.model);
  const bonds = indexPairs.bySameOperator.get(unit2.conformation.operator.key);
  if (!bonds)
    return IntraUnitBonds.Empty;
  const { a, b, edgeProps: { key, flag, order } } = indexPairs.bonds;
  const { invertedIndex } = Model.getInvertedAtomSourceIndex(unit2.model);
  const { elements } = unit2;
  const atomA = [];
  const atomB = [];
  const flags2 = [];
  const orders = [];
  const keys = [];
  for (let j = 0, jl = bonds.length; j < jl; ++j) {
    const i = bonds[j];
    if (a[i] >= b[i])
      continue;
    const aI = invertedIndex[a[i]];
    const _aI = SortedArray.indexOf(elements, aI);
    if (_aI < 0)
      continue;
    const bI = invertedIndex[b[i]];
    const _bI = SortedArray.indexOf(elements, bI);
    if (_bI < 0)
      continue;
    atomA[atomA.length] = _aI;
    atomB[atomB.length] = _bI;
    flags2[flags2.length] = flag[i];
    orders[orders.length] = order[i];
    keys[keys.length] = key[i];
  }
  return getGraph2(atomA, atomB, orders, flags2, keys, elements.length, {
    canRemap: false,
    cacheable: indexPairs.cacheable
  });
}
function computeIntraUnitBonds(unit2, props) {
  const p3 = { ...DefaultBondComputationProps, ...props };
  if (p3.noCompute)
    return IntraUnitBonds.Empty;
  if (unit2.elements.length <= 1)
    return IntraUnitBonds.Empty;
  if (!p3.forceCompute && IndexPairBonds.Provider.get(unit2.model)) {
    return canGetFromIndexPairBonds(unit2) ? getIndexPairBonds(unit2) : findIndexPairBonds(unit2);
  } else {
    return findBonds(unit2, p3);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/unit/bonds/inter-compute.js
var v3distance3 = Vec3.distance;
var v3set = Vec3.set;
var v3squaredDistance2 = Vec3.squaredDistance;
var v3transformMat4 = Vec3.transformMat4;
var tmpDistVecA2 = Vec3();
var tmpDistVecB2 = Vec3();
function getDistance2(unitA, indexA, unitB, indexB) {
  unitA.conformation.position(indexA, tmpDistVecA2);
  unitB.conformation.position(indexB, tmpDistVecB2);
  return v3distance3(tmpDistVecA2, tmpDistVecB2);
}
var _imageTransform = Mat4();
var _imageA = Vec3();
function findPairBonds(unitA, unitB, props, builder) {
  const { maxRadius } = props;
  const { elements: atomsA, residueIndex: residueIndexA } = unitA;
  const { x: xA, y: yA, z: zA } = unitA.model.atomicConformation;
  const { elements: atomsB, residueIndex: residueIndexB } = unitB;
  const atomCount2 = unitA.elements.length;
  const { type_symbol: type_symbolA, label_alt_id: label_alt_idA, label_atom_id: label_atom_idA, label_comp_id: label_comp_idA } = unitA.model.atomicHierarchy.atoms;
  const { type_symbol: type_symbolB, label_alt_id: label_alt_idB, label_atom_id: label_atom_idB, label_comp_id: label_comp_idB } = unitB.model.atomicHierarchy.atoms;
  const { auth_seq_id: auth_seq_idA } = unitA.model.atomicHierarchy.residues;
  const { auth_seq_id: auth_seq_idB } = unitB.model.atomicHierarchy.residues;
  const { occupancy: occupancyA } = unitA.model.atomicConformation;
  const { occupancy: occupancyB } = unitB.model.atomicConformation;
  const hasOccupancy = occupancyA.isDefined && occupancyB.isDefined;
  const structConn = unitA.model === unitB.model && StructConn.Provider.get(unitA.model);
  const indexPairs = !props.forceCompute && unitA.model === unitB.model && IndexPairBonds.Provider.get(unitA.model);
  const { atomSourceIndex: sourceIndex } = unitA.model.atomicHierarchy;
  const { invertedIndex } = indexPairs ? Model.getInvertedAtomSourceIndex(unitB.model) : { invertedIndex: void 0 };
  const structConnExhaustive = unitA.model === unitB.model && StructConn.isExhaustive(unitA.model);
  const imageTransform = Mat4.mul(_imageTransform, unitB.conformation.operator.inverse, unitA.conformation.operator.matrix);
  const isNotIdentity = !Mat4.isIdentity(imageTransform);
  const { center: bCenter, radius: bRadius } = unitB.boundary.sphere;
  const testDistanceSq = (bRadius + maxRadius) * (bRadius + maxRadius);
  builder.startUnitPair(unitA.id, unitB.id);
  const opKeyA = unitA.conformation.operator.key;
  const opKeyB = unitB.conformation.operator.key;
  for (let _aI = 0; _aI < atomCount2; _aI++) {
    const aI = atomsA[_aI];
    v3set(_imageA, xA[aI], yA[aI], zA[aI]);
    if (isNotIdentity)
      v3transformMat4(_imageA, _imageA, imageTransform);
    if (v3squaredDistance2(_imageA, bCenter) > testDistanceSq)
      continue;
    if (!props.forceCompute && indexPairs) {
      const { maxDistance } = indexPairs;
      const { offset, b, edgeProps: { order, distance, flag, key, operatorA, operatorB } } = indexPairs.bonds;
      const srcA = sourceIndex.value(aI);
      const aeI2 = getElementIdx(type_symbolA.value(aI));
      for (let i = offset[srcA], il = offset[srcA + 1]; i < il; ++i) {
        const bI = invertedIndex[b[i]];
        const _bI = SortedArray.indexOf(unitB.elements, bI);
        if (_bI < 0)
          continue;
        const opA = operatorA[i];
        const opB = operatorB[i];
        if (opA >= 0 && opB >= 0) {
          if (opA === opB)
            continue;
          if (opA !== opKeyA || opB !== opKeyB)
            continue;
        }
        const beI = getElementIdx(type_symbolA.value(bI));
        const d = distance[i];
        const dist = getDistance2(unitA, aI, unitB, bI);
        let add = false;
        if (d >= 0) {
          add = equalEps(dist, d, 0.3);
        } else if (maxDistance >= 0) {
          add = dist < maxDistance;
        } else {
          const pairingThreshold = getPairingThreshold(aeI2, beI, getElementThreshold(aeI2), getElementThreshold(beI));
          add = dist < pairingThreshold;
          if (isHydrogen(aeI2) && isHydrogen(beI)) {
            add = false;
          }
        }
        if (add) {
          builder.add(_aI, _bI, { order: order[i], flag: flag[i], key: key[i] });
        }
      }
      continue;
    }
    const structConnEntries = props.forceCompute ? void 0 : structConn && structConn.byAtomIndex.get(aI);
    if (structConnEntries && structConnEntries.length) {
      let added = false;
      for (const se of structConnEntries) {
        const { partnerA, partnerB } = se;
        const p3 = partnerA.atomIndex === aI ? partnerB : partnerA;
        const _bI = SortedArray.indexOf(unitB.elements, p3.atomIndex);
        if (_bI < 0)
          continue;
        if (getDistance2(unitA, aI, unitB, p3.atomIndex) > maxRadius)
          continue;
        builder.add(_aI, _bI, { order: se.order, flag: se.flags, key: se.rowIndex });
        added = true;
      }
      if (added)
        continue;
    }
    if (structConnExhaustive)
      continue;
    const occA = occupancyA.value(aI);
    const { lookup3d } = unitB;
    const { indices, count, squaredDistances } = lookup3d.find(_imageA[0], _imageA[1], _imageA[2], maxRadius);
    if (count === 0)
      continue;
    const aeI = getElementIdx(type_symbolA.value(aI));
    const isHa = isHydrogen(aeI);
    const thresholdA = getElementThreshold(aeI);
    const altA = label_alt_idA.value(aI);
    const metalA = MetalsSet.has(aeI);
    const atomIdA = label_atom_idA.value(aI);
    const compIdA = label_comp_idA.value(residueIndexA[aI]);
    for (let ni = 0; ni < count; ni++) {
      const _bI = indices[ni];
      const bI = atomsB[_bI];
      const altB = label_alt_idB.value(bI);
      if (altA && altB && altA !== altB)
        continue;
      if (hasOccupancy && occupancyB.value(bI) < 1 && occA < 1) {
        if (auth_seq_idA.value(residueIndexA[aI]) === auth_seq_idB.value(residueIndexB[bI])) {
          continue;
        }
      }
      if (structConn && unitA.model === unitB.model) {
        const residuePair = sortedCantorPairing(residueIndexA[aI], residueIndexB[bI]);
        if (structConn.residueCantorPairs.has(residuePair))
          continue;
      }
      const beI = getElementIdx(type_symbolB.value(bI));
      const isHb = isHydrogen(beI);
      if (isHa && isHb)
        continue;
      const isMetal2 = (metalA || MetalsSet.has(beI)) && !(isHa || isHb);
      const dist = Math.sqrt(squaredDistances[ni]);
      if (dist === 0)
        continue;
      const pairingThreshold = getPairingThreshold(aeI, beI, thresholdA, getElementThreshold(beI));
      if (dist <= pairingThreshold) {
        const atomIdB = label_atom_idB.value(bI);
        const compIdB = label_comp_idB.value(residueIndexB[bI]);
        builder.add(_aI, _bI, {
          order: getInterBondOrderFromTable(compIdA, compIdB, atomIdA, atomIdB),
          flag: (isMetal2 ? BondType.Flag.MetallicCoordination : BondType.Flag.Covalent) | BondType.Flag.Computed,
          key: -1
        });
      }
    }
  }
  builder.finishUnitPair();
}
function canAddFromIndexPairBonds(structure) {
  for (const m of structure.models) {
    const indexPairs = IndexPairBonds.Provider.get(m);
    if (!(indexPairs === null || indexPairs === void 0 ? void 0 : indexPairs.hasOperators))
      return false;
  }
  for (const u of structure.units) {
    if (u.conformation.operator.key === -1)
      return false;
  }
  return true;
}
function addIndexPairBonds(structure, builder) {
  const opUnits = /* @__PURE__ */ new Map();
  for (const u of structure.units) {
    const { key } = u.conformation.operator;
    if (opUnits.has(key))
      opUnits.get(key).add(u);
    else
      opUnits.set(key, /* @__PURE__ */ new Set([u]));
  }
  for (const m of structure.models) {
    const indexPairs = IndexPairBonds.Provider.get(m);
    const { a, b } = indexPairs.bonds;
    const { order, flag, key, operatorA, operatorB } = indexPairs.bonds.edgeProps;
    const { invertedIndex } = Model.getInvertedAtomSourceIndex(m);
    const atomsToUnits = /* @__PURE__ */ new Map();
    for (const u of structure.units) {
      if (u.model !== m)
        continue;
      for (let i = 0, il = u.elements.length; i < il; ++i) {
        const aI = u.elements[i];
        if (atomsToUnits.has(aI))
          atomsToUnits.get(aI).add(u);
        else
          atomsToUnits.set(aI, /* @__PURE__ */ new Set([u]));
      }
    }
    const pairs = /* @__PURE__ */ new Map();
    for (let i = 0, il = operatorA.length; i < il; ++i) {
      let unitsA;
      let unitsB;
      if (operatorA[i] === operatorB[i]) {
        unitsA = atomsToUnits.get(invertedIndex[a[i]]);
        unitsB = atomsToUnits.get(invertedIndex[b[i]]);
      } else {
        unitsA = opUnits.get(operatorA[i]);
        unitsB = opUnits.get(operatorB[i]);
      }
      if (!unitsA || !unitsB)
        continue;
      for (const uA of unitsA) {
        if (operatorA[i] !== uA.conformation.operator.key)
          continue;
        for (const uB of unitsB) {
          if (operatorB[i] !== uB.conformation.operator.key)
            continue;
          if (uA === uB || !Unit.isAtomic(uA) || !Unit.isAtomic(uB))
            continue;
          if (uA.id > uB.id)
            continue;
          const h = cantorPairing(uA.id, uB.id);
          if (pairs.has(h))
            pairs.get(h).add(i);
          else
            pairs.set(h, /* @__PURE__ */ new Set([i]));
        }
      }
    }
    const unitIds = [-1, -1];
    pairs.forEach((indices, h) => {
      const [unitIdA, unitIdB] = invertCantorPairing(unitIds, h);
      const uA = structure.unitMap.get(unitIdA);
      const uB = structure.unitMap.get(unitIdB);
      builder.startUnitPair(unitIdA, unitIdB);
      indices.forEach((i) => {
        const aI = invertedIndex[a[i]];
        const _aI = SortedArray.indexOf(uA.elements, aI);
        if (_aI < 0)
          return;
        const bI = invertedIndex[b[i]];
        const _bI = SortedArray.indexOf(uB.elements, bI);
        if (_bI < 0)
          return;
        builder.add(_aI, _bI, { order: order[i], flag: flag[i], key: key[i] });
      });
      builder.finishUnitPair();
    });
  }
}
var DefaultInterBondComputationProps = {
  ...DefaultBondComputationProps,
  ignoreWater: true,
  ignoreIon: true
};
function findBonds2(structure, props) {
  const builder = new InterUnitGraph.Builder();
  const hasIndexPairBonds = structure.models.some((m) => IndexPairBonds.Provider.get(m));
  const hasExhaustiveStructConn = structure.models.some((m) => StructConn.isExhaustive(m));
  if (props.noCompute || structure.isCoarseGrained && !hasIndexPairBonds && !hasExhaustiveStructConn) {
    return new InterUnitBonds(builder.getMap());
  }
  if (!props.forceCompute && canAddFromIndexPairBonds(structure)) {
    addIndexPairBonds(structure, builder);
    return new InterUnitBonds(builder.getMap());
  }
  Structure.eachUnitPair(structure, (unitA, unitB) => {
    findPairBonds(unitA, unitB, props, builder);
  }, {
    maxRadius: props.maxRadius,
    validUnit: (unit2) => props.validUnit(unit2),
    validUnitPair: (unitA, unitB) => props.validUnitPair(structure, unitA, unitB)
  });
  return new InterUnitBonds(builder.getMap());
}
function computeInterUnitBonds(structure, props) {
  const p3 = { ...DefaultInterBondComputationProps, ...props };
  return findBonds2(structure, {
    ...p3,
    validUnit: props && props.validUnit || ((u) => Unit.isAtomic(u)),
    validUnitPair: props && props.validUnitPair || ((s, a, b) => {
      const isValidPair = Structure.validUnitPair(s, a, b);
      if (!isValidPair)
        return false;
      const mtA = a.model.atomicHierarchy.derived.residue.moleculeType;
      const mtB = b.model.atomicHierarchy.derived.residue.moleculeType;
      const notWater = (!Unit.isAtomic(a) || mtA[a.residueIndex[a.elements[0]]] !== MoleculeType.Water) && (!Unit.isAtomic(b) || mtB[b.residueIndex[b.elements[0]]] !== MoleculeType.Water);
      const notIonA = !Unit.isAtomic(a) || mtA[a.residueIndex[a.elements[0]]] !== MoleculeType.Ion;
      const notIonB = !Unit.isAtomic(b) || mtB[b.residueIndex[b.elements[0]]] !== MoleculeType.Ion;
      const notIon = notIonA && notIonB;
      const check = (notWater || !p3.ignoreWater) && (notIon || !p3.ignoreIon);
      if (!check) {
        return hasCommonStructConnRecord(a, b);
      }
      return true;
    })
  });
}
function hasCommonStructConnRecord(unitA, unitB) {
  if (unitA.model !== unitB.model || !Unit.isAtomic(unitA) || !Unit.isAtomic(unitB))
    return false;
  const structConn = StructConn.Provider.get(unitA.model);
  if (!structConn)
    return false;
  const smaller = unitA.elements.length < unitB.elements.length ? unitA : unitB;
  const bigger = unitA.elements.length >= unitB.elements.length ? unitA : unitB;
  const { elements: xs } = smaller;
  const { elements: ys } = bigger;
  const { indexOf } = SortedArray;
  for (let i = 0, _i = xs.length; i < _i; i++) {
    const aI = xs[i];
    const entries = structConn.byAtomIndex.get(aI);
    if (!(entries === null || entries === void 0 ? void 0 : entries.length))
      continue;
    for (const e of entries) {
      const bI = e.partnerA.atomIndex === aI ? e.partnerB.atomIndex : e.partnerA.atomIndex;
      if (indexOf(ys, bI) >= 0)
        return true;
    }
  }
  return false;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/unit/bonds.js
var Bond;
(function(Bond2) {
  function Location2(aStructure, aUnit, aIndex, bStructure, bUnit, bIndex) {
    return {
      kind: "bond-location",
      aStructure,
      aUnit,
      aIndex,
      bStructure,
      bUnit,
      bIndex
    };
  }
  Bond2.Location = Location2;
  function isLocation(x) {
    return !!x && x.kind === "bond-location";
  }
  Bond2.isLocation = isLocation;
  function areLocationsEqual(locA, locB) {
    return locA.aStructure.label === locB.aStructure.label && locA.bStructure.label === locB.bStructure.label && locA.aIndex === locB.aIndex && locA.bIndex === locB.bIndex && locA.aUnit.id === locB.aUnit.id && locA.bUnit.id === locB.bUnit.id;
  }
  Bond2.areLocationsEqual = areLocationsEqual;
  function Loci2(structure, bonds) {
    return { kind: "bond-loci", structure, bonds };
  }
  Bond2.Loci = Loci2;
  function isLoci(x) {
    return !!x && x.kind === "bond-loci";
  }
  Bond2.isLoci = isLoci;
  function areLociEqual(a, b) {
    if (a.structure !== b.structure)
      return false;
    if (a.bonds.length !== b.bonds.length)
      return false;
    for (let i = 0, il = a.bonds.length; i < il; ++i) {
      if (!areLocationsEqual(a.bonds[i], b.bonds[i]))
        return false;
    }
    return true;
  }
  Bond2.areLociEqual = areLociEqual;
  function isLociEmpty(loci) {
    return loci.bonds.length === 0 ? true : false;
  }
  Bond2.isLociEmpty = isLociEmpty;
  function remapLoci(loci, structure) {
    if (structure === loci.structure)
      return loci;
    const bonds = [];
    loci.bonds.forEach((l) => {
      const unitA = structure.unitMap.get(l.aUnit.id);
      if (!unitA)
        return;
      const unitB = structure.unitMap.get(l.bUnit.id);
      if (!unitB)
        return;
      const elementA = l.aUnit.elements[l.aIndex];
      const indexA = SortedArray.indexOf(unitA.elements, elementA);
      if (indexA === -1)
        return;
      const elementB = l.bUnit.elements[l.bIndex];
      const indexB = SortedArray.indexOf(unitB.elements, elementB);
      if (indexB === -1)
        return;
      bonds.push(Location2(loci.structure, unitA, indexA, loci.structure, unitB, indexB));
    });
    return Loci2(structure, bonds);
  }
  Bond2.remapLoci = remapLoci;
  function toStructureElementLoci(loci) {
    const elements = [];
    const map2 = /* @__PURE__ */ new Map();
    for (const lociBond of loci.bonds) {
      const { aIndex, aUnit, bIndex, bUnit } = lociBond;
      if (aUnit === bUnit) {
        if (map2.has(aUnit.id))
          map2.get(aUnit.id).push(aIndex, bIndex);
        else
          map2.set(aUnit.id, [aIndex, bIndex]);
      } else {
        if (map2.has(aUnit.id))
          map2.get(aUnit.id).push(aIndex);
        else
          map2.set(aUnit.id, [aIndex]);
        if (map2.has(bUnit.id))
          map2.get(bUnit.id).push(bIndex);
        else
          map2.set(bUnit.id, [bIndex]);
      }
    }
    map2.forEach((indices, id) => {
      elements.push({
        unit: loci.structure.unitMap.get(id),
        indices: SortedArray.deduplicate(SortedArray.ofUnsortedArray(indices))
      });
    });
    return element_exports.Loci(loci.structure, elements);
  }
  Bond2.toStructureElementLoci = toStructureElementLoci;
  function toFirstStructureElementLoci(loci) {
    const { aUnit, aIndex } = loci.bonds[0];
    return element_exports.Loci(loci.structure, [{ unit: aUnit, indices: OrderedSet.ofSingleton(aIndex) }]);
  }
  Bond2.toFirstStructureElementLoci = toFirstStructureElementLoci;
  function getType(structure, location) {
    if (location.aUnit === location.bUnit) {
      const bonds = location.aUnit.bonds;
      const idx = bonds.getEdgeIndex(location.aIndex, location.bIndex);
      if (idx < 0)
        return BondType.create(BondType.Flag.None);
      return BondType.create(bonds.edgeProps.flags[idx]);
    } else {
      const bond = structure.interUnitBonds.getBondFromLocation(location);
      if (bond)
        return BondType.create(bond.props.flag);
      return BondType.create(BondType.Flag.None);
    }
  }
  Bond2.getType = getType;
  function getOrder(structure, location) {
    if (location.aUnit === location.bUnit) {
      const bonds = location.aUnit.bonds;
      const idx = bonds.getEdgeIndex(location.aIndex, location.bIndex);
      if (idx < 0)
        return 0;
      return bonds.edgeProps.order[idx];
    } else {
      const bond = structure.interUnitBonds.getBondFromLocation(location);
      if (bond)
        return bond.props.order;
      return 0;
    }
  }
  Bond2.getOrder = getOrder;
  function getIntraUnitBondCount(structure) {
    let count = 0;
    for (const ug of structure.unitSymmetryGroups) {
      const u = ug.units[0];
      if (Unit.isAtomic(u)) {
        count += u.bonds.edgeCount * ug.units.length;
      }
    }
    return count;
  }
  Bond2.getIntraUnitBondCount = getIntraUnitBondCount;
  class ElementBondIterator {
    move() {
      this.advance();
      return this.current;
    }
    setElement(structure, unit2, index) {
      this.structure = structure;
      this.unit = unit2;
      this.index = index;
      this.interBondIndices = structure.interUnitBonds.getEdgeIndices(index, unit2.id);
      this.interBondCount = this.interBondIndices.length;
      this.interBondIndex = 0;
      this.intraBondEnd = unit2.bonds.offset[index + 1];
      this.intraBondIndex = unit2.bonds.offset[index];
      this.hasNext = this.interBondIndex < this.interBondCount || this.intraBondIndex < this.intraBondEnd;
    }
    advance() {
      if (this.intraBondIndex < this.intraBondEnd) {
        this.current.otherUnit = this.unit;
        this.current.otherIndex = this.unit.bonds.b[this.intraBondIndex];
        this.current.type = this.unit.bonds.edgeProps.flags[this.intraBondIndex];
        this.current.order = this.unit.bonds.edgeProps.order[this.intraBondIndex];
        this.intraBondIndex += 1;
      } else if (this.interBondIndex < this.interBondCount) {
        const b = this.structure.interUnitBonds.edges[this.interBondIndices[this.interBondIndex]];
        this.current.otherUnit = this.structure.unitMap.get(b.unitA !== this.unit.id ? b.unitA : b.unitB);
        this.current.otherIndex = b.indexA !== this.index ? b.indexA : b.indexB;
        this.current.type = b.props.flag;
        this.current.order = b.props.order;
        this.interBondIndex += 1;
      } else {
        this.hasNext = false;
        return;
      }
      this.hasNext = this.interBondIndex < this.interBondCount || this.intraBondIndex < this.intraBondEnd;
    }
    constructor() {
      this.current = {};
      this.hasNext = false;
    }
  }
  Bond2.ElementBondIterator = ElementBondIterator;
  function getBoundingSphere(loci, boundingSphere) {
    return CentroidHelper.fromPairProvider(loci.bonds.length, (i, pA, pB) => {
      const { aUnit, aIndex, bUnit, bIndex } = loci.bonds[i];
      aUnit.conformation.position(aUnit.elements[aIndex], pA);
      bUnit.conformation.position(bUnit.elements[bIndex], pB);
    }, boundingSphere);
  }
  Bond2.getBoundingSphere = getBoundingSphere;
})(Bond || (Bond = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/unit/rings/compute.js
function computeRings(unit2) {
  const size = largestResidue(unit2);
  const state = State(unit2, size);
  const residuesIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.residueAtomSegments, unit2.elements);
  while (residuesIt.hasNext) {
    const seg = residuesIt.move();
    processResidue(state, seg.start, seg.end);
  }
  return state.rings;
}
var Constants;
(function(Constants2) {
  Constants2[Constants2["MaxDepth"] = 5] = "MaxDepth";
})(Constants || (Constants = {}));
function State(unit2, capacity) {
  return {
    startVertex: 0,
    endVertex: 0,
    count: 0,
    isRingAtom: new Int32Array(capacity),
    marked: new Int32Array(capacity),
    queue: new Int32Array(capacity),
    pred: new Int32Array(capacity),
    depth: new Int32Array(capacity),
    left: new Int32Array(Constants.MaxDepth),
    right: new Int32Array(Constants.MaxDepth),
    color: new Int32Array(capacity),
    currentColor: 0,
    currentAltLoc: "",
    hasAltLoc: false,
    rings: [],
    currentRings: [],
    unit: unit2,
    bonds: unit2.bonds,
    altLoc: unit2.model.atomicHierarchy.atoms.label_alt_id
  };
}
function resetState(state) {
  state.count = state.endVertex - state.startVertex;
  const { isRingAtom, pred, color, depth, marked } = state;
  for (let i = 0; i < state.count; i++) {
    isRingAtom[i] = 0;
    pred[i] = -1;
    marked[i] = -1;
    color[i] = 0;
    depth[i] = 0;
  }
  state.currentColor = 0;
  state.currentAltLoc = "";
  state.hasAltLoc = false;
}
function resetDepth(state) {
  const { depth } = state;
  for (let i = 0; i < state.count; i++) {
    depth[i] = state.count + 1;
  }
}
function largestResidue(unit2) {
  const residuesIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.residueAtomSegments, unit2.elements);
  let size = 0;
  while (residuesIt.hasNext) {
    const seg = residuesIt.move();
    size = Math.max(size, seg.end - seg.start);
  }
  return size;
}
function isStartIndex(state, i) {
  const bondOffset = state.bonds.offset;
  const a = state.startVertex + i;
  const bStart = bondOffset[a], bEnd = bondOffset[a + 1];
  const bondCount = bEnd - bStart;
  if (bondCount <= 1 || state.isRingAtom[i] && bondCount === 2)
    return false;
  return true;
}
function processResidue(state, start, end) {
  state.startVertex = start;
  state.endVertex = end;
  if (state.endVertex - state.startVertex < 3)
    return;
  state.currentRings = [];
  const { elements } = state.unit;
  const altLocs = [];
  for (let i = state.startVertex; i < state.endVertex; i++) {
    const altLoc = state.altLoc.value(elements[i]);
    arraySetAdd(altLocs, altLoc);
  }
  arraySetRemove(altLocs, "");
  let mark = 1;
  if (altLocs.length === 0) {
    resetState(state);
    for (let i = 0; i < state.count; i++) {
      if (!isStartIndex(state, i))
        continue;
      resetDepth(state);
      mark = findRings(state, i, mark);
    }
  } else {
    for (let aI = 0; aI < altLocs.length; aI++) {
      resetState(state);
      state.hasAltLoc = true;
      state.currentAltLoc = altLocs[aI];
      for (let i = 0; i < state.count; i++) {
        if (!isStartIndex(state, i))
          continue;
        const altLoc = state.altLoc.value(elements[state.startVertex + i]);
        if (altLoc && altLoc !== state.currentAltLoc) {
          continue;
        }
        resetDepth(state);
        mark = findRings(state, i, mark);
      }
    }
  }
  for (let i = 0, _i = state.currentRings.length; i < _i; i++) {
    state.rings.push(state.currentRings[i]);
  }
}
function addRing(state, a, b, isRingAtom) {
  if (b < a) {
    return false;
  }
  const { pred, color, left, right } = state;
  const nc = ++state.currentColor;
  let current = a;
  for (let t = 0; t < Constants.MaxDepth; t++) {
    color[current] = nc;
    current = pred[current];
    if (current < 0)
      break;
  }
  let leftOffset = 0, rightOffset = 0;
  let found = false, target = 0;
  current = b;
  for (let t = 0; t < Constants.MaxDepth; t++) {
    if (color[current] === nc) {
      target = current;
      found = true;
      break;
    }
    right[rightOffset++] = current;
    current = pred[current];
    if (current < 0)
      break;
  }
  if (!found) {
    return false;
  }
  current = a;
  for (let t = 0; t < Constants.MaxDepth; t++) {
    left[leftOffset++] = current;
    if (target === current)
      break;
    current = pred[current];
    if (current < 0)
      break;
  }
  const len = leftOffset + rightOffset;
  if (len < 3) {
    return false;
  }
  const ring = new Int32Array(len);
  let ringOffset = 0;
  for (let t = 0; t < leftOffset; t++) {
    ring[ringOffset++] = state.startVertex + left[t];
    isRingAtom[left[t]] = 1;
  }
  for (let t = rightOffset - 1; t >= 0; t--) {
    ring[ringOffset++] = state.startVertex + right[t];
    isRingAtom[right[t]] = 1;
  }
  sortArray(ring);
  for (let rI = 0, _rI = state.currentRings.length; rI < _rI; rI++) {
    const r = state.currentRings[rI];
    if (ring.length === r.length) {
      if (SortedArray.areEqual(ring, r))
        return false;
    } else if (ring.length > r.length) {
      if (SortedArray.isSubset(ring, r))
        return false;
    }
  }
  state.currentRings.push(SortedArray.ofSortedArray(ring));
  return true;
}
function findRings(state, from, mark) {
  const { bonds, startVertex, endVertex, isRingAtom, marked, queue, pred, depth } = state;
  const { elements } = state.unit;
  const { b: neighbor, edgeProps: { flags: bondFlags }, offset } = bonds;
  marked[from] = mark;
  depth[from] = 0;
  queue[0] = from;
  let head = 0, size = 1;
  while (head < size) {
    const top = queue[head++];
    const d = depth[top];
    const a = startVertex + top;
    const start = offset[a], end = offset[a + 1];
    for (let i = start; i < end; i++) {
      const b = neighbor[i];
      if (b < startVertex || b >= endVertex || !BondType.isCovalent(bondFlags[i]))
        continue;
      if (state.hasAltLoc) {
        const altLoc = state.altLoc.value(elements[b]);
        if (altLoc && state.currentAltLoc !== altLoc) {
          continue;
        }
      }
      const other = b - startVertex;
      if (marked[other] === mark) {
        if (pred[other] !== top && pred[top] !== other) {
          if (addRing(state, top, other, isRingAtom)) {
            return mark + 1;
          }
        }
        continue;
      }
      const newDepth = Math.min(depth[other], d + 1);
      if (newDepth > Constants.MaxDepth)
        continue;
      depth[other] = newDepth;
      marked[other] = mark;
      queue[size++] = other;
      pred[other] = top;
    }
  }
  return mark + 1;
}
function getFingerprint(elements) {
  const len = elements.length;
  const reversed = new Array(len);
  for (let i = 0; i < len; i++)
    reversed[i] = elements[len - i - 1];
  const rotNormal = getMinimalRotation(elements);
  const rotReversed = getMinimalRotation(reversed);
  let isNormalSmaller = false;
  for (let i = 0; i < len; i++) {
    const u = elements[(i + rotNormal) % len], v = reversed[(i + rotReversed) % len];
    if (u !== v) {
      isNormalSmaller = u < v;
      break;
    }
  }
  if (isNormalSmaller)
    return buildFinderprint(elements, rotNormal);
  return buildFinderprint(reversed, rotReversed);
}
function getMinimalRotation(elements) {
  const len = elements.length;
  const f = new Int32Array(len * 2);
  for (let i = 0; i < f.length; i++)
    f[i] = -1;
  let u = "", v = "", k = 0;
  for (let j = 1; j < f.length; j++) {
    let i = f[j - k - 1];
    while (i !== -1) {
      u = elements[j % len];
      v = elements[(k + i + 1) % len];
      if (u === v)
        break;
      if (u < v)
        k = j - i - 1;
      i = f[i];
    }
    if (i === -1) {
      u = elements[j % len];
      v = elements[(k + i + 1) % len];
      if (u !== v) {
        if (u < v)
          k = j;
        f[j - k] = -1;
      } else
        f[j - k] = i + 1;
    } else
      f[j - k] = i + 1;
  }
  return k;
}
function buildFinderprint(elements, offset) {
  const len = elements.length;
  const ret = [];
  let i;
  for (i = 0; i < len - 1; i++) {
    ret.push(elements[(i + offset) % len]);
    ret.push("-");
  }
  ret.push(elements[(i + offset) % len]);
  return ret.join("");
}
function createIndex(rings2, aromaticRings) {
  const elementRingIndices = /* @__PURE__ */ new Map();
  const elementAromaticRingIndices = /* @__PURE__ */ new Map();
  for (let rI = 0, _rI = rings2.length; rI < _rI; rI++) {
    const r = rings2[rI];
    for (let i = 0, _i = r.length; i < _i; i++) {
      const e = r[i];
      if (elementRingIndices.has(e))
        elementRingIndices.get(e).push(rI);
      else
        elementRingIndices.set(e, [rI]);
    }
  }
  for (let aI = 0, _aI = aromaticRings.length; aI < _aI; aI++) {
    const rI = aromaticRings[aI];
    const r = rings2[rI];
    for (let i = 0, _i = r.length; i < _i; i++) {
      const e = r[i];
      if (elementAromaticRingIndices.has(e))
        elementAromaticRingIndices.get(e).push(rI);
      else
        elementAromaticRingIndices.set(e, [rI]);
    }
  }
  const graph = new IntAdjacencyGraph.UniqueEdgeBuilder(rings2.length);
  for (let rI = 0, _rI = rings2.length; rI < _rI; rI++) {
    const r = rings2[rI];
    for (let i = 0, _i = r.length; i < _i; i++) {
      const e = r[i];
      const containedRings = elementRingIndices.get(e);
      if (containedRings.length === 1)
        continue;
      for (let j = 0, _j = containedRings.length; j < _j; j++) {
        const rJ = containedRings[j];
        if (rI >= rJ)
          continue;
        graph.addEdge(rI, rJ);
      }
    }
  }
  const components = IntAdjacencyGraph.connectedComponents(graph.getGraph());
  const ringComponentIndex = components.componentIndex;
  const ringComponents = [];
  for (let i = 0; i < components.componentCount; i++)
    ringComponents[i] = [];
  for (let rI = 0, _rI = rings2.length; rI < _rI; rI++) {
    ringComponents[ringComponentIndex[rI]].push(rI);
  }
  return { elementRingIndices, elementAromaticRingIndices, ringComponentIndex, ringComponents };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/atomic/measures.js
var AtomicNumbers = {
  "H": 1,
  "D": 1,
  "T": 1,
  "HE": 2,
  "LI": 3,
  "BE": 4,
  "B": 5,
  "C": 6,
  "N": 7,
  "O": 8,
  "F": 9,
  "NE": 10,
  "NA": 11,
  "MG": 12,
  "AL": 13,
  "SI": 14,
  "P": 15,
  "S": 16,
  "CL": 17,
  "AR": 18,
  "K": 19,
  "CA": 20,
  "SC": 21,
  "TI": 22,
  "V": 23,
  "CR": 24,
  "MN": 25,
  "FE": 26,
  "CO": 27,
  "NI": 28,
  "CU": 29,
  "ZN": 30,
  "GA": 31,
  "GE": 32,
  "AS": 33,
  "SE": 34,
  "BR": 35,
  "KR": 36,
  "RB": 37,
  "SR": 38,
  "Y": 39,
  "ZR": 40,
  "NB": 41,
  "MO": 42,
  "TC": 43,
  "RU": 44,
  "RH": 45,
  "PD": 46,
  "AG": 47,
  "CD": 48,
  "IN": 49,
  "SN": 50,
  "SB": 51,
  "TE": 52,
  "I": 53,
  "XE": 54,
  "CS": 55,
  "BA": 56,
  "LA": 57,
  "CE": 58,
  "PR": 59,
  "ND": 60,
  "PM": 61,
  "SM": 62,
  "EU": 63,
  "GD": 64,
  "TB": 65,
  "DY": 66,
  "HO": 67,
  "ER": 68,
  "TM": 69,
  "YB": 70,
  "LU": 71,
  "HF": 72,
  "TA": 73,
  "W": 74,
  "RE": 75,
  "OS": 76,
  "IR": 77,
  "PT": 78,
  "AU": 79,
  "HG": 80,
  "TL": 81,
  "PB": 82,
  "BI": 83,
  "PO": 84,
  "AT": 85,
  "RN": 86,
  "FR": 87,
  "RA": 88,
  "AC": 89,
  "TH": 90,
  "PA": 91,
  "U": 92,
  "NP": 93,
  "PU": 94,
  "AM": 95,
  "CM": 96,
  "BK": 97,
  "CF": 98,
  "ES": 99,
  "FM": 100,
  "MD": 101,
  "NO": 102,
  "LR": 103,
  "RF": 104,
  "DB": 105,
  "SG": 106,
  "BH": 107,
  "HS": 108,
  "MT": 109
};
var ElementVdwRadii = {
  1: 1.1,
  2: 1.4,
  3: 1.81,
  4: 1.53,
  5: 1.92,
  6: 1.7,
  7: 1.55,
  8: 1.52,
  9: 1.47,
  10: 1.54,
  11: 2.27,
  12: 1.73,
  13: 1.84,
  14: 2.1,
  15: 1.8,
  16: 1.8,
  17: 1.75,
  18: 1.88,
  19: 2.75,
  20: 2.31,
  21: 2.3,
  22: 2.15,
  23: 2.05,
  24: 2.05,
  25: 2.05,
  26: 2.05,
  27: 2,
  28: 2,
  29: 2,
  30: 2.1,
  31: 1.87,
  32: 2.11,
  33: 1.85,
  34: 1.9,
  35: 1.83,
  36: 2.02,
  37: 3.03,
  38: 2.49,
  39: 2.4,
  40: 2.3,
  41: 2.15,
  42: 2.1,
  43: 2.05,
  44: 2.05,
  45: 2,
  46: 2.05,
  47: 2.1,
  48: 2.2,
  49: 2.2,
  50: 1.93,
  51: 2.17,
  52: 2.06,
  53: 1.98,
  54: 2.16,
  55: 3.43,
  56: 2.68,
  57: 2.5,
  58: 2.48,
  59: 2.47,
  60: 2.45,
  61: 2.43,
  62: 2.42,
  63: 2.4,
  64: 2.38,
  65: 2.37,
  66: 2.35,
  67: 2.33,
  68: 2.32,
  69: 2.3,
  70: 2.28,
  71: 2.27,
  72: 2.25,
  73: 2.2,
  74: 2.1,
  75: 2.05,
  76: 2,
  77: 2,
  78: 2.05,
  79: 2.1,
  80: 2.05,
  81: 1.96,
  82: 2.02,
  83: 2.07,
  84: 1.97,
  85: 2.02,
  86: 2.2,
  87: 3.48,
  88: 2.83,
  89: 2,
  90: 2.4,
  91: 2,
  92: 2.3,
  93: 2,
  94: 2,
  95: 2,
  96: 2,
  97: 2,
  98: 2,
  99: 2,
  100: 2,
  101: 2,
  102: 2,
  103: 2,
  104: 2,
  105: 2,
  106: 2,
  107: 2,
  108: 2,
  109: 2
};
var ElementAtomWeights = {
  1: 1.008,
  2: 4.0026,
  3: 6.94,
  4: 9.0122,
  5: 10.81,
  6: 10.81,
  7: 14.007,
  8: 15.999,
  9: 18.998,
  10: 20.18,
  11: 22.99,
  12: 24.305,
  13: 26.982,
  14: 28.085,
  15: 30.974,
  16: 32.06,
  17: 35.45,
  18: 39.948,
  19: 39.098,
  20: 40.078,
  21: 44.956,
  22: 47.867,
  23: 50.942,
  24: 51.996,
  25: 54.938,
  26: 55.845,
  27: 58.933,
  28: 58.693,
  29: 63.546,
  30: 65.38,
  31: 69.723,
  32: 72.63,
  33: 74.922,
  34: 78.971,
  35: 79.904,
  36: 83.798,
  37: 85.468,
  38: 87.62,
  39: 88.906,
  40: 91.224,
  41: 92.906,
  42: 95.95,
  43: 96.906,
  44: 101.07,
  45: 102.91,
  46: 106.42,
  47: 107.87,
  48: 112.41,
  49: 114.82,
  50: 118.71,
  51: 121.76,
  52: 127.6,
  53: 127.6,
  54: 131.29,
  55: 132.91,
  56: 137.33,
  57: 138.91,
  58: 140.12,
  59: 140.91,
  60: 144.24,
  61: 144.912,
  62: 150.36,
  63: 151.96,
  64: 157.25,
  65: 158.93,
  66: 162.5,
  67: 164.93,
  68: 167.26,
  69: 168.93,
  70: 173.05,
  71: 174.97,
  72: 178.49,
  73: 180.95,
  74: 183.84,
  75: 186.21,
  76: 190.23,
  77: 192.22,
  78: 195.08,
  79: 196.97,
  80: 200.59,
  81: 204.38,
  82: 207.2,
  83: 208.98,
  84: 1.97,
  85: 2.02,
  86: 2.2,
  87: 3.48,
  88: 2.83,
  89: 2,
  90: 232.04,
  91: 231.04,
  92: 238.03,
  93: 237.048,
  94: 244.064,
  95: 243.061,
  96: 247.07,
  97: 247.07,
  98: 251.079,
  99: 252.083,
  100: 257.095,
  101: 258.098,
  102: 259.101,
  103: 262.11,
  104: 267.122,
  105: 270.131,
  106: 271.134,
  107: 270.133,
  108: 270.134,
  109: 278.156
};
var DefaultVdwRadius = 1.7;
var DefaultAtomWeight = 10.81;
var DefaultAtomNumber = 0;
function VdwRadius(element) {
  const i = AtomicNumbers[element];
  return i === void 0 ? DefaultVdwRadius : ElementVdwRadii[i];
}
function AtomWeight(element) {
  const i = AtomicNumbers[element];
  return i === void 0 ? DefaultAtomWeight : ElementAtomWeights[i];
}
function AtomNumber(element) {
  const i = AtomicNumbers[element];
  return i === void 0 ? DefaultAtomNumber : i;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/atomic/types.js
var Elements;
(function(Elements2) {
  Elements2["H"] = "H";
  Elements2["D"] = "D";
  Elements2["T"] = "T";
  Elements2["HE"] = "HE";
  Elements2["LI"] = "LI";
  Elements2["BE"] = "BE";
  Elements2["B"] = "B";
  Elements2["C"] = "C";
  Elements2["N"] = "N";
  Elements2["O"] = "O";
  Elements2["F"] = "F";
  Elements2["NE"] = "NE";
  Elements2["NA"] = "NA";
  Elements2["MG"] = "MG";
  Elements2["AL"] = "AL";
  Elements2["SI"] = "SI";
  Elements2["P"] = "P";
  Elements2["S"] = "S";
  Elements2["CL"] = "CL";
  Elements2["AR"] = "AR";
  Elements2["K"] = "K";
  Elements2["CA"] = "CA";
  Elements2["SC"] = "SC";
  Elements2["TI"] = "TI";
  Elements2["V"] = "V";
  Elements2["CR"] = "CR";
  Elements2["MN"] = "MN";
  Elements2["FE"] = "FE";
  Elements2["CO"] = "CO";
  Elements2["NI"] = "NI";
  Elements2["CU"] = "CU";
  Elements2["ZN"] = "ZN";
  Elements2["GA"] = "GA";
  Elements2["GE"] = "GE";
  Elements2["AS"] = "AS";
  Elements2["SE"] = "SE";
  Elements2["BR"] = "BR";
  Elements2["KR"] = "KR";
  Elements2["RB"] = "RB";
  Elements2["SR"] = "SR";
  Elements2["Y"] = "Y";
  Elements2["ZR"] = "ZR";
  Elements2["NB"] = "NB";
  Elements2["MO"] = "MO";
  Elements2["TC"] = "TC";
  Elements2["RU"] = "RU";
  Elements2["RH"] = "RH";
  Elements2["PD"] = "PD";
  Elements2["AG"] = "AG";
  Elements2["CD"] = "CD";
  Elements2["IN"] = "IN";
  Elements2["SN"] = "SN";
  Elements2["SB"] = "SB";
  Elements2["TE"] = "TE";
  Elements2["I"] = "I";
  Elements2["XE"] = "XE";
  Elements2["CS"] = "CS";
  Elements2["BA"] = "BA";
  Elements2["LA"] = "LA";
  Elements2["CE"] = "CE";
  Elements2["PR"] = "PR";
  Elements2["ND"] = "ND";
  Elements2["PM"] = "PM";
  Elements2["SM"] = "SM";
  Elements2["EU"] = "EU";
  Elements2["GD"] = "GD";
  Elements2["TB"] = "TB";
  Elements2["DY"] = "DY";
  Elements2["HO"] = "HO";
  Elements2["ER"] = "ER";
  Elements2["TM"] = "TM";
  Elements2["YB"] = "YB";
  Elements2["LU"] = "LU";
  Elements2["HF"] = "HF";
  Elements2["TA"] = "TA";
  Elements2["W"] = "W";
  Elements2["RE"] = "RE";
  Elements2["OS"] = "OS";
  Elements2["IR"] = "IR";
  Elements2["PT"] = "PT";
  Elements2["AU"] = "AU";
  Elements2["HG"] = "HG";
  Elements2["TL"] = "TL";
  Elements2["PB"] = "PB";
  Elements2["BI"] = "BI";
  Elements2["PO"] = "PO";
  Elements2["AT"] = "AT";
  Elements2["RN"] = "RN";
  Elements2["FR"] = "FR";
  Elements2["RA"] = "RA";
  Elements2["AC"] = "AC";
  Elements2["TH"] = "TH";
  Elements2["PA"] = "PA";
  Elements2["U"] = "U";
  Elements2["NP"] = "NP";
  Elements2["PU"] = "PU";
  Elements2["AM"] = "AM";
  Elements2["CM"] = "CM";
  Elements2["BK"] = "BK";
  Elements2["CF"] = "CF";
  Elements2["ES"] = "ES";
  Elements2["FM"] = "FM";
  Elements2["MD"] = "MD";
  Elements2["NO"] = "NO";
  Elements2["LR"] = "LR";
  Elements2["RF"] = "RF";
  Elements2["DB"] = "DB";
  Elements2["SG"] = "SG";
  Elements2["BH"] = "BH";
  Elements2["HS"] = "HS";
  Elements2["MT"] = "MT";
  Elements2["DS"] = "DS";
  Elements2["RG"] = "RG";
  Elements2["CN"] = "CN";
  Elements2["NH"] = "NH";
  Elements2["FL"] = "FL";
  Elements2["MC"] = "MC";
  Elements2["LV"] = "LV";
  Elements2["TS"] = "TS";
  Elements2["OG"] = "OG";
})(Elements || (Elements = {}));
var ElementNames = {
  H: "Hydrogen",
  HE: "Helium",
  LI: "Lithium",
  BE: "Beryllium",
  B: "Boron",
  C: "Carbon",
  N: "Nitrogen",
  O: "Oxygen",
  F: "Fluorine",
  NE: "Neon",
  NA: "Sodium",
  MG: "Magnesium",
  AL: "Aluminum",
  SI: "Silicon",
  P: "Phosphorus",
  S: "Sulfur",
  CL: "Chlorine",
  AR: "Argon",
  K: "Potassium",
  CA: "Calcium",
  SC: "Scandium",
  TI: "Titanium",
  V: "Vanadium",
  CR: "Chromium",
  MN: "Manganese",
  FE: "Iron",
  CO: "Cobalt",
  NI: "Nickel",
  CU: "Copper",
  ZN: "Zinc",
  GA: "Gallium",
  GE: "Germanium",
  AS: "Arsenic",
  SE: "Selenium",
  BR: "Bromine",
  KR: "Krypton",
  RB: "Rubidium",
  SR: "Strontium",
  Y: "Yttrium",
  ZR: "Zirconium",
  NB: "Niobium",
  MO: "Molybdenum",
  TC: "Technetium",
  RU: "Ruthenium",
  RH: "Rhodium",
  PD: "Palladium",
  AG: "Silver",
  CD: "Cadmium",
  IN: "Indium",
  SN: "Tin",
  SB: "Antimony",
  TE: "Tellurium",
  I: "Iodine",
  XE: "Xenon",
  CS: "Cesium",
  BA: "Barium",
  LA: "Lanthanum",
  CE: "Cerium",
  PR: "Praseodymium",
  ND: "Neodymium",
  PM: "Promethium",
  SM: "Samarium",
  EU: "Europium",
  GD: "Gadolinium",
  TB: "Terbium",
  DY: "Dysprosium",
  HO: "Holmium",
  ER: "Erbium",
  TM: "Thulium",
  YB: "Ytterbium",
  LU: "Lutetium",
  HF: "Hafnium",
  TA: "Tantalum",
  W: "Wolfram",
  RE: "Rhenium",
  OS: "Osmium",
  IR: "Iridium",
  PT: "Platinum",
  AU: "Gold",
  HG: "Mercury",
  TL: "Thallium",
  PB: "Lead",
  BI: "Bismuth",
  PO: "Polonium",
  AT: "Astatine",
  RN: "Radon",
  FR: "Francium",
  RA: "Radium",
  AC: "Actinium",
  TH: "Thorium",
  PA: "Protactinium",
  U: "Uranium",
  NP: "Neptunium",
  PU: "Plutonium",
  AM: "Americium",
  CM: "Curium",
  BK: "Berkelium",
  CF: "Californium",
  ES: "Einsteinium",
  FM: "Fermium",
  MD: "Mendelevium",
  NO: "Nobelium",
  LR: "Lawrencium",
  RF: "Rutherfordium",
  DB: "Dubnium",
  SG: "Seaborgium",
  BH: "Bohrium",
  HS: "Hassium",
  MT: "Meitnerium",
  DS: "Darmstadtium",
  RG: "Roentgenium",
  CN: "Copernicium",
  NH: "Nihonium",
  FL: "Flerovium",
  MC: "Moscovium",
  LV: "Livermorium",
  TS: "Tennessine",
  OG: "Oganesson"
};
var AlkaliMetals = /* @__PURE__ */ new Set(["LI", "NA", "K", "RB", "CS", "FR"]);
function isAlkaliMetal(element) {
  return AlkaliMetals.has(element);
}
var AlkalineEarthMetals = /* @__PURE__ */ new Set(["BE", "MG", "CA", "SR", "BA", "RA"]);
function isAlkalineEarthMetal(element) {
  return AlkalineEarthMetals.has(element);
}
var PostTransitionMetals = /* @__PURE__ */ new Set(["ZN", "GA", "CD", "IN", "SN", "HG", "TI", "PB", "BI", "PO", "CN"]);
function isPostTransitionMetal(element) {
  return PostTransitionMetals.has(element);
}
var Halogens = /* @__PURE__ */ new Set(["F", "CL", "BR", "I", "AT"]);
function isHalogen(element) {
  return Halogens.has(element);
}
function isTransitionMetal(element) {
  const no = AtomNumber(element);
  return no >= 21 && no <= 29 || no >= 39 && no <= 47 || no >= 72 && no <= 79 || no >= 104 && no <= 108;
}
function isLanthanide(element) {
  const no = AtomNumber(element);
  return no >= 57 && no <= 71;
}
function isActinide(element) {
  const no = AtomNumber(element);
  return no >= 89 && no <= 103;
}
function isMetal(element) {
  return isAlkaliMetal(element) || isAlkalineEarthMetal(element) || isLanthanide(element) || isActinide(element) || isTransitionMetal(element) || isPostTransitionMetal(element);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/util.js
function getCoarseBegCompId(unit2, element) {
  const entityKey = unit2.coarseElements.entityKey[element];
  const seq = unit2.model.sequence.byEntityKey[entityKey].sequence;
  const seq_id_begin = unit2.coarseElements.seq_id_begin.value(element);
  return seq.compId.value(seq_id_begin - 1);
}
function getElementMoleculeType(unit2, element) {
  switch (unit2.kind) {
    case Unit.Kind.Atomic:
      return unit2.model.atomicHierarchy.derived.residue.moleculeType[unit2.residueIndex[element]];
    case Unit.Kind.Spheres:
    case Unit.Kind.Gaussians:
      const compId2 = getCoarseBegCompId(unit2, element);
      const cc = unit2.model.properties.chemicalComponentMap.get(compId2);
      if (cc)
        return getMoleculeType(cc.type, compId2);
  }
  return MoleculeType.Unknown;
}
var EmptyAtomIds = /* @__PURE__ */ new Set();
function getAtomIdForAtomRole(polymerType, atomRole) {
  const p3 = PolymerTypeAtomRoleId[polymerType];
  if (p3 !== void 0) {
    const a = p3[atomRole];
    if (a !== void 0)
      return a;
  }
  return EmptyAtomIds;
}
var tmpPositionsVec = Vec3.zero();
function getPositions(unit2, indices) {
  const c = unit2.conformation;
  const positions = new Float32Array(indices.length * 3);
  const { elements } = unit2;
  for (let i = 0, il = indices.length; i < il; ++i) {
    c.position(elements[indices[i]], tmpPositionsVec);
    Vec3.toArray(tmpPositionsVec, positions, i * 3);
  }
  return positions;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/unit/rings.js
var UnitRings = class {
  get index() {
    if (this._index)
      return this._index;
    this._index = createIndex(this.all, this.aromaticRings);
    return this._index;
  }
  get byFingerprint() {
    if (this._byFingerprint)
      return this._byFingerprint;
    this._byFingerprint = createByFingerprint(this.unit, this.all);
    return this._byFingerprint;
  }
  /** Maps atom index inside a Unit to ring indices (an atom can be part of more than one ring) */
  get elementRingIndices() {
    return this.index.elementRingIndices;
  }
  get elementAromaticRingIndices() {
    return this.index.elementAromaticRingIndices;
  }
  /** Maps UnitRings.Index to index to ringComponents */
  get ringComponentIndex() {
    return this.index.ringComponentIndex;
  }
  get ringComponents() {
    return this.index.ringComponents;
  }
  get aromaticRings() {
    if (this._aromaticRings)
      return this._aromaticRings;
    this._aromaticRings = getAromaticRings(this.unit, this.all);
    return this._aromaticRings;
  }
  constructor(all2, unit2) {
    this.unit = unit2;
    this.all = all2;
  }
};
var UnitRing;
(function(UnitRing2) {
  function fingerprint(unit2, ring) {
    const { elements } = unit2;
    const { type_symbol } = unit2.model.atomicHierarchy.atoms;
    const symbols = [];
    for (let i = 0, _i = ring.length; i < _i; i++)
      symbols[symbols.length] = type_symbol.value(elements[ring[i]]);
    return elementFingerprint(symbols);
  }
  UnitRing2.fingerprint = fingerprint;
  function elementFingerprint(elements) {
    return getFingerprint(elements);
  }
  UnitRing2.elementFingerprint = elementFingerprint;
  const AromaticRingElements = /* @__PURE__ */ new Set([
    Elements.B,
    Elements.C,
    Elements.N,
    Elements.O,
    Elements.SI,
    Elements.P,
    Elements.S,
    Elements.GE,
    Elements.AS,
    Elements.SN,
    Elements.SB,
    Elements.BI
  ]);
  const AromaticRingPlanarityThreshold = 0.05;
  function isAromatic(unit2, ring) {
    const { elements, bonds: { b, offset, edgeProps: { flags: flags2 } } } = unit2;
    const { type_symbol, label_comp_id } = unit2.model.atomicHierarchy.atoms;
    if (label_comp_id.value(unit2.elements[ring[0]]) === "PRO")
      return false;
    let aromaticBondCount = 0;
    let hasAromaticRingElement = false;
    for (let i = 0, il = ring.length; i < il; ++i) {
      const aI = ring[i];
      if (!hasAromaticRingElement && AromaticRingElements.has(type_symbol.value(elements[aI]))) {
        hasAromaticRingElement = true;
      }
      for (let j = offset[aI], jl = offset[aI + 1]; j < jl; ++j) {
        if (BondType.is(BondType.Flag.Aromatic, flags2[j])) {
          if (SortedArray.has(ring, b[j]))
            aromaticBondCount += 1;
        }
      }
    }
    if (aromaticBondCount === 2 * ring.length)
      return true;
    if (!hasAromaticRingElement)
      return false;
    if (ring.length < 5)
      return false;
    if (aromaticBondCount > 0)
      return false;
    const ma = PrincipalAxes.calculateMomentsAxes(getPositions(unit2, ring));
    return Vec3.magnitude(ma.dirC) < AromaticRingPlanarityThreshold;
  }
  UnitRing2.isAromatic = isAromatic;
  function getAltId2(unit2, ring) {
    const { label_alt_id } = unit2.model.atomicHierarchy.atoms;
    const { elements } = unit2;
    for (let i = 0, il = ring.length; i < il; ++i) {
      const eI = elements[ring[i]];
      const altId = label_alt_id.value(eI);
      if (altId)
        return altId;
    }
    return "";
  }
  UnitRing2.getAltId = getAltId2;
})(UnitRing || (UnitRing = {}));
(function(UnitRings2) {
  function create(unit2) {
    const rings2 = computeRings(unit2);
    return new UnitRings2(rings2, unit2);
  }
  UnitRings2.create = create;
  function byFingerprintAndResidue(rings2, fingerprints) {
    const map2 = /* @__PURE__ */ new Map();
    for (let fI = 0, _fI = fingerprints.length; fI < _fI; fI++) {
      const fp = fingerprints[fI];
      addSingleResidueRings(rings2, fp, map2);
    }
    return map2;
  }
  UnitRings2.byFingerprintAndResidue = byFingerprintAndResidue;
})(UnitRings || (UnitRings = {}));
function createByFingerprint(unit2, rings2) {
  const byFingerprint = /* @__PURE__ */ new Map();
  let idx = 0;
  for (let rI = 0, _rI = rings2.length; rI < _rI; rI++) {
    const r = rings2[rI];
    const fp = UnitRing.fingerprint(unit2, r);
    if (byFingerprint.has(fp))
      byFingerprint.get(fp).push(idx);
    else
      byFingerprint.set(fp, [idx]);
    idx++;
  }
  return byFingerprint;
}
function ringResidueIdx(unit2, ring) {
  const { elements } = unit2;
  const residueIndex2 = unit2.model.atomicHierarchy.residueAtomSegments.index;
  const idx = residueIndex2[elements[ring[0]]];
  for (let rI = 1, _rI = ring.length; rI < _rI; rI++) {
    if (idx !== residueIndex2[elements[ring[rI]]])
      return -1;
  }
  return idx;
}
function addSingleResidueRings(rings2, fp, map2) {
  const byFp = rings2.byFingerprint.get(fp);
  if (!byFp)
    return;
  for (let rI = 0, _rI = byFp.length; rI < _rI; rI++) {
    const r = byFp[rI];
    const idx = ringResidueIdx(rings2.unit, rings2.all[r]);
    if (idx >= 0) {
      if (map2.has(idx))
        map2.get(idx).push(r);
      else
        map2.set(idx, [r]);
    }
  }
}
function getAromaticRings(unit2, rings2) {
  const aromaticRings = [];
  for (let i = 0, il = rings2.length; i < il; ++i) {
    if (UnitRing.isAromatic(unit2, rings2[i]))
      aromaticRings.push(i);
  }
  return aromaticRings;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-data/int/sorted-ranges.js
var SortedRanges;
(function(SortedRanges2) {
  function ofSortedRanges(array2) {
    return SortedArray.ofSortedArray(array2);
  }
  SortedRanges2.ofSortedRanges = ofSortedRanges;
  function start(ranges) {
    return ranges[0];
  }
  SortedRanges2.start = start;
  function end(ranges) {
    return ranges[ranges.length - 1] + 1;
  }
  SortedRanges2.end = end;
  function min(ranges) {
    return ranges[0];
  }
  SortedRanges2.min = min;
  function max(ranges) {
    return ranges[ranges.length - 1];
  }
  SortedRanges2.max = max;
  function size(ranges) {
    let size2 = 0;
    for (let i = 0, il = ranges.length; i < il; i += 2) {
      size2 += ranges[i + 1] - ranges[i] + 1;
    }
    return size2;
  }
  SortedRanges2.size = size;
  function count(ranges) {
    return ranges.length / 2;
  }
  SortedRanges2.count = count;
  function startAt(ranges, index) {
    return ranges[index * 2];
  }
  SortedRanges2.startAt = startAt;
  function endAt(ranges, index) {
    return ranges[index * 2 + 1] + 1;
  }
  SortedRanges2.endAt = endAt;
  function minAt(ranges, index) {
    return ranges[index * 2];
  }
  SortedRanges2.minAt = minAt;
  function maxAt(ranges, index) {
    return ranges[index * 2 + 1];
  }
  SortedRanges2.maxAt = maxAt;
  function areEqual(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0, il = a.length; i < il; ++i) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  SortedRanges2.areEqual = areEqual;
  function forEach(ranges, f) {
    let k = 0;
    for (let i = 0, il = ranges.length; i < il; i += 2) {
      for (let j = ranges[i], jl = ranges[i + 1]; j <= jl; ++j) {
        f(j, k);
        ++k;
      }
    }
  }
  SortedRanges2.forEach = forEach;
  function has(ranges, set2) {
    return firstIntersectionIndex(ranges, set2) !== -1;
  }
  SortedRanges2.has = has;
  function hasFrom(ranges, set2, from) {
    return firstIntersectionIndexFrom(ranges, set2, from) !== -1;
  }
  SortedRanges2.hasFrom = hasFrom;
  function firstIntersectionIndex(ranges, set2) {
    return firstIntersectionIndexFrom(ranges, set2, 0);
  }
  SortedRanges2.firstIntersectionIndex = firstIntersectionIndex;
  function firstIntersectionIndexFrom(ranges, set2, from) {
    if (minAt(ranges, from) > OrderedSet.max(set2) || max(ranges) < OrderedSet.min(set2))
      return -1;
    for (let i = from, il = count(ranges); i < il; ++i) {
      const interval = Interval.ofRange(minAt(ranges, i), maxAt(ranges, i));
      if (OrderedSet.areIntersecting(interval, set2))
        return i;
    }
    return -1;
  }
  SortedRanges2.firstIntersectionIndexFrom = firstIntersectionIndexFrom;
  function transientSegments(ranges, set2) {
    return new Iterator2(ranges, set2);
  }
  SortedRanges2.transientSegments = transientSegments;
  class Iterator2 {
    updateValue() {
      this.value.index = this.curIndex;
      this.value.start = OrderedSet.findPredecessorIndex(this.set, startAt(this.ranges, this.curIndex));
      this.value.end = OrderedSet.findPredecessorIndex(this.set, endAt(this.ranges, this.curIndex));
    }
    move() {
      if (this.hasNext) {
        this.updateValue();
        this.curIndex = firstIntersectionIndexFrom(this.ranges, this.set, this.curIndex + 1);
        this.hasNext = this.curIndex !== -1;
      }
      return this.value;
    }
    constructor(ranges, set2) {
      this.ranges = ranges;
      this.set = set2;
      this.value = { index: 0, start: 0, end: 0 };
      this.curIndex = 0;
      this.hasNext = false;
      this.curIndex = firstIntersectionIndex(ranges, set2);
      this.hasNext = this.curIndex !== -1;
    }
  }
  SortedRanges2.Iterator = Iterator2;
})(SortedRanges || (SortedRanges = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/util/polymer.js
function getAtomicPolymerElements(unit2) {
  const indices = [];
  const { elements, model } = unit2;
  const { residueAtomSegments } = unit2.model.atomicHierarchy;
  const { traceElementIndex } = model.atomicHierarchy.derived.residue;
  const polymerIt = SortedRanges.transientSegments(unit2.model.atomicRanges.polymerRanges, elements);
  const residueIt = Segmentation.transientSegments(residueAtomSegments, elements);
  while (polymerIt.hasNext) {
    const polymerSegment = polymerIt.move();
    residueIt.setSegment(polymerSegment);
    while (residueIt.hasNext) {
      const residueSegment = residueIt.move();
      const { start, end, index } = residueSegment;
      if (OrderedSet.areIntersecting(Interval.ofRange(elements[start], elements[end - 1]), elements)) {
        const elementIndex = traceElementIndex[index];
        indices.push(elementIndex === -1 ? residueAtomSegments.offsets[index] : elementIndex);
      }
    }
  }
  return SortedArray.ofSortedArray(indices);
}
function getCoarsePolymerElements(unit2) {
  const indices = [];
  const { elements, model } = unit2;
  const { spheres: spheres2, gaussians } = model.coarseHierarchy;
  const polymerRanges = Unit.isSpheres(unit2) ? spheres2.polymerRanges : gaussians.polymerRanges;
  const polymerIt = SortedRanges.transientSegments(polymerRanges, elements);
  while (polymerIt.hasNext) {
    const { start, end } = polymerIt.move();
    for (let i = start; i < end; ++i) {
      indices.push(elements[i]);
    }
  }
  return SortedArray.ofSortedArray(indices);
}
function getAtomicGapElements(unit2) {
  const indices = [];
  const { elements, model, residueIndex: residueIndex2 } = unit2;
  const { residueAtomSegments } = unit2.model.atomicHierarchy;
  const { traceElementIndex } = model.atomicHierarchy.derived.residue;
  const gapIt = SortedRanges.transientSegments(unit2.model.atomicRanges.gapRanges, unit2.elements);
  while (gapIt.hasNext) {
    const gapSegment = gapIt.move();
    const indexStart = residueIndex2[elements[gapSegment.start]];
    const indexEnd = residueIndex2[elements[gapSegment.end - 1]];
    const elementIndexStart = traceElementIndex[indexStart];
    const elementIndexEnd = traceElementIndex[indexEnd];
    indices.push(elementIndexStart === -1 ? residueAtomSegments.offsets[indexStart] : elementIndexStart);
    indices.push(elementIndexEnd === -1 ? residueAtomSegments.offsets[indexEnd] : elementIndexEnd);
  }
  return SortedArray.ofSortedArray(indices);
}
function getCoarseGapElements(unit2) {
  const indices = [];
  const { elements, model } = unit2;
  const { spheres: spheres2, gaussians } = model.coarseHierarchy;
  const gapRanges = Unit.isSpheres(unit2) ? spheres2.gapRanges : gaussians.gapRanges;
  const gapIt = SortedRanges.transientSegments(gapRanges, elements);
  while (gapIt.hasNext) {
    const { start, end } = gapIt.move();
    indices.push(elements[start], elements[end - 1]);
  }
  return SortedArray.ofSortedArray(indices);
}
function getNucleotideElements(unit2) {
  const indices = [];
  const { elements, model } = unit2;
  const { chainAtomSegments, residueAtomSegments } = model.atomicHierarchy;
  const { moleculeType, traceElementIndex } = model.atomicHierarchy.derived.residue;
  const chainIt = Segmentation.transientSegments(chainAtomSegments, elements);
  const residueIt = Segmentation.transientSegments(residueAtomSegments, elements);
  while (chainIt.hasNext) {
    residueIt.setSegment(chainIt.move());
    while (residueIt.hasNext) {
      const { index } = residueIt.move();
      if (isNucleic(moleculeType[index])) {
        const elementIndex = traceElementIndex[index];
        indices.push(elementIndex === -1 ? residueAtomSegments.offsets[index] : elementIndex);
      }
    }
  }
  return SortedArray.ofSortedArray(indices);
}
function getProteinElements(unit2) {
  const indices = [];
  const { elements, model } = unit2;
  const { chainAtomSegments, residueAtomSegments } = model.atomicHierarchy;
  const { moleculeType, traceElementIndex } = model.atomicHierarchy.derived.residue;
  const chainIt = Segmentation.transientSegments(chainAtomSegments, elements);
  const residueIt = Segmentation.transientSegments(residueAtomSegments, elements);
  while (chainIt.hasNext) {
    residueIt.setSegment(chainIt.move());
    while (residueIt.hasNext) {
      const { index } = residueIt.move();
      if (isProtein(moleculeType[index])) {
        const elementIndex = traceElementIndex[index];
        indices.push(elementIndex === -1 ? residueAtomSegments.offsets[index] : elementIndex);
      }
    }
  }
  return SortedArray.ofSortedArray(indices);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/util/principal-axes.js
var tempPos = Vec3();
function toPositionsArray(unit2) {
  const { elements, conformation } = unit2;
  const positions = new Float32Array(elements.length * 3);
  for (let i = 0, il = elements.length; i < il; i++) {
    conformation.invariantPosition(elements[i], tempPos);
    Vec3.toArray(tempPos, positions, i * 3);
  }
  return positions;
}
function getPrincipalAxes(unit2) {
  const positions = toPositionsArray(unit2);
  return PrincipalAxes.ofPositions(positions);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/boundary-helper.js
var v3dot = Vec3.dot;
var v3copy = Vec3.copy;
var v3scaleAndSub = Vec3.scaleAndSub;
var v3scaleAndAdd = Vec3.scaleAndAdd;
var BoundaryHelper = class {
  computeExtrema(i, p3) {
    const d = v3dot(this.dir[i], p3);
    if (d < this.minDist[i]) {
      this.minDist[i] = d;
      v3copy(this.extrema[i * 2], p3);
    }
    if (d > this.maxDist[i]) {
      this.maxDist[i] = d;
      v3copy(this.extrema[i * 2 + 1], p3);
    }
  }
  computeSphereExtrema(i, center, radius) {
    const di = this.dir[i];
    const d = v3dot(di, center);
    if (d - radius < this.minDist[i]) {
      this.minDist[i] = d - radius;
      v3scaleAndSub(this.extrema[i * 2], center, di, radius);
    }
    if (d + radius > this.maxDist[i]) {
      this.maxDist[i] = d + radius;
      v3scaleAndAdd(this.extrema[i * 2 + 1], center, di, radius);
    }
  }
  includeSphere(s) {
    if (Sphere3D.hasExtrema(s) && s.extrema.length > 1) {
      for (const e of s.extrema) {
        this.includePosition(e);
      }
    } else {
      this.includePositionRadius(s.center, s.radius);
    }
  }
  includePosition(p3) {
    for (let i = 0; i < this.dirLength; ++i) {
      this.computeExtrema(i, p3);
    }
  }
  includePositionRadius(center, radius) {
    for (let i = 0; i < this.dirLength; ++i) {
      this.computeSphereExtrema(i, center, radius);
    }
  }
  finishedIncludeStep() {
    for (let i = 0; i < this.extrema.length; i++) {
      this.centroidHelper.includeStep(this.extrema[i]);
    }
    this.centroidHelper.finishedIncludeStep();
  }
  radiusSphere(s) {
    if (Sphere3D.hasExtrema(s) && s.extrema.length > 1) {
      for (const e of s.extrema) {
        this.radiusPosition(e);
      }
    } else {
      this.radiusPositionRadius(s.center, s.radius);
    }
  }
  radiusPosition(p3) {
    this.centroidHelper.radiusStep(p3);
  }
  radiusPositionRadius(center, radius) {
    this.centroidHelper.radiusSphereStep(center, radius);
  }
  getSphere(sphere) {
    return Sphere3D.setExtrema(this.centroidHelper.getSphere(sphere), this.extrema.slice());
  }
  getBox(box) {
    return Box3D.fromVec3Array(box || Box3D(), this.extrema);
  }
  reset() {
    for (let i = 0; i < this.dirLength; ++i) {
      this.minDist[i] = Infinity;
      this.maxDist[i] = -Infinity;
      this.extrema[i * 2] = Vec3();
      this.extrema[i * 2 + 1] = Vec3();
    }
    this.centroidHelper.reset();
  }
  constructor(quality) {
    this.minDist = [];
    this.maxDist = [];
    this.extrema = [];
    this.centroidHelper = new CentroidHelper();
    this.dir = getEposDir(quality);
    this.dirLength = this.dir.length;
    this.reset();
  }
};
function getEposDir(quality) {
  let dir;
  switch (quality) {
    case "6":
      dir = [...Type001];
      break;
    case "14":
      dir = [...Type001, ...Type111];
      break;
    case "26":
      dir = [...Type001, ...Type111, ...Type011];
      break;
    case "98":
      dir = [...Type001, ...Type111, ...Type011, ...Type012, ...Type112, ...Type122];
      break;
  }
  return dir.map((a) => {
    const v = Vec3.create(a[0], a[1], a[2]);
    return Vec3.normalize(v, v);
  });
}
var Type001 = [
  [1, 0, 0],
  [0, 1, 0],
  [0, 0, 1]
];
var Type111 = [
  [1, 1, 1],
  [-1, 1, 1],
  [-1, -1, 1],
  [1, -1, 1]
];
var Type011 = [
  [1, 1, 0],
  [1, -1, 0],
  [1, 0, 1],
  [1, 0, -1],
  [0, 1, 1],
  [0, 1, -1]
];
var Type012 = [
  [0, 1, 2],
  [0, 2, 1],
  [1, 0, 2],
  [2, 0, 1],
  [1, 2, 0],
  [2, 1, 0],
  [0, 1, -2],
  [0, 2, -1],
  [1, 0, -2],
  [2, 0, -1],
  [1, -2, 0],
  [2, -1, 0]
];
var Type112 = [
  [1, 1, 2],
  [2, 1, 1],
  [1, 2, 1],
  [1, -1, 2],
  [1, 1, -2],
  [1, -1, -2],
  [2, -1, 1],
  [2, 1, -1],
  [2, -1, -1],
  [1, -2, 1],
  [1, 2, -1],
  [1, -2, -1]
];
var Type122 = [
  [2, 2, 1],
  [1, 2, 2],
  [2, 1, 2],
  [2, -2, 1],
  [2, 2, -1],
  [2, -2, -1],
  [1, -2, 2],
  [1, 2, -2],
  [1, -2, -2],
  [2, -1, 2],
  [2, 1, -2],
  [2, -1, -2]
];

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/boundary.js
var v3set2 = Vec3.set;
var boundaryHelperCoarse = new BoundaryHelper("14");
var boundaryHelperFine = new BoundaryHelper("98");
function getBoundaryHelper(count) {
  return count > 1e4 ? boundaryHelperCoarse : boundaryHelperFine;
}
function getFastBoundary(data) {
  const box = Box3D.computeBounding(data);
  return { box, sphere: Sphere3D.fromBox3D(Sphere3D(), box) };
}
var p = Vec3();
function getBoundary(data) {
  const { x, y, z, radius, indices } = data;
  const n = OrderedSet.size(indices);
  if (n > 25e4) {
    return getFastBoundary(data);
  }
  const boundaryHelper = getBoundaryHelper(n);
  boundaryHelper.reset();
  for (let t = 0; t < n; t++) {
    const i = OrderedSet.getAt(indices, t);
    v3set2(p, x[i], y[i], z[i]);
    boundaryHelper.includePositionRadius(p, radius && radius[i] || 0);
  }
  boundaryHelper.finishedIncludeStep();
  for (let t = 0; t < n; t++) {
    const i = OrderedSet.getAt(indices, t);
    v3set2(p, x[i], y[i], z[i]);
    boundaryHelper.radiusPositionRadius(p, radius && radius[i] || 0);
  }
  const sphere = boundaryHelper.getSphere();
  if (!radius && Sphere3D.hasExtrema(sphere) && n <= sphere.extrema.length) {
    const extrema = [];
    for (let t = 0; t < n; t++) {
      const i = OrderedSet.getAt(indices, t);
      extrema.push(Vec3.create(x[i], y[i], z[i]));
    }
    Sphere3D.setExtrema(sphere, extrema);
  }
  return { box: boundaryHelper.getBox(), sphere };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/unit/bonds/element-set-intra-bond-cache.js
var ElementSetIntraBondCache = class _ElementSetIntraBondCache {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  get(xs) {
    const hash = SortedArray.hashCode(xs);
    if (!this.data.has(hash))
      return void 0;
    for (const [s, b] of this.data.get(hash)) {
      if (SortedArray.areEqual(xs, s))
        return b;
    }
  }
  set(xs, bonds) {
    const hash = SortedArray.hashCode(xs);
    if (this.data.has(hash)) {
      const es = this.data.get(hash);
      for (const e of es) {
        if (SortedArray.areEqual(xs, e[0])) {
          e[1] = bonds;
          return;
        }
      }
      es.push([xs, bonds]);
    } else {
      this.data.set(hash, [[xs, bonds]]);
    }
  }
  static get(model) {
    if (!model._dynamicPropertyData.ElementSetIntraBondCache) {
      model._dynamicPropertyData.ElementSetIntraBondCache = new _ElementSetIntraBondCache();
    }
    return model._dynamicPropertyData.ElementSetIntraBondCache;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/symmetry.js
var Assembly = class {
  get operatorGroups() {
    if (this._operators)
      return this._operators;
    this._operators = this.operatorsProvider();
    return this._operators;
  }
  constructor(id, details, operatorsProvider) {
    this.operatorsProvider = operatorsProvider;
    this.id = id;
    this.details = details;
  }
};
(function(Assembly2) {
  function create(id, details, operatorsProvider) {
    return new Assembly2(id, details, operatorsProvider);
  }
  Assembly2.create = create;
})(Assembly || (Assembly = {}));
var Symmetry;
(function(Symmetry2) {
  Symmetry2.Default = { assemblies: [], spacegroup: Spacegroup.ZeroP1, isNonStandardCrystalFrame: false };
  function findAssembly(model, id) {
    const _id = id.toLocaleLowerCase();
    const symmetry = ModelSymmetry.Provider.get(model);
    return symmetry ? arrayFind(symmetry.assemblies, (a) => a.id.toLowerCase() === _id) : void 0;
  }
  Symmetry2.findAssembly = findAssembly;
  function getUnitcellLabel(symmetry) {
    const { cell, name, num } = symmetry.spacegroup;
    const { size, anglesInRadians } = cell;
    const a = size[0].toFixed(2);
    const b = size[1].toFixed(2);
    const c = size[2].toFixed(2);
    const alpha = radToDeg(anglesInRadians[0]).toFixed(2);
    const beta = radToDeg(anglesInRadians[1]).toFixed(2);
    const gamma = radToDeg(anglesInRadians[2]).toFixed(2);
    const label = [];
    label.push(`Unit Cell <b>${name}</b> #${num}`);
    label.push(`${a}×${b}×${c} Å`);
    label.push(`α=${alpha}° β=${beta}° γ=${gamma}°`);
    return label.join(" | ");
  }
  Symmetry2.getUnitcellLabel = getUnitcellLabel;
})(Symmetry || (Symmetry = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/property/assembly.js
function createAssemblies(pdbx_struct_assembly, pdbx_struct_assembly_gen, pdbx_struct_oper_list) {
  if (!pdbx_struct_assembly._rowCount)
    return [];
  const matrices = getMatrices(pdbx_struct_oper_list);
  const assemblies = [];
  for (let i = 0; i < pdbx_struct_assembly._rowCount; i++) {
    assemblies[assemblies.length] = createAssembly(pdbx_struct_assembly, pdbx_struct_assembly_gen, i, matrices);
  }
  return assemblies;
}
function createAssembly(pdbx_struct_assembly, pdbx_struct_assembly_gen, index, matrices) {
  const id = pdbx_struct_assembly.id.value(index);
  const details = pdbx_struct_assembly.details.value(index);
  const generators = [];
  const { assembly_id, oper_expression, asym_id_list } = pdbx_struct_assembly_gen;
  for (let i = 0, _i = pdbx_struct_assembly_gen._rowCount; i < _i; i++) {
    if (assembly_id.value(i) !== id)
      continue;
    generators[generators.length] = {
      assemblyId: id,
      expression: oper_expression.value(i),
      asymIds: asym_id_list.value(i)
    };
  }
  return Assembly.create(id, details, operatorGroupsProvider(generators, matrices));
}
function operatorGroupsProvider(generators, matrices) {
  return () => {
    const groups = [];
    let operatorOffset = 0;
    for (let i = 0; i < generators.length; i++) {
      const gen = generators[i];
      const operatorList = parseOperatorList(gen.expression);
      const operatorNames = expandOperators(operatorList);
      const operators = getAssemblyOperators(matrices, operatorNames, operatorOffset, gen.assemblyId);
      const selector = Queries.generators.atoms({ chainTest: Queries.pred.and(Queries.pred.eq((ctx) => StructureProperties.unit.operator_name(ctx.element), SymmetryOperator.DefaultName), Queries.pred.inSet((ctx) => StructureProperties.chain.label_asym_id(ctx.element), gen.asymIds)) });
      groups[groups.length] = { selector, operators, asymIds: gen.asymIds };
      operatorOffset += operators.length;
    }
    return groups;
  };
}
function getMatrices(pdbx_struct_oper_list) {
  const { id, matrix, vector, _schema } = pdbx_struct_oper_list;
  const matrices = /* @__PURE__ */ new Map();
  const t = Vec3();
  for (let i = 0, _i = pdbx_struct_oper_list._rowCount; i < _i; i++) {
    const m = Tensor.toMat4(Mat4(), _schema.matrix.space, matrix.value(i));
    Tensor.toVec3(t, _schema.vector.space, vector.value(i));
    Mat4.setTranslation(m, t);
    Mat4.setValue(m, 3, 3, 1);
    matrices.set(id.value(i), m);
  }
  return matrices;
}
function expandOperators(operatorList) {
  const ops = [];
  const currentOp = [];
  for (let i = 0; i < operatorList.length; i++)
    currentOp[i] = "";
  expandOperators1(operatorList, ops, operatorList.length - 1, currentOp);
  return ops;
}
function expandOperators1(operatorNames, list2, i, current) {
  if (i < 0) {
    list2[list2.length] = current.slice(0);
    return;
  }
  const ops = operatorNames[i], len = ops.length;
  for (let j = 0; j < len; j++) {
    current[i] = ops[j];
    expandOperators1(operatorNames, list2, i - 1, current);
  }
}
function getAssemblyOperators(matrices, operatorNames, startIndex, assemblyId) {
  const operators = [];
  let index = startIndex;
  for (const op of operatorNames) {
    const m = Mat4.identity();
    for (let i = 0; i < op.length; i++) {
      Mat4.mul(m, m, matrices.get(op[i]));
    }
    index++;
    operators[operators.length] = SymmetryOperator.create(`ASM_${index}`, m, { assembly: { id: assemblyId, operId: index, operList: op } });
  }
  return operators;
}
function parseOperatorList(value) {
  const oeRegex = /\(?([^\(\)]+)\)?]*/g, groups = [], ret = [];
  let g;
  while (g = oeRegex.exec(value))
    groups[groups.length] = g[1];
  groups.forEach((g2) => {
    const group = [];
    g2.split(",").forEach((e) => {
      const dashIndex = e.indexOf("-");
      if (dashIndex > 0) {
        const from = parseInt(e.substring(0, dashIndex)), to = parseInt(e.substr(dashIndex + 1));
        for (let i = from; i <= to; i++)
          group[group.length] = i.toString();
      } else {
        group[group.length] = e.trim();
      }
    });
    ret[ret.length] = group;
  });
  return ret;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/property/symmetry.js
var ModelSymmetry;
(function(ModelSymmetry2) {
  ModelSymmetry2.Descriptor = {
    name: "model_symmetry"
  };
  ModelSymmetry2.Provider = FormatPropertyProvider.create(ModelSymmetry2.Descriptor);
  function fromData(data) {
    const assemblies = createAssemblies(data.pdbx_struct_assembly, data.pdbx_struct_assembly_gen, data.pdbx_struct_oper_list);
    const spacegroup = getSpacegroup(data.symmetry, data.cell);
    const isNonStandardCrystalFrame = checkNonStandardCrystalFrame(data.atom_sites, spacegroup);
    return { assemblies, spacegroup, isNonStandardCrystalFrame, ncsOperators: getNcsOperators(data.struct_ncs_oper) };
  }
  ModelSymmetry2.fromData = fromData;
  function fromCell(size, anglesInRadians) {
    const spaceCell = SpacegroupCell.create("P 1", size, anglesInRadians);
    const spacegroup = Spacegroup.create(spaceCell);
    return { assemblies: [], spacegroup, isNonStandardCrystalFrame: false };
  }
  ModelSymmetry2.fromCell = fromCell;
})(ModelSymmetry || (ModelSymmetry = {}));
function checkNonStandardCrystalFrame(atom_sites, spacegroup) {
  if (atom_sites._rowCount === 0)
    return false;
  return false;
}
function getSpacegroupNameOrNumber(symmetry) {
  const groupNumber = symmetry["Int_Tables_number"].value(0);
  const groupName = symmetry["space_group_name_H-M"].value(0);
  if (!symmetry["Int_Tables_number"].isDefined)
    return groupName;
  if (!symmetry["space_group_name_H-M"].isDefined)
    return groupNumber;
  return groupName;
}
function getSpacegroup(symmetry, cell) {
  if (symmetry._rowCount === 0 || cell._rowCount === 0)
    return Spacegroup.ZeroP1;
  const a = cell.length_a.value(0);
  const b = cell.length_b.value(0);
  const c = cell.length_c.value(0);
  if (a === 0 || b === 0 || c === 0)
    return Spacegroup.ZeroP1;
  const alpha = cell.angle_alpha.value(0);
  const beta = cell.angle_beta.value(0);
  const gamma = cell.angle_gamma.value(0);
  if (alpha === 0 || beta === 0 || gamma === 0)
    return Spacegroup.ZeroP1;
  const nameOrNumber = getSpacegroupNameOrNumber(symmetry);
  const spaceCell = SpacegroupCell.create(nameOrNumber, Vec3.create(a, b, c), Vec3.scale(Vec3(), Vec3.create(alpha, beta, gamma), Math.PI / 180));
  return Spacegroup.create(spaceCell);
}
function getNcsOperators(struct_ncs_oper) {
  if (struct_ncs_oper._rowCount === 0)
    return void 0;
  const { id, matrix, vector } = struct_ncs_oper;
  const matrixSpace = mmCIF_Schema.struct_ncs_oper.matrix.space, vectorSpace = mmCIF_Schema.struct_ncs_oper.vector.space;
  const opers = [];
  for (let i = 0; i < struct_ncs_oper._rowCount; i++) {
    const m = Tensor.toMat3(Mat3(), matrixSpace, matrix.value(i));
    const v = Tensor.toVec3(Vec3(), vectorSpace, vector.value(i));
    if (!SymmetryOperator.checkIfRotationAndTranslation(m, v))
      continue;
    if (struct_ncs_oper.code.value(i) === "given" && !Mat3.isIdentity(m) && !Vec3.isZero(v))
      continue;
    const ncsId = id.value(i);
    opers[opers.length] = SymmetryOperator.ofRotationAndOffset(`ncs_${ncsId}`, m, v, ncsId);
  }
  return opers;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/unit/resonance.js
function getResonance(unit2) {
  return {
    delocalizedTriplets: getDelocalizedTriplets(unit2)
  };
}
function getDelocalizedTriplets(unit2) {
  const bonds = unit2.bonds;
  const { b, edgeProps, offset } = bonds;
  const { order: _order, flags: _flags } = edgeProps;
  const { elementAromaticRingIndices } = unit2.rings;
  const triplets = [];
  const thirdElementMap = /* @__PURE__ */ new Map();
  const indicesMap = /* @__PURE__ */ new Map();
  const add = (a, b2, c) => {
    const index = triplets.length;
    triplets.push(SortedArray.ofUnsortedArray([a, b2, c]));
    thirdElementMap.set(sortedCantorPairing(a, b2), c);
    if (indicesMap.has(a))
      indicesMap.get(a).push(index);
    else
      indicesMap.set(a, [index]);
  };
  for (let i = 0; i < unit2.elements.length; i++) {
    if (elementAromaticRingIndices.has(i))
      continue;
    const count = offset[i + 1] - offset[i] + 1;
    if (count < 2)
      continue;
    const deloBonds = [];
    for (let t = offset[i], _t = offset[i + 1]; t < _t; t++) {
      const f = _flags[t];
      if (!BondType.is(f, BondType.Flag.Aromatic))
        continue;
      deloBonds.push(b[t]);
    }
    if (deloBonds.length >= 2) {
      add(i, deloBonds[0], deloBonds[1]);
      for (let j = 1, jl = deloBonds.length; j < jl; j++) {
        add(i, deloBonds[j], deloBonds[0]);
      }
    }
  }
  return {
    getThirdElement: (a, b2) => {
      return thirdElementMap.get(sortedCantorPairing(a, b2));
    },
    getTripletIndices: (a) => {
      return indicesMap.get(a);
    },
    triplets
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/unit.js
var Unit;
(function(Unit2) {
  let Kind;
  (function(Kind2) {
    Kind2[Kind2["Atomic"] = 0] = "Atomic";
    Kind2[Kind2["Spheres"] = 1] = "Spheres";
    Kind2[Kind2["Gaussians"] = 2] = "Gaussians";
  })(Kind = Unit2.Kind || (Unit2.Kind = {}));
  let Kinds;
  (function(Kinds2) {
    Kinds2[Kinds2["Atomic"] = 0] = "Atomic";
    Kinds2[Kinds2["Spheres"] = 1] = "Spheres";
    Kinds2[Kinds2["Gaussians"] = 2] = "Gaussians";
  })(Kinds = Unit2.Kinds || (Unit2.Kinds = {}));
  function isAtomic(u) {
    return u.kind === Kind.Atomic;
  }
  Unit2.isAtomic = isAtomic;
  function isCoarse(u) {
    return u.kind === Kind.Spheres || u.kind === Kind.Gaussians;
  }
  Unit2.isCoarse = isCoarse;
  function isSpheres(u) {
    return u.kind === Kind.Spheres;
  }
  Unit2.isSpheres = isSpheres;
  function isGaussians(u) {
    return u.kind === Kind.Gaussians;
  }
  Unit2.isGaussians = isGaussians;
  function create(id, invariantId, chainGroupId, traits, kind, model, operator, elements, props) {
    switch (kind) {
      case Kind.Atomic:
        return new Atomic(id, invariantId, chainGroupId, traits, model, elements, SymmetryOperator.createMapping(operator, model.atomicConformation), props !== null && props !== void 0 ? props : AtomicProperties());
      case Kind.Spheres:
        return createCoarse(id, invariantId, chainGroupId, traits, model, Kind.Spheres, elements, SymmetryOperator.createMapping(operator, model.coarseConformation.spheres, getSphereRadiusFunc(model)), props !== null && props !== void 0 ? props : CoarseProperties());
      case Kind.Gaussians:
        return createCoarse(id, invariantId, chainGroupId, traits, model, Kind.Gaussians, elements, SymmetryOperator.createMapping(operator, model.coarseConformation.gaussians, getGaussianRadiusFunc(model)), props !== null && props !== void 0 ? props : CoarseProperties());
    }
  }
  Unit2.create = create;
  function getUnitIndexMap(units) {
    const unitIndexMap = IntMap.Mutable();
    for (let i = 0, _i = units.length; i < _i; i++) {
      unitIndexMap.set(units[i].id, i);
    }
    return unitIndexMap;
  }
  function getTransformHash(units) {
    const ids = [];
    for (let i = 0, _i = units.length; i < _i; i++) {
      ids.push(units[i].id);
    }
    return hashFnv32a(ids);
  }
  function SymmetryGroup(units) {
    const props = {};
    return {
      elements: units[0].elements,
      units,
      get unitIndexMap() {
        if (props.unitIndexMap)
          return props.unitIndexMap;
        props.unitIndexMap = getUnitIndexMap(units);
        return props.unitIndexMap;
      },
      hashCode: hashUnit(units[0]),
      transformHash: getTransformHash(units)
    };
  }
  Unit2.SymmetryGroup = SymmetryGroup;
  (function(SymmetryGroup2) {
    function areInvariantElementsEqual(a, b) {
      if (a.hashCode !== b.hashCode)
        return false;
      return SortedArray.areEqual(a.elements, b.elements);
    }
    SymmetryGroup2.areInvariantElementsEqual = areInvariantElementsEqual;
    function getUnitSymmetryGroupsIndexMap(symmetryGroups) {
      const unitSymmetryGroupsIndexMap = IntMap.Mutable();
      for (let i = 0, il = symmetryGroups.length; i < il; ++i) {
        const sg = symmetryGroups[i];
        for (let j = 0, jl = sg.units.length; j < jl; ++j) {
          unitSymmetryGroupsIndexMap.set(sg.units[j].id, i);
        }
      }
      return unitSymmetryGroupsIndexMap;
    }
    SymmetryGroup2.getUnitSymmetryGroupsIndexMap = getUnitSymmetryGroupsIndexMap;
  })(SymmetryGroup = Unit2.SymmetryGroup || (Unit2.SymmetryGroup = {}));
  function conformationId(unit2) {
    return Unit2.isAtomic(unit2) ? unit2.model.atomicConformation.id : unit2.model.coarseConformation.id;
  }
  Unit2.conformationId = conformationId;
  function hashUnit(u) {
    return hash2(u.invariantId, SortedArray.hashCode(u.elements));
  }
  Unit2.hashUnit = hashUnit;
  let Trait;
  (function(Trait2) {
    Trait2[Trait2["None"] = 0] = "None";
    Trait2[Trait2["MultiChain"] = 1] = "MultiChain";
    Trait2[Trait2["Partitioned"] = 2] = "Partitioned";
    Trait2[Trait2["FastBoundary"] = 4] = "FastBoundary";
    Trait2[Trait2["Water"] = 8] = "Water";
  })(Trait = Unit2.Trait || (Unit2.Trait = {}));
  let Traits;
  (function(Traits2) {
    Traits2.is = BitFlags.has;
    Traits2.create = BitFlags.create;
  })(Traits = Unit2.Traits || (Unit2.Traits = {}));
  function BaseProperties() {
    return {};
  }
  function getSphereRadiusFunc(model) {
    const r = model.coarseConformation.spheres.radius;
    return (i) => r[i];
  }
  function getGaussianRadiusFunc(_model) {
    return (i) => 0;
  }
  class Atomic {
    get transientCache() {
      if (this._transientCache === void 0)
        this._transientCache = /* @__PURE__ */ new Map();
      return this._transientCache;
    }
    getChild(elements) {
      if (elements.length === this.elements.length)
        return this;
      return new Atomic(this.id, this.invariantId, this.chainGroupId, this.traits, this.model, elements, this.conformation, AtomicProperties());
    }
    getCopy(id, invariantId, chainGroupId, options) {
      const unit2 = new Atomic(id, invariantId, chainGroupId, this.traits, this.model, this.elements, this.conformation, this.props);
      if (options === null || options === void 0 ? void 0 : options.propagateTransientCache) {
        unit2._transientCache = this._transientCache;
      }
      return unit2;
    }
    applyOperator(id, operator, dontCompose = false) {
      const op = dontCompose ? operator : SymmetryOperator.compose(this.conformation.operator, operator);
      return new Atomic(id, this.invariantId, this.chainGroupId, this.traits, this.model, this.elements, SymmetryOperator.createMapping(op, this.model.atomicConformation, this.conformation.r), this.props);
    }
    remapModel(model, dynamicBonds, props) {
      var _a, _b;
      if (!props) {
        props = {
          ...this.props,
          bonds: dynamicBonds && !((_b = (_a = this.props.bonds) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.canRemap) ? void 0 : tryRemapBonds(this, this.props.bonds, model, dynamicBonds)
        };
        if (!Unit2.isSameConformation(this, model)) {
          props.boundary = void 0;
          props.lookup3d = void 0;
          props.principalAxes = void 0;
        }
      }
      let operator = this.conformation.operator;
      const symmetry = ModelSymmetry.Provider.get(model);
      if (operator.spgrOp !== -1 && symmetry && symmetry !== ModelSymmetry.Provider.get(this.model)) {
        const [i, j, k] = operator.hkl;
        const { toFractional } = symmetry.spacegroup.cell;
        const ref = Vec3.transformMat4(Vec3(), Model.getCenter(model), toFractional);
        operator = Spacegroup.getSymmetryOperatorRef(symmetry.spacegroup, operator.spgrOp, i, j, k, ref);
      }
      const conformation = this.model.atomicConformation !== model.atomicConformation || operator !== this.conformation.operator ? SymmetryOperator.createMapping(operator, model.atomicConformation) : this.conformation;
      return new Atomic(this.id, this.invariantId, this.chainGroupId, this.traits, model, this.elements, conformation, props);
    }
    get boundary() {
      if (this.props.boundary)
        return this.props.boundary;
      const { x, y, z } = this.model.atomicConformation;
      this.props.boundary = Traits.is(this.traits, Trait.FastBoundary) ? getFastBoundary({ x, y, z, indices: this.elements }) : getBoundary({ x, y, z, indices: this.elements });
      return this.props.boundary;
    }
    get lookup3d() {
      if (this.props.lookup3d)
        return this.props.lookup3d;
      const { x, y, z } = this.model.atomicConformation;
      this.props.lookup3d = GridLookup3D({ x, y, z, indices: this.elements }, this.boundary);
      return this.props.lookup3d;
    }
    get principalAxes() {
      if (this.props.principalAxes)
        return this.props.principalAxes;
      this.props.principalAxes = getPrincipalAxes(this);
      return this.props.principalAxes;
    }
    get bonds() {
      var _a;
      if (this.props.bonds)
        return this.props.bonds;
      const cache = ElementSetIntraBondCache.get(this.model);
      let bonds = cache.get(this.elements);
      if (!bonds) {
        bonds = computeIntraUnitBonds(this);
        if ((_a = bonds.props) === null || _a === void 0 ? void 0 : _a.cacheable) {
          cache.set(this.elements, bonds);
        }
      }
      this.props.bonds = bonds;
      return this.props.bonds;
    }
    get rings() {
      if (this.props.rings)
        return this.props.rings;
      this.props.rings = UnitRings.create(this);
      return this.props.rings;
    }
    get resonance() {
      if (this.props.resonance)
        return this.props.resonance;
      this.props.resonance = getResonance(this);
      return this.props.resonance;
    }
    get polymerElements() {
      if (this.props.polymerElements)
        return this.props.polymerElements;
      this.props.polymerElements = getAtomicPolymerElements(this);
      return this.props.polymerElements;
    }
    get gapElements() {
      if (this.props.gapElements)
        return this.props.gapElements;
      this.props.gapElements = getAtomicGapElements(this);
      return this.props.gapElements;
    }
    get nucleotideElements() {
      if (this.props.nucleotideElements)
        return this.props.nucleotideElements;
      this.props.nucleotideElements = getNucleotideElements(this);
      return this.props.nucleotideElements;
    }
    get proteinElements() {
      if (this.props.proteinElements)
        return this.props.proteinElements;
      this.props.proteinElements = getProteinElements(this);
      return this.props.proteinElements;
    }
    get residueCount() {
      if (this.props.residueCount !== void 0)
        return this.props.residueCount;
      let residueCount = 0;
      const residueIt = Segmentation.transientSegments(this.model.atomicHierarchy.residueAtomSegments, this.elements);
      while (residueIt.hasNext) {
        residueIt.move();
        residueCount += 1;
      }
      this.props.residueCount = residueCount;
      return this.props.residueCount;
    }
    getResidueIndex(elementIndex) {
      return this.residueIndex[this.elements[elementIndex]];
    }
    constructor(id, invariantId, chainGroupId, traits, model, elements, conformation, props) {
      this.kind = Kind.Atomic;
      this.objectPrimitive = "atomistic";
      this._transientCache = void 0;
      this.id = id;
      this.invariantId = invariantId;
      this.chainGroupId = chainGroupId;
      this.traits = traits;
      this.model = model;
      this.elements = elements;
      this.conformation = conformation;
      this.residueIndex = model.atomicHierarchy.residueAtomSegments.index;
      this.chainIndex = model.atomicHierarchy.chainAtomSegments.index;
      this.props = props;
    }
  }
  Unit2.Atomic = Atomic;
  function AtomicProperties() {
    return BaseProperties();
  }
  class Coarse {
    get transientCache() {
      if (this._transientCache === void 0)
        this._transientCache = /* @__PURE__ */ new Map();
      return this._transientCache;
    }
    getChild(elements) {
      if (elements.length === this.elements.length)
        return this;
      return createCoarse(this.id, this.invariantId, this.chainGroupId, this.traits, this.model, this.kind, elements, this.conformation, CoarseProperties());
    }
    getCopy(id, invariantId, chainGroupId, options) {
      const unit2 = createCoarse(id, invariantId, chainGroupId, this.traits, this.model, this.kind, this.elements, this.conformation, this.props);
      if (options === null || options === void 0 ? void 0 : options.propagateTransientCache) {
        unit2._transientCache = this._transientCache;
      }
      return unit2;
    }
    applyOperator(id, operator, dontCompose = false) {
      const op = dontCompose ? operator : SymmetryOperator.compose(this.conformation.operator, operator);
      return createCoarse(id, this.invariantId, this.chainGroupId, this.traits, this.model, this.kind, this.elements, SymmetryOperator.createMapping(op, this.getCoarseConformation(), this.conformation.r), this.props);
    }
    remapModel(model, dynamicBonds, props) {
      const coarseConformation = this.getCoarseConformation();
      const modelCoarseConformation = getCoarseConformation(this.kind, model);
      if (!props) {
        props = { ...this.props };
        if (!Unit2.isSameConformation(this, model)) {
          props.boundary = void 0;
          props.lookup3d = void 0;
          props.principalAxes = void 0;
        }
      }
      const conformation = coarseConformation !== modelCoarseConformation ? SymmetryOperator.createMapping(this.conformation.operator, modelCoarseConformation, this.kind === Unit2.Kind.Spheres ? getSphereRadiusFunc(model) : getGaussianRadiusFunc(model)) : this.conformation;
      return new Coarse(this.id, this.invariantId, this.chainGroupId, this.traits, model, this.kind, this.elements, conformation, props);
    }
    get boundary() {
      if (this.props.boundary)
        return this.props.boundary;
      const { x, y, z } = this.getCoarseConformation();
      this.props.boundary = Traits.is(this.traits, Trait.FastBoundary) ? getFastBoundary({ x, y, z, indices: this.elements }) : getBoundary({ x, y, z, indices: this.elements });
      return this.props.boundary;
    }
    get lookup3d() {
      if (this.props.lookup3d)
        return this.props.lookup3d;
      const { x, y, z } = this.getCoarseConformation();
      this.props.lookup3d = GridLookup3D({ x, y, z, indices: this.elements }, this.boundary);
      return this.props.lookup3d;
    }
    get principalAxes() {
      if (this.props.principalAxes)
        return this.props.principalAxes;
      this.props.principalAxes = getPrincipalAxes(this);
      return this.props.principalAxes;
    }
    get polymerElements() {
      if (this.props.polymerElements)
        return this.props.polymerElements;
      this.props.polymerElements = getCoarsePolymerElements(this);
      return this.props.polymerElements;
    }
    get gapElements() {
      if (this.props.gapElements)
        return this.props.gapElements;
      this.props.gapElements = getCoarseGapElements(this);
      return this.props.gapElements;
    }
    getCoarseConformation() {
      return getCoarseConformation(this.kind, this.model);
    }
    constructor(id, invariantId, chainGroupId, traits, model, kind, elements, conformation, props) {
      this._transientCache = void 0;
      this.kind = kind;
      this.objectPrimitive = kind === Kind.Spheres ? "sphere" : "gaussian";
      this.id = id;
      this.invariantId = invariantId;
      this.chainGroupId = chainGroupId;
      this.traits = traits;
      this.model = model;
      this.elements = elements;
      this.conformation = conformation;
      this.coarseElements = kind === Kind.Spheres ? model.coarseHierarchy.spheres : model.coarseHierarchy.gaussians;
      this.coarseConformation = kind === Kind.Spheres ? model.coarseConformation.spheres : model.coarseConformation.gaussians;
      this.props = props;
    }
  }
  function getCoarseConformation(kind, model) {
    return kind === Kind.Spheres ? model.coarseConformation.spheres : model.coarseConformation.gaussians;
  }
  function CoarseProperties() {
    return BaseProperties();
  }
  class Spheres extends Coarse {
  }
  Unit2.Spheres = Spheres;
  class Gaussians extends Coarse {
  }
  Unit2.Gaussians = Gaussians;
  function createCoarse(id, invariantId, chainGroupId, traits, model, kind, elements, conformation, props) {
    return new Coarse(id, invariantId, chainGroupId, traits, model, kind, elements, conformation, props);
  }
  function areSameChainOperatorGroup(a, b) {
    return a.chainGroupId === b.chainGroupId && a.conformation.operator.name === b.conformation.operator.name;
  }
  Unit2.areSameChainOperatorGroup = areSameChainOperatorGroup;
  function areOperatorsEqual(a, b) {
    return Mat4.areEqual(a.conformation.operator.matrix, b.conformation.operator.matrix, 1e-6);
  }
  Unit2.areOperatorsEqual = areOperatorsEqual;
  function areConformationsEqual(a, b) {
    if (a === b)
      return true;
    if (!SortedArray.areEqual(a.elements, b.elements))
      return false;
    return isSameConformation(a, b.model);
  }
  Unit2.areConformationsEqual = areConformationsEqual;
  function tryRemapBonds(a, old, model, dynamicBonds) {
    var _a;
    if (!old)
      return void 0;
    if (a.model.atomicConformation.id === model.atomicConformation.id)
      return old;
    const oldIndex = IndexPairBonds.Provider.get(a.model);
    if (oldIndex) {
      const newIndex = IndexPairBonds.Provider.get(model);
      if (!newIndex || oldIndex === newIndex)
        return old;
      return void 0;
    }
    if (((_a = old.props) === null || _a === void 0 ? void 0 : _a.canRemap) || !dynamicBonds) {
      return old;
    }
    return isSameConformation(a, model) ? old : void 0;
  }
  function isSameConformation(u, model) {
    const coordsHistory = Model.CoordinatesHistory.get(Model.getRoot(model));
    if (coordsHistory)
      return coordsHistory.areEqual(u.elements, u.kind, model);
    const xs = u.elements;
    const { x: xa, y: ya, z: za } = u.conformation.coordinates;
    const { x: xb, y: yb, z: zb } = getModelConformationOfKind(u.kind, model);
    for (let i = 0, _i = xs.length; i < _i; i++) {
      const u2 = xs[i];
      if (xa[u2] !== xb[u2] || ya[u2] !== yb[u2] || za[u2] !== zb[u2])
        return false;
    }
    return true;
  }
  Unit2.isSameConformation = isSameConformation;
  function getModelConformationOfKind(kind, model) {
    return kind === Kind.Atomic ? model.atomicConformation : kind === Kind.Spheres ? model.coarseConformation.spheres : model.coarseConformation.gaussians;
  }
  Unit2.getModelConformationOfKind = getModelConformationOfKind;
  function getConformation2(u) {
    return getModelConformationOfKind(u.kind, u.model);
  }
  Unit2.getConformation = getConformation2;
  function getModelHierarchyOfKind(kind, model) {
    return kind === Kind.Atomic ? model.atomicHierarchy : kind === Kind.Spheres ? model.coarseHierarchy.spheres : model.coarseHierarchy.gaussians;
  }
  Unit2.getModelHierarchyOfKind = getModelHierarchyOfKind;
  function getHierarchy(u) {
    return getModelHierarchyOfKind(u.kind, u.model);
  }
  Unit2.getHierarchy = getHierarchy;
})(Unit || (Unit = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/util/lookup3d.js
var StructureResult;
(function(StructureResult2) {
  function add(result2, unit2, index, distSq) {
    result2.indices[result2.count] = index;
    result2.units[result2.count] = unit2;
    result2.squaredDistances[result2.count] = distSq;
    result2.count++;
  }
  StructureResult2.add = add;
  function create() {
    return { count: 0, indices: [], units: [], squaredDistances: [] };
  }
  StructureResult2.create = create;
  function copy(out, result2) {
    for (let i = 0; i < result2.count; ++i) {
      out.indices[i] = result2.indices[i];
      out.units[i] = result2.units[i];
      out.squaredDistances[i] = result2.squaredDistances[i];
    }
    out.count = result2.count;
    return out;
  }
  StructureResult2.copy = copy;
})(StructureResult || (StructureResult = {}));
function StructureLookup3DResultContext() {
  return { result: StructureResult.create(), closeUnitsResult: Result.create(), unitGroupResult: Result.create() };
}
var StructureLookup3D = class {
  findUnitIndices(x, y, z, radius) {
    return this.unitLookup.find(x, y, z, radius);
  }
  find(x, y, z, radius, ctx) {
    return this._find(x, y, z, radius, ctx !== null && ctx !== void 0 ? ctx : this.findContext);
  }
  _find(x, y, z, radius, ctx) {
    Result.reset(ctx.result);
    const { units } = this.structure;
    const closeUnits = this.unitLookup.find(x, y, z, radius, ctx.closeUnitsResult);
    if (closeUnits.count === 0)
      return ctx.result;
    for (let t = 0, _t = closeUnits.count; t < _t; t++) {
      const unit2 = units[closeUnits.indices[t]];
      Vec3.set(this.pivot, x, y, z);
      if (!unit2.conformation.operator.isIdentity) {
        Vec3.transformMat4(this.pivot, this.pivot, unit2.conformation.operator.inverse);
      }
      const unitLookup = unit2.lookup3d;
      const groupResult = unitLookup.find(this.pivot[0], this.pivot[1], this.pivot[2], radius, ctx.unitGroupResult);
      for (let j = 0, _j = groupResult.count; j < _j; j++) {
        StructureResult.add(ctx.result, unit2, groupResult.indices[j], groupResult.squaredDistances[j]);
      }
    }
    return ctx.result;
  }
  nearest(x, y, z, k = 1, ctx) {
    return this._nearest(x, y, z, k, ctx !== null && ctx !== void 0 ? ctx : this.findContext);
  }
  _nearest(x, y, z, k, ctx) {
    const result2 = ctx.result, heap = this.heap;
    Result.reset(result2);
    heap.clear();
    const { units } = this.structure;
    let elementsCount = 0;
    const closeUnits = this.unitLookup.nearest(x, y, z, units.length, (uid) => (elementsCount += units[uid].elements.length) >= k, ctx.closeUnitsResult);
    if (closeUnits.count === 0)
      return result2;
    let totalCount = 0, maxDistResult = -Number.MAX_VALUE;
    for (let t = 0, _t = closeUnits.count; t < _t; t++) {
      const unitSqDist = closeUnits.squaredDistances[t];
      if (totalCount >= k && maxDistResult < unitSqDist)
        break;
      Vec3.set(this.pivot, x, y, z);
      const unit2 = units[closeUnits.indices[t]];
      if (!unit2.conformation.operator.isIdentity) {
        Vec3.transformMat4(this.pivot, this.pivot, unit2.conformation.operator.inverse);
      }
      const unitLookup = unit2.lookup3d;
      const groupResult = unitLookup.nearest(this.pivot[0], this.pivot[1], this.pivot[2], k, void 0, ctx.unitGroupResult);
      if (groupResult.count === 0)
        continue;
      totalCount += groupResult.count;
      maxDistResult = Math.max(maxDistResult, groupResult.squaredDistances[groupResult.count - 1]);
      for (let j = 0, _j = groupResult.count; j < _j; j++) {
        heap.insert(groupResult.squaredDistances[j], { index: groupResult.indices[j], unit: unit2 });
      }
    }
    if (k === 1) {
      const node = heap.findMinimum();
      if (node) {
        const { key: squaredDistance } = node;
        const { unit: unit2, index } = node.value;
        StructureResult.add(result2, unit2, index, squaredDistance);
      }
    } else {
      while (!heap.isEmpty() && result2.count < k) {
        const node = heap.extractMinimum();
        const { key: squaredDistance } = node;
        const { unit: unit2, index } = node.value;
        StructureResult.add(result2, unit2, index, squaredDistance);
      }
    }
    return result2;
  }
  findIntoBuilder(x, y, z, radius, builder) {
    const { units } = this.structure;
    const closeUnits = this.unitLookup.find(x, y, z, radius);
    if (closeUnits.count === 0)
      return;
    for (let t = 0, _t = closeUnits.count; t < _t; t++) {
      const unit2 = units[closeUnits.indices[t]];
      Vec3.set(this.pivot, x, y, z);
      if (!unit2.conformation.operator.isIdentity) {
        Vec3.transformMat4(this.pivot, this.pivot, unit2.conformation.operator.inverse);
      }
      const unitLookup = unit2.lookup3d;
      const groupResult = unitLookup.find(this.pivot[0], this.pivot[1], this.pivot[2], radius);
      if (groupResult.count === 0)
        continue;
      const elements = unit2.elements;
      builder.beginUnit(unit2.id);
      for (let j = 0, _j = groupResult.count; j < _j; j++) {
        builder.addElement(elements[groupResult.indices[j]]);
      }
      builder.commitUnit();
    }
  }
  findIntoBuilderIf(x, y, z, radius, builder, test) {
    const { units } = this.structure;
    const closeUnits = this.unitLookup.find(x, y, z, radius);
    if (closeUnits.count === 0)
      return;
    const loc = element_exports.Location.create(this.structure);
    for (let t = 0, _t = closeUnits.count; t < _t; t++) {
      const unit2 = units[closeUnits.indices[t]];
      Vec3.set(this.pivot, x, y, z);
      if (!unit2.conformation.operator.isIdentity) {
        Vec3.transformMat4(this.pivot, this.pivot, unit2.conformation.operator.inverse);
      }
      const unitLookup = unit2.lookup3d;
      const groupResult = unitLookup.find(this.pivot[0], this.pivot[1], this.pivot[2], radius);
      if (groupResult.count === 0)
        continue;
      const elements = unit2.elements;
      loc.unit = unit2;
      builder.beginUnit(unit2.id);
      for (let j = 0, _j = groupResult.count; j < _j; j++) {
        loc.element = elements[groupResult.indices[j]];
        if (test(loc)) {
          builder.addElement(loc.element);
        }
      }
      builder.commitUnit();
    }
  }
  findIntoBuilderWithRadius(x, y, z, pivotR, maxRadius, radius, eRadius, builder) {
    const { units } = this.structure;
    const closeUnits = this.unitLookup.find(x, y, z, radius);
    if (closeUnits.count === 0)
      return;
    const se = element_exports.Location.create(this.structure);
    const queryRadius = pivotR + maxRadius + radius;
    for (let t = 0, _t = closeUnits.count; t < _t; t++) {
      const unit2 = units[closeUnits.indices[t]];
      Vec3.set(this.pivot, x, y, z);
      if (!unit2.conformation.operator.isIdentity) {
        Vec3.transformMat4(this.pivot, this.pivot, unit2.conformation.operator.inverse);
      }
      const unitLookup = unit2.lookup3d;
      const groupResult = unitLookup.find(this.pivot[0], this.pivot[1], this.pivot[2], queryRadius);
      if (groupResult.count === 0)
        continue;
      const elements = unit2.elements;
      se.unit = unit2;
      builder.beginUnit(unit2.id);
      for (let j = 0, _j = groupResult.count; j < _j; j++) {
        se.element = elements[groupResult.indices[j]];
        const rr = eRadius(se);
        if (Math.sqrt(groupResult.squaredDistances[j]) - pivotR - rr > radius)
          continue;
        builder.addElement(elements[groupResult.indices[j]]);
      }
      builder.commitUnit();
    }
  }
  check(x, y, z, radius) {
    const { units } = this.structure;
    const closeUnits = this.unitLookup.find(x, y, z, radius);
    if (closeUnits.count === 0)
      return false;
    for (let t = 0, _t = closeUnits.count; t < _t; t++) {
      const unit2 = units[closeUnits.indices[t]];
      Vec3.set(this.pivot, x, y, z);
      if (!unit2.conformation.operator.isIdentity) {
        Vec3.transformMat4(this.pivot, this.pivot, unit2.conformation.operator.inverse);
      }
      const groupLookup = unit2.lookup3d;
      if (groupLookup.check(this.pivot[0], this.pivot[1], this.pivot[2], radius))
        return true;
    }
    return false;
  }
  approxNearest(x, y, z, radius, ctx) {
    return this._approxNearest(x, y, z, radius, ctx !== null && ctx !== void 0 ? ctx : this.findContext);
  }
  _approxNearest(x, y, z, radius, ctx) {
    Result.reset(ctx.result);
    const { units } = this.structure;
    const closeUnits = this.unitLookup.find(x, y, z, radius, ctx.closeUnitsResult);
    if (closeUnits.count === 0)
      return ctx.result;
    let minDistSq = Number.MAX_VALUE;
    for (let t = 0, _t = closeUnits.count; t < _t; t++) {
      const unit2 = units[closeUnits.indices[t]];
      Vec3.set(this.pivot, x, y, z);
      if (!unit2.conformation.operator.isIdentity) {
        Vec3.transformMat4(this.pivot, this.pivot, unit2.conformation.operator.inverse);
      }
      const unitLookup = unit2.lookup3d;
      const groupResult = unitLookup.approxNearest(this.pivot[0], this.pivot[1], this.pivot[2], radius, ctx.unitGroupResult);
      for (let j = 0, _j = groupResult.count; j < _j; j++) {
        if (groupResult.squaredDistances[j] < minDistSq) {
          StructureResult.add(ctx.result, unit2, groupResult.indices[j], groupResult.squaredDistances[j]);
          minDistSq = groupResult.squaredDistances[j];
        }
      }
    }
    return ctx.result;
  }
  get boundary() {
    return this.structure.boundary;
  }
  constructor(structure) {
    this.structure = structure;
    this.pivot = Vec3();
    this.heap = new FibonacciHeap();
    this.findContext = StructureLookup3DResultContext();
    const { units, boundary } = structure;
    const unitCount = units.length;
    const xs = new Float32Array(unitCount);
    const ys = new Float32Array(unitCount);
    const zs = new Float32Array(unitCount);
    const radius = new Float32Array(unitCount);
    const center = Vec3();
    for (let i = 0; i < unitCount; i++) {
      const unit2 = units[i];
      const s = unit2.boundary.sphere;
      Vec3.transformMat4(center, s.center, unit2.conformation.operator.matrix);
      xs[i] = center[0];
      ys[i] = center[1];
      zs[i] = center[2];
      radius[i] = s.radius;
    }
    const position = { x: xs, y: ys, z: zs, radius, indices: OrderedSet.ofBounds(0, unitCount) };
    this.unitLookup = GridLookup3D(position, boundary);
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/utils/structure-set.js
function structureUnion(source, structures) {
  if (structures.length === 0)
    return Structure.Empty;
  if (structures.length === 1)
    return structures[0];
  const unitMap = /* @__PURE__ */ new Map();
  const fullUnits = /* @__PURE__ */ new Set();
  for (const { units } of structures) {
    for (let i = 0, _i = units.length; i < _i; i++) {
      const u = units[i];
      if (unitMap.has(u.id)) {
        if (fullUnits.has(u.id))
          continue;
        const merged = SortedArray.union(unitMap.get(u.id), u.elements);
        unitMap.set(u.id, merged);
        if (merged.length === source.unitMap.get(u.id).elements.length)
          fullUnits.add(u.id);
      } else {
        unitMap.set(u.id, u.elements);
        if (u.elements.length === source.unitMap.get(u.id).elements.length)
          fullUnits.add(u.id);
      }
    }
  }
  const builder = source.subsetBuilder(true);
  unitMap.forEach(buildUnion, builder);
  return builder.getStructure();
}
function buildUnion(elements, id) {
  this.setUnit(id, elements);
}
function structureAreEqual(sA, sB) {
  if (sA === sB)
    return true;
  if (sA.units.length !== sB.units.length)
    return false;
  const aU = sA.units, bU = sB.unitMap;
  for (let i = 0, _i = aU.length; i < _i; i++) {
    const u = aU[i];
    if (!bU.has(u.id))
      return false;
    const v = bU.get(u.id);
    if (!SortedArray.areEqual(u.elements, v.elements))
      return false;
  }
  return true;
}
function structureAreIntersecting(sA, sB) {
  if (sA === sB)
    return true;
  let a, b;
  if (sA.units.length < sB.units.length) {
    a = sA;
    b = sB;
  } else {
    a = sB;
    b = sA;
  }
  const aU = a.units, bU = b.unitMap;
  for (let i = 0, _i = aU.length; i < _i; i++) {
    const u = aU[i];
    if (!bU.has(u.id))
      continue;
    const v = bU.get(u.id);
    if (SortedArray.areIntersecting(u.elements, v.elements))
      return true;
  }
  return false;
}
function structureIntersect(sA, sB) {
  if (sA === sB)
    return sA;
  if (!structureAreIntersecting(sA, sB))
    return Structure.Empty;
  let a, b;
  if (sA.units.length < sB.units.length) {
    a = sA;
    b = sB;
  } else {
    a = sB;
    b = sA;
  }
  const aU = a.units, bU = b.unitMap;
  const units = [];
  for (let i = 0, _i = aU.length; i < _i; i++) {
    const u = aU[i];
    if (!bU.has(u.id))
      continue;
    const v = bU.get(u.id);
    if (SortedArray.areIntersecting(u.elements, v.elements)) {
      const int7 = SortedArray.intersect(u.elements, v.elements);
      units[units.length] = u.getChild(int7);
    }
  }
  return Structure.create(units, { parent: sA.parent || sB.parent });
}
function structureSubtract(a, b) {
  if (a === b)
    return Structure.Empty;
  if (!structureAreIntersecting(a, b))
    return a;
  const aU = a.units, bU = b.unitMap;
  const units = [];
  for (let i = 0, _i = aU.length; i < _i; i++) {
    const u = aU[i];
    if (!bU.has(u.id)) {
      units[units.length] = u;
      continue;
    }
    const v = bU.get(u.id);
    const sub = SortedArray.subtract(u.elements, v.elements);
    if (sub.length > 0) {
      units[units.length] = u.getChild(sub);
    }
  }
  return Structure.create(units, { parent: a.parent || b.parent });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/selection.js
var StructureSelection;
(function(StructureSelection2) {
  function Singletons(source, structure) {
    return { kind: "singletons", source, structure };
  }
  StructureSelection2.Singletons = Singletons;
  function Sequence2(source, structures) {
    return { kind: "sequence", source, structures };
  }
  StructureSelection2.Sequence = Sequence2;
  function Empty(source) {
    return Singletons(source, Structure.Empty);
  }
  StructureSelection2.Empty = Empty;
  ;
  function isSingleton(s) {
    return s.kind === "singletons";
  }
  StructureSelection2.isSingleton = isSingleton;
  function isEmpty(s) {
    return isSingleton(s) ? s.structure.units.length === 0 : s.structures.length === 0;
  }
  StructureSelection2.isEmpty = isEmpty;
  function structureCount(sel) {
    if (isSingleton(sel))
      return sel.structure.elementCount;
    return sel.structures.length;
  }
  StructureSelection2.structureCount = structureCount;
  function unionStructure(sel) {
    if (isEmpty(sel))
      return Structure.Empty;
    if (isSingleton(sel))
      return sel.structure;
    return structureUnion(sel.source, sel.structures);
  }
  StructureSelection2.unionStructure = unionStructure;
  function toLociWithCurrentUnits(sel) {
    const elements = [];
    const { unitMap } = sel.source;
    for (const unit2 of unionStructure(sel).units) {
      if (unit2 === unitMap.get(unit2.id)) {
        elements[elements.length] = {
          unit: unit2,
          indices: OrderedSet.ofBounds(0, unit2.elements.length)
        };
      } else {
        elements[elements.length] = {
          unit: unit2,
          indices: OrderedSet.ofSortedArray(SortedArray.indicesOf(unitMap.get(unit2.id).elements, unit2.elements))
        };
      }
    }
    return element_exports.Loci(sel.source, elements);
  }
  StructureSelection2.toLociWithCurrentUnits = toLociWithCurrentUnits;
  function toLociWithSourceUnits(sel) {
    const elements = [];
    const { unitMap } = sel.source;
    for (const _unit of unionStructure(sel).units) {
      const unit2 = unitMap.get(_unit.id);
      if (unit2 === _unit) {
        elements[elements.length] = {
          unit: unit2,
          indices: OrderedSet.ofBounds(0, unit2.elements.length)
        };
      } else {
        elements[elements.length] = {
          unit: unit2,
          indices: OrderedSet.ofSortedArray(SortedArray.indicesOf(unit2.elements, _unit.elements))
        };
      }
    }
    return element_exports.Loci(sel.source, elements);
  }
  StructureSelection2.toLociWithSourceUnits = toLociWithSourceUnits;
  function getSelection(source, structures, allSingletons) {
    const len = structures.length;
    if (len === 0)
      return Empty(source);
    if (allSingletons)
      return Singletons(source, structureUnion(source, structures));
    return Sequence2(source, structures);
  }
  class LinearBuilderImpl {
    add(structure) {
      const elementCount = structure.elementCount;
      if (elementCount === 0)
        return;
      this.structures[this.structures.length] = structure;
      if (elementCount !== 1)
        this.allSingletons = false;
    }
    getSelection() {
      return getSelection(this.source, this.structures, this.allSingletons);
    }
    constructor(source) {
      this.source = source;
      this.structures = [];
      this.allSingletons = true;
    }
  }
  class HashBuilderImpl {
    add(structure) {
      const atomCount2 = structure.elementCount;
      if (atomCount2 === 0 || !this.uniqueSets.add(structure))
        return;
      this.structures[this.structures.length] = structure;
      if (atomCount2 !== 1)
        this.allSingletons = false;
    }
    getSelection() {
      return getSelection(this.structure, this.structures, this.allSingletons);
    }
    constructor(structure) {
      this.structure = structure;
      this.structures = [];
      this.allSingletons = true;
      this.uniqueSets = HashSet(Structure.hashCode, Structure.areUnitIdsAndIndicesEqual);
    }
  }
  function LinearBuilder(structure) {
    return new LinearBuilderImpl(structure);
  }
  StructureSelection2.LinearBuilder = LinearBuilder;
  function UniqueBuilder(structure) {
    return new HashBuilderImpl(structure);
  }
  StructureSelection2.UniqueBuilder = UniqueBuilder;
  function forEach(sel, fn) {
    let idx = 0;
    if (StructureSelection2.isSingleton(sel)) {
      for (const unit2 of sel.structure.units) {
        const { elements } = unit2;
        for (let i = 0, _i = elements.length; i < _i; i++) {
          const s = Structure.create([unit2.getChild(SortedArray.ofSingleton(elements[i]))], { parent: sel.source });
          fn(s, idx++);
        }
      }
    } else {
      for (const s of sel.structures) {
        fn(s, idx++);
      }
    }
  }
  StructureSelection2.forEach = forEach;
  function withInputStructure(selection, structure) {
    if (isSingleton(selection))
      return Singletons(structure, selection.structure);
    return Sequence2(structure, selection.structures);
  }
  StructureSelection2.withInputStructure = withInputStructure;
})(StructureSelection || (StructureSelection = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/queries/internal.js
var internal_exports = {};
__export(internal_exports, {
  atomicHet: () => atomicHet,
  atomicSequence: () => atomicSequence,
  bundleElementImpl: () => bundleElementImpl,
  bundleGenerator: () => bundleGenerator,
  defaultBondTest: () => defaultBondTest,
  spheres: () => spheres,
  water: () => water
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/element/schema.js
function isItems(schema) {
  return !!schema.items;
}
function schemaItemToExpression(item) {
  const { and } = MolScriptBuilder.core.logic;
  const { eq, gre: gte, lte } = MolScriptBuilder.core.rel;
  const { macromolecular, ihm, core: core2 } = MolScriptBuilder.struct.atomProperty;
  const propTests = {};
  if (isDefined(item.label_entity_id)) {
    propTests["entity-test"] = eq([macromolecular.label_entity_id(), item.label_entity_id]);
  }
  const chainTests = [];
  if (isDefined(item.operator_name))
    chainTests.push(eq([core2.operatorName(), item.operator_name]));
  if (isDefined(item.label_asym_id))
    chainTests.push(eq([macromolecular.label_asym_id(), item.label_asym_id]));
  if (isDefined(item.auth_asym_id))
    chainTests.push(eq([macromolecular.auth_asym_id(), item.auth_asym_id]));
  if (chainTests.length === 1) {
    propTests["chain-test"] = chainTests[0];
  } else if (chainTests.length > 1) {
    propTests["chain-test"] = and(chainTests);
  }
  const residueTests = [];
  if (isDefined(item.label_seq_id)) {
    residueTests.push(ihm.hasSeqId({ 0: item.label_seq_id }));
  }
  if (isDefined(item.auth_seq_id))
    residueTests.push(eq([macromolecular.auth_seq_id(), item.auth_seq_id]));
  if (isDefined(item.pdbx_PDB_ins_code))
    residueTests.push(eq([macromolecular.pdbx_PDB_ins_code(), item.pdbx_PDB_ins_code]));
  if (isDefined(item.beg_label_seq_id) || isDefined(item.end_label_seq_id)) {
    residueTests.push(ihm.overlapsSeqIdRange({ beg: item.beg_label_seq_id, end: item.end_label_seq_id }));
  }
  if (isDefined(item.beg_auth_seq_id))
    residueTests.push(gte([macromolecular.auth_seq_id(), item.beg_auth_seq_id]));
  if (isDefined(item.end_auth_seq_id))
    residueTests.push(lte([macromolecular.auth_seq_id(), item.end_auth_seq_id]));
  if (residueTests.length === 1) {
    propTests["residue-test"] = residueTests[0];
  } else if (residueTests.length > 1) {
    propTests["residue-test"] = and(residueTests);
  }
  const atomTests = [];
  if (isDefined(item.label_comp_id))
    atomTests.push(eq([macromolecular.label_comp_id(), item.label_comp_id]));
  if (isDefined(item.auth_comp_id))
    atomTests.push(eq([macromolecular.auth_comp_id(), item.auth_comp_id]));
  if (isDefined(item.atom_id))
    atomTests.push(eq([macromolecular.id(), item.atom_id]));
  if (isDefined(item.atom_index))
    atomTests.push(eq([MolScriptBuilder.struct.atomProperty.core.sourceIndex(), item.atom_index]));
  if (isDefined(item.label_atom_id))
    atomTests.push(eq([macromolecular.label_atom_id(), item.label_atom_id]));
  if (isDefined(item.auth_atom_id))
    atomTests.push(eq([macromolecular.auth_atom_id(), item.auth_atom_id]));
  if (isDefined(item.type_symbol))
    atomTests.push(eq([MolScriptBuilder.struct.atomProperty.core.elementSymbol(), item.type_symbol.toUpperCase()]));
  if (atomTests.length === 1) {
    propTests["atom-test"] = atomTests[0];
  } else if (atomTests.length > 1) {
    propTests["atom-test"] = and(atomTests);
  }
  return MolScriptBuilder.struct.generator.atomGroups(propTests);
}
function toExpression(schema) {
  const expressions = [];
  forEachItem(schema, (item) => expressions.push(schemaItemToExpression(item)));
  if (expressions.length === 1)
    return expressions[0];
  return unionExpression(expressions);
}
function unionExpression(expressions) {
  return MolScriptBuilder.struct.combinator.merge(expressions.map((e) => MolScriptBuilder.struct.modifier.union([e])));
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function forEachItem(schema, f) {
  if (isItems(schema)) {
    if (Array.isArray(schema.items)) {
      if (schema.prefix) {
        for (const item of schema.items) {
          f(Object.assign({}, schema.prefix, item));
        }
      } else {
        for (const item of schema.items) {
          f(item);
        }
      }
    } else {
      const current = { ...schema.prefix };
      const keys = Object.keys(schema.items);
      const n = schema.items[keys[0]].length;
      for (let i = 0; i < n; i++) {
        for (const k of keys) {
          current[k] = schema.items[k][i];
        }
        f(current);
      }
    }
  } else {
    f(schema);
  }
}
function toLoci(structure, schema, queryContext) {
  const expr = toExpression(schema);
  return Loci.fromExpression(structure, expr, queryContext);
}
function toBundle(structure, schema, queryContext) {
  const loci = toLoci(structure, schema, queryContext);
  return Bundle.fromLoci(loci);
}
var Schema2 = {
  forEachItem,
  toExpression,
  toLoci,
  toBundle
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/element/bundle.js
var Bundle;
(function(Bundle2) {
  Bundle2.Empty = { hash: -1, elements: [] };
  function fromSubStructure(parent, structure) {
    return fromLoci(StructureSelection.toLociWithSourceUnits(StructureSelection.Singletons(parent, structure)));
  }
  Bundle2.fromSubStructure = fromSubStructure;
  function fromSelection(selection) {
    return fromLoci(StructureSelection.toLociWithSourceUnits(selection));
  }
  Bundle2.fromSelection = fromSelection;
  function fromExpression(structure, expression, queryContext) {
    return fromLoci(Loci.fromExpression(structure, expression, queryContext));
  }
  Bundle2.fromExpression = fromExpression;
  function fromQuery(structure, query2, queryContext) {
    return fromLoci(Loci.fromQuery(structure, query2, queryContext));
  }
  Bundle2.fromQuery = fromQuery;
  function fromSchema(structure, schema, queryContext) {
    return Schema2.toBundle(structure, schema, queryContext);
  }
  Bundle2.fromSchema = fromSchema;
  function fromLoci(loci) {
    const _elements = [];
    for (const e of loci.elements) {
      const { unit: unit2, indices } = e;
      if (OrderedSet.size(indices) === 0)
        continue;
      const ranges = [];
      const set2 = [];
      if (OrderedSet.isInterval(indices)) {
        if (OrderedSet.size(indices) === 1) {
          set2.push(Interval.min(indices));
        } else {
          ranges.push(Interval.min(indices), Interval.max(indices));
        }
      } else {
        let i = 0;
        const len = indices.length;
        while (i < len) {
          const start = i;
          i++;
          while (i < len && indices[i - 1] + 1 === indices[i])
            i++;
          const end = i;
          if (end - start > 2) {
            ranges.push(indices[start], indices[end - 1]);
          } else {
            for (let j = start; j < end; j++) {
              set2[set2.length] = indices[j];
            }
          }
        }
      }
      _elements.push({
        unit: unit2,
        set: SortedArray.ofSortedArray(set2),
        ranges: SortedRanges.ofSortedRanges(ranges)
      });
    }
    const elementGroups = /* @__PURE__ */ new Map();
    for (let i = 0, il = _elements.length; i < il; ++i) {
      const e = _elements[i];
      const key = hash2(hashFnv32a(e.ranges), hashFnv32a(e.set));
      if (elementGroups.has(key)) {
        const { groupedUnits } = elementGroups.get(key);
        if (groupedUnits.has(e.unit.invariantId)) {
          groupedUnits.get(e.unit.invariantId).push(e.unit.id);
        } else {
          groupedUnits.set(e.unit.invariantId, [e.unit.id]);
        }
      } else {
        const groupedUnits = /* @__PURE__ */ new Map();
        groupedUnits.set(e.unit.invariantId, [e.unit.id]);
        elementGroups.set(key, { groupedUnits, set: e.set, ranges: e.ranges });
      }
    }
    const elements = [];
    elementGroups.forEach((e) => {
      const groupedUnits = [];
      e.groupedUnits.forEach((g) => groupedUnits.push(SortedArray.ofUnsortedArray(g)));
      groupedUnits.sort((a, b) => a[0] - b[0]);
      elements.push({ groupedUnits, set: e.set, ranges: e.ranges });
    });
    return { hash: loci.structure.hashCode, elements };
  }
  Bundle2.fromLoci = fromLoci;
  function getUnitsFromIds(unitIds, structure) {
    const units = [];
    for (let i = 0, il = unitIds.length; i < il; ++i) {
      const unitId = unitIds[i];
      if (structure.unitMap.has(unitId))
        units.push(structure.unitMap.get(unitId));
    }
    return units;
  }
  function toLoci2(bundle, structure) {
    if (bundle.hash !== -1 && bundle.hash !== structure.hashCode) {
      new Error("Bundle not compatible with given structure");
    }
    const elements = [];
    for (const e of bundle.elements) {
      for (const g of e.groupedUnits) {
        const units = getUnitsFromIds(g, structure);
        if (units.length === 0)
          continue;
        let indices;
        if (e.ranges.length === 0) {
          indices = e.set;
        } else if (e.set.length === 0) {
          if (e.ranges.length === 2) {
            indices = Interval.ofRange(e.ranges[0], e.ranges[1]);
          } else {
            const _indices = new Int32Array(SortedRanges.size(e.ranges));
            SortedRanges.forEach(e.ranges, (v, i) => _indices[i] = v);
            indices = SortedArray.ofSortedArray(_indices);
          }
        } else {
          const rangesSize = SortedRanges.size(e.ranges);
          const _indices = new Int32Array(e.set.length + rangesSize);
          SortedRanges.forEach(e.ranges, (v, i) => _indices[i] = v);
          _indices.set(e.set, rangesSize);
          indices = SortedArray.ofUnsortedArray(_indices);
        }
        for (const unit2 of units) {
          elements.push({ unit: unit2, indices });
        }
      }
    }
    return Loci(structure, elements);
  }
  Bundle2.toLoci = toLoci2;
  function toStructure(bundle, parent) {
    if (bundle.hash !== -1 && bundle.hash !== parent.hashCode) {
      new Error("Bundle not compatible with given structure");
    }
    const units = [];
    for (const e of bundle.elements) {
      for (const g of e.groupedUnits) {
        const _units = getUnitsFromIds(g, parent);
        if (_units.length === 0)
          continue;
        const ue = _units[0].elements;
        const rangesSize = SortedRanges.size(e.ranges);
        const setSize = e.set.length;
        const _indices = new Int32Array(setSize + rangesSize);
        let indices;
        if (rangesSize === 0) {
          for (let i = 0, il = setSize; i < il; ++i) {
            _indices[i] = ue[e.set[i]];
          }
          indices = SortedArray.ofSortedArray(_indices);
        } else if (setSize === 0) {
          SortedRanges.forEach(e.ranges, (v, i) => _indices[i] = ue[v]);
          indices = SortedArray.ofSortedArray(_indices);
        } else {
          if (SortedArray.min(e.set) > SortedRanges.max(e.ranges)) {
            SortedRanges.forEach(e.ranges, (v, i) => _indices[i] = ue[v]);
            for (let i = 0, il = setSize; i < il; ++i) {
              _indices[i + rangesSize] = ue[e.set[i]];
            }
            indices = SortedArray.ofSortedArray(_indices);
          } else if (SortedRanges.min(e.ranges) > SortedArray.max(e.set)) {
            for (let i = 0, il = setSize; i < il; ++i) {
              _indices[i] = ue[e.set[i]];
            }
            SortedRanges.forEach(e.ranges, (v, i) => _indices[i + setSize] = ue[v]);
            indices = SortedArray.ofSortedArray(_indices);
          } else {
            SortedRanges.forEach(e.ranges, (v, i) => _indices[i] = ue[v]);
            for (let i = 0, il = setSize; i < il; ++i) {
              _indices[i + rangesSize] = ue[e.set[i]];
            }
            indices = SortedArray.ofUnsortedArray(_indices);
          }
        }
        for (const unit2 of _units) {
          units.push(unit2.getChild(indices));
        }
      }
    }
    return Structure.create(units, { parent });
  }
  Bundle2.toStructure = toStructure;
  function elementToExpression(e) {
    return MolScriptBuilder.internal.generator.bundleElement({
      groupedUnits: MolScriptBuilder.core.type.list(e.groupedUnits.map((u) => MolScriptBuilder.core.type.list(u))),
      ranges: MolScriptBuilder.core.type.list(e.ranges),
      set: MolScriptBuilder.core.type.list(e.set)
    });
  }
  function toExpression2(bundle) {
    return MolScriptBuilder.internal.generator.bundle({
      elements: MolScriptBuilder.core.type.list(bundle.elements.map(elementToExpression))
    });
  }
  Bundle2.toExpression = toExpression2;
  function areEqual(a, b) {
    if (a.elements.length !== b.elements.length)
      return false;
    for (let i = 0, il = a.elements.length; i < il; ++i) {
      const elementA = a.elements[i], elementB = b.elements[i];
      if (elementA.groupedUnits.length !== elementB.groupedUnits.length)
        return false;
      for (let j = 0, jl = elementB.groupedUnits.length; j < jl; ++j) {
        if (!SortedArray.areEqual(elementA.groupedUnits[j], elementB.groupedUnits[j]))
          return false;
      }
      if (!SortedArray.areEqual(elementA.set, elementB.set))
        return false;
      if (!SortedRanges.areEqual(elementA.ranges, elementB.ranges))
        return false;
    }
    return true;
  }
  Bundle2.areEqual = areEqual;
})(Bundle || (Bundle = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/queries/internal.js
function defaultBondTest(ctx) {
  return BondType.isCovalent(ctx.atomicBond.type);
}
function atomicSequence() {
  return function query_atomicSequence(ctx) {
    const { inputStructure } = ctx;
    const l = element_exports.Location.create(inputStructure);
    const units = [];
    for (const unit2 of inputStructure.units) {
      if (unit2.kind !== Unit.Kind.Atomic)
        continue;
      l.unit = unit2;
      const elements = unit2.elements;
      l.element = elements[0];
      if (StructureProperties.entity.type(l) !== "polymer")
        continue;
      const residuesIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.residueAtomSegments, elements);
      let residueCount = 0;
      while (residuesIt.hasNext) {
        residueCount++;
        residuesIt.move();
      }
      if (residueCount < 8)
        continue;
      units.push(unit2);
    }
    return StructureSelection.Singletons(inputStructure, Structure.create(units, { parent: inputStructure }));
  };
}
function water() {
  return function query_water(ctx) {
    const { inputStructure } = ctx;
    const l = element_exports.Location.create(inputStructure);
    const units = [];
    for (const unit2 of inputStructure.units) {
      if (unit2.kind !== Unit.Kind.Atomic)
        continue;
      l.unit = unit2;
      const elements = unit2.elements;
      l.element = elements[0];
      if (StructureProperties.entity.type(l) !== "water")
        continue;
      units.push(unit2);
    }
    return StructureSelection.Singletons(inputStructure, Structure.create(units, { parent: inputStructure }));
  };
}
function atomicHet() {
  return function query_atomicHet(ctx) {
    const { inputStructure } = ctx;
    const l = element_exports.Location.create(inputStructure);
    const units = [];
    for (const unit2 of inputStructure.units) {
      if (unit2.kind !== Unit.Kind.Atomic)
        continue;
      l.unit = unit2;
      const elements = unit2.elements;
      l.element = elements[0];
      if (StructureProperties.entity.type(l) === "water")
        continue;
      if (StructureProperties.entity.type(l) === "polymer") {
        const residuesIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.residueAtomSegments, elements);
        let residueCount = 0;
        while (residuesIt.hasNext) {
          residueCount++;
          residuesIt.move();
        }
        if (residueCount >= 8)
          continue;
      }
      units.push(unit2);
    }
    return StructureSelection.Singletons(inputStructure, Structure.create(units, { parent: inputStructure }));
  };
}
function spheres() {
  return function query_spheres(ctx) {
    const { inputStructure } = ctx;
    const units = [];
    for (const unit2 of inputStructure.units) {
      if (unit2.kind !== Unit.Kind.Spheres)
        continue;
      units.push(unit2);
    }
    return StructureSelection.Singletons(inputStructure, Structure.create(units, { parent: inputStructure }));
  };
}
function bundleElementImpl(groupedUnits, ranges, set2) {
  return {
    groupedUnits,
    ranges,
    set: set2
  };
}
function bundleGenerator(elements) {
  return function query_bundleGenerator(ctx) {
    const bundle = {
      hash: ctx.inputStructure.hashCode,
      elements
    };
    return StructureSelection.Sequence(ctx.inputStructure, [Bundle.toStructure(bundle, ctx.inputStructure)]);
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/context.js
var QueryContext = class {
  pushCurrentElement() {
    this.currentElementStack[this.currentElementStack.length] = this.element;
    this.element = element_exports.Location.create(void 0);
    return this.element;
  }
  popCurrentElement() {
    this.element = this.currentElementStack.pop();
  }
  pushCurrentBond() {
    if (this.atomicBond)
      this.currentAtomicBondStack.push(this.atomicBond);
    this.atomicBond = new QueryContextBondInfo();
    return this.atomicBond;
  }
  popCurrentBond() {
    if (this.currentAtomicBondStack.length > 0) {
      this.atomicBond = this.currentAtomicBondStack.pop();
    } else {
      this.atomicBond = void 0;
    }
  }
  pushCurrentStructure() {
    if (this.currentStructure)
      this.currentStructureStack.push(this.currentStructure);
  }
  popCurrentStructure() {
    if (this.currentStructureStack.length)
      this.currentStructure = this.currentStructureStack.pop();
    else
      this.currentStructure = void 0;
  }
  pushInputStructure(structure) {
    this.inputStructureStack.push(this.inputStructure);
    this.inputStructure = structure;
  }
  popInputStructure() {
    if (this.inputStructureStack.length === 0)
      throw new Error("Must push before pop.");
    this.inputStructure = this.inputStructureStack.pop();
  }
  throwIfTimedOut() {
    if (this.timeoutMs === 0)
      return;
    if (now() - this.timeCreated > this.timeoutMs) {
      throw new Error(`The query took too long to execute (> ${this.timeoutMs / 1e3}s).`);
    }
  }
  tryGetCurrentSelection() {
    if (!this.currentSelection)
      throw new Error("The current selection is not assigned.");
    return this.currentSelection;
  }
  constructor(structure, options) {
    this.currentElementStack = [];
    this.currentAtomicBondStack = [];
    this.currentStructureStack = [];
    this.inputStructureStack = [];
    this.timeCreated = now();
    this.element = element_exports.Location.create(void 0);
    this.currentStructure = void 0;
    this.atomicBond = new QueryContextBondInfo();
    this.currentSelection = void 0;
    this.inputStructure = structure;
    this.timeoutMs = options && options.timeoutMs || 0;
    this.currentSelection = options && options.currentSelection;
  }
};
var QueryContextBondInfo = class {
  constructor() {
    this.a = element_exports.Location.create(void 0);
    this.aIndex = 0;
    this.b = element_exports.Location.create(void 0);
    this.bIndex = 0;
    this.type = BondType.Flag.None;
    this.order = 0;
    this.key = -1;
    this.testFn = defaultBondTest;
  }
  setStructure(s) {
    this.a.structure = s;
    this.b.structure = s;
  }
  setTestFn(fn) {
    this.testFn = fn || defaultBondTest;
  }
  test(ctx, trySwap) {
    if (this.testFn(ctx))
      return true;
    if (trySwap) {
      this.swap();
      return this.testFn(ctx);
    }
    return false;
  }
  swap() {
    const idxA = this.aIndex;
    this.aIndex = this.bIndex;
    this.bIndex = idxA;
    const unitA = this.a.unit;
    this.a.unit = this.b.unit;
    this.b.unit = unitA;
    const eA = this.a.element;
    this.a.element = this.b.element;
    this.b.element = eA;
  }
  get length() {
    return element_exports.Location.distance(this.a, this.b);
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/query.js
var StructureQuery;
(function(StructureQuery2) {
  function run(query2, structure, options) {
    return query2(new QueryContext(structure, options));
  }
  StructureQuery2.run = run;
  function loci(query2, structure, options) {
    const sel = query2(new QueryContext(structure, options));
    return StructureSelection.toLociWithSourceUnits(sel);
  }
  StructureQuery2.loci = loci;
})(StructureQuery || (StructureQuery = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/queries/generators.js
var generators_exports = {};
__export(generators_exports, {
  all: () => all,
  atoms: () => atoms,
  bondedAtomicPairs: () => bondedAtomicPairs,
  chains: () => chains,
  none: () => none,
  querySelection: () => querySelection,
  residues: () => residues,
  rings: () => rings
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/utils/builders.js
var UniqueStructuresBuilder = class {
  add(s) {
    if (!s.elementCount)
      return;
    if (s.elementCount !== 1)
      this.allSingletons = false;
    if (this.set.add(s)) {
      this.structures[this.structures.length] = s;
    }
  }
  getSelection() {
    if (this.allSingletons)
      return StructureSelection.Singletons(this.source, structureUnion(this.source, this.structures));
    return StructureSelection.Sequence(this.source, this.structures);
  }
  constructor(source) {
    this.source = source;
    this.set = HashSet(Structure.hashCode, Structure.areUnitIdsAndIndicesEqual);
    this.structures = [];
    this.allSingletons = true;
  }
};
var LinearGroupingBuilder = class {
  add(key, unit2, element) {
    let b = this.builderMap.get(key);
    if (!b) {
      b = this.source.subsetBuilder(true);
      this.builders[this.builders.length] = b;
      this.builderMap.set(key, b);
    }
    b.addToUnit(unit2, element);
  }
  allSingletons() {
    for (let i = 0, _i = this.builders.length; i < _i; i++) {
      if (this.builders[i].elementCount > 1)
        return false;
    }
    return true;
  }
  singletonSelection() {
    const builder = this.source.subsetBuilder(true);
    const loc = element_exports.Location.create(this.source);
    for (let i = 0, _i = this.builders.length; i < _i; i++) {
      this.builders[i].setSingletonLocation(loc);
      builder.addToUnit(loc.unit.id, loc.element);
    }
    return StructureSelection.Singletons(this.source, builder.getStructure());
  }
  fullSelection() {
    const structures = new Array(this.builders.length);
    for (let i = 0, _i = this.builders.length; i < _i; i++) {
      structures[i] = this.builders[i].getStructure();
    }
    return StructureSelection.Sequence(this.source, structures);
  }
  getSelection() {
    const len = this.builders.length;
    if (len === 0)
      return StructureSelection.Empty(this.source);
    if (this.allSingletons())
      return this.singletonSelection();
    return this.fullSelection();
  }
  constructor(source) {
    this.source = source;
    this.builders = [];
    this.builderMap = /* @__PURE__ */ new Map();
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/queries/generators.js
var none = (ctx) => StructureSelection.Sequence(ctx.inputStructure, []);
var all = (ctx) => StructureSelection.Singletons(ctx.inputStructure, ctx.inputStructure);
function residues(params) {
  return atoms({ ...params, groupBy: (ctx) => StructureProperties.residue.key(ctx.element) });
}
function chains(params) {
  return atoms({ ...params, groupBy: (ctx) => StructureProperties.chain.key(ctx.element) });
}
function _true(ctx) {
  return true;
}
function _zero(ctx) {
  return 0;
}
function atoms(params) {
  if (!params || !params.atomTest && !params.residueTest && !params.chainTest && !params.entityTest && !params.unitTest && !params.groupBy)
    return all;
  if (!!params.atomTest && !params.residueTest && !params.chainTest && !params.entityTest && !params.unitTest && !params.groupBy)
    return atomGroupsLinear(params.atomTest);
  const normalized = {
    unitTest: params.unitTest || _true,
    entityTest: params.entityTest || _true,
    chainTest: params.chainTest || _true,
    residueTest: params.residueTest || _true,
    atomTest: params.atomTest || _true,
    groupBy: params.groupBy || _zero
  };
  if (!params.groupBy)
    return atomGroupsSegmented(normalized);
  return atomGroupsGrouped(normalized);
}
function atomGroupsLinear(atomTest) {
  return function query_atomGroupsLinear(ctx) {
    const { inputStructure } = ctx;
    const { units } = inputStructure;
    const l = ctx.pushCurrentElement();
    const builder = inputStructure.subsetBuilder(true);
    l.structure = inputStructure;
    for (const unit2 of units) {
      l.unit = unit2;
      const elements = unit2.elements;
      builder.beginUnit(unit2.id);
      for (let j = 0, _j = elements.length; j < _j; j++) {
        l.element = elements[j];
        if (atomTest(ctx))
          builder.addElement(l.element);
      }
      builder.commitUnit();
      ctx.throwIfTimedOut();
    }
    ctx.popCurrentElement();
    return StructureSelection.Singletons(inputStructure, builder.getStructure());
  };
}
function atomGroupsSegmented({ unitTest, entityTest, chainTest, residueTest, atomTest }) {
  return function query_atomGroupsSegmented(ctx) {
    const { inputStructure } = ctx;
    const { units } = inputStructure;
    const l = ctx.pushCurrentElement();
    const builder = inputStructure.subsetBuilder(true);
    const chainLevel = residueTest === _true && atomTest === _true;
    const residueLevel = atomTest === _true;
    l.structure = inputStructure;
    for (const unit2 of units) {
      l.unit = unit2;
      if (!unitTest(ctx))
        continue;
      const { elements, model } = unit2;
      builder.beginUnit(unit2.id);
      if (unit2.kind === Unit.Kind.Atomic) {
        const chainsIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.chainAtomSegments, elements);
        const residuesIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.residueAtomSegments, elements);
        while (chainsIt.hasNext) {
          const chainSegment = chainsIt.move();
          l.element = elements[chainSegment.start];
          if (!entityTest(ctx) || !chainTest(ctx))
            continue;
          if (chainLevel) {
            builder.addElementRange(elements, chainSegment.start, chainSegment.end);
            continue;
          }
          residuesIt.setSegment(chainSegment);
          while (residuesIt.hasNext) {
            const residueSegment = residuesIt.move();
            l.element = elements[residueSegment.start];
            if (!residueTest(ctx))
              continue;
            if (residueLevel) {
              builder.addElementRange(elements, residueSegment.start, residueSegment.end);
              continue;
            }
            for (let j = residueSegment.start, _j = residueSegment.end; j < _j; j++) {
              l.element = elements[j];
              if (atomTest(ctx)) {
                builder.addElement(l.element);
              }
            }
          }
        }
      } else {
        const { chainElementSegments } = unit2.kind === Unit.Kind.Spheres ? model.coarseHierarchy.spheres : model.coarseHierarchy.gaussians;
        const chainsIt = Segmentation.transientSegments(chainElementSegments, elements);
        while (chainsIt.hasNext) {
          const chainSegment = chainsIt.move();
          l.element = elements[chainSegment.start];
          if (!entityTest(ctx) || !chainTest(ctx))
            continue;
          if (chainLevel) {
            builder.addElementRange(elements, chainSegment.start, chainSegment.end);
            continue;
          }
          for (let j = chainSegment.start, _j = chainSegment.end; j < _j; j++) {
            l.element = elements[j];
            if (residueTest(ctx)) {
              builder.addElement(l.element);
            }
          }
        }
      }
      builder.commitUnit();
      ctx.throwIfTimedOut();
    }
    ctx.popCurrentElement();
    return StructureSelection.Singletons(inputStructure, builder.getStructure());
  };
}
function atomGroupsGrouped({ unitTest, entityTest, chainTest, residueTest, atomTest, groupBy }) {
  return function query_atomGroupsGrouped(ctx) {
    const { inputStructure } = ctx;
    const { units } = inputStructure;
    const l = ctx.pushCurrentElement();
    const builder = new LinearGroupingBuilder(inputStructure);
    l.structure = inputStructure;
    for (const unit2 of units) {
      l.unit = unit2;
      if (!unitTest(ctx))
        continue;
      const { elements, model } = unit2;
      if (unit2.kind === Unit.Kind.Atomic) {
        const chainsIt = Segmentation.transientSegments(model.atomicHierarchy.chainAtomSegments, elements);
        const residuesIt = Segmentation.transientSegments(model.atomicHierarchy.residueAtomSegments, elements);
        while (chainsIt.hasNext) {
          const chainSegment = chainsIt.move();
          l.element = elements[chainSegment.start];
          if (!entityTest(ctx) || !chainTest(ctx))
            continue;
          residuesIt.setSegment(chainSegment);
          while (residuesIt.hasNext) {
            const residueSegment = residuesIt.move();
            l.element = elements[residueSegment.start];
            if (!residueTest(ctx))
              continue;
            for (let j = residueSegment.start, _j = residueSegment.end; j < _j; j++) {
              l.element = elements[j];
              if (atomTest(ctx)) {
                builder.add(groupBy(ctx), unit2.id, l.element);
              }
            }
          }
        }
      } else {
        const { chainElementSegments } = unit2.kind === Unit.Kind.Spheres ? model.coarseHierarchy.spheres : model.coarseHierarchy.gaussians;
        const chainsIt = Segmentation.transientSegments(chainElementSegments, elements);
        while (chainsIt.hasNext) {
          const chainSegment = chainsIt.move();
          l.element = elements[chainSegment.start];
          if (!entityTest(ctx) || !chainTest(ctx))
            continue;
          for (let j = chainSegment.start, _j = chainSegment.end; j < _j; j++) {
            l.element = elements[j];
            if (residueTest(ctx)) {
              builder.add(groupBy(ctx), unit2.id, l.element);
            }
          }
        }
      }
      ctx.throwIfTimedOut();
    }
    ctx.popCurrentElement();
    return builder.getSelection();
  };
}
function getRingStructure(unit2, ring, inputStructure) {
  const elements = new Int32Array(ring.length);
  for (let i = 0, _i = ring.length; i < _i; i++)
    elements[i] = unit2.elements[ring[i]];
  return Structure.create([unit2.getChild(SortedArray.ofSortedArray(elements))], { parent: inputStructure });
}
function rings(fingerprints, onlyAromatic) {
  return function query_rings(ctx) {
    const { units } = ctx.inputStructure;
    const ret = StructureSelection.LinearBuilder(ctx.inputStructure);
    if (!fingerprints || fingerprints.length === 0) {
      for (const u of units) {
        if (!Unit.isAtomic(u))
          continue;
        if (onlyAromatic) {
          for (const r of u.rings.aromaticRings) {
            ret.add(getRingStructure(u, u.rings.all[r], ctx.inputStructure));
          }
        } else {
          for (const r of u.rings.all) {
            ret.add(getRingStructure(u, r, ctx.inputStructure));
          }
        }
      }
    } else {
      const uniqueFps = UniqueArray.create();
      for (let i = 0; i < fingerprints.length; i++)
        UniqueArray.add(uniqueFps, fingerprints[i], fingerprints[i]);
      for (const u of units) {
        if (!Unit.isAtomic(u))
          continue;
        const rings2 = u.rings;
        for (const fp of uniqueFps.array) {
          if (!rings2.byFingerprint.has(fp))
            continue;
          for (const r of rings2.byFingerprint.get(fp)) {
            if (onlyAromatic && !rings2.aromaticRings.includes(r))
              continue;
            ret.add(getRingStructure(u, rings2.all[r], ctx.inputStructure));
          }
        }
      }
    }
    return ret.getSelection();
  };
}
function querySelection(selection, query2, inComplement = false) {
  return function query_querySelection(ctx) {
    const targetSel = selection(ctx);
    if (StructureSelection.structureCount(targetSel) === 0)
      return targetSel;
    const target = inComplement ? structureSubtract(ctx.inputStructure, StructureSelection.unionStructure(targetSel)) : StructureSelection.unionStructure(targetSel);
    if (target.elementCount === 0)
      return StructureSelection.Empty(ctx.inputStructure);
    ctx.throwIfTimedOut();
    ctx.pushInputStructure(target);
    const result2 = query2(ctx);
    ctx.popInputStructure();
    return StructureSelection.withInputStructure(result2, ctx.inputStructure);
  };
}
function bondedAtomicPairs(bondTest) {
  return function query_bondedAtomicPairs(ctx) {
    const structure = ctx.inputStructure;
    const interBonds = structure.interUnitBonds;
    const ret = StructureSelection.UniqueBuilder(ctx.inputStructure);
    ctx.pushCurrentBond();
    const atomicBond = ctx.atomicBond;
    atomicBond.setTestFn(bondTest);
    atomicBond.setStructure(structure);
    for (const unit2 of structure.units) {
      if (unit2.kind !== Unit.Kind.Atomic)
        continue;
      const { offset: intraBondOffset, b: intraBondB, edgeProps: { flags: flags2, order, key } } = unit2.bonds;
      atomicBond.a.unit = unit2;
      atomicBond.b.unit = unit2;
      for (let i = 0, _i = unit2.elements.length; i < _i; i++) {
        atomicBond.aIndex = i;
        atomicBond.a.element = unit2.elements[i];
        for (let lI = intraBondOffset[i], _lI = intraBondOffset[i + 1]; lI < _lI; lI++) {
          atomicBond.bIndex = intraBondB[lI];
          atomicBond.b.element = unit2.elements[intraBondB[lI]];
          atomicBond.type = flags2[lI];
          atomicBond.order = order[lI];
          atomicBond.key = key[lI];
          if (atomicBond.test(ctx, false)) {
            const b = structure.subsetBuilder(false);
            b.beginUnit(unit2.id);
            b.addElement(atomicBond.a.element);
            b.addElement(atomicBond.b.element);
            b.commitUnit();
            ret.add(b.getStructure());
          }
        }
      }
    }
    for (const bond of interBonds.edges) {
      atomicBond.a.unit = structure.unitMap.get(bond.unitA);
      atomicBond.a.element = atomicBond.a.unit.elements[bond.indexA];
      atomicBond.aIndex = bond.indexA;
      atomicBond.b.unit = structure.unitMap.get(bond.unitB);
      atomicBond.b.element = atomicBond.b.unit.elements[bond.indexB];
      atomicBond.bIndex = bond.indexB;
      atomicBond.order = bond.props.order;
      atomicBond.type = bond.props.flag;
      atomicBond.key = bond.props.key;
      if (atomicBond.test(ctx, false)) {
        const b = structure.subsetBuilder(false);
        b.addToUnit(atomicBond.a.unit.id, atomicBond.a.element);
        b.addToUnit(atomicBond.b.unit.id, atomicBond.b.element);
        ret.add(b.getStructure());
      }
    }
    ctx.popCurrentBond();
    return ret.getSelection();
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/queries/modifiers.js
var modifiers_exports = {};
__export(modifiers_exports, {
  exceptBy: () => exceptBy,
  expandProperty: () => expandProperty,
  includeConnected: () => includeConnected,
  includeSurroundings: () => includeSurroundings,
  intersectBy: () => intersectBy,
  querySelection: () => querySelection2,
  surroundingLigands: () => surroundingLigands,
  union: () => union,
  wholeResidues: () => wholeResidues
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/util/unique-subset-builder.js
var StructureUniqueSubsetBuilder = class {
  addToUnit(parentId, e) {
    const unit2 = this.unitMap.get(parentId);
    if (!!unit2) {
      if (UniqueArray.add(unit2, e, e))
        this.elementCount++;
    } else {
      const arr = UniqueArray.create();
      UniqueArray.add(arr, e, e);
      this.unitMap.set(parentId, arr);
      this.ids[this.ids.length] = parentId;
      this.elementCount++;
    }
  }
  has(parentId, e) {
    const unit2 = this.unitMap.get(parentId);
    if (!unit2)
      return false;
    return UniqueArray.has(unit2, e);
  }
  beginUnit(parentId) {
    this.parentId = parentId;
    if (this.unitMap.has(parentId)) {
      this.currentUnit = this.unitMap.get(parentId);
    } else {
      this.currentUnit = this.currentUnit.array.length > 0 ? UniqueArray.create() : this.currentUnit;
    }
  }
  addElement(e) {
    if (UniqueArray.add(this.currentUnit, e, e))
      this.elementCount++;
  }
  commitUnit() {
    if (this.currentUnit.array.length === 0 || this.unitMap.has(this.parentId))
      return;
    this.ids[this.ids.length] = this.parentId;
    this.unitMap.set(this.parentId, this.currentUnit);
    this.parentId = -1;
  }
  getStructure() {
    if (this.isEmpty)
      return Structure.Empty;
    const newUnits = [];
    sortArray(this.ids);
    const symmGroups = StructureSymmetry.UnitEquivalenceBuilder();
    for (let i = 0, _i = this.ids.length; i < _i; i++) {
      const id = this.ids[i];
      const parent = this.parent.unitMap.get(id);
      const unit2 = this.unitMap.get(id).array;
      const l = unit2.length;
      if (unit2.length === parent.elements.length) {
        newUnits[newUnits.length] = parent;
        symmGroups.add(parent.id, parent);
        continue;
      }
      if (l > 1)
        sortArray(unit2);
      let child = parent.getChild(SortedArray.ofSortedArray(unit2));
      const pivot = symmGroups.add(child.id, child);
      if (child !== pivot)
        child = pivot.applyOperator(child.id, child.conformation.operator, true);
      newUnits[newUnits.length] = child;
    }
    return Structure.create(newUnits, { parent: this.parent });
  }
  get isEmpty() {
    return this.elementCount === 0;
  }
  constructor(parent) {
    this.parent = parent;
    this.ids = [];
    this.unitMap = IntMap.Mutable();
    this.parentId = -1;
    this.currentUnit = UniqueArray.create();
    this.elementCount = 0;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/atomic/hierarchy.js
var AtomsSchema = {
  /**
   * The chemical element of this atom site.
   * For mmCIF files, this points to atom_type.symbol in the ATOM_TYPE category.
   */
  type_symbol: Column.Schema.Aliased(mmCIF_Schema.atom_site.type_symbol),
  /**
   * A component of the identifier for this atom site.
   * This is a standardized name for the atom within its residue.
   * For mmCIF files, this points to chem_comp_atom.atom_id in the CHEM_COMP_ATOM category.
   */
  label_atom_id: mmCIF_Schema.atom_site.label_atom_id,
  /**
   * An alternative identifier for label_atom_id that may be provided by an author
   * in order to match the identification used in the publication that describes the structure.
   */
  auth_atom_id: mmCIF_Schema.atom_site.auth_atom_id,
  /**
   * A component of the identifier for this atom site.
   * Identifies an alternative conformation for this atom site.
   */
  label_alt_id: mmCIF_Schema.atom_site.label_alt_id,
  /**
   * A component of the identifier for this atom site.
   * For mmCIF files, this points to chem_comp.id in the CHEM_COMP category.
   */
  label_comp_id: mmCIF_Schema.atom_site.label_comp_id,
  /**
   * An alternative identifier for atom_site.label_comp_id that may be provided by an author
   * in order to match the identification used in the publication that describes the structure.
   */
  auth_comp_id: mmCIF_Schema.atom_site.auth_comp_id,
  /**
   * The net integer charge assigned to this atom.
   * This is the formal charge assignment normally found in chemical diagrams.
   */
  pdbx_formal_charge: mmCIF_Schema.atom_site.pdbx_formal_charge
  // id, occupancy and B_iso_or_equiv are part of conformation
};
var ResiduesSchema = {
  /**
   * The group of atoms to which the atom site belongs. This data item is provided for
   * compatibility with the original Protein Data Bank format, and only for that purpose.
   */
  group_PDB: mmCIF_Schema.atom_site.group_PDB,
  /**
   * For mmCIF files, this points to entity_poly_seq.num in the ENTITY_POLY_SEQ category.
   */
  label_seq_id: mmCIF_Schema.atom_site.label_seq_id,
  /**
   * An alternative identifier for atom_site.label_seq_id that may be provided by an author
   * in order to match the identification used in the publication that describes the structure.
   */
  auth_seq_id: mmCIF_Schema.atom_site.auth_seq_id,
  /**
   * PDB insertion code.
   */
  pdbx_PDB_ins_code: mmCIF_Schema.atom_site.pdbx_PDB_ins_code
  // comp_id is part of atoms because of microheterogeneity
};
var ChainsSchema = {
  /**
   * A component of the identifier for this atom site.
   * For mmCIF files, this points to struct_asym.id in the STRUCT_ASYM category.
   */
  label_asym_id: mmCIF_Schema.atom_site.label_asym_id,
  /**
   * An alternative identifier for atomsite.label_asym_id that may be provided by an author
   * in order to match the identification used in the publication that describes the structure.
   */
  auth_asym_id: mmCIF_Schema.atom_site.auth_asym_id,
  /**
   * For mmCIF files, this points to _entity.id in the ENTITY category.
   */
  label_entity_id: mmCIF_Schema.atom_site.label_entity_id
};
var AtomicIndex;
(function(AtomicIndex2) {
  function EmptyResidueKey() {
    return { label_entity_id: "", label_asym_id: "", auth_seq_id: 0, pdbx_PDB_ins_code: void 0 };
  }
  AtomicIndex2.EmptyResidueKey = EmptyResidueKey;
})(AtomicIndex || (AtomicIndex = {}));
var AtomicHierarchy;
(function(AtomicHierarchy2) {
  function chainStartResidueIndex(segs, cI) {
    return segs.residueAtomSegments.index[segs.chainAtomSegments.offsets[cI]];
  }
  AtomicHierarchy2.chainStartResidueIndex = chainStartResidueIndex;
  function chainEndResidueIndexExcl(segs, cI) {
    return segs.residueAtomSegments.index[segs.chainAtomSegments.offsets[cI + 1] - 1] + 1;
  }
  AtomicHierarchy2.chainEndResidueIndexExcl = chainEndResidueIndexExcl;
  function chainResidueCount(segs, cI) {
    return chainEndResidueIndexExcl(segs, cI) - chainStartResidueIndex(segs, cI);
  }
  AtomicHierarchy2.chainResidueCount = chainResidueCount;
  function residueFirstAtomIndex(hierarchy, rI) {
    return hierarchy.residueAtomSegments.offsets[rI];
  }
  AtomicHierarchy2.residueFirstAtomIndex = residueFirstAtomIndex;
  function atomChainIndex(hierarchy, eI) {
    return hierarchy.chainAtomSegments.index[eI];
  }
  AtomicHierarchy2.atomChainIndex = atomChainIndex;
  function residueChainIndex(hierarchy, rI) {
    return hierarchy.chainAtomSegments.index[hierarchy.residueAtomSegments.offsets[rI]];
  }
  AtomicHierarchy2.residueChainIndex = residueChainIndex;
})(AtomicHierarchy || (AtomicHierarchy = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/secondary-structure.js
function SecondaryStructure(type3, key, elements, getIndex) {
  return { type: type3, key, elements, getIndex };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/nodejs-shims.js
var RUNNING_IN_NODEJS = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
var File_ = getFile();
function getFile() {
  if (typeof File === "undefined" || RUNNING_IN_NODEJS) {
    class File_NodeJs {
      arrayBuffer() {
        return this.blob.arrayBuffer();
      }
      slice(start, end, contentType) {
        return this.blob.slice(start, end, contentType);
      }
      stream() {
        return this.blob.stream();
      }
      text() {
        return this.blob.text();
      }
      bytes() {
        return this.blob.bytes();
      }
      constructor(fileBits, fileName, options) {
        var _a;
        this.blob = new Blob(fileBits, options);
        this.size = this.blob.size;
        this.type = this.blob.type;
        this.name = fileName;
        this.lastModified = (_a = options === null || options === void 0 ? void 0 : options.lastModified) !== null && _a !== void 0 ? _a : 0;
        this.webkitRelativePath = "";
      }
    }
    return File_NodeJs;
  } else {
    return File;
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/zip/bin.js
function toInt32(x) {
  return x >> 0;
}
function readUshort(buff, p3) {
  return buff[p3] | buff[p3 + 1] << 8;
}
function writeUshort(buff, p3, n) {
  buff[p3] = n & 255;
  buff[p3 + 1] = n >> 8 & 255;
}
function readUint(buff, p3) {
  return buff[p3 + 3] * (256 * 256 * 256) + (buff[p3 + 2] << 16 | buff[p3 + 1] << 8 | buff[p3]);
}
function writeUint(buff, p3, n) {
  buff[p3] = n & 255;
  buff[p3 + 1] = n >> 8 & 255;
  buff[p3 + 2] = n >> 16 & 255;
  buff[p3 + 3] = n >> 24 & 255;
}
function readASCII(buff, p3, l) {
  let s = "";
  for (let i = 0; i < l; i++)
    s += String.fromCharCode(buff[p3 + i]);
  return s;
}
function pad(n) {
  return n.length < 2 ? "0" + n : n;
}
function readUTF8(buff, p3, l) {
  let s = "", ns;
  for (let i = 0; i < l; i++)
    s += "%" + pad(buff[p3 + i].toString(16));
  try {
    ns = decodeURIComponent(s);
  } catch (e) {
    return readASCII(buff, p3, l);
  }
  return ns;
}
function writeUTF8(buff, p3, str9) {
  const strl = str9.length;
  let i = 0;
  for (let ci = 0; ci < strl; ci++) {
    const code = str9.charCodeAt(ci);
    if ((code & 4294967295 - (1 << 7) + 1) === 0) {
      buff[p3 + i] = code;
      i++;
    } else if ((code & 4294967295 - (1 << 11) + 1) === 0) {
      buff[p3 + i] = 192 | code >> 6;
      buff[p3 + i + 1] = 128 | code >> 0 & 63;
      i += 2;
    } else if ((code & 4294967295 - (1 << 16) + 1) === 0) {
      buff[p3 + i] = 224 | code >> 12;
      buff[p3 + i + 1] = 128 | code >> 6 & 63;
      buff[p3 + i + 2] = 128 | code >> 0 & 63;
      i += 3;
    } else if ((code & 4294967295 - (1 << 21) + 1) === 0) {
      buff[p3 + i] = 240 | code >> 18;
      buff[p3 + i + 1] = 128 | code >> 12 & 63;
      buff[p3 + i + 2] = 128 | code >> 6 & 63;
      buff[p3 + i + 3] = 128 | code >> 0 & 63;
      i += 4;
    } else
      throw new Error("e");
  }
  return i;
}
function sizeUTF8(str9) {
  const strl = str9.length;
  let i = 0;
  for (let ci = 0; ci < strl; ci++) {
    const code = str9.charCodeAt(ci);
    if ((code & 4294967295 - (1 << 7) + 1) === 0) {
      i++;
    } else if ((code & 4294967295 - (1 << 11) + 1) === 0) {
      i += 2;
    } else if ((code & 4294967295 - (1 << 16) + 1) === 0) {
      i += 3;
    } else if ((code & 4294967295 - (1 << 21) + 1) === 0) {
      i += 4;
    } else {
      throw new Error("e");
    }
  }
  return i;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/zip/checksum.js
var CrcTable = function() {
  const tab = new Uint32Array(256);
  for (let n = 0; n < 256; n++) {
    let c = n;
    for (let k = 0; k < 8; k++) {
      if (c & 1)
        c = 3988292384 ^ c >>> 1;
      else
        c = c >>> 1;
    }
    tab[n] = c;
  }
  return tab;
}();
function _crc(c, buf, off, len) {
  for (let i = 0; i < len; i++) {
    c = CrcTable[(c ^ buf[off + i]) & 255] ^ c >>> 8;
  }
  return c;
}
function crc(b, o, l) {
  return _crc(4294967295, b, o, l) ^ 4294967295;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/zip/util.js
var hasCompressionStreamSupport = {
  deflate: void 0,
  "deflate-raw": void 0,
  gzip: void 0
};
function checkCompressionStreamSupport(format) {
  if (hasCompressionStreamSupport[format] === void 0) {
    try {
      new CompressionStream(format);
      hasCompressionStreamSupport[format] = true;
    } catch (e) {
      hasCompressionStreamSupport[format] = false;
    }
  }
  return !!hasCompressionStreamSupport[format];
}
var U = function() {
  const u16 = Uint16Array, u32 = Uint32Array;
  return {
    next_code: new u16(16),
    bl_count: new u16(16),
    ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
    of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],
    exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],
    ldef: new u16(32),
    df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],
    dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],
    ddef: new u32(32),
    flmap: new u16(512),
    fltree: [],
    fdmap: new u16(32),
    fdtree: [],
    lmap: new u16(32768),
    ltree: [],
    ttree: [],
    dmap: new u16(32768),
    dtree: [],
    imap: new u16(512),
    itree: [],
    // rev9 : new u16(  512)
    rev15: new u16(1 << 15),
    lhst: new u32(286),
    dhst: new u32(30),
    ihst: new u32(19),
    lits: new u32(15e3),
    strt: new u16(1 << 16),
    prev: new u16(1 << 15)
  };
}();
(function() {
  const len = 1 << 15;
  for (let i = 0; i < len; i++) {
    let x = i;
    x = (x & 2863311530) >>> 1 | (x & 1431655765) << 1;
    x = (x & 3435973836) >>> 2 | (x & 858993459) << 2;
    x = (x & 4042322160) >>> 4 | (x & 252645135) << 4;
    x = (x & 4278255360) >>> 8 | (x & 16711935) << 8;
    U.rev15[i] = (x >>> 16 | x << 16) >>> 17;
  }
  function pushV(tgt, n, sv) {
    while (n-- !== 0)
      tgt.push(0, sv);
  }
  for (let i = 0; i < 32; i++) {
    U.ldef[i] = U.of0[i] << 3 | U.exb[i];
    U.ddef[i] = U.df0[i] << 4 | U.dxb[i];
  }
  pushV(U.fltree, 144, 8);
  pushV(U.fltree, 255 - 143, 9);
  pushV(U.fltree, 279 - 255, 7);
  pushV(U.fltree, 287 - 279, 8);
  makeCodes(U.fltree, 9);
  codes2map(U.fltree, 9, U.flmap);
  revCodes(U.fltree, 9);
  pushV(U.fdtree, 32, 5);
  makeCodes(U.fdtree, 5);
  codes2map(U.fdtree, 5, U.fdmap);
  revCodes(U.fdtree, 5);
  pushV(U.itree, 19, 0);
  pushV(U.ltree, 286, 0);
  pushV(U.dtree, 30, 0);
  pushV(U.ttree, 320, 0);
})();
function codes2map(tree, MAX_BITS, map2) {
  const max_code = tree.length;
  const r15 = U.rev15;
  for (let i = 0; i < max_code; i += 2) {
    if (tree[i + 1] !== 0) {
      const lit = i >> 1;
      const cl = tree[i + 1], val = lit << 4 | cl;
      const rest = MAX_BITS - cl;
      let i0 = tree[i] << rest;
      const i1 = i0 + (1 << rest);
      while (i0 !== i1) {
        const p0 = r15[i0] >>> 15 - MAX_BITS;
        map2[p0] = val;
        i0++;
      }
    }
  }
}
function makeCodes(tree, MAX_BITS) {
  const max_code = tree.length;
  const bl_count = U.bl_count;
  for (let i = 0; i <= MAX_BITS; i++)
    bl_count[i] = 0;
  for (let i = 1; i < max_code; i += 2)
    bl_count[tree[i]]++;
  const next_code = U.next_code;
  let code = 0;
  bl_count[0] = 0;
  for (let bits = 1; bits <= MAX_BITS; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (let n = 0; n < max_code; n += 2) {
    const len = tree[n + 1];
    if (len !== 0) {
      tree[n] = next_code[len];
      next_code[len]++;
    }
  }
}
function revCodes(tree, MAX_BITS) {
  const r15 = U.rev15, imb = 15 - MAX_BITS;
  for (let i = 0; i < tree.length; i += 2) {
    const i0 = tree[i] << MAX_BITS - tree[i + 1];
    tree[i] = r15[i0] >>> imb;
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/zip/inflate.js
function InflateContext(data, buf) {
  const noBuf = buf === void 0;
  if (buf === void 0)
    buf = new Uint8Array(data.length >>> 2 << 3);
  return {
    data,
    buf,
    noBuf,
    BFINAL: 0,
    off: 0,
    pos: 0
  };
}
function inflateBlocks(ctx, count) {
  const { data, noBuf } = ctx;
  let { buf, BFINAL, off, pos } = ctx;
  let iBlock = 0;
  while (BFINAL === 0 && iBlock < count) {
    let lmap, dmap;
    let ML = 0, MD = 0;
    BFINAL = _bitsF(data, pos, 1);
    iBlock += 1;
    const BTYPE = _bitsF(data, pos + 1, 2);
    pos += 3;
    if (BTYPE === 0) {
      if ((pos & 7) !== 0)
        pos += 8 - (pos & 7);
      const p8 = (pos >>> 3) + 4;
      const len = data[p8 - 4] | data[p8 - 3] << 8;
      if (noBuf)
        buf = _check(buf, off + len);
      buf.set(new Uint8Array(data.buffer, data.byteOffset + p8, len), off);
      pos = p8 + len << 3;
      off += len;
      continue;
    }
    if (noBuf)
      buf = _check(buf, off + (1 << 17));
    if (BTYPE === 1) {
      lmap = U.flmap;
      dmap = U.fdmap;
      ML = (1 << 9) - 1;
      MD = (1 << 5) - 1;
    } else if (BTYPE === 2) {
      const HLIT = _bitsE(data, pos, 5) + 257;
      const HDIST = _bitsE(data, pos + 5, 5) + 1;
      const HCLEN = _bitsE(data, pos + 10, 4) + 4;
      pos += 14;
      for (let i = 0; i < 38; i += 2) {
        U.itree[i] = 0;
        U.itree[i + 1] = 0;
      }
      let tl = 1;
      for (let i = 0; i < HCLEN; i++) {
        const l = _bitsE(data, pos + i * 3, 3);
        U.itree[(U.ordr[i] << 1) + 1] = l;
        if (l > tl)
          tl = l;
      }
      pos += 3 * HCLEN;
      makeCodes(U.itree, tl);
      codes2map(U.itree, tl, U.imap);
      lmap = U.lmap;
      dmap = U.dmap;
      pos = _decodeTiny(U.imap, (1 << tl) - 1, HLIT + HDIST, data, pos, U.ttree);
      const mx0 = _copyOut(U.ttree, 0, HLIT, U.ltree);
      ML = (1 << mx0) - 1;
      const mx1 = _copyOut(U.ttree, HLIT, HDIST, U.dtree);
      MD = (1 << mx1) - 1;
      makeCodes(U.ltree, mx0);
      codes2map(U.ltree, mx0, lmap);
      makeCodes(U.dtree, mx1);
      codes2map(U.dtree, mx1, dmap);
    } else {
      throw new Error(`unknown BTYPE ${BTYPE}`);
    }
    while (true) {
      const code = lmap[_get17(data, pos) & ML];
      pos += code & 15;
      const lit = code >>> 4;
      if (lit >>> 8 === 0) {
        buf[off++] = lit;
      } else if (lit === 256) {
        break;
      } else {
        let end = off + lit - 254;
        if (lit > 264) {
          const ebs = U.ldef[lit - 257];
          end = off + (ebs >>> 3) + _bitsE(data, pos, ebs & 7);
          pos += ebs & 7;
        }
        const dcode = dmap[_get17(data, pos) & MD];
        pos += dcode & 15;
        const dlit = dcode >>> 4;
        const dbs = U.ddef[dlit];
        const dst = (dbs >>> 4) + _bitsF(data, pos, dbs & 15);
        pos += dbs & 15;
        if (noBuf)
          buf = _check(buf, off + (1 << 17));
        while (off < end) {
          buf[off] = buf[off++ - dst];
          buf[off] = buf[off++ - dst];
          buf[off] = buf[off++ - dst];
          buf[off] = buf[off++ - dst];
        }
        off = end;
      }
    }
  }
  ctx.buf = buf;
  ctx.BFINAL = BFINAL;
  ctx.off = off;
  ctx.pos = pos;
}
async function _inflate(runtime, data, buf) {
  if (data[0] === 3 && data[1] === 0)
    return buf ? buf : new Uint8Array(0);
  if (checkCompressionStreamSupport("deflate-raw")) {
    const ds = new DecompressionStream("deflate-raw");
    const blob = new Blob([data]);
    const decompressedStream = blob.stream().pipeThrough(ds);
    let offset = 0;
    const chunks = [];
    const reader = decompressedStream.getReader();
    const readChunk = async () => {
      const { done, value } = await reader.read();
      if (done)
        return;
      if (runtime.shouldUpdate) {
        await runtime.update({ message: "Inflating blocks...", current: offset, max: buf === null || buf === void 0 ? void 0 : buf.length });
      }
      if (buf) {
        buf.set(value, offset);
      } else {
        chunks.push(value);
      }
      offset += value.length;
      return readChunk();
    };
    await readChunk();
    if (!buf) {
      buf = new Uint8Array(offset);
      for (let i = 0, j = 0; i < chunks.length; i++) {
        buf.set(chunks[i], j);
        j += chunks[i].length;
      }
    }
    return buf;
  }
  const ctx = InflateContext(data, buf);
  while (ctx.BFINAL === 0) {
    if (runtime.shouldUpdate) {
      await runtime.update({ message: "Inflating blocks...", current: ctx.pos, max: data.length });
    }
    inflateBlocks(ctx, 100);
  }
  return ctx.buf.length === ctx.off ? ctx.buf : ctx.buf.slice(0, ctx.off);
}
function _check(buf, len) {
  const bl = buf.length;
  if (len <= bl)
    return buf;
  const nbuf = new Uint8Array(Math.max(bl << 1, len));
  nbuf.set(buf, 0);
  return nbuf;
}
function _decodeTiny(lmap, LL, len, data, pos, tree) {
  let i = 0;
  while (i < len) {
    const code = lmap[_get17(data, pos) & LL];
    pos += code & 15;
    const lit = code >>> 4;
    if (lit <= 15) {
      tree[i] = lit;
      i++;
    } else {
      let ll = 0, n = 0;
      if (lit === 16) {
        n = 3 + _bitsE(data, pos, 2);
        pos += 2;
        ll = tree[i - 1];
      } else if (lit === 17) {
        n = 3 + _bitsE(data, pos, 3);
        pos += 3;
      } else if (lit === 18) {
        n = 11 + _bitsE(data, pos, 7);
        pos += 7;
      }
      const ni = i + n;
      while (i < ni) {
        tree[i] = ll;
        i++;
      }
    }
  }
  return pos;
}
function _copyOut(src, off, len, tree) {
  let mx = 0, i = 0;
  const tl = tree.length >>> 1;
  while (i < len) {
    const v = src[i + off];
    tree[i << 1] = 0;
    tree[(i << 1) + 1] = v;
    if (v > mx)
      mx = v;
    i++;
  }
  while (i < tl) {
    tree[i << 1] = 0;
    tree[(i << 1) + 1] = 0;
    i++;
  }
  return mx;
}
function _bitsE(dt, pos, length) {
  return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8) >>> (pos & 7) & (1 << length) - 1;
}
function _bitsF(dt, pos, length) {
  return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (pos & 7) & (1 << length) - 1;
}
function _get17(dt, pos) {
  return (dt[pos >>> 3] | dt[(pos >>> 3) + 1] << 8 | dt[(pos >>> 3) + 2] << 16) >>> (pos & 7);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/zip/huffman.js
function _hufTree(hst, tree, MAXL) {
  const list2 = [];
  const hl = hst.length, tl = tree.length;
  for (let i = 0; i < tl; i += 2) {
    tree[i] = 0;
    tree[i + 1] = 0;
  }
  for (let i = 0; i < hl; i++)
    if (hst[i] !== 0)
      list2.push({ lit: i, f: hst[i], d: void 0 });
  const end = list2.length, l2 = list2.slice(0);
  if (end === 0)
    return 0;
  if (end === 1) {
    const lit = list2[0].lit, l22 = lit === 0 ? 1 : 0;
    tree[(lit << 1) + 1] = 1;
    tree[(l22 << 1) + 1] = 1;
    return 1;
  }
  list2.sort(function(a2, b2) {
    return a2.f - b2.f;
  });
  let a = list2[0], b = list2[1], i0 = 0, i1 = 1, i2 = 2;
  list2[0] = {
    lit: -1,
    f: a.f + b.f,
    l: a,
    r: b,
    d: 0
  };
  while (i1 !== end - 1) {
    if (i0 !== i1 && (i2 === end || list2[i0].f < list2[i2].f)) {
      a = list2[i0++];
    } else {
      a = list2[i2++];
    }
    if (i0 !== i1 && (i2 === end || list2[i0].f < list2[i2].f)) {
      b = list2[i0++];
    } else {
      b = list2[i2++];
    }
    list2[i1++] = {
      lit: -1,
      f: a.f + b.f,
      l: a,
      r: b,
      d: void 0
    };
  }
  let maxl = setDepth(list2[i1 - 1], 0);
  if (maxl > MAXL) {
    restrictDepth(l2, MAXL, maxl);
    maxl = MAXL;
  }
  for (let i = 0; i < end; i++)
    tree[(l2[i].lit << 1) + 1] = l2[i].d;
  return maxl;
}
function setDepth(t, d) {
  if (t.lit !== -1) {
    t.d = d;
    return d;
  }
  return Math.max(setDepth(t.l, d + 1), setDepth(t.r, d + 1));
}
function restrictDepth(dps, MD, maxl) {
  let i = 0, dbt = 0;
  const bCost = 1 << maxl - MD;
  dps.sort(function(a, b) {
    return b.d === a.d ? a.f - b.f : b.d - a.d;
  });
  for (i = 0; i < dps.length; i++) {
    if (dps[i].d > MD) {
      const od = dps[i].d;
      dps[i].d = MD;
      dbt += bCost - (1 << maxl - od);
    } else {
      break;
    }
  }
  dbt = dbt >>> maxl - MD;
  while (dbt > 0) {
    const od = dps[i].d;
    if (od < MD) {
      dps[i].d++;
      dbt -= 1 << MD - od - 1;
    } else {
      i++;
    }
  }
  for (; i >= 0; i--) {
    if (dps[i].d === MD && dbt < 0) {
      dps[i].d--;
      dbt++;
    }
  }
  if (dbt !== 0)
    console.log("debt left");
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/zip/deflate.js
function DeflateContext(data, out, opos, lvl) {
  const { lits, strt, prev } = U;
  return {
    data,
    out,
    opt: Opts[lvl],
    i: 0,
    pos: opos << 3,
    cvrd: 0,
    dlen: data.length,
    li: 0,
    lc: 0,
    bs: 0,
    ebits: 0,
    c: 0,
    nc: 0,
    lits,
    strt,
    prev
  };
}
function deflateChunk(ctx, count) {
  const { data, dlen, out, opt } = ctx;
  let { i, pos, cvrd, li, lc, bs, ebits, c, nc } = ctx;
  const { lits, strt, prev } = U;
  const end = Math.min(i + count, dlen);
  for (; i < end; i++) {
    c = nc;
    if (i + 1 < dlen - 2) {
      nc = _hash(data, i + 1);
      const ii = i + 1 & 32767;
      prev[ii] = strt[nc];
      strt[nc] = ii;
    }
    if (cvrd <= i) {
      if ((li > 14e3 || lc > 26697) && dlen - i > 100) {
        if (cvrd < i) {
          lits[li] = i - cvrd;
          li += 2;
          cvrd = i;
        }
        pos = _writeBlock(i === dlen - 1 || cvrd === dlen ? 1 : 0, lits, li, ebits, data, bs, i - bs, out, pos);
        li = lc = ebits = 0;
        bs = i;
      }
      let mch = 0;
      if (i < dlen - 2) {
        mch = _bestMatch(data, i, prev, c, Math.min(opt[2], dlen - i), opt[3]);
      }
      if (mch !== 0) {
        const len = mch >>> 16, dst = mch & 65535;
        const lgi = _goodIndex(len, U.of0);
        U.lhst[257 + lgi]++;
        const dgi = _goodIndex(dst, U.df0);
        U.dhst[dgi]++;
        ebits += U.exb[lgi] + U.dxb[dgi];
        lits[li] = len << 23 | i - cvrd;
        lits[li + 1] = dst << 16 | lgi << 8 | dgi;
        li += 2;
        cvrd = i + len;
      } else {
        U.lhst[data[i]]++;
      }
      lc++;
    }
  }
  ctx.i = i;
  ctx.pos = pos;
  ctx.cvrd = cvrd;
  ctx.li = li;
  ctx.lc = lc;
  ctx.bs = bs;
  ctx.ebits = ebits;
  ctx.c = c;
  ctx.nc = nc;
}
var Opts = [
  /*      good lazy nice chain */
  /* 0 */
  [0, 0, 0, 0, 0],
  /* store only */
  /* 1 */
  [4, 4, 8, 4, 0],
  /* max speed, no lazy matches */
  /* 2 */
  [4, 5, 16, 8, 0],
  /* 3 */
  [4, 6, 16, 16, 0],
  /* 4 */
  [4, 10, 16, 32, 0],
  /* lazy matches */
  /* 5 */
  [8, 16, 32, 32, 0],
  /* 6 */
  [8, 16, 128, 128, 0],
  /* 7 */
  [8, 32, 128, 256, 0],
  /* 8 */
  [32, 128, 258, 1024, 1],
  /* 9 */
  [32, 258, 258, 4096, 1]
  /* max compression */
];
async function _deflateRaw(runtime, data, out, opos, lvl) {
  if (checkCompressionStreamSupport("deflate-raw")) {
    const cs = new CompressionStream("deflate-raw");
    const blob = new Blob([data]);
    const compressedStream = blob.stream().pipeThrough(cs);
    const reader = compressedStream.getReader();
    let offset = opos;
    const writeChunk = async () => {
      const { done, value } = await reader.read();
      if (done)
        return;
      if (runtime.shouldUpdate) {
        await runtime.update({ message: "Deflating...", current: offset, max: out.length });
      }
      out.set(value, offset);
      offset += value.length;
      return writeChunk();
    };
    await writeChunk();
    return offset;
  }
  const ctx = DeflateContext(data, out, opos, lvl);
  const { dlen } = ctx;
  if (lvl === 0) {
    let { i: i2, pos: pos2 } = ctx;
    while (i2 < dlen) {
      const len = Math.min(65535, dlen - i2);
      _putsE(out, pos2, i2 + len === dlen ? 1 : 0);
      pos2 = _copyExact(data, i2, len, out, pos2 + 8);
      i2 += len;
    }
    return pos2 >>> 3;
  }
  if (dlen > 2) {
    ctx.nc = _hash(data, 0);
    ctx.strt[ctx.nc] = 0;
  }
  while (ctx.i < dlen) {
    if (runtime.shouldUpdate) {
      await runtime.update({ message: "Deflating...", current: ctx.i, max: dlen });
    }
    deflateChunk(ctx, 1024 * 1024);
  }
  let { li, cvrd, pos } = ctx;
  const { i, lits, bs, ebits } = ctx;
  if (bs !== i || data.length === 0) {
    if (cvrd < i) {
      lits[li] = i - cvrd;
      li += 2;
      cvrd = i;
    }
    pos = _writeBlock(1, lits, li, ebits, data, bs, i - bs, out, pos);
  }
  while ((pos & 7) !== 0)
    pos++;
  return pos >>> 3;
}
function _bestMatch(data, i, prev, c, nice, chain2) {
  let ci = i & 32767, pi = prev[ci];
  let dif = ci - pi + (1 << 15) & 32767;
  if (pi === ci || c !== _hash(data, i - dif))
    return 0;
  let tl = 0, td = 0;
  const dlim = Math.min(32767, i);
  while (dif <= dlim && --chain2 !== 0 && pi !== ci) {
    if (tl === 0 || data[i + tl] === data[i + tl - dif]) {
      let cl = _howLong(data, i, dif);
      if (cl > tl) {
        tl = cl;
        td = dif;
        if (tl >= nice)
          break;
        if (dif + 2 < cl)
          cl = dif + 2;
        let maxd = 0;
        for (let j = 0; j < cl - 2; j++) {
          const ei = i - dif + j + (1 << 15) & 32767;
          const li = prev[ei];
          const curd = ei - li + (1 << 15) & 32767;
          if (curd > maxd) {
            maxd = curd;
            pi = ei;
          }
        }
      }
    }
    ci = pi;
    pi = prev[ci];
    dif += ci - pi + (1 << 15) & 32767;
  }
  return tl << 16 | td;
}
function _howLong(data, i, dif) {
  if (data[i] !== data[i - dif] || data[i + 1] !== data[i + 1 - dif] || data[i + 2] !== data[i + 2 - dif])
    return 0;
  const oi = i, l = Math.min(data.length, i + 258);
  i += 3;
  while (i < l && data[i] === data[i - dif])
    i++;
  return i - oi;
}
function _hash(data, i) {
  return (data[i] << 8 | data[i + 1]) + (data[i + 2] << 4) & 65535;
}
function _writeBlock(BFINAL, lits, li, ebits, data, o0, l0, out, pos) {
  U.lhst[256]++;
  const [ML, MD, MH, numl, numd, numh, lset, dset] = getTrees();
  const cstSize = ((pos + 3 & 7) === 0 ? 0 : 8 - (pos + 3 & 7)) + 32 + (l0 << 3);
  const fxdSize = ebits + contSize(U.fltree, U.lhst) + contSize(U.fdtree, U.dhst);
  let dynSize = ebits + contSize(U.ltree, U.lhst) + contSize(U.dtree, U.dhst);
  dynSize += 14 + 3 * numh + contSize(U.itree, U.ihst) + (U.ihst[16] * 2 + U.ihst[17] * 3 + U.ihst[18] * 7);
  for (let j = 0; j < 286; j++)
    U.lhst[j] = 0;
  for (let j = 0; j < 30; j++)
    U.dhst[j] = 0;
  for (let j = 0; j < 19; j++)
    U.ihst[j] = 0;
  const BTYPE = cstSize < fxdSize && cstSize < dynSize ? 0 : fxdSize < dynSize ? 1 : 2;
  _putsF(out, pos, BFINAL);
  _putsF(out, pos + 1, BTYPE);
  pos += 3;
  if (BTYPE === 0) {
    while ((pos & 7) !== 0)
      pos++;
    pos = _copyExact(data, o0, l0, out, pos);
  } else {
    let ltree, dtree;
    if (BTYPE === 1) {
      ltree = U.fltree;
      dtree = U.fdtree;
    } else if (BTYPE === 2) {
      makeCodes(U.ltree, ML);
      revCodes(U.ltree, ML);
      makeCodes(U.dtree, MD);
      revCodes(U.dtree, MD);
      makeCodes(U.itree, MH);
      revCodes(U.itree, MH);
      ltree = U.ltree;
      dtree = U.dtree;
      _putsE(out, pos, numl - 257);
      pos += 5;
      _putsE(out, pos, numd - 1);
      pos += 5;
      _putsE(out, pos, numh - 4);
      pos += 4;
      for (let i = 0; i < numh; i++)
        _putsE(out, pos + i * 3, U.itree[(U.ordr[i] << 1) + 1]);
      pos += 3 * numh;
      pos = _codeTiny(lset, U.itree, out, pos);
      pos = _codeTiny(dset, U.itree, out, pos);
    } else {
      assertUnreachable(BTYPE);
    }
    let off = o0;
    for (let si = 0; si < li; si += 2) {
      const qb = lits[si], len = qb >>> 23, end = off + (qb & (1 << 23) - 1);
      while (off < end)
        pos = _writeLit(data[off++], ltree, out, pos);
      if (len !== 0) {
        const qc = lits[si + 1], dst = qc >> 16, lgi = qc >> 8 & 255, dgi = qc & 255;
        pos = _writeLit(257 + lgi, ltree, out, pos);
        _putsE(out, pos, len - U.of0[lgi]);
        pos += U.exb[lgi];
        pos = _writeLit(dgi, dtree, out, pos);
        _putsF(out, pos, dst - U.df0[dgi]);
        pos += U.dxb[dgi];
        off += len;
      }
    }
    pos = _writeLit(256, ltree, out, pos);
  }
  return pos;
}
function _copyExact(data, off, len, out, pos) {
  let p8 = pos >>> 3;
  out[p8] = len;
  out[p8 + 1] = len >>> 8;
  out[p8 + 2] = 255 - out[p8];
  out[p8 + 3] = 255 - out[p8 + 1];
  p8 += 4;
  out.set(new Uint8Array(data.buffer, off, len), p8);
  return pos + (len + 4 << 3);
}
function getTrees() {
  const ML = _hufTree(U.lhst, U.ltree, 15);
  const MD = _hufTree(U.dhst, U.dtree, 15);
  const lset = [];
  const numl = _lenCodes(U.ltree, lset);
  const dset = [];
  const numd = _lenCodes(U.dtree, dset);
  for (let i = 0; i < lset.length; i += 2)
    U.ihst[lset[i]]++;
  for (let i = 0; i < dset.length; i += 2)
    U.ihst[dset[i]]++;
  const MH = _hufTree(U.ihst, U.itree, 7);
  let numh = 19;
  while (numh > 4 && U.itree[(U.ordr[numh - 1] << 1) + 1] === 0)
    numh--;
  return [ML, MD, MH, numl, numd, numh, lset, dset];
}
function contSize(tree, hst) {
  let s = 0;
  for (let i = 0; i < hst.length; i++)
    s += hst[i] * tree[(i << 1) + 1];
  return s;
}
function _codeTiny(set2, tree, out, pos) {
  for (let i = 0; i < set2.length; i += 2) {
    const l = set2[i], rst = set2[i + 1];
    pos = _writeLit(l, tree, out, pos);
    const rsl = l === 16 ? 2 : l === 17 ? 3 : 7;
    if (l > 15) {
      _putsE(out, pos, rst);
      pos += rsl;
    }
  }
  return pos;
}
function _lenCodes(tree, set2) {
  let len = tree.length;
  while (len !== 2 && tree[len - 1] === 0)
    len -= 2;
  for (let i = 0; i < len; i += 2) {
    const l = tree[i + 1], nxt = i + 3 < len ? tree[i + 3] : -1, nnxt = i + 5 < len ? tree[i + 5] : -1, prv = i === 0 ? -1 : tree[i - 1];
    if (l === 0 && nxt === l && nnxt === l) {
      let lz = i + 5;
      while (lz + 2 < len && tree[lz + 2] === l)
        lz += 2;
      const zc = Math.min(lz + 1 - i >>> 1, 138);
      if (zc < 11)
        set2.push(17, zc - 3);
      else
        set2.push(18, zc - 11);
      i += zc * 2 - 2;
    } else if (l === prv && nxt === l && nnxt === l) {
      let lz = i + 5;
      while (lz + 2 < len && tree[lz + 2] === l)
        lz += 2;
      const zc = Math.min(lz + 1 - i >>> 1, 6);
      set2.push(16, zc - 3);
      i += zc * 2 - 2;
    } else {
      set2.push(l, 0);
    }
  }
  return len >>> 1;
}
function _goodIndex(v, arr) {
  let i = 0;
  if (arr[i | 16] <= v)
    i |= 16;
  if (arr[i | 8] <= v)
    i |= 8;
  if (arr[i | 4] <= v)
    i |= 4;
  if (arr[i | 2] <= v)
    i |= 2;
  if (arr[i | 1] <= v)
    i |= 1;
  return i;
}
function _writeLit(ch, ltree, out, pos) {
  _putsF(out, pos, ltree[ch << 1]);
  return pos + ltree[(ch << 1) + 1];
}
function _putsE(dt, pos, val) {
  val = val << (pos & 7);
  const o = pos >>> 3;
  dt[o] |= val;
  dt[o + 1] |= val >>> 8;
}
function _putsF(dt, pos, val) {
  val = val << (pos & 7);
  const o = pos >>> 3;
  dt[o] |= val;
  dt[o + 1] |= val >>> 8;
  dt[o + 2] |= val >>> 16;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/zip/zip.js
async function unzip(runtime, buf, onlyNames = false) {
  const out = /* @__PURE__ */ Object.create(null);
  const data = new Uint8Array(buf);
  if (readUshort(data, 0) !== 19280) {
    throw new Error('Invalid ZIP file. A valid ZIP file must start with two magic bytes \\x50\\x4b ("PK" in ASCII).');
  }
  let eocd = data.length - 4;
  while (readUint(data, eocd) !== 101010256)
    eocd--;
  let o = eocd;
  o += 4;
  o += 4;
  const cnu = readUshort(data, o);
  o += 2;
  o += 2;
  o += 4;
  const coffs = readUint(data, o);
  o += 4;
  o = coffs;
  for (let i = 0; i < cnu; i++) {
    o += 4;
    o += 4;
    o += 4;
    o += 4;
    o += 4;
    o += 4;
    o += 4;
    const nl = readUshort(data, o);
    const el = readUshort(data, o + 2);
    const cl = readUshort(data, o + 4);
    o += 6;
    o += 8;
    const roff = readUint(data, o);
    o += 4;
    o += nl + el + cl;
    await _readLocal(runtime, data, roff, out, onlyNames);
  }
  return out;
}
async function _readLocal(runtime, data, o, out, onlyNames) {
  o += 4;
  o += 2;
  o += 2;
  const cmpr = readUshort(data, o);
  o += 2;
  o += 4;
  o += 4;
  const csize = readUint(data, o);
  o += 4;
  const usize = readUint(data, o);
  o += 4;
  const nlen = readUshort(data, o);
  o += 2;
  const elen = readUshort(data, o);
  o += 2;
  const name = readUTF8(data, o, nlen);
  o += nlen;
  o += elen;
  if (onlyNames) {
    out[name] = { size: usize, csize };
    return;
  }
  const file = new Uint8Array(data.buffer, o, csize);
  if (cmpr === 0) {
    out[name] = file;
  } else if (cmpr === 8) {
    const buf = new Uint8Array(usize);
    await inflateRaw(runtime, file, buf);
    out[name] = buf;
  } else {
    throw new Error(`unknown compression method: ${cmpr}`);
  }
}
async function inflateRaw(runtime, file, buf) {
  return _inflate(runtime, file, buf);
}
async function ungzip(runtime, file, buf) {
  const flg = file[3];
  let o = 10;
  if (flg & 4) {
    const xlen = readUshort(file, o);
    o += xlen;
  }
  if (flg & 8) {
    let zero = o;
    while (file[zero] !== 0)
      ++zero;
    o = zero + 1;
  }
  if (flg & 16) {
    let zero = o;
    while (file[zero] !== 0)
      ++zero;
    o = zero + 1;
  }
  if (flg & 1) {
    o += 2;
  }
  const crc32 = toInt32(readUint(file, file.length - 8));
  const isize = readUint(file, file.length - 4);
  if (buf === void 0)
    buf = new Uint8Array(isize);
  const blocks = new Uint8Array(file.buffer, file.byteOffset + o, file.length - o - 8);
  const inflated = await inflateRaw(runtime, blocks, buf);
  const crcValue = crc(inflated, 0, inflated.length);
  if (crc32 !== crcValue) {
    console.error("ungzip: checksums don't match");
  }
  return inflated;
}
async function deflateRaw(runtime, data, opts) {
  if (opts === void 0)
    opts = { level: 6 };
  const buf = new Uint8Array(50 + Math.floor(data.length * 1.1));
  const off = await _deflateRaw(runtime, data, buf, 0, opts.level);
  return new Uint8Array(buf.buffer, 0, off);
}
function Zip(obj, noCmpr = false) {
  return Task.create("Zip", (ctx) => zip(ctx, obj, noCmpr));
}
async function zip(runtime, obj, noCmpr = false) {
  let tot = 0;
  const zpd = {};
  for (const p3 in obj) {
    const cpr = !_noNeed(p3) && !noCmpr, buf = obj[p3];
    const crcValue = crc(buf, 0, buf.length);
    zpd[p3] = {
      cpr,
      usize: buf.length,
      crc: crcValue,
      file: cpr ? await deflateRaw(runtime, buf) : buf
    };
  }
  for (const p3 in zpd)
    tot += zpd[p3].file.length + 30 + 46 + 2 * sizeUTF8(p3);
  tot += 22;
  const data = new Uint8Array(tot);
  let o = 0;
  const fof = [];
  for (const p3 in zpd) {
    const file = zpd[p3];
    fof.push(o);
    o = _writeHeader(data, o, p3, file, 0);
  }
  let i = 0;
  const ioff = o;
  for (const p3 in zpd) {
    const file = zpd[p3];
    fof.push(o);
    o = _writeHeader(data, o, p3, file, 1, fof[i++]);
  }
  const csize = o - ioff;
  writeUint(data, o, 101010256);
  o += 4;
  o += 4;
  writeUshort(data, o, i);
  o += 2;
  writeUshort(data, o, i);
  o += 2;
  writeUint(data, o, csize);
  o += 4;
  writeUint(data, o, ioff);
  o += 4;
  o += 2;
  return data.buffer;
}
function _noNeed(fn) {
  const ext = fn.split(".").pop().toLowerCase();
  return "png,jpg,jpeg,zip".indexOf(ext) !== -1;
}
function _writeHeader(data, o, p3, obj, t, roff = 0) {
  const file = obj.file;
  writeUint(data, o, t === 0 ? 67324752 : 33639248);
  o += 4;
  if (t === 1)
    o += 2;
  writeUshort(data, o, 20);
  o += 2;
  writeUshort(data, o, 0);
  o += 2;
  writeUshort(data, o, obj.cpr ? 8 : 0);
  o += 2;
  writeUint(data, o, 0);
  o += 4;
  writeUint(data, o, obj.crc);
  o += 4;
  writeUint(data, o, file.length);
  o += 4;
  writeUint(data, o, obj.usize);
  o += 4;
  writeUshort(data, o, sizeUTF8(p3));
  o += 2;
  writeUshort(data, o, 0);
  o += 2;
  if (t === 1) {
    o += 2;
    o += 2;
    o += 6;
    writeUint(data, o, roff);
    o += 4;
  }
  const nlen = writeUTF8(data, o, p3);
  o += nlen;
  if (t === 0) {
    data.set(file, o);
    o += file.length;
  }
  return o;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/data-source.js
var DataCompressionMethod;
(function(DataCompressionMethod2) {
  DataCompressionMethod2[DataCompressionMethod2["None"] = 0] = "None";
  DataCompressionMethod2[DataCompressionMethod2["Gzip"] = 1] = "Gzip";
  DataCompressionMethod2[DataCompressionMethod2["Zip"] = 2] = "Zip";
})(DataCompressionMethod || (DataCompressionMethod = {}));
function readFromFile(file, type3) {
  return readFromFileInternal(file, type3);
}
function ajaxGet(params) {
  if (typeof params === "string")
    return ajaxGetInternal(params, params, "string");
  return ajaxGetInternal(params.title, params.url, params.type || "string", params.body, params.headers);
}
function isDone(data) {
  if (RUNNING_IN_NODEJS)
    throw new Error("`isDone` should not be used when running in Node.js");
  if (data instanceof FileReader) {
    return data.readyState === FileReader.DONE;
  } else if (data instanceof XMLHttpRequest) {
    return data.readyState === XMLHttpRequest.DONE;
  }
  throw new Error("unknown data type");
}
function genericError(isDownload) {
  if (isDownload)
    return "Failed to download data. Possible reasons: Resource is not available, or CORS is not allowed on the server.";
  return "Failed to open file.";
}
function readData(ctx, action, data) {
  if (RUNNING_IN_NODEJS)
    throw new Error("`readData` should not be used when running in Node.js");
  return new Promise((resolve, reject) => {
    if (isDone(data)) {
      const { error: error2 } = data;
      if (error2 !== null && error2 !== void 0) {
        reject(error2 !== null && error2 !== void 0 ? error2 : genericError(data instanceof XMLHttpRequest));
      } else {
        resolve(data);
      }
      return;
    }
    let hasError = false;
    data.onerror = (e) => {
      if (hasError)
        return;
      const { error: error2 } = e.target;
      reject(error2 !== null && error2 !== void 0 ? error2 : genericError(data instanceof XMLHttpRequest));
    };
    data.onprogress = (e) => {
      if (!ctx.shouldUpdate || hasError)
        return;
      try {
        if (e.lengthComputable) {
          ctx.update({ message: action, isIndeterminate: false, current: e.loaded, max: e.total });
        } else {
          ctx.update({ message: `${action} ${(e.loaded / 1024 / 1024).toFixed(2)} MB`, isIndeterminate: true });
        }
      } catch (e2) {
        hasError = true;
        reject(e2);
      }
    };
    data.onload = (e) => {
      resolve(data);
    };
  });
}
function getCompression(name) {
  return /\.gz$/i.test(name) ? DataCompressionMethod.Gzip : /\.zip$/i.test(name) ? DataCompressionMethod.Zip : DataCompressionMethod.None;
}
var reFilterPath = /^(__MACOSX|.DS_Store)/;
async function decompress(ctx, data, compression) {
  switch (compression) {
    case DataCompressionMethod.None:
      return data;
    case DataCompressionMethod.Gzip:
      return ungzip(ctx, data);
    case DataCompressionMethod.Zip:
      const parsed = await unzip(ctx, data.buffer);
      const names = Object.keys(parsed).filter((n) => !reFilterPath.test(n));
      if (names.length !== 1)
        throw new Error("can only decompress zip files with a single entry");
      return parsed[names[0]];
  }
}
async function processFile(ctx, fileContent, type3, compression) {
  if (fileContent === null)
    throw new Error("no data given");
  let data = new Uint8Array(fileContent);
  if (compression !== DataCompressionMethod.None && type3 !== "zip") {
    data = await decompress(ctx, data, compression);
  }
  if (type3 === "binary") {
    return data;
  } else if (type3 === "zip") {
    return await unzip(ctx, data.buffer);
  } else if (type3 === "string") {
    return utf8ReadLong(data);
  } else if (type3 === "xml") {
    const parser = new DOMParser();
    return parser.parseFromString(utf8Read(data), "application/xml");
  } else if (type3 === "json") {
    return JSON.parse(utf8Read(data));
  }
  throw new Error(`could not get requested response data '${type3}'`);
}
function readFromFileInternal(file, type3) {
  if (RUNNING_IN_NODEJS) {
    return readFromFileInternal_NodeJS(file, type3);
  }
  let reader = void 0;
  return Task.create("Read File", async (ctx) => {
    try {
      await ctx.update({ message: "Opening file...", canAbort: true });
      reader = new FileReader();
      reader.readAsArrayBuffer(file);
      const fileReader = await readData(ctx, "Reading...", reader);
      const fileContent = fileReader.result;
      await ctx.update({ message: "Processing file...", canAbort: false });
      return await processFile(ctx, fileContent, type3, getCompression(file.name));
    } finally {
      reader = void 0;
    }
  }, () => {
    if (reader)
      reader.abort();
  });
}
function readFromFileInternal_NodeJS(file, type3) {
  return Task.create("Read File", async (ctx) => {
    await ctx.update({ message: "Opening file...", canAbort: false });
    const fileContent = await file.arrayBuffer();
    await ctx.update({ message: "Processing file...", canAbort: false });
    return await processFile(ctx, fileContent, type3, getCompression(file.name));
  });
}
var RequestPool = class _RequestPool {
  static get() {
    if (RUNNING_IN_NODEJS)
      throw new Error("`RequestPool.get` should not be used when running in Node.js");
    if (this.pool.length) {
      return this.pool.pop();
    }
    return new XMLHttpRequest();
  }
  static emptyFunc() {
  }
  static deposit(req) {
    if (this.pool.length < this.poolSize) {
      req.onabort = _RequestPool.emptyFunc;
      req.onerror = _RequestPool.emptyFunc;
      req.onload = _RequestPool.emptyFunc;
      req.onprogress = _RequestPool.emptyFunc;
      this.pool.push(req);
    }
  }
};
RequestPool.pool = [];
RequestPool.poolSize = 15;
function processAjax(req, type3) {
  if (req.status >= 200 && req.status < 400) {
    const { response } = req;
    RequestPool.deposit(req);
    if ((type3 === "binary" || type3 === "zip") && response instanceof ArrayBuffer) {
      return new Uint8Array(response);
    } else if (type3 === "string" && typeof response === "string") {
      return response;
    } else if (type3 === "xml" && response instanceof XMLDocument) {
      return response;
    } else if (type3 === "json" && typeof response === "object") {
      return response;
    }
    throw new Error(`could not get requested response data '${type3}'`);
  } else {
    RequestPool.deposit(req);
    throw new Error(`Download failed with status code ${req.status}`);
  }
}
function getRequestResponseType(type3) {
  switch (type3) {
    case "json":
      return "json";
    case "xml":
      return "document";
    case "string":
      return "text";
    case "binary":
      return "arraybuffer";
    case "zip":
      return "arraybuffer";
  }
}
function ajaxGetInternal(title, url, type3, body, headers) {
  if (RUNNING_IN_NODEJS) {
    if (url.startsWith("file://")) {
      return ajaxGetInternal_file_NodeJS(title, url, type3, body, headers);
    } else {
      return ajaxGetInternal_http_NodeJS(title, url, type3, body, headers);
    }
  }
  let xhttp = void 0;
  return Task.create(title ? title : "Download", async (ctx) => {
    xhttp = RequestPool.get();
    xhttp.open(body ? "post" : "get", url, true);
    if (headers) {
      for (const [name, value] of headers) {
        xhttp.setRequestHeader(name, value);
      }
    }
    xhttp.responseType = getRequestResponseType(type3);
    xhttp.send(body);
    await ctx.update({ message: "Waiting for server...", canAbort: true });
    const req = await readData(ctx, "Downloading...", xhttp);
    xhttp = void 0;
    await ctx.update({ message: "Parsing response...", canAbort: false });
    const result2 = processAjax(req, type3);
    return result2;
  }, () => {
    if (xhttp) {
      xhttp.abort();
      xhttp = void 0;
    }
  });
}
var _fs = void 0;
function getFS() {
  if (!_fs) {
    throw new Error("When running in Node.js and reading from files, call mol-util/data-source's setFSModule function first.");
  }
  return _fs;
}
function readFileAsync(filename) {
  return new Promise((resolve, reject) => {
    getFS().readFile(filename, (err, data) => {
      if (err)
        reject(err);
      else
        resolve(data);
    });
  });
}
function ajaxGetInternal_file_NodeJS(title, url, type3, body, headers) {
  if (!RUNNING_IN_NODEJS)
    throw new Error("This function should only be used when running in Node.js");
  if (!url.startsWith("file://"))
    throw new Error("This function is only for URLs with protocol file://");
  return Task.create(title !== null && title !== void 0 ? title : "Download", async (ctx) => {
    const filename = url.substring("file://".length);
    await ctx.update({ message: "Loading file...", canAbort: false });
    const data = await readFileAsync(filename);
    await ctx.update({ message: "Parsing response...", canAbort: false });
    const result2 = await processFile(ctx, data, type3, DataCompressionMethod.None);
    return result2;
  });
}
function ajaxGetInternal_http_NodeJS(title, url, type3, body, headers) {
  if (!RUNNING_IN_NODEJS)
    throw new Error("This function should only be used when running in Node.js");
  const aborter = new AbortController();
  return Task.create(title !== null && title !== void 0 ? title : "Download", async (ctx) => {
    await ctx.update({ message: "Downloading...", canAbort: true });
    const response = await fetch(url, { signal: aborter.signal });
    if (!(response.status >= 200 && response.status < 400)) {
      throw new Error(`Download failed with status code ${response.status}`);
    }
    const fileContent = await response.bytes();
    await ctx.update({ message: "Parsing response...", canAbort: false });
    const result2 = await processFile(ctx, fileContent, type3, DataCompressionMethod.None);
    return result2;
  }, () => {
    aborter.abort();
  });
}
async function ajaxGetMany(ctx, assetManager, sources, maxConcurrency) {
  const len = sources.length;
  const slots = new Array(sources.length);
  await ctx.update({ message: "Downloading...", current: 0, max: len });
  let promises = [], promiseKeys = [];
  let currentSrc = 0;
  for (let _i = Math.min(len, maxConcurrency); currentSrc < _i; currentSrc++) {
    const current = sources[currentSrc];
    promises.push(wrapPromise(currentSrc, current.id, assetManager.resolve(Asset.getUrlAsset(assetManager, current.url), current.isBinary ? "binary" : "string").runAsChild(ctx)));
    promiseKeys.push(currentSrc);
  }
  let done = 0;
  while (promises.length > 0) {
    const r = await Promise.race(promises);
    const src = sources[r.index];
    const idx = promiseKeys.indexOf(r.index);
    done++;
    if (r.kind === "error" && !src.canFail) {
      throw new Error(`${src.url}: ${r.error}`);
    }
    if (ctx.shouldUpdate) {
      await ctx.update({ message: "Downloading...", current: done, max: len });
    }
    slots[r.index] = r;
    promises = promises.filter(_filterRemoveIndex, idx);
    promiseKeys = promiseKeys.filter(_filterRemoveIndex, idx);
    if (currentSrc < len) {
      const current = sources[currentSrc];
      const asset = assetManager.resolve(Asset.getUrlAsset(assetManager, current.url), current.isBinary ? "binary" : "string").runAsChild(ctx);
      promises.push(wrapPromise(currentSrc, current.id, asset));
      promiseKeys.push(currentSrc);
      currentSrc++;
    }
  }
  return slots;
}
function _filterRemoveIndex(_, i) {
  return this !== i;
}
async function wrapPromise(index, id, p3) {
  try {
    const result2 = await p3;
    return { kind: "ok", result: result2, index, id };
  } catch (error2) {
    return { kind: "error", error: error2, index, id };
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/assets.js
var Asset;
(function(Asset2) {
  function Url(url, options) {
    return { kind: "url", id: UUID.create22(), url, ...options };
  }
  Asset2.Url = Url;
  function File2(file) {
    return { kind: "file", id: UUID.create22(), name: file.name, file };
  }
  Asset2.File = File2;
  function isUrl(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "url";
  }
  Asset2.isUrl = isUrl;
  function isFile(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "file";
  }
  Asset2.isFile = isFile;
  function Wrapper(data, asset, manager) {
    return {
      data,
      dispose: () => {
        manager.release(asset);
      }
    };
  }
  Asset2.Wrapper = Wrapper;
  function getUrl(url) {
    return typeof url === "string" ? url : url.url;
  }
  Asset2.getUrl = getUrl;
  function getUrlAsset(manager, url, body) {
    if (typeof url === "string") {
      const asset = manager.tryFindUrl(url, body);
      return asset || Url(url, { body });
    }
    return url;
  }
  Asset2.getUrlAsset = getUrlAsset;
})(Asset || (Asset = {}));
var AssetManager = class {
  constructor() {
    this._assets = /* @__PURE__ */ new Map();
  }
  get assets() {
    return iterableToArray(this._assets.values());
  }
  tryFindUrl(url, body) {
    const assets = this.assets.values();
    while (true) {
      const v = assets.next();
      if (v.done)
        return;
      const asset = v.value.asset;
      if (Asset.isUrl(asset) && asset.url === url && (asset.body || "") === (body || ""))
        return asset;
    }
  }
  set(asset, file, options) {
    this._assets.set(asset.id, { asset, file, refCount: 0, tag: options === null || options === void 0 ? void 0 : options.tag, isStatic: options === null || options === void 0 ? void 0 : options.isStatic });
  }
  get(asset) {
    return this._assets.get(asset.id);
  }
  delete(asset) {
    return this._assets.delete(asset.id);
  }
  has(asset) {
    return this._assets.has(asset.id);
  }
  resolve(asset, type3, store = true) {
    if (Asset.isUrl(asset)) {
      return Task.create(`Download ${asset.title || asset.url}`, async (ctx) => {
        if (this._assets.has(asset.id)) {
          const entry = this._assets.get(asset.id);
          entry.refCount++;
          return Asset.Wrapper(await readFromFile(entry.file, type3).runInContext(ctx), asset, this);
        }
        if (!store) {
          return Asset.Wrapper(await ajaxGet({ ...asset, type: type3 }).runInContext(ctx), asset, this);
        }
        const data = await ajaxGet({ ...asset, type: "binary" }).runInContext(ctx);
        const file = new File_([data], "raw-data");
        this._assets.set(asset.id, { asset, file, refCount: 1 });
        return Asset.Wrapper(await readFromFile(file, type3).runInContext(ctx), asset, this);
      });
    } else {
      return Task.create(`Read ${asset.name}`, async (ctx) => {
        if (this._assets.has(asset.id)) {
          const entry = this._assets.get(asset.id);
          entry.refCount++;
          return Asset.Wrapper(await readFromFile(entry.file, type3).runInContext(ctx), asset, this);
        }
        if (!(asset.file instanceof File_)) {
          throw new Error(`Cannot resolve file asset '${asset.name}' (${asset.id})`);
        }
        if (store) {
          this._assets.set(asset.id, { asset, file: asset.file, refCount: 1 });
        }
        return Asset.Wrapper(await readFromFile(asset.file, type3).runInContext(ctx), asset, this);
      });
    }
  }
  release(asset) {
    const entry = this._assets.get(asset.id);
    if (!entry)
      return;
    entry.refCount--;
    if (entry.refCount <= 0 && !entry.isStatic)
      this._assets.delete(asset.id);
  }
  clearTag(tag) {
    const keys = Array.from(this._assets.keys());
    for (const key of keys) {
      const entry = this._assets.get(key);
      if (entry && entry.tag === tag) {
        this._assets.delete(key);
      }
    }
  }
  clear() {
    this._assets.clear();
  }
  dispose() {
    this.clear();
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/param-definition.js
var ParamDefinition;
(function(ParamDefinition2) {
  ParamDefinition2.Essential = { isEssential: true };
  function setInfo(param, info) {
    if (!info)
      return param;
    if (info.label)
      param.label = info.label;
    if (info.description)
      param.description = info.description;
    if (info.legend)
      param.legend = info.legend;
    if (info.fieldLabels)
      param.fieldLabels = info.fieldLabels;
    if (info.isHidden)
      param.isHidden = info.isHidden;
    if (info.shortLabel)
      param.shortLabel = info.shortLabel;
    if (info.twoColumns)
      param.twoColumns = info.twoColumns;
    if (info.isEssential)
      param.isEssential = info.isEssential;
    if (info.category)
      param.category = info.category;
    if (info.hideIf)
      param.hideIf = info.hideIf;
    if (info.help)
      param.help = info.help;
    return param;
  }
  function Optional(p3) {
    const ret = { ...p3 };
    ret.isOptional = true;
    return ret;
  }
  ParamDefinition2.Optional = Optional;
  function Value(defaultValue, info) {
    return setInfo({ type: "value", defaultValue }, info);
  }
  ParamDefinition2.Value = Value;
  function Select(defaultValue, options, info) {
    return setInfo({ type: "select", defaultValue: checkDefaultKey(defaultValue, options), options, cycle: info === null || info === void 0 ? void 0 : info.cycle }, info);
  }
  ParamDefinition2.Select = Select;
  function MultiSelect(defaultValue, options, info) {
    const ret = setInfo({ type: "multi-select", defaultValue, options }, info);
    if (info === null || info === void 0 ? void 0 : info.emptyValue)
      ret.emptyValue = info.emptyValue;
    return ret;
  }
  ParamDefinition2.MultiSelect = MultiSelect;
  function Boolean(defaultValue, info) {
    return setInfo({ type: "boolean", defaultValue }, info);
  }
  ParamDefinition2.Boolean = Boolean;
  function Text(defaultValue = "", info) {
    return setInfo({ type: "text", defaultValue, multiline: info === null || info === void 0 ? void 0 : info.multiline, placeholder: info === null || info === void 0 ? void 0 : info.placeholder, disableInteractiveUpdates: info === null || info === void 0 ? void 0 : info.disableInteractiveUpdates }, info);
  }
  ParamDefinition2.Text = Text;
  function Color(defaultValue, info) {
    const ret = setInfo({ type: "color", defaultValue }, info);
    if (info === null || info === void 0 ? void 0 : info.isExpanded)
      ret.isExpanded = info.isExpanded;
    return ret;
  }
  ParamDefinition2.Color = Color;
  function ColorList(defaultValue, info) {
    let def;
    if (typeof defaultValue === "string") {
      const colors = getColorListFromName(defaultValue);
      def = { kind: colors.type !== "qualitative" ? "interpolate" : "set", colors: colors.list };
    } else {
      def = defaultValue;
    }
    return setInfo({ type: "color-list", presetKind: (info === null || info === void 0 ? void 0 : info.presetKind) || "all", defaultValue: def, offsets: !!(info === null || info === void 0 ? void 0 : info.offsets) }, info);
  }
  ParamDefinition2.ColorList = ColorList;
  function Vec32(defaultValue, range2, info) {
    return setInfo(setRange({ type: "vec3", defaultValue }, range2), info);
  }
  ParamDefinition2.Vec3 = Vec32;
  function Mat42(defaultValue, info) {
    return setInfo({ type: "mat4", defaultValue }, info);
  }
  ParamDefinition2.Mat4 = Mat42;
  function Url(url, info) {
    const defaultValue = typeof url === "string" ? Asset.Url(url) : Asset.Url(url.url, { body: url.body });
    const ret = setInfo({ type: "url", defaultValue }, info);
    return ret;
  }
  ParamDefinition2.Url = Url;
  function File2(info) {
    const ret = setInfo({ type: "file", defaultValue: null }, info);
    if (info === null || info === void 0 ? void 0 : info.accept)
      ret.accept = info.accept;
    return ret;
  }
  ParamDefinition2.File = File2;
  function FileList(info) {
    const ret = setInfo({ type: "file-list", defaultValue: null }, info);
    if (info === null || info === void 0 ? void 0 : info.accept)
      ret.accept = info.accept;
    return ret;
  }
  ParamDefinition2.FileList = FileList;
  function setRange(p3, range2) {
    if (!range2)
      return p3;
    if (typeof range2.min !== "undefined")
      p3.min = range2.min;
    if (typeof range2.max !== "undefined")
      p3.max = range2.max;
    if (typeof range2.step !== "undefined")
      p3.step = range2.step;
    return p3;
  }
  function Numeric(defaultValue, range2, info) {
    const ret = setInfo(setRange({ type: "number", defaultValue }, range2), info);
    if (info === null || info === void 0 ? void 0 : info.immediateUpdate)
      ret.immediateUpdate = true;
    return ret;
  }
  ParamDefinition2.Numeric = Numeric;
  function Interval2(defaultValue, range2, info) {
    return setInfo(setRange({ type: "interval", defaultValue }, range2), info);
  }
  ParamDefinition2.Interval = Interval2;
  function LineGraph(defaultValue, info) {
    const ret = setInfo({ type: "line-graph", defaultValue }, info);
    if (info === null || info === void 0 ? void 0 : info.getVolume)
      ret.getVolume = info.getVolume;
    return ret;
  }
  ParamDefinition2.LineGraph = LineGraph;
  function Group(params, info) {
    const ret = setInfo({ type: "group", defaultValue: (info === null || info === void 0 ? void 0 : info.customDefault) || getDefaultValues(params), params }, info);
    if (info === null || info === void 0 ? void 0 : info.presets)
      ret.presets = info.presets;
    if (info === null || info === void 0 ? void 0 : info.isExpanded)
      ret.isExpanded = info.isExpanded;
    if (info === null || info === void 0 ? void 0 : info.isFlat)
      ret.isFlat = info.isFlat;
    if (info === null || info === void 0 ? void 0 : info.pivot)
      ret.pivot = info.pivot;
    return ret;
  }
  ParamDefinition2.Group = Group;
  function EmptyGroup(info) {
    return Group({}, info);
  }
  ParamDefinition2.EmptyGroup = EmptyGroup;
  function Mapped(defaultKey, names, map2, info) {
    const name = checkDefaultKey(defaultKey, names);
    return setInfo({
      type: "mapped",
      defaultValue: { name, params: map2(name).defaultValue },
      select: Select(name, names, info),
      map: map2
    }, info);
  }
  ParamDefinition2.Mapped = Mapped;
  function MappedStatic(defaultKey, map2, info) {
    const options = (info === null || info === void 0 ? void 0 : info.options) ? info.options : Object.keys(map2).map((k) => [k, map2[k].label || stringToWords(k)]);
    const name = checkDefaultKey(defaultKey, options);
    return setInfo({
      type: "mapped",
      defaultValue: { name, params: map2[name].defaultValue },
      select: Select(name, options, info),
      map: (key) => map2[key]
    }, info);
  }
  ParamDefinition2.MappedStatic = MappedStatic;
  function ObjectList(element, getLabel, info) {
    return setInfo({ type: "object-list", element, getLabel, ctor: _defaultObjectListCtor, defaultValue: (info === null || info === void 0 ? void 0 : info.defaultValue) || [] }, info);
  }
  ParamDefinition2.ObjectList = ObjectList;
  function _defaultObjectListCtor() {
    return getDefaultValues(this.element);
  }
  function unsetGetValue() {
    throw new Error("getValue not set. Fix runtime.");
  }
  function ValueRef(getOptions, resolveRef, info) {
    var _a;
    return setInfo({ type: "value-ref", defaultValue: { ref: (_a = info === null || info === void 0 ? void 0 : info.defaultRef) !== null && _a !== void 0 ? _a : "", getValue: unsetGetValue }, getOptions, resolveRef }, info);
  }
  ParamDefinition2.ValueRef = ValueRef;
  function DataRef(info) {
    var _a;
    return setInfo({ type: "data-ref", defaultValue: { ref: (_a = info === null || info === void 0 ? void 0 : info.defaultRef) !== null && _a !== void 0 ? _a : "", getValue: unsetGetValue } }, info);
  }
  ParamDefinition2.DataRef = DataRef;
  function Converted(fromValue, toValue, converted) {
    return setInfo({ type: "converted", defaultValue: toValue(converted.defaultValue), converted, fromValue, toValue }, converted);
  }
  ParamDefinition2.Converted = Converted;
  function Conditioned(defaultValue, conditionParams, conditionForValue, conditionedValue, info) {
    const options = Object.keys(conditionParams).map((k) => [k, k]);
    return setInfo({ type: "conditioned", select: Select(conditionForValue(defaultValue), options, info), defaultValue, conditionParams, conditionForValue, conditionedValue }, info);
  }
  ParamDefinition2.Conditioned = Conditioned;
  function Script(defaultValue, info) {
    return setInfo({ type: "script", defaultValue }, info);
  }
  ParamDefinition2.Script = Script;
  function For(params) {
    return 0;
  }
  ParamDefinition2.For = For;
  function getDefaultValues(params) {
    const d = {};
    for (const k of Object.keys(params)) {
      if (params[k].isOptional)
        continue;
      d[k] = params[k].defaultValue;
    }
    return d;
  }
  ParamDefinition2.getDefaultValues = getDefaultValues;
  function _resolveRef(resolve, ref, getData2) {
    return () => resolve(ref, getData2);
  }
  function resolveRefValue(p3, value, getData2) {
    if (!value)
      return;
    if (p3.type === "value-ref") {
      const v = value;
      if (!v.ref)
        v.getValue = () => {
          throw new Error("Unset ref in ValueRef value.");
        };
      else
        v.getValue = _resolveRef(p3.resolveRef, v.ref, getData2);
    } else if (p3.type === "data-ref") {
      const v = value;
      if (!v.ref)
        v.getValue = () => {
          throw new Error("Unset ref in ValueRef value.");
        };
      else
        v.getValue = _resolveRef(getData2, v.ref, getData2);
    } else if (p3.type === "group") {
      resolveRefs(p3.params, value, getData2);
    } else if (p3.type === "mapped") {
      const v = value;
      const param = p3.map(v.name);
      resolveRefValue(param, v.params, getData2);
    } else if (p3.type === "object-list") {
      if (!hasValueRef(p3.element))
        return;
      for (const e of value) {
        resolveRefs(p3.element, e, getData2);
      }
    }
  }
  function hasParamValueRef(p3) {
    if (p3.type === "value-ref" || p3.type === "data-ref") {
      return true;
    } else if (p3.type === "group") {
      if (hasValueRef(p3.params))
        return true;
    } else if (p3.type === "mapped") {
      for (const [o] of p3.select.options) {
        if (hasParamValueRef(p3.map(o)))
          return true;
      }
    } else if (p3.type === "object-list") {
      return hasValueRef(p3.element);
    }
    return false;
  }
  function hasValueRef(params) {
    for (const n of Object.keys(params)) {
      if (hasParamValueRef(params[n]))
        return true;
    }
    return false;
  }
  function resolveRefs(params, values, getData2) {
    for (const n of Object.keys(params)) {
      resolveRefValue(params[n], values === null || values === void 0 ? void 0 : values[n], getData2);
    }
  }
  ParamDefinition2.resolveRefs = resolveRefs;
  function setDefaultValues(params, defaultValues) {
    for (const k of Object.keys(params)) {
      if (params[k].isOptional)
        continue;
      params[k].defaultValue = defaultValues[k];
    }
  }
  ParamDefinition2.setDefaultValues = setDefaultValues;
  function clone(params) {
    return deepClone(params);
  }
  ParamDefinition2.clone = clone;
  function validate(params, values) {
    return void 0;
  }
  ParamDefinition2.validate = validate;
  function areEqual(params, a, b) {
    if (a === b)
      return true;
    if (typeof a !== "object" || typeof b !== "object")
      return false;
    for (const k of Object.keys(params)) {
      if (!isParamEqual(params[k], a[k], b[k]))
        return false;
    }
    return true;
  }
  ParamDefinition2.areEqual = areEqual;
  function isParamEqual(p3, a, b) {
    if (a === b)
      return true;
    if (p3.type === "group") {
      return areEqual(p3.params, a, b);
    } else if (p3.type === "mapped") {
      const u = a, v = b;
      if (u.name !== v.name)
        return false;
      const map2 = p3.map(u.name);
      return isParamEqual(map2, u.params, v.params);
    } else if (p3.type === "multi-select") {
      const u = a, v = b;
      if (u.length !== v.length)
        return false;
      if (u.length < 10) {
        for (let i = 0, _i = u.length; i < _i; i++) {
          if (u[i] === v[i])
            continue;
          if (v.indexOf(u[i]) < 0)
            return false;
        }
      } else {
        const vSet = new Set(v);
        for (let i = 0, _i = u.length; i < _i; i++) {
          if (u[i] === v[i])
            continue;
          if (!vSet.has(u[i]))
            return false;
        }
      }
      return true;
    } else if (p3.type === "interval") {
      return a[0] === b[0] && a[1] === b[1];
    } else if (p3.type === "line-graph") {
      const u = a, v = b;
      if (u.length !== v.length)
        return false;
      for (let i = 0, _i = u.length; i < _i; i++) {
        if (!Vec2.areEqual(u[i], v[i]))
          return false;
      }
      return true;
    } else if (p3.type === "vec3") {
      return Vec3.equals(a, b);
    } else if (p3.type === "mat4") {
      return Mat4.areEqual(a, b, EPSILON);
    } else if (p3.type === "script") {
      const u = a, v = b;
      return u.language === v.language && u.expression === v.expression;
    } else if (p3.type === "object-list") {
      const u = a, v = b;
      const l = u.length;
      if (l !== v.length)
        return false;
      for (let i = 0; i < l; i++) {
        if (!areEqual(p3.element, u[i], v[i]))
          return false;
      }
      return true;
    } else if (typeof a === "object" && typeof b === "object") {
      return shallowEqualObjects(a, b);
    }
    return false;
  }
  ParamDefinition2.isParamEqual = isParamEqual;
  function merge2(params, a, b) {
    if (a === void 0)
      return { ...b };
    if (b === void 0)
      return { ...a };
    const o = /* @__PURE__ */ Object.create(null);
    for (const k of Object.keys(params)) {
      o[k] = mergeParam(params[k], a[k], b[k]);
    }
    return o;
  }
  ParamDefinition2.merge = merge2;
  function mergeParam(p3, a, b) {
    if (a === void 0)
      return typeof b === "object" && !Array.isArray(b) ? { ...b } : b;
    if (b === void 0)
      return typeof a === "object" && !Array.isArray(a) ? { ...a } : a;
    if (p3.type === "group") {
      return merge2(p3.params, a, b);
    } else if (p3.type === "mapped") {
      const u = a, v = b;
      if (u.name !== v.name)
        return { ...v };
      const map2 = p3.map(v.name);
      return {
        name: v.name,
        params: mergeParam(map2, u.params, v.params)
      };
    } else if (p3.type === "value") {
      return b;
    } else if (typeof a === "object" && typeof b === "object") {
      if (Array.isArray(b)) {
        return b;
      }
      return { ...a, ...b };
    } else {
      return b;
    }
  }
  ParamDefinition2.mergeParam = mergeParam;
  function selectHasOption(p3, v) {
    for (const o of p3.options) {
      if (o[0] === v)
        return true;
    }
    return false;
  }
  function normalizeParam(p3, value, defaultIfUndefined) {
    if (value === void 0 || value === null) {
      return defaultIfUndefined ? p3.defaultValue : void 0;
    }
    if (p3.type === "value") {
      return value;
    } else if (p3.type === "group") {
      const ret = /* @__PURE__ */ Object.create(null);
      for (const key of Object.keys(p3.params)) {
        const param = p3.params[key];
        if (value[key] === void 0) {
          if (defaultIfUndefined)
            ret[key] = param.defaultValue;
        } else {
          ret[key] = normalizeParam(param, value[key], defaultIfUndefined);
        }
      }
      return ret;
    } else if (p3.type === "mapped") {
      const v = value;
      if (typeof v.name !== "string") {
        return p3.defaultValue;
      }
      if (typeof v.params === "undefined") {
        return defaultIfUndefined ? p3.defaultValue : void 0;
      }
      if (!selectHasOption(p3.select, v.name)) {
        return p3.defaultValue;
      }
      const param = p3.map(v.name);
      return {
        name: v.name,
        params: normalizeParam(param, v.params, defaultIfUndefined)
      };
    } else if (p3.type === "select") {
      if (!selectHasOption(p3, value))
        return p3.defaultValue;
      return value;
    } else if (p3.type === "multi-select") {
      if (!Array.isArray(value))
        return p3.defaultValue;
      const ret = value.filter(function(v) {
        return selectHasOption(this, v);
      }, p3);
      if (value.length > 0 && ret.length === 0)
        return p3.defaultValue;
      return ret;
    } else if (p3.type === "object-list") {
      if (!Array.isArray(value))
        return p3.defaultValue;
      return value.map((v) => normalizeParams(p3.element, v, defaultIfUndefined ? "all" : "skip"));
    }
    return value;
  }
  function normalizeParams(p3, value, defaultIfUndefined) {
    if (typeof value !== "object" || value === null) {
      return defaultIfUndefined ? getDefaultValues(p3) : value;
    }
    const ret = /* @__PURE__ */ Object.create(null);
    for (const key of Object.keys(p3)) {
      const param = p3[key];
      if (value[key] === void 0) {
        if (defaultIfUndefined === "all")
          ret[key] = param.defaultValue;
      } else {
        ret[key] = normalizeParam(param, value[key], defaultIfUndefined !== "skip");
      }
    }
    return ret;
  }
  ParamDefinition2.normalizeParams = normalizeParams;
  function objectToOptions(options, f) {
    const ret = [];
    for (const k of Object.keys(options)) {
      if (!f) {
        if (typeof options[k] === "string")
          ret.push([k, options[k]]);
        else
          ret.push([k, f === null ? k : stringToWords(k)]);
      } else {
        const o = f(k, options[k]);
        ret.push(typeof o === "string" ? [k, o] : [k, o[0], o[1]]);
      }
    }
    return ret;
  }
  ParamDefinition2.objectToOptions = objectToOptions;
  function arrayToOptions(xs, f) {
    const ret = [];
    for (const x of xs) {
      if (!f) {
        ret.push([x, f === null ? x : stringToWords(x)]);
      } else {
        ret.push([x, f(x)]);
      }
    }
    return ret;
  }
  ParamDefinition2.arrayToOptions = arrayToOptions;
  function optionLabel(param, value) {
    for (const o of param.options) {
      if (o[0] === value)
        return o[1];
    }
    return "";
  }
  ParamDefinition2.optionLabel = optionLabel;
  function checkDefaultKey(k, options) {
    for (const o of options) {
      if (o[0] === k)
        return k;
    }
    return options.length > 0 ? options[0][0] : void 0;
  }
  function withDefaults(schema, updates) {
    const next = {};
    for (const k of Object.keys(updates)) {
      const v = updates[k];
      if (!schema[k] || v === null || v === void 0 || schema[k].defaultValue === v)
        continue;
      next[k] = { ...schema[k], defaultValue: v };
    }
    return { ...schema, ...next };
  }
  ParamDefinition2.withDefaults = withDefaults;
})(ParamDefinition || (ParamDefinition = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp/common.js
var DSSPType;
(function(DSSPType2) {
  DSSPType2.is = BitFlags.has;
  DSSPType2.create = BitFlags.create;
  let Flag;
  (function(Flag2) {
    Flag2[Flag2["_"] = 0] = "_";
    Flag2[Flag2["H"] = 1] = "H";
    Flag2[Flag2["B"] = 2] = "B";
    Flag2[Flag2["E"] = 4] = "E";
    Flag2[Flag2["G"] = 8] = "G";
    Flag2[Flag2["I"] = 16] = "I";
    Flag2[Flag2["S"] = 32] = "S";
    Flag2[Flag2["T"] = 64] = "T";
    Flag2[Flag2["T3"] = 128] = "T3";
    Flag2[Flag2["T4"] = 256] = "T4";
    Flag2[Flag2["T5"] = 512] = "T5";
    Flag2[Flag2["T3S"] = 1024] = "T3S";
    Flag2[Flag2["T4S"] = 2048] = "T4S";
    Flag2[Flag2["T5S"] = 4096] = "T5S";
  })(Flag = DSSPType2.Flag || (DSSPType2.Flag = {}));
})(DSSPType || (DSSPType = {}));
var BridgeType;
(function(BridgeType2) {
  BridgeType2[BridgeType2["PARALLEL"] = 0] = "PARALLEL";
  BridgeType2[BridgeType2["ANTI_PARALLEL"] = 1] = "ANTI_PARALLEL";
})(BridgeType || (BridgeType = {}));
var Bridge = class {
  constructor(p1, p22, type3) {
    this.partner1 = Math.min(p1, p22);
    this.partner2 = Math.max(p1, p22);
    this.type = type3;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp/bends.js
function assignBends(ctx) {
  const { unit: unit2, flags: flags2, proteinInfo } = ctx;
  const c = unit2.conformation;
  const { traceElementIndex } = unit2.model.atomicHierarchy.derived.residue;
  const { residueIndices, nIndices } = proteinInfo;
  const residueCount = residueIndices.length;
  const p3 = (i, v) => i === -1 ? Vec3.setNaN(v) : c.position(i, v);
  const caPosPrev2 = Vec3();
  const caPos = Vec3();
  const caPosNext2 = Vec3();
  const cPos = Vec3();
  const nPosNext = Vec3();
  const caMinus2 = Vec3();
  const caPlus2 = Vec3();
  f1: for (let i = 2; i < residueCount - 2; i++) {
    for (let k = 0; k < 4; k++) {
      const index = i + k - 2;
      p3(traceElementIndex[index], cPos);
      p3(nIndices[index + 1], nPosNext);
      if (Vec3.squaredDistance(cPos, nPosNext) > 6.25) {
        continue f1;
      }
    }
    const oRIprev2 = residueIndices[i - 2];
    const oRI = residueIndices[i];
    const oRInext2 = residueIndices[i + 2];
    const caAtomPrev2 = traceElementIndex[oRIprev2];
    const caAtom = traceElementIndex[oRI];
    const caAtomNext2 = traceElementIndex[oRInext2];
    p3(caAtomPrev2, caPosPrev2);
    p3(caAtom, caPos);
    p3(caAtomNext2, caPosNext2);
    Vec3.sub(caMinus2, caPosPrev2, caPos);
    Vec3.sub(caPlus2, caPos, caPosNext2);
    const angle = radToDeg(Vec3.angle(caMinus2, caPlus2));
    if (angle && angle > 70) {
      flags2[i] |= DSSPType.Flag.S;
    }
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp/backbone-hbonds.js
var caMaxDist = 9;
var Q = -27.888;
var hbondEnergyCutoff = -0.5;
var hbondEnergyMinimal = -9.9;
function calcHbondEnergy(oPos, cPos, nPos, hPos) {
  const distOH = Vec3.distance(oPos, hPos);
  const distCH = Vec3.distance(cPos, hPos);
  const distCN = Vec3.distance(cPos, nPos);
  const distON = Vec3.distance(oPos, nPos);
  const e1 = Q / distOH - Q / distCH;
  const e2 = Q / distCN - Q / distON;
  const e = e1 + e2;
  if (e < hbondEnergyMinimal)
    return hbondEnergyMinimal;
  return e;
}
function calcUnitBackboneHbonds(unit2, proteinInfo, lookup3d) {
  const { residueIndices, cIndices, hIndices, nIndices, oIndices } = proteinInfo;
  const { index } = unit2.model.atomicHierarchy;
  const c = unit2.conformation;
  const { traceElementIndex } = unit2.model.atomicHierarchy.derived.residue;
  const residueCount = residueIndices.length;
  const oAtomResidues = [];
  const nAtomResidues = [];
  const energies = [];
  const oPos = Vec3();
  const cPos = Vec3();
  const caPos = Vec3();
  const nPos = Vec3();
  const hPos = Vec3();
  const cPosPrev = Vec3();
  const oPosPrev = Vec3();
  for (let i = 0, il = residueIndices.length; i < il; ++i) {
    const oPI = i;
    const oRI = residueIndices[i];
    const oAtom = oIndices[oPI];
    const cAtom = cIndices[oPI];
    const caAtom = traceElementIndex[oRI];
    if (oAtom === -1 || cAtom === -1)
      continue;
    if (index.findAtomOnResidue(oRI, "OXT") !== -1)
      continue;
    c.invariantPosition(oAtom, oPos);
    c.invariantPosition(cAtom, cPos);
    c.invariantPosition(caAtom, caPos);
    const { indices, count } = lookup3d.find(caPos[0], caPos[1], caPos[2], caMaxDist);
    for (let j = 0; j < count; ++j) {
      const nPI = indices[j];
      if (nPI === oPI || nPI - 1 === oPI || nPI + 1 === oPI)
        continue;
      const nAtom = nIndices[nPI];
      if (nAtom === -1)
        continue;
      c.invariantPosition(nAtom, nPos);
      const hAtom = hIndices[nPI];
      if (hAtom === -1) {
        if (nPI === 0)
          continue;
        const nPIprev = nPI - 1;
        const oAtomPrev = oIndices[nPIprev];
        const cAtomPrev = cIndices[nPIprev];
        if (oAtomPrev === -1 || cAtomPrev === -1)
          continue;
        c.invariantPosition(oAtomPrev, oPosPrev);
        c.invariantPosition(cAtomPrev, cPosPrev);
        Vec3.sub(hPos, cPosPrev, oPosPrev);
        const dist = Vec3.distance(oPosPrev, cPosPrev);
        Vec3.scaleAndAdd(hPos, nPos, hPos, 1 / dist);
      } else {
        c.invariantPosition(hAtom, hPos);
      }
      const e = calcHbondEnergy(oPos, cPos, nPos, hPos);
      if (e > hbondEnergyCutoff)
        continue;
      oAtomResidues[oAtomResidues.length] = oPI;
      nAtomResidues[nAtomResidues.length] = nPI;
      energies[energies.length] = e;
    }
  }
  return buildHbondGraph(residueCount, oAtomResidues, nAtomResidues, energies);
}
function buildHbondGraph(residueCount, oAtomResidues, nAtomResidues, energies) {
  const builder = new IntAdjacencyGraph.DirectedEdgeBuilder(residueCount, oAtomResidues, nAtomResidues);
  const _energies = new Float32Array(builder.slotCount);
  for (let i = 0, _i = builder.edgeCount; i < _i; i++) {
    builder.addNextEdge();
    builder.assignProperty(_energies, energies[i]);
  }
  return builder.createGraph({ energies });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp/turns.js
function assignTurns(ctx) {
  const { proteinInfo, hbonds, flags: flags2 } = ctx;
  const turnFlag = [DSSPType.Flag.T3S, DSSPType.Flag.T4S, DSSPType.Flag.T5S, DSSPType.Flag.T3, DSSPType.Flag.T4, DSSPType.Flag.T5];
  for (let idx = 0; idx < 3; idx++) {
    for (let i = 0, il = proteinInfo.residueIndices.length - 1; i < il; ++i) {
      if (hbonds.getDirectedEdgeIndex(i, i + idx + 3) !== -1) {
        flags2[i] |= turnFlag[idx + 3] | turnFlag[idx];
        if (ctx.params.oldDefinition) {
          for (let k = 1; k < idx + 3; ++k) {
            flags2[i + k] |= turnFlag[idx + 3] | DSSPType.Flag.T;
          }
        } else {
          for (let k = 0; k <= idx + 3; ++k) {
            flags2[i + k] |= turnFlag[idx + 3] | DSSPType.Flag.T;
          }
        }
      }
    }
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp/helices.js
function assignHelices(ctx) {
  const { proteinInfo, flags: flags2 } = ctx;
  const residueCount = proteinInfo.residueIndices.length;
  const turnFlag = [DSSPType.Flag.T3S, DSSPType.Flag.T4S, DSSPType.Flag.T5S, DSSPType.Flag.T3, DSSPType.Flag.T4, DSSPType.Flag.T5];
  const helixFlag = [0, 0, 0, DSSPType.Flag.G, DSSPType.Flag.H, DSSPType.Flag.I];
  const helixCheckOrder = ctx.params.oldOrdering ? [4, 3, 5] : [3, 4, 5];
  for (let ni = 0; ni < helixCheckOrder.length; ni++) {
    const n = helixCheckOrder[ni];
    for (let i = 1, il = residueCount - n; i < il; i++) {
      const fI = DSSPType.create(flags2[i]);
      const fI1 = DSSPType.create(flags2[i - 1]);
      const fI2 = DSSPType.create(flags2[i + 1]);
      if (ctx.params.oldOrdering) {
        if (n === 3 && (DSSPType.is(fI, DSSPType.Flag.H) || DSSPType.is(fI2, DSSPType.Flag.H)) || // for 3-10 yield to alpha helix
        n === 5 && (DSSPType.is(fI, DSSPType.Flag.H) || DSSPType.is(fI, DSSPType.Flag.G) || (DSSPType.is(fI2, DSSPType.Flag.H) || DSSPType.is(fI2, DSSPType.Flag.G)))) {
          continue;
        }
      } else {
        if (n === 4 && (DSSPType.is(fI, DSSPType.Flag.G) || DSSPType.is(fI2, DSSPType.Flag.G)) || // for alpha helix yield to 3-10
        n === 5 && (DSSPType.is(fI, DSSPType.Flag.H) || DSSPType.is(fI, DSSPType.Flag.G) || (DSSPType.is(fI2, DSSPType.Flag.H) || DSSPType.is(fI2, DSSPType.Flag.G)))) {
          continue;
        }
      }
      if (DSSPType.is(fI, turnFlag[n]) && DSSPType.is(fI, turnFlag[n - 3]) && // check fI for turn start of proper type
      DSSPType.is(fI1, turnFlag[n]) && DSSPType.is(fI1, turnFlag[n - 3])) {
        if (ctx.params.oldDefinition) {
          for (let k = 0; k < n; k++) {
            flags2[i + k] |= helixFlag[n];
          }
        } else {
          for (let k = -1; k <= n; k++) {
            flags2[i + k] |= helixFlag[n];
          }
        }
      }
    }
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp/ladders.js
function shouldExtendLadder(ladder, bridge) {
  if (bridge.type !== ladder.type)
    return false;
  if (bridge.partner1 !== ladder.firstEnd + 1)
    return false;
  if (bridge.type === BridgeType.PARALLEL) {
    if (bridge.partner2 === ladder.secondEnd + 1) {
      return true;
    }
  } else {
    if (bridge.partner2 === ladder.secondStart - 1) {
      return true;
    }
  }
  return false;
}
function resemblesBulge(ladder1, ladder2) {
  if (!(ladder1.type === ladder2.type && ladder2.firstStart - ladder1.firstEnd < 6 && ladder1.firstStart < ladder2.firstStart && ladder2.nextLadder === 0))
    return false;
  if (ladder1.type === BridgeType.PARALLEL) {
    return bulgeCriterion2(ladder1, ladder2);
  } else {
    return bulgeCriterion2(ladder2, ladder1);
  }
}
function bulgeCriterion2(ladder1, ladder2) {
  return ladder2.secondStart - ladder1.secondEnd > 0 && (ladder2.secondStart - ladder1.secondEnd < 6 && ladder2.firstStart - ladder1.firstEnd < 3 || ladder2.secondStart - ladder1.secondEnd < 3);
}
function assignLadders(ctx) {
  const { bridges, ladders } = ctx;
  for (let bridgeIndex = 0; bridgeIndex < bridges.length; bridgeIndex++) {
    const bridge = bridges[bridgeIndex];
    let found = false;
    for (let ladderIndex = 0; ladderIndex < ladders.length; ladderIndex++) {
      const ladder = ladders[ladderIndex];
      if (shouldExtendLadder(ladder, bridge)) {
        found = true;
        ladder.firstEnd++;
        if (bridge.type === BridgeType.PARALLEL) {
          ladder.secondEnd++;
        } else {
          ladder.secondStart--;
        }
      }
    }
    if (!found) {
      ladders[ladders.length] = {
        previousLadder: 0,
        nextLadder: 0,
        firstStart: bridge.partner1,
        firstEnd: bridge.partner1,
        secondStart: bridge.partner2,
        secondEnd: bridge.partner2,
        type: bridge.type
      };
    }
  }
  for (let ladderIndex1 = 0; ladderIndex1 < ladders.length; ladderIndex1++) {
    const ladder1 = ladders[ladderIndex1];
    for (let ladderIndex2 = ladderIndex1; ladderIndex2 < ladders.length; ladderIndex2++) {
      const ladder2 = ladders[ladderIndex2];
      if (resemblesBulge(ladder1, ladder2)) {
        ladder1.nextLadder = ladderIndex2;
        ladder2.previousLadder = ladderIndex1;
      }
    }
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp/bridges.js
function assignBridges(ctx) {
  const { proteinInfo, hbonds, flags: flags2, bridges } = ctx;
  const { offset, b } = hbonds;
  let i, j;
  for (let k = 0, kl = proteinInfo.residueIndices.length; k < kl; ++k) {
    for (let t = offset[k], _t = offset[k + 1]; t < _t; t++) {
      const l = b[t];
      if (k > l)
        continue;
      i = k + 1;
      j = l;
      if (i !== j && hbonds.getDirectedEdgeIndex(j, i + 1) !== -1) {
        flags2[i] |= DSSPType.Flag.B;
        flags2[j] |= DSSPType.Flag.B;
        bridges[bridges.length] = new Bridge(i, j, BridgeType.PARALLEL);
      }
      i = k;
      j = l - 1;
      if (i !== j && hbonds.getDirectedEdgeIndex(j - 1, i) !== -1) {
        flags2[i] |= DSSPType.Flag.B;
        flags2[j] |= DSSPType.Flag.B;
        bridges[bridges.length] = new Bridge(j, i, BridgeType.PARALLEL);
      }
      i = k;
      j = l;
      if (i !== j && hbonds.getDirectedEdgeIndex(j, i) !== -1) {
        flags2[i] |= DSSPType.Flag.B;
        flags2[j] |= DSSPType.Flag.B;
        bridges[bridges.length] = new Bridge(j, i, BridgeType.ANTI_PARALLEL);
      }
      i = k + 1;
      j = l - 1;
      if (i !== j && hbonds.getDirectedEdgeIndex(j - 1, i + 1) !== -1) {
        flags2[i] |= DSSPType.Flag.B;
        flags2[j] |= DSSPType.Flag.B;
        bridges[bridges.length] = new Bridge(j, i, BridgeType.ANTI_PARALLEL);
      }
    }
  }
  bridges.sort((a, b2) => a.partner1 > b2.partner1 ? 1 : a.partner1 < b2.partner1 ? -1 : 0);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp/sheets.js
function isHelixType(f) {
  return DSSPType.is(f, DSSPType.Flag.G) || DSSPType.is(f, DSSPType.Flag.H) || DSSPType.is(f, DSSPType.Flag.I);
}
function assignSheets(ctx) {
  const { ladders, flags: flags2 } = ctx;
  for (let ladderIndex = 0; ladderIndex < ladders.length; ladderIndex++) {
    const ladder = ladders[ladderIndex];
    for (let lcount = ladder.firstStart; lcount <= ladder.firstEnd; lcount++) {
      const diff = ladder.firstStart - lcount;
      const l2count = ladder.secondStart - diff;
      if (ladder.firstStart !== ladder.firstEnd) {
        flags2[lcount] |= DSSPType.Flag.E;
        flags2[l2count] |= DSSPType.Flag.E;
      } else {
        if (!isHelixType(flags2[lcount]) && DSSPType.is(flags2[lcount], DSSPType.Flag.E)) {
          flags2[lcount] |= DSSPType.Flag.B;
        }
        if (!isHelixType(flags2[l2count]) && DSSPType.is(flags2[l2count], DSSPType.Flag.E)) {
          flags2[l2count] |= DSSPType.Flag.B;
        }
      }
    }
    if (ladder.nextLadder === 0)
      continue;
    const conladder = ladders[ladder.nextLadder];
    for (let lcount = ladder.firstStart; lcount <= conladder.firstEnd; lcount++) {
      flags2[lcount] |= DSSPType.Flag.E;
    }
    if (ladder.type === BridgeType.PARALLEL) {
      for (let lcount = ladder.secondStart; lcount <= conladder.secondEnd; lcount++) {
        flags2[lcount] |= DSSPType.Flag.E;
      }
    } else {
      for (let lcount = conladder.secondEnd; lcount <= ladder.secondStart; lcount++) {
        flags2[lcount] |= DSSPType.Flag.E;
      }
    }
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp/dihedral-angles.js
function calculateUnitDihedralAngles(unit2, proteinInfo) {
  const { cIndices, nIndices, residueIndices } = proteinInfo;
  const c = unit2.conformation;
  const { index } = unit2.model.atomicHierarchy;
  const { traceElementIndex } = unit2.model.atomicHierarchy.derived.residue;
  const residueCount = residueIndices.length;
  const p3 = (i, v) => i === -1 ? Vec3.setNaN(v) : c.position(i, v);
  let cPosPrev = Vec3(), caPosPrev = Vec3(), nPosPrev = Vec3();
  let cPos = Vec3(), caPos = Vec3(), nPos = Vec3();
  const cPosNext = Vec3(), caPosNext = Vec3(), nPosNext = Vec3();
  if (residueCount === 0)
    return { phi: new Float32Array(0), psi: new Float32Array(0) };
  const phi = new Float32Array(residueCount - 1);
  const psi = new Float32Array(residueCount - 1);
  p3(-1, cPosPrev);
  p3(-1, caPosPrev);
  p3(-1, nPosPrev);
  p3(cIndices[0], cPos);
  p3(traceElementIndex[residueIndices[0]], caPos);
  p3(nIndices[0], nPos);
  p3(cIndices[1], cPosNext);
  p3(traceElementIndex[residueIndices[1]], caPosNext);
  p3(nIndices[1], nPosNext);
  for (let i = 0; i < residueCount - 1; ++i) {
    if (index.findAtomOnResidue(residueIndices[i], "OXT") !== -1)
      continue;
    phi[i] = radToDeg(Vec3.dihedralAngle(cPosPrev, nPos, caPos, cPos));
    psi[i] = radToDeg(Vec3.dihedralAngle(nPos, caPos, cPos, nPosNext));
    cPosPrev = cPos, caPosPrev = caPos, nPosPrev = nPos;
    cPos = cPosNext, caPos = caPosNext, nPos = nPosNext;
    p3(cIndices[i + 1], cPosNext);
    p3(traceElementIndex[residueIndices[i + 1]], caPosNext);
    p3(nIndices[i + 1], nPosNext);
  }
  return { phi, psi };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp/trace-lookup.js
function calcUnitProteinTraceLookup3D(unit2, unitProteinResidues) {
  const { x, y, z } = unit2.model.atomicConformation;
  const { traceElementIndex } = unit2.model.atomicHierarchy.derived.residue;
  const indices = new Uint32Array(unitProteinResidues.length);
  for (let i = 0, il = unitProteinResidues.length; i < il; ++i) {
    indices[i] = traceElementIndex[unitProteinResidues[i]];
  }
  const position = { x, y, z, indices: SortedArray.ofSortedArray(indices) };
  return GridLookup3D(position, getBoundary(position));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp/protein-info.js
function getUnitProteinInfo(unit2) {
  const { index } = unit2.model.atomicHierarchy;
  const { proteinElements, residueIndex: residueIndex2 } = unit2;
  const residueCount = proteinElements.length;
  const unitProteinResidues = new Uint32Array(residueCount);
  const c = new Int32Array(residueCount);
  const h = new Int32Array(residueCount);
  const o = new Int32Array(residueCount);
  const n = new Int32Array(residueCount);
  for (let i = 0; i < residueCount; ++i) {
    const rI = residueIndex2[proteinElements[i]];
    unitProteinResidues[i] = rI;
    c[i] = index.findAtomOnResidue(rI, "C");
    h[i] = index.findAtomOnResidue(rI, "H");
    o[i] = index.findAtomOnResidue(rI, "O");
    n[i] = index.findAtomOnResidue(rI, "N");
  }
  return {
    residueIndices: SortedArray.ofSortedArray(unitProteinResidues),
    cIndices: c,
    hIndices: h,
    oIndices: o,
    nIndices: n
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/dssp.js
var DSSPComputationParams = {
  oldDefinition: ParamDefinition.Boolean(true, { description: "Whether to use the old DSSP convention for the annotation of turns and helices, causes them to be two residues shorter" }),
  oldOrdering: ParamDefinition.Boolean(true, { description: "Alpha-helices are preferred over 3-10 helices" })
};
var DefaultDSSPComputationProps = ParamDefinition.getDefaultValues(DSSPComputationParams);
async function computeUnitDSSP(unit2, params) {
  const proteinInfo = getUnitProteinInfo(unit2);
  const { residueIndices } = proteinInfo;
  const lookup3d = calcUnitProteinTraceLookup3D(unit2, residueIndices);
  const hbonds = calcUnitBackboneHbonds(unit2, proteinInfo, lookup3d);
  const residueCount = residueIndices.length;
  const flags2 = new Uint32Array(residueCount);
  const torsionAngles = calculateUnitDihedralAngles(unit2, proteinInfo);
  const ladders = [];
  const bridges = [];
  const getResidueFlag = params.oldDefinition ? getOriginalResidueFlag : getUpdatedResidueFlag;
  const getFlagName = params.oldOrdering ? getOriginalFlagName : getUpdatedFlagName;
  const ctx = {
    params,
    getResidueFlag,
    getFlagName,
    unit: unit2,
    proteinInfo,
    flags: flags2,
    hbonds,
    torsionAngles,
    ladders,
    bridges
  };
  assignTurns(ctx);
  assignHelices(ctx);
  assignBends(ctx);
  assignBridges(ctx);
  assignLadders(ctx);
  assignSheets(ctx);
  const assignment = getDSSPAssignment(flags2, getResidueFlag);
  const type3 = new Uint32Array(residueCount);
  const keys = [];
  const elements = [];
  const getIndex = (rI) => SortedArray.indexOf(residueIndices, rI);
  for (let i = 0, il = residueIndices.length; i < il; ++i) {
    const assign = assignment[i];
    type3[i] = assign;
    const flag = getResidueFlag(flags2[i]);
    if (elements.length === 0 || flag !== elements[elements.length - 1].flags) {
      elements[elements.length] = createElement(mapToKind(assign), flags2[i], getResidueFlag);
    }
    keys[i] = elements.length - 1;
  }
  return SecondaryStructure(type3, keys, elements, getIndex);
}
function createElement(kind, flag, getResidueFlag) {
  if (kind === "helix") {
    return {
      kind: "helix",
      flags: getResidueFlag(flag)
    };
  } else if (kind === "sheet") {
    return {
      kind: "sheet",
      flags: getResidueFlag(flag)
    };
  } else if (kind === "turn" || kind === "bend") {
    return {
      kind: "turn",
      flags: getResidueFlag(flag)
    };
  } else {
    return {
      kind: "none"
    };
  }
}
function mapToKind(assignment) {
  if (assignment === SecondaryStructureType.SecondaryStructureDssp.H || assignment === SecondaryStructureType.SecondaryStructureDssp.G || assignment === SecondaryStructureType.SecondaryStructureDssp.I) {
    return "helix";
  } else if (assignment === SecondaryStructureType.SecondaryStructureDssp.B || assignment === SecondaryStructureType.SecondaryStructureDssp.E) {
    return "sheet";
  } else if (assignment === SecondaryStructureType.SecondaryStructureDssp.T) {
    return "turn";
  } else if (assignment === SecondaryStructureType.SecondaryStructureDssp.S) {
    return "bend";
  } else {
    return "none";
  }
}
function getOriginalResidueFlag(f) {
  if (DSSPType.is(f, DSSPType.Flag.H))
    return SecondaryStructureType.SecondaryStructureDssp.H;
  if (DSSPType.is(f, DSSPType.Flag.E))
    return SecondaryStructureType.SecondaryStructureDssp.E;
  if (DSSPType.is(f, DSSPType.Flag.B))
    return SecondaryStructureType.SecondaryStructureDssp.B;
  if (DSSPType.is(f, DSSPType.Flag.G))
    return SecondaryStructureType.SecondaryStructureDssp.G;
  if (DSSPType.is(f, DSSPType.Flag.I))
    return SecondaryStructureType.SecondaryStructureDssp.I;
  if (DSSPType.is(f, DSSPType.Flag.T))
    return SecondaryStructureType.SecondaryStructureDssp.T;
  if (DSSPType.is(f, DSSPType.Flag.S))
    return SecondaryStructureType.SecondaryStructureDssp.S;
  return SecondaryStructureType.Flag.None;
}
function getOriginalFlagName(f) {
  if (DSSPType.is(f, DSSPType.Flag.H))
    return "H";
  if (DSSPType.is(f, DSSPType.Flag.E))
    return "E";
  if (DSSPType.is(f, DSSPType.Flag.B))
    return "B";
  if (DSSPType.is(f, DSSPType.Flag.G))
    return "G";
  if (DSSPType.is(f, DSSPType.Flag.I))
    return "I";
  if (DSSPType.is(f, DSSPType.Flag.T))
    return "T";
  if (DSSPType.is(f, DSSPType.Flag.S))
    return "S";
  return "-";
}
function getUpdatedResidueFlag(f) {
  if (DSSPType.is(f, DSSPType.Flag.I))
    return SecondaryStructureType.SecondaryStructureDssp.I;
  if (DSSPType.is(f, DSSPType.Flag.H))
    return SecondaryStructureType.SecondaryStructureDssp.H;
  if (DSSPType.is(f, DSSPType.Flag.E))
    return SecondaryStructureType.SecondaryStructureDssp.E;
  if (DSSPType.is(f, DSSPType.Flag.B))
    return SecondaryStructureType.SecondaryStructureDssp.B;
  if (DSSPType.is(f, DSSPType.Flag.G))
    return SecondaryStructureType.SecondaryStructureDssp.G;
  if (DSSPType.is(f, DSSPType.Flag.T))
    return SecondaryStructureType.SecondaryStructureDssp.T;
  if (DSSPType.is(f, DSSPType.Flag.S))
    return SecondaryStructureType.SecondaryStructureDssp.S;
  return SecondaryStructureType.Flag.None;
}
function getUpdatedFlagName(f) {
  if (DSSPType.is(f, DSSPType.Flag.I))
    return "I";
  if (DSSPType.is(f, DSSPType.Flag.H))
    return "H";
  if (DSSPType.is(f, DSSPType.Flag.E))
    return "E";
  if (DSSPType.is(f, DSSPType.Flag.B))
    return "B";
  if (DSSPType.is(f, DSSPType.Flag.G))
    return "G";
  if (DSSPType.is(f, DSSPType.Flag.T))
    return "T";
  if (DSSPType.is(f, DSSPType.Flag.S))
    return "S";
  return "-";
}
function getDSSPAssignment(flags2, getResidueFlag) {
  const type3 = new Uint32Array(flags2.length);
  for (let i = 0, il = flags2.length; i < il; ++i) {
    const f = DSSPType.create(flags2[i]);
    type3[i] = getResidueFlag(f);
  }
  return type3;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/common/custom-structure-property.js
var CustomStructureProperty;
(function(CustomStructureProperty2) {
  function createProvider(builder) {
    const descriptorName = builder.descriptor.name;
    const propertyDataName = builder.type === "root" ? "inheritedPropertyData" : "currentPropertyData";
    const get = (data) => {
      if (!(descriptorName in data[propertyDataName])) {
        data[propertyDataName][descriptorName] = {
          props: { ...ParamDefinition.getDefaultValues(builder.getParams(data)) },
          data: ValueBox.create(void 0)
        };
      }
      return data[propertyDataName][descriptorName];
    };
    const set2 = (data, props, value) => {
      const property2 = get(data);
      data[propertyDataName][descriptorName] = {
        props,
        data: ValueBox.withValue(property2.data, value)
      };
    };
    return {
      label: builder.label,
      descriptor: builder.descriptor,
      isHidden: builder.isHidden,
      getParams: (data) => {
        const params = ParamDefinition.clone(builder.getParams(data));
        ParamDefinition.setDefaultValues(params, get(data).props);
        return params;
      },
      defaultParams: builder.defaultParams,
      isApplicable: builder.isApplicable,
      attach: async (ctx, data, props = {}, addRef) => {
        if (addRef)
          data.customPropertyDescriptors.reference(builder.descriptor, true);
        if (builder.type === "root")
          data = data.root;
        const rootProps = get(data.root).props;
        const property2 = get(data);
        const p3 = ParamDefinition.merge(builder.defaultParams, rootProps, props);
        if (property2.data.value && ParamDefinition.areEqual(builder.defaultParams, property2.props, p3))
          return;
        const { value, assets } = await builder.obtain(ctx, data, p3);
        data.customPropertyDescriptors.add(builder.descriptor);
        data.customPropertyDescriptors.assets(builder.descriptor, assets);
        set2(data, p3, value);
      },
      ref: (data, add) => data.customPropertyDescriptors.reference(builder.descriptor, add),
      get: (data) => get(data).data,
      set: (data, props = {}, value) => {
        if (builder.type === "root")
          data = data.root;
        const property2 = get(data);
        const p3 = ParamDefinition.merge(builder.defaultParams, property2.props, props);
        if (!ParamDefinition.areEqual(builder.defaultParams, property2.props, p3)) {
          set2(data, p3, value);
          data.customPropertyDescriptors.assets(builder.descriptor);
        }
      },
      props: (data) => get(data).props
    };
  }
  CustomStructureProperty2.createProvider = createProvider;
  function createSimple(name, type3, defaultValue) {
    const defaultParams = { value: ParamDefinition.Value(defaultValue, { isHidden: true }) };
    return createProvider({
      label: stringToWords(name),
      descriptor: CustomPropertyDescriptor({ name }),
      isHidden: true,
      type: type3,
      defaultParams,
      getParams: () => ({ value: ParamDefinition.Value(defaultValue, { isHidden: true }) }),
      isApplicable: () => true,
      obtain: async (ctx, data, props) => {
        return { ...ParamDefinition.getDefaultValues(defaultParams), ...props };
      }
    });
  }
  CustomStructureProperty2.createSimple = createSimple;
})(CustomStructureProperty || (CustomStructureProperty = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/property/secondary-structure.js
var ModelSecondaryStructure;
(function(ModelSecondaryStructure2) {
  ModelSecondaryStructure2.Descriptor = {
    name: "model_secondary_structure"
  };
  ModelSecondaryStructure2.Provider = FormatPropertyProvider.create(ModelSecondaryStructure2.Descriptor);
  function fromStruct(conf, sheetRange, hierarchy) {
    const map2 = /* @__PURE__ */ new Map();
    const elements = [{ kind: "none" }];
    const coordinates = getCoordinateType(conf, sheetRange);
    addHelices(conf, coordinates, map2, elements);
    addSheets(sheetRange, coordinates, map2, conf._rowCount, elements);
    const n = hierarchy.residues._rowCount;
    const getIndex = (rI) => rI;
    const secStruct = {
      type: new Int32Array(n),
      key: new Int32Array(n),
      elements
    };
    if (map2.size > 0)
      assignSecondaryStructureRanges(hierarchy, coordinates, map2, secStruct);
    return SecondaryStructure(secStruct.type, secStruct.key, secStruct.elements, getIndex);
  }
  ModelSecondaryStructure2.fromStruct = fromStruct;
})(ModelSecondaryStructure || (ModelSecondaryStructure = {}));
function getCoordinateType(conf, sheetRange) {
  if (conf._rowCount > 0) {
    if (conf.beg_label_seq_id.valueKind(0) !== Column.ValueKinds.Present || conf.end_label_seq_id.valueKind(0) !== Column.ValueKinds.Present)
      return "auth";
  } else if (sheetRange) {
    if (sheetRange.beg_label_seq_id.valueKind(0) !== Column.ValueKinds.Present || sheetRange.end_label_seq_id.valueKind(0) !== Column.ValueKinds.Present)
      return "auth";
  }
  return "label";
}
function addHelices(cat, coordinates, map2, elements) {
  if (!cat._rowCount)
    return;
  const { beg_label_asym_id, beg_label_seq_id, beg_auth_seq_id, pdbx_beg_PDB_ins_code } = cat;
  const { end_label_seq_id, end_auth_seq_id, pdbx_end_PDB_ins_code } = cat;
  const { pdbx_PDB_helix_class, conf_type_id, details } = cat;
  const beg_seq_id = coordinates === "label" ? beg_label_seq_id : beg_auth_seq_id;
  const end_seq_id = coordinates === "label" ? end_label_seq_id : end_auth_seq_id;
  for (let i = 0, _i = cat._rowCount; i < _i; i++) {
    const type3 = SecondaryStructureType.create(pdbx_PDB_helix_class.valueKind(i) === Column.ValueKinds.Present ? SecondaryStructureType.SecondaryStructurePdb[pdbx_PDB_helix_class.value(i)] : conf_type_id.valueKind(i) === Column.ValueKinds.Present ? SecondaryStructureType.SecondaryStructureMmcif[conf_type_id.value(i)] : SecondaryStructureType.Flag.NA);
    const element = {
      kind: "helix",
      flags: type3,
      type_id: conf_type_id.valueKind(i) === Column.ValueKinds.Present ? conf_type_id.value(i) : "helx_p",
      helix_class: pdbx_PDB_helix_class.value(i),
      details: details.valueKind(i) === Column.ValueKinds.Present ? details.value(i) : void 0
    };
    const entry = {
      startSeqId: beg_seq_id.value(i),
      startInsCode: pdbx_beg_PDB_ins_code.value(i),
      endSeqId: end_seq_id.value(i),
      endInsCode: pdbx_end_PDB_ins_code.value(i),
      type: type3,
      key: elements.length
    };
    elements[elements.length] = element;
    const asymId = beg_label_asym_id.value(i);
    if (map2.has(asymId)) {
      const entries = map2.get(asymId);
      if (entries.has(entry.startSeqId)) {
        entries.get(entry.startSeqId).push(entry);
      } else {
        entries.set(entry.startSeqId, [entry]);
      }
    } else {
      map2.set(asymId, /* @__PURE__ */ new Map([[entry.startSeqId, [entry]]]));
    }
  }
}
function addSheets(cat, coordinates, map2, sheetCount, elements) {
  if (!cat._rowCount)
    return;
  const { beg_label_asym_id, beg_label_seq_id, beg_auth_seq_id, pdbx_beg_PDB_ins_code } = cat;
  const { end_label_seq_id, end_auth_seq_id, pdbx_end_PDB_ins_code } = cat;
  const { sheet_id } = cat;
  const beg_seq_id = coordinates === "label" ? beg_label_seq_id : beg_auth_seq_id;
  const end_seq_id = coordinates === "label" ? end_label_seq_id : end_auth_seq_id;
  const sheet_id_key = /* @__PURE__ */ new Map();
  let currentKey = sheetCount + 1;
  for (let i = 0, _i = cat._rowCount; i < _i; i++) {
    const id = sheet_id.value(i);
    let key;
    if (sheet_id_key.has(id))
      key = sheet_id_key.get(id);
    else {
      key = currentKey++;
      sheet_id_key.set(id, key);
    }
    const type3 = SecondaryStructureType.create(SecondaryStructureType.Flag.Beta | SecondaryStructureType.Flag.BetaSheet);
    const element = {
      kind: "sheet",
      flags: type3,
      sheet_id: id,
      symmetry: void 0
    };
    const entry = {
      startSeqId: beg_seq_id.value(i),
      startInsCode: pdbx_beg_PDB_ins_code.value(i),
      endSeqId: end_seq_id.value(i),
      endInsCode: pdbx_end_PDB_ins_code.value(i),
      type: type3,
      key: elements.length
    };
    elements[elements.length] = element;
    const asymId = beg_label_asym_id.value(i);
    if (map2.has(asymId)) {
      const entries = map2.get(asymId);
      if (entries.has(entry.startSeqId)) {
        entries.get(entry.startSeqId).push(entry);
      } else {
        entries.set(entry.startSeqId, [entry]);
      }
    } else {
      map2.set(asymId, /* @__PURE__ */ new Map([[entry.startSeqId, [entry]]]));
    }
  }
  return;
}
function assignSecondaryStructureEntry(hierarchy, coordinates, entry, resStart, resEnd, data) {
  const { auth_seq_id, label_seq_id, pdbx_PDB_ins_code } = hierarchy.residues;
  const { endSeqId, endInsCode, key, type: type3 } = entry;
  const seq_id = coordinates === "label" ? label_seq_id : auth_seq_id;
  let rI = resStart;
  while (rI < resEnd) {
    const seqNumber = seq_id.value(rI);
    data.type[rI] = type3;
    data.key[rI] = key;
    if (seqNumber > endSeqId || seqNumber === endSeqId && pdbx_PDB_ins_code.value(rI) === endInsCode) {
      break;
    }
    rI++;
  }
}
function assignSecondaryStructureRanges(hierarchy, coordinates, map2, data) {
  const { count: chainCount } = hierarchy.chainAtomSegments;
  const { label_asym_id } = hierarchy.chains;
  const { auth_seq_id, label_seq_id, pdbx_PDB_ins_code } = hierarchy.residues;
  const seq_id = coordinates === "label" ? label_seq_id : auth_seq_id;
  for (let cI = 0; cI < chainCount; cI++) {
    const resStart = AtomicHierarchy.chainStartResidueIndex(hierarchy, cI), resEnd = AtomicHierarchy.chainEndResidueIndexExcl(hierarchy, cI);
    const asymId = label_asym_id.value(cI);
    if (map2.has(asymId)) {
      const entries = map2.get(asymId);
      for (let rI = resStart; rI < resEnd; rI++) {
        const seqId2 = seq_id.value(rI);
        if (entries.has(seqId2)) {
          const entryList = entries.get(seqId2);
          for (const entry of entryList) {
            const insCode = pdbx_PDB_ins_code.value(rI);
            if (entry.startInsCode !== insCode)
              continue;
            assignSecondaryStructureEntry(hierarchy, coordinates, entry, rI, resEnd, data);
          }
        }
      }
    }
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure/zhang-skolnik.js
var HelixDistances = [5.45, 5.18, 6.37];
var HelixDelta = 2.1;
var SheetDistances = [6.1, 10.4, 13];
var SheetDelta = 1.42;
var posA = Vec3();
var posB = Vec3();
function zhangSkolnickAtomicSS(unit2, residueIndices, i, distances, delta2) {
  const c = unit2.conformation;
  const { traceElementIndex } = unit2.model.atomicHierarchy.derived.residue;
  for (let j = Math.max(0, i - 2); j <= i; ++j) {
    for (let k = 2; k < 5; ++k) {
      if (j + k >= residueIndices.length)
        return false;
      const rA = residueIndices[j];
      const rB = residueIndices[j + k];
      const aA = traceElementIndex[rA];
      const aB = traceElementIndex[rB];
      if (aA === -1 || aB === -1)
        return false;
      c.invariantPosition(aA, posA);
      c.invariantPosition(aB, posB);
      const d = Vec3.distance(posA, posB);
      if (Math.abs(d - distances[k - 2]) >= delta2)
        return false;
    }
  }
  return true;
}
async function computeUnitZhangSkolnik(unit2) {
  const count = unit2.proteinElements.length;
  const type3 = new Uint32Array(count);
  const keys = [];
  const elements = [];
  const { proteinElements, residueIndex: residueIndex2 } = unit2;
  const residueCount = proteinElements.length;
  const unitProteinResidues = new Uint32Array(residueCount);
  for (let i = 0; i < residueCount; ++i) {
    const rI = residueIndex2[proteinElements[i]];
    unitProteinResidues[i] = rI;
  }
  const residueIndices = SortedArray.ofSortedArray(unitProteinResidues);
  const getIndex = (rI) => SortedArray.indexOf(residueIndices, rI);
  for (let i = 0, il = residueIndices.length; i < il; ++i) {
    let flag = SecondaryStructureType.Flag.None;
    if (zhangSkolnickAtomicSS(unit2, residueIndices, i, HelixDistances, HelixDelta)) {
      flag = SecondaryStructureType.Flag.Helix;
    } else if (zhangSkolnickAtomicSS(unit2, residueIndices, i, SheetDistances, SheetDelta)) {
      flag = SecondaryStructureType.Flag.Beta;
    }
    type3[i] = flag;
    if (elements.length === 0 || flag !== getFlag(elements[elements.length - 1])) {
      elements[elements.length] = createElement2(mapToKind2(flag), flag);
    }
    keys[i] = elements.length - 1;
  }
  return SecondaryStructure(type3, keys, elements, getIndex);
}
function createElement2(kind, flag) {
  if (kind === "helix") {
    return { kind: "helix", flags: flag };
  } else if (kind === "sheet") {
    return { kind: "sheet", flags: flag };
  } else {
    return { kind: "none" };
  }
}
function mapToKind2(flag) {
  if (flag === SecondaryStructureType.Flag.Helix) {
    return "helix";
  } else if (flag === SecondaryStructureType.Flag.Beta) {
    return "sheet";
  } else {
    return "none";
  }
}
function getFlag(element) {
  if (element.kind === "helix") {
    return element.flags;
  } else if (element.kind === "sheet") {
    return element.flags;
  } else {
    return SecondaryStructureType.Flag.None;
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/secondary-structure.js
function getSecondaryStructureParams(_data) {
  return {
    type: ParamDefinition.MappedStatic("auto", {
      "auto": ParamDefinition.EmptyGroup({ label: "Automatic" }),
      "model": ParamDefinition.EmptyGroup({ label: "Model" }),
      "dssp": ParamDefinition.Group(DSSPComputationParams, { label: "DSSP", isFlat: true }),
      "zhang-skolnick": ParamDefinition.EmptyGroup({ label: "Zhang-Skolnick" })
    }, { options: [["auto", "Automatic"], ["model", "Model"], ["dssp", "DSSP"], ["zhang-skolnick", "Zhang-Skolnick"]] })
  };
}
var SecondaryStructureParams = getSecondaryStructureParams();
var SecondaryStructureProvider = CustomStructureProperty.createProvider({
  label: "Secondary Structure",
  descriptor: CustomPropertyDescriptor({
    name: "molstar_computed_secondary_structure"
    // TODO `cifExport` and `symbol`
  }),
  type: "root",
  defaultParams: SecondaryStructureParams,
  getParams: getSecondaryStructureParams,
  isApplicable: (data) => true,
  obtain: async (ctx, data, props) => {
    const p3 = { ...ParamDefinition.getDefaultValues(SecondaryStructureParams), ...props };
    switch (p3.type.name) {
      case "auto":
        return { value: await computeAuto(data) };
      case "dssp":
        return { value: await computeDssp(data, p3.type.params) };
      case "model":
        return { value: await computeModel(data) };
      case "zhang-skolnick":
        return { value: await computeZhangSkolnik(data) };
    }
  }
});
async function computeAuto(structure) {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = 0, il = structure.unitSymmetryGroups.length; i < il; ++i) {
    const u = structure.unitSymmetryGroups[i].units[0];
    const m = u.model;
    if (Model.isFromPdbArchive(m) && Model.isExperimental(m) && !Model.isCoarseGrained(m) || Model.hasSecondaryStructure(m)) {
      const secondaryStructure = ModelSecondaryStructure.Provider.get(m);
      if (secondaryStructure)
        map2.set(u.invariantId, secondaryStructure);
    } else if (Unit.isAtomic(u) && !Model.isCoarseGrained(m)) {
      const secondaryStructure = await computeUnitDSSP(u, DefaultDSSPComputationProps);
      map2.set(u.invariantId, secondaryStructure);
    } else if (Unit.isAtomic(u)) {
      const secondaryStructure = await computeUnitZhangSkolnik(u);
      map2.set(u.invariantId, secondaryStructure);
    }
  }
  return map2;
}
async function computeDssp(structure, props) {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = 0, il = structure.unitSymmetryGroups.length; i < il; ++i) {
    const u = structure.unitSymmetryGroups[i].units[0];
    if (Unit.isAtomic(u) && !Model.isCoarseGrained(u.model)) {
      const secondaryStructure = await computeUnitDSSP(u, props);
      map2.set(u.invariantId, secondaryStructure);
    }
  }
  return map2;
}
async function computeZhangSkolnik(structure) {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = 0, il = structure.unitSymmetryGroups.length; i < il; ++i) {
    const u = structure.unitSymmetryGroups[i].units[0];
    if (Unit.isAtomic(u)) {
      const secondaryStructure = await computeUnitZhangSkolnik(u);
      map2.set(u.invariantId, secondaryStructure);
    }
  }
  return map2;
}
async function computeModel(structure) {
  const map2 = /* @__PURE__ */ new Map();
  for (let i = 0, il = structure.unitSymmetryGroups.length; i < il; ++i) {
    const u = structure.unitSymmetryGroups[i].units[0];
    if (Unit.isAtomic(u)) {
      const secondaryStructure = ModelSecondaryStructure.Provider.get(u.model);
      if (secondaryStructure)
        map2.set(u.invariantId, secondaryStructure);
    }
  }
  return map2;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/properties.js
function p2(p3) {
  return p3;
}
var constant = {
  true: p2((l) => true),
  false: p2((l) => false),
  zero: p2((l) => 0)
};
function notAtomic() {
  throw new Error("Property only available for atomic models.");
}
function notCoarse(kind) {
  if (!!kind)
    throw new Error(`Property only available for coarse models (${kind}).`);
  throw new Error("Property only available for coarse models.");
}
var atom = {
  key: p2((l) => l.element),
  // Conformation
  x: p2((l) => l.unit.conformation.x(l.element)),
  y: p2((l) => l.unit.conformation.y(l.element)),
  z: p2((l) => l.unit.conformation.z(l.element)),
  id: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicConformation.atomId.value(l.element)),
  occupancy: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicConformation.occupancy.value(l.element)),
  B_iso_or_equiv: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicConformation.B_iso_or_equiv.value(l.element)),
  sourceIndex: p2((l) => Unit.isAtomic(l.unit) ? l.unit.model.atomicHierarchy.atomSourceIndex.value(l.element) : l.element),
  // Hierarchy
  type_symbol: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicHierarchy.atoms.type_symbol.value(l.element)),
  label_atom_id: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicHierarchy.atoms.label_atom_id.value(l.element)),
  auth_atom_id: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicHierarchy.atoms.auth_atom_id.value(l.element)),
  label_alt_id: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicHierarchy.atoms.label_alt_id.value(l.element)),
  label_comp_id: p2(compId),
  auth_comp_id: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicHierarchy.atoms.auth_comp_id.value(l.element)),
  pdbx_formal_charge: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicHierarchy.atoms.pdbx_formal_charge.value(l.element)),
  // Derived
  vdw_radius: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : VdwRadius(l.unit.model.atomicHierarchy.atoms.type_symbol.value(l.element)))
};
function compId(l) {
  if (!Unit.isAtomic(l.unit))
    notAtomic();
  return l.unit.model.atomicHierarchy.atoms.label_comp_id.value(l.element);
}
function seqId(l) {
  return !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicHierarchy.residues.label_seq_id.value(l.unit.residueIndex[l.element]);
}
function hasMicroheterogeneity(l) {
  if (!Unit.isAtomic(l.unit))
    notAtomic();
  const entitySeq = l.unit.model.sequence.byEntityKey[eK(l)];
  return entitySeq && entitySeq.sequence.microHet.has(seqId(l));
}
function microheterogeneityCompIds(l) {
  if (!Unit.isAtomic(l.unit))
    notAtomic();
  const entitySeq = l.unit.model.sequence.byEntityKey[eK(l)];
  if (entitySeq) {
    return entitySeq.sequence.microHet.get(seqId(l)) || [compId(l)];
  } else {
    return [compId(l)];
  }
}
var residue = {
  key: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.residueIndex[l.element]),
  group_PDB: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicHierarchy.residues.group_PDB.value(l.unit.residueIndex[l.element])),
  label_seq_id: p2(seqId),
  auth_seq_id: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicHierarchy.residues.auth_seq_id.value(l.unit.residueIndex[l.element])),
  pdbx_PDB_ins_code: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicHierarchy.residues.pdbx_PDB_ins_code.value(l.unit.residueIndex[l.element])),
  // Properties
  isNonStandard: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : microheterogeneityCompIds(l).some((c) => l.unit.model.properties.chemicalComponentMap.get(c).mon_nstd_flag[0] === "n")),
  hasMicroheterogeneity: p2(hasMicroheterogeneity),
  microheterogeneityCompIds: p2(microheterogeneityCompIds),
  secondary_structure_type: p2((l) => {
    var _a;
    if (!Unit.isAtomic(l.unit))
      notAtomic();
    const secStruc = (_a = SecondaryStructureProvider.get(l.structure).value) === null || _a === void 0 ? void 0 : _a.get(l.unit.invariantId);
    return secStruc ? secStruc.type[secStruc.getIndex(l.unit.residueIndex[l.element])] : SecondaryStructureType.Flag.NA;
  }),
  secondary_structure_key: p2((l) => {
    var _a;
    if (!Unit.isAtomic(l.unit))
      notAtomic();
    const secStruc = (_a = SecondaryStructureProvider.get(l.structure).value) === null || _a === void 0 ? void 0 : _a.get(l.unit.invariantId);
    return secStruc ? secStruc.key[secStruc.getIndex(l.unit.residueIndex[l.element])] : -1;
  }),
  chem_comp_type: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.properties.chemicalComponentMap.get(compId(l)).type)
};
var chain = {
  key: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.chainIndex[l.element]),
  label_asym_id: p2((l) => !Unit.isAtomic(l.unit) ? l.unit.coarseElements.asym_id.value(l.element) : l.unit.model.atomicHierarchy.chains.label_asym_id.value(l.unit.chainIndex[l.element])),
  auth_asym_id: p2((l) => !Unit.isAtomic(l.unit) ? notAtomic() : l.unit.model.atomicHierarchy.chains.auth_asym_id.value(l.unit.chainIndex[l.element])),
  label_entity_id: p2((l) => !Unit.isAtomic(l.unit) ? l.unit.coarseElements.entity_id.value(l.element) : l.unit.model.atomicHierarchy.chains.label_entity_id.value(l.unit.chainIndex[l.element]))
};
var coarse = {
  key: atom.key,
  entityKey: p2((l) => !Unit.isCoarse(l.unit) ? notCoarse() : l.unit.coarseElements.entityKey[l.element]),
  x: atom.x,
  y: atom.y,
  z: atom.z,
  asym_id: p2((l) => !Unit.isCoarse(l.unit) ? notCoarse() : l.unit.coarseElements.asym_id.value(l.element)),
  entity_id: p2((l) => !Unit.isCoarse(l.unit) ? notCoarse() : l.unit.coarseElements.entity_id.value(l.element)),
  seq_id_begin: p2((l) => !Unit.isCoarse(l.unit) ? notCoarse() : l.unit.coarseElements.seq_id_begin.value(l.element)),
  seq_id_end: p2((l) => !Unit.isCoarse(l.unit) ? notCoarse() : l.unit.coarseElements.seq_id_end.value(l.element)),
  sphere_radius: p2((l) => !Unit.isSpheres(l.unit) ? notCoarse("spheres") : l.unit.coarseConformation.radius[l.element]),
  sphere_rmsf: p2((l) => !Unit.isSpheres(l.unit) ? notCoarse("spheres") : l.unit.coarseConformation.rmsf[l.element]),
  gaussian_weight: p2((l) => !Unit.isGaussians(l.unit) ? notCoarse("gaussians") : l.unit.coarseConformation.weight[l.element]),
  gaussian_covariance_matrix: p2((l) => !Unit.isGaussians(l.unit) ? notCoarse("gaussians") : l.unit.coarseConformation.covariance_matrix[l.element])
};
function eK(l) {
  switch (l.unit.kind) {
    case Unit.Kind.Atomic:
      return l.unit.model.atomicHierarchy.index.getEntityFromChain(l.unit.chainIndex[l.element]);
    case Unit.Kind.Spheres:
      return l.unit.model.coarseHierarchy.spheres.entityKey[l.element];
    case Unit.Kind.Gaussians:
      return l.unit.model.coarseHierarchy.gaussians.entityKey[l.element];
  }
}
var entity = {
  key: p2(eK),
  id: p2((l) => l.unit.model.entities.data.id.value(eK(l))),
  type: p2((l) => l.unit.model.entities.data.type.value(eK(l))),
  src_method: p2((l) => l.unit.model.entities.data.src_method.value(eK(l))),
  pdbx_description: p2((l) => l.unit.model.entities.data.pdbx_description.value(eK(l))),
  formula_weight: p2((l) => l.unit.model.entities.data.formula_weight.value(eK(l))),
  pdbx_number_of_molecules: p2((l) => l.unit.model.entities.data.pdbx_number_of_molecules.value(eK(l))),
  details: p2((l) => l.unit.model.entities.data.details.value(eK(l))),
  pdbx_mutation: p2((l) => l.unit.model.entities.data.pdbx_mutation.value(eK(l))),
  pdbx_fragment: p2((l) => l.unit.model.entities.data.pdbx_fragment.value(eK(l))),
  pdbx_ec: p2((l) => l.unit.model.entities.data.pdbx_ec.value(eK(l))),
  pdbx_parent_entity_id: p2((l) => l.unit.model.entities.data.pdbx_parent_entity_id.value(eK(l))),
  subtype: p2((l) => l.unit.model.entities.subtype.value(eK(l))),
  prd_id: p2((l) => {
    var _a, _b;
    return (_b = (_a = l.unit.model.entities.prd_id) === null || _a === void 0 ? void 0 : _a.value(eK(l))) !== null && _b !== void 0 ? _b : "";
  })
};
var _emptyList = [];
var unit = {
  id: p2((l) => l.unit.id),
  chainGroupId: p2((l) => l.unit.chainGroupId),
  multiChain: p2((l) => Unit.Traits.is(l.unit.traits, Unit.Trait.MultiChain)),
  object_primitive: p2((l) => l.unit.objectPrimitive),
  operator_name: p2((l) => l.unit.conformation.operator.name),
  operator_key: p2((l) => l.unit.conformation.operator.key),
  model_index: p2((l) => l.unit.model.modelNum),
  model_label: p2((l) => l.unit.model.label),
  model_entry_id: p2((l) => l.unit.model.entryId),
  hkl: p2((l) => l.unit.conformation.operator.hkl),
  spgrOp: p2((l) => l.unit.conformation.operator.spgrOp),
  model_num: p2((l) => l.unit.model.modelNum),
  pdbx_struct_assembly_id: p2((l) => {
    var _a;
    return ((_a = l.unit.conformation.operator.assembly) === null || _a === void 0 ? void 0 : _a.id) || SymmetryOperator.DefaultName;
  }),
  pdbx_struct_oper_list_ids: p2((l) => {
    var _a;
    return ((_a = l.unit.conformation.operator.assembly) === null || _a === void 0 ? void 0 : _a.operList) || _emptyList;
  }),
  struct_ncs_oper_id: p2((l) => l.unit.conformation.operator.ncsId)
};
var StructureProperties = {
  constant,
  atom,
  residue,
  chain,
  entity,
  unit,
  coarse
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/utils/residue-set.js
var ResidueSet = class {
  add(entry) {
    let root = this.index.get(entry.label_asym_id);
    if (!root) {
      root = /* @__PURE__ */ new Map();
      this.index.set(entry.label_asym_id, root);
    }
    let entries = root.get(entry.label_seq_id);
    if (!entries) {
      entries = [];
      root.set(entry.label_seq_id, entries);
    }
    const exists = this._find(entry, entries);
    if (!exists) {
      entries.push(entry);
      return true;
    }
    return false;
  }
  hasLabelAsymId(asym_id) {
    return this.index.has(asym_id);
  }
  has(loc) {
    var _a, _b;
    const asym_id = this._asym_id(loc);
    if (!this.index.has(asym_id))
      return;
    const root = this.index.get(asym_id);
    const seq_id = this._seq_id(loc);
    if (!root.has(seq_id))
      return;
    const entries = root.get(seq_id);
    const comp_id = this._comp_id(loc);
    const alt_id = this._alt_id(loc);
    const ins_code = this._ins_code(loc);
    const op_name = (_a = this._op_name(loc)) !== null && _a !== void 0 ? _a : "1_555";
    for (const e of entries) {
      if (e.label_comp_id !== comp_id || e.label_alt_id !== alt_id || e.ins_code !== ins_code)
        continue;
      if (this.checkOperator && ((_b = e.operator_name) !== null && _b !== void 0 ? _b : "1_555") !== op_name)
        continue;
      return e;
    }
  }
  static getLabel(entry, checkOperator = false) {
    var _a;
    return `${entry.label_asym_id} ${entry.label_comp_id} ${entry.label_seq_id}:${entry.ins_code}:${entry.label_alt_id}${checkOperator ? " " + ((_a = entry.operator_name) !== null && _a !== void 0 ? _a : "1_555") : ""}`;
  }
  static getEntryFromLocation(loc) {
    var _a;
    return {
      label_asym_id: StructureProperties.chain.label_asym_id(loc),
      label_comp_id: StructureProperties.atom.label_comp_id(loc),
      label_seq_id: StructureProperties.residue.label_seq_id(loc),
      label_alt_id: StructureProperties.atom.label_alt_id(loc),
      ins_code: StructureProperties.residue.pdbx_PDB_ins_code(loc),
      operator_name: (_a = StructureProperties.unit.operator_name(loc)) !== null && _a !== void 0 ? _a : "1_555"
    };
  }
  _find(entry, xs) {
    var _a, _b;
    for (const e of xs) {
      if (e.label_comp_id !== entry.label_comp_id || e.label_alt_id !== entry.label_alt_id || e.ins_code !== entry.ins_code)
        continue;
      if (this.checkOperator && ((_a = e.operator_name) !== null && _a !== void 0 ? _a : "1_555") !== ((_b = entry.operator_name) !== null && _b !== void 0 ? _b : "1_555"))
        continue;
      return true;
    }
    return false;
  }
  constructor(options) {
    var _a;
    this.index = /* @__PURE__ */ new Map();
    this.checkOperator = false;
    this._asym_id = StructureProperties.chain.label_asym_id;
    this._seq_id = StructureProperties.residue.label_seq_id;
    this._comp_id = StructureProperties.atom.label_comp_id;
    this._alt_id = StructureProperties.atom.label_alt_id;
    this._ins_code = StructureProperties.residue.pdbx_PDB_ins_code;
    this._op_name = StructureProperties.unit.operator_name;
    this.checkOperator = (_a = options === null || options === void 0 ? void 0 : options.checkOperator) !== null && _a !== void 0 ? _a : false;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/queries/modifiers.js
function getWholeResidues(ctx, source, structure) {
  const builder = source.subsetBuilder(true);
  for (const unit2 of structure.units) {
    if (unit2.kind !== Unit.Kind.Atomic) {
      builder.setUnit(unit2.id, unit2.elements);
      continue;
    }
    const { residueAtomSegments } = unit2.model.atomicHierarchy;
    const sourceElements = source.unitMap.get(unit2.id).elements;
    const elements = unit2.elements;
    builder.beginUnit(unit2.id);
    const residuesIt = Segmentation.transientSegments(residueAtomSegments, elements);
    while (residuesIt.hasNext) {
      const rI = residuesIt.move().index;
      for (let j = residueAtomSegments.offsets[rI], _j = residueAtomSegments.offsets[rI + 1]; j < _j; j++) {
        if (SortedArray.has(sourceElements, j))
          builder.addElement(j);
      }
    }
    builder.commitUnit();
    ctx.throwIfTimedOut();
  }
  return builder.getStructure();
}
function wholeResidues(query2) {
  return function query_wholeResidues(ctx) {
    const inner = query2(ctx);
    if (StructureSelection.isSingleton(inner)) {
      return StructureSelection.Singletons(ctx.inputStructure, getWholeResidues(ctx, ctx.inputStructure, inner.structure));
    } else {
      const builder = new UniqueStructuresBuilder(ctx.inputStructure);
      for (const s of inner.structures) {
        builder.add(getWholeResidues(ctx, ctx.inputStructure, s));
      }
      return builder.getSelection();
    }
  };
}
function getIncludeSurroundings(ctx, source, structure, params) {
  const builder = new StructureUniqueSubsetBuilder(source);
  const lookup = source.lookup3d;
  const r = params.radius;
  for (const unit2 of structure.units) {
    const c = unit2.conformation;
    const elements = unit2.elements;
    for (let i = 0, _i = elements.length; i < _i; i++) {
      const e = elements[i];
      lookup.findIntoBuilder(c.x(e), c.y(e), c.z(e), r, builder);
    }
    ctx.throwIfTimedOut();
  }
  return !!params.wholeResidues ? getWholeResidues(ctx, source, builder.getStructure()) : builder.getStructure();
}
function getIncludeSurroundingsWithRadius(ctx, source, structure, params) {
  const builder = new StructureUniqueSubsetBuilder(source);
  const lookup = source.lookup3d;
  const { elementRadius, elementRadiusClosure, sourceMaxRadius, radius } = params;
  ctx.pushCurrentElement();
  ctx.element.structure = structure;
  for (const unit2 of structure.units) {
    ctx.element.unit = unit2;
    const c = unit2.conformation;
    const elements = unit2.elements;
    for (let i = 0, _i = elements.length; i < _i; i++) {
      const e = elements[i];
      ctx.element.element = e;
      const eRadius = elementRadius(ctx);
      lookup.findIntoBuilderWithRadius(c.x(e), c.y(e), c.z(e), eRadius, sourceMaxRadius, radius, elementRadiusClosure, builder);
    }
    ctx.throwIfTimedOut();
  }
  ctx.popCurrentElement();
  return !!params.wholeResidues ? getWholeResidues(ctx, source, builder.getStructure()) : builder.getStructure();
}
function createElementRadiusFn(ctx, eRadius) {
  return (e) => {
    ctx.element.structure = e.structure;
    ctx.element.unit = e.unit;
    ctx.element.element = e.element;
    return eRadius(ctx);
  };
}
function findStructureRadius(ctx, eRadius) {
  let r = 0;
  ctx.element.structure = ctx.inputStructure;
  for (const unit2 of ctx.inputStructure.units) {
    ctx.element.unit = unit2;
    const elements = unit2.elements;
    for (let i = 0, _i = elements.length; i < _i; i++) {
      const e = elements[i];
      ctx.element.element = e;
      const eR = eRadius(ctx);
      if (eR > r)
        r = eR;
    }
  }
  ctx.throwIfTimedOut();
  return r;
}
function includeSurroundings(query2, params) {
  return function query_includeSurroundings(ctx) {
    const inner = query2(ctx);
    if (params.elementRadius) {
      const prms = {
        ...params,
        elementRadius: params.elementRadius,
        elementRadiusClosure: createElementRadiusFn(ctx, params.elementRadius),
        sourceMaxRadius: findStructureRadius(ctx, params.elementRadius)
      };
      if (StructureSelection.isSingleton(inner)) {
        const surr = getIncludeSurroundingsWithRadius(ctx, ctx.inputStructure, inner.structure, prms);
        const ret = StructureSelection.Singletons(ctx.inputStructure, surr);
        return ret;
      } else {
        const builder = new UniqueStructuresBuilder(ctx.inputStructure);
        for (const s of inner.structures) {
          builder.add(getIncludeSurroundingsWithRadius(ctx, ctx.inputStructure, s, prms));
        }
        return builder.getSelection();
      }
    }
    if (StructureSelection.isSingleton(inner)) {
      const surr = getIncludeSurroundings(ctx, ctx.inputStructure, inner.structure, params);
      const ret = StructureSelection.Singletons(ctx.inputStructure, surr);
      return ret;
    } else {
      const builder = new UniqueStructuresBuilder(ctx.inputStructure);
      for (const s of inner.structures) {
        builder.add(getIncludeSurroundings(ctx, ctx.inputStructure, s, params));
      }
      return builder.getSelection();
    }
  };
}
function querySelection2(selection, query2) {
  return function query_querySelection(ctx) {
    const targetSel = selection(ctx);
    if (StructureSelection.structureCount(targetSel) === 0)
      return targetSel;
    const ret = StructureSelection.UniqueBuilder(ctx.inputStructure);
    const add = (s) => ret.add(s);
    StructureSelection.forEach(targetSel, (s, sI) => {
      ctx.pushInputStructure(s);
      StructureSelection.forEach(query2(ctx), add);
      ctx.popInputStructure();
      if (sI % 10 === 0)
        ctx.throwIfTimedOut();
    });
    return ret.getSelection();
  };
}
function intersectBy(query2, by) {
  return function query_intersectBy(ctx) {
    const selection = query2(ctx);
    if (StructureSelection.structureCount(selection) === 0)
      return selection;
    const bySel = by(ctx);
    if (StructureSelection.structureCount(bySel) === 0)
      return StructureSelection.Empty(ctx.inputStructure);
    const unionBy = StructureSelection.unionStructure(bySel);
    const ret = StructureSelection.UniqueBuilder(ctx.inputStructure);
    StructureSelection.forEach(selection, (s, sI) => {
      const ii = structureIntersect(unionBy, s);
      if (ii.elementCount !== 0)
        ret.add(ii);
      if (sI % 50 === 0)
        ctx.throwIfTimedOut();
    });
    return ret.getSelection();
  };
}
function exceptBy(query2, by) {
  return function query_exceptBy(ctx) {
    const selection = query2(ctx);
    if (StructureSelection.structureCount(selection) === 0)
      return selection;
    const bySel = by(ctx);
    if (StructureSelection.structureCount(bySel) === 0)
      return selection;
    const subtractBy = StructureSelection.unionStructure(bySel);
    const ret = StructureSelection.UniqueBuilder(ctx.inputStructure);
    StructureSelection.forEach(selection, (s, sI) => {
      const diff = structureSubtract(s, subtractBy);
      if (diff.elementCount !== 0)
        ret.add(diff);
      if (sI % 50 === 0)
        ctx.throwIfTimedOut();
    });
    return ret.getSelection();
  };
}
function union(query2) {
  return function query_union(ctx) {
    const ret = StructureSelection.LinearBuilder(ctx.inputStructure);
    ret.add(StructureSelection.unionStructure(query2(ctx)));
    return ret.getSelection();
  };
}
function expandProperty(query2, property2) {
  return function query_expandProperty(ctx) {
    const src = query2(ctx);
    const propertyToStructureIndexMap = /* @__PURE__ */ new Map();
    const builders = [];
    ctx.pushCurrentElement();
    StructureSelection.forEach(src, (s, sI) => {
      ctx.element.structure = s;
      for (const unit2 of s.units) {
        ctx.element.unit = unit2;
        const elements = unit2.elements;
        for (let i = 0, _i = elements.length; i < _i; i++) {
          ctx.element.element = elements[i];
          const p3 = property2(ctx);
          let arr;
          if (propertyToStructureIndexMap.has(p3))
            arr = propertyToStructureIndexMap.get(p3);
          else {
            arr = UniqueArray.create();
            propertyToStructureIndexMap.set(p3, arr);
          }
          UniqueArray.add(arr, sI, sI);
        }
      }
      builders[sI] = ctx.inputStructure.subsetBuilder(true);
      if (sI % 10 === 0)
        ctx.throwIfTimedOut();
    });
    ctx.element.structure = ctx.inputStructure;
    for (const unit2 of ctx.inputStructure.units) {
      ctx.element.unit = unit2;
      const elements = unit2.elements;
      for (let i = 0, _i = elements.length; i < _i; i++) {
        ctx.element.element = elements[i];
        const p3 = property2(ctx);
        if (!propertyToStructureIndexMap.has(p3))
          continue;
        const indices = propertyToStructureIndexMap.get(p3).array;
        for (let _sI = 0, __sI = indices.length; _sI < __sI; _sI++) {
          builders[indices[_sI]].addToUnit(unit2.id, elements[i]);
        }
      }
    }
    ctx.popCurrentElement();
    const ret = StructureSelection.UniqueBuilder(ctx.inputStructure);
    for (const b of builders)
      ret.add(b.getStructure());
    return ret.getSelection();
  };
}
function includeConnected({ query: query2, layerCount, wholeResidues: wholeResidues2, bondTest, fixedPoint: fixedPoint2 }) {
  const lc = Math.max(layerCount, 0);
  return function query_includeConnected(ctx) {
    const builder = StructureSelection.UniqueBuilder(ctx.inputStructure);
    const src = query2(ctx);
    ctx.pushCurrentBond();
    ctx.atomicBond.setTestFn(bondTest);
    StructureSelection.forEach(src, (s, sI) => {
      let incl = s;
      if (fixedPoint2) {
        while (true) {
          const prevCount = incl.elementCount;
          incl = includeConnectedStep(ctx, wholeResidues2, incl);
          if (incl.elementCount === prevCount)
            break;
        }
      } else {
        for (let i = 0; i < lc; i++) {
          incl = includeConnectedStep(ctx, wholeResidues2, incl);
        }
      }
      builder.add(incl);
      if (sI % 10 === 0)
        ctx.throwIfTimedOut();
    });
    ctx.popCurrentBond();
    return builder.getSelection();
  };
}
function includeConnectedStep(ctx, wholeResidues2, structure) {
  const expanded = expandConnected(ctx, structure);
  if (wholeResidues2)
    return getWholeResidues(ctx, ctx.inputStructure, expanded);
  return expanded;
}
function expandConnected(ctx, structure) {
  const inputStructure = ctx.inputStructure;
  const interBonds = inputStructure.interUnitBonds;
  const builder = new StructureUniqueSubsetBuilder(inputStructure);
  const atomicBond = ctx.atomicBond;
  for (const unit2 of structure.units) {
    if (unit2.kind !== Unit.Kind.Atomic) {
      builder.beginUnit(unit2.id);
      for (let i = 0, _i = unit2.elements.length; i < _i; i++) {
        builder.addElement(unit2.elements[i]);
      }
      builder.commitUnit();
      continue;
    }
    const inputUnitA = inputStructure.unitMap.get(unit2.id);
    const { offset: intraBondOffset, b: intraBondB, edgeProps: { flags: flags2, order, key } } = inputUnitA.bonds;
    atomicBond.setStructure(inputStructure);
    atomicBond.a.unit = inputUnitA;
    atomicBond.b.unit = inputUnitA;
    for (let i = 0, _i = unit2.elements.length; i < _i; i++) {
      builder.addToUnit(unit2.id, unit2.elements[i]);
      const aIndex = SortedArray.indexOf(inputUnitA.elements, unit2.elements[i]);
      for (let lI = intraBondOffset[aIndex], _lI = intraBondOffset[aIndex + 1]; lI < _lI; lI++) {
        const bIndex = intraBondB[lI];
        const bElement = inputUnitA.elements[bIndex];
        if (SortedArray.has(unit2.elements, bElement) || builder.has(unit2.id, bElement))
          continue;
        atomicBond.aIndex = aIndex;
        atomicBond.a.element = unit2.elements[i];
        atomicBond.bIndex = bIndex;
        atomicBond.b.element = bElement;
        atomicBond.type = flags2[lI];
        atomicBond.order = order[lI];
        atomicBond.key = key[lI];
        if (atomicBond.test(ctx, true)) {
          builder.addToUnit(unit2.id, bElement);
        }
      }
    }
    for (const bondedUnit of interBonds.getConnectedUnits(inputUnitA.id)) {
      const currentUnitB = structure.unitMap.get(bondedUnit.unitB);
      const inputUnitB = inputStructure.unitMap.get(bondedUnit.unitB);
      for (const aI of bondedUnit.connectedIndices) {
        if (!SortedArray.has(unit2.elements, inputUnitA.elements[aI]))
          continue;
        for (const bond of bondedUnit.getEdges(aI)) {
          const bElement = inputUnitB.elements[bond.indexB];
          if (currentUnitB && SortedArray.has(currentUnitB.elements, bElement) || builder.has(bondedUnit.unitB, bElement))
            continue;
          atomicBond.a.unit = inputUnitA;
          atomicBond.aIndex = aI;
          atomicBond.a.element = inputUnitA.elements[aI];
          atomicBond.b.unit = inputUnitB;
          atomicBond.bIndex = bond.indexB;
          atomicBond.b.element = bElement;
          atomicBond.type = bond.props.flag;
          atomicBond.order = bond.props.order;
          atomicBond.key = bond.props.key;
          if (atomicBond.test(ctx, true)) {
            builder.addToUnit(bondedUnit.unitB, bElement);
          }
        }
      }
    }
  }
  return builder.getStructure();
}
function surroundingLigands({ query: query2, radius, includeWater }) {
  const _ent_type = StructureProperties.entity.type;
  function testIsWater(l) {
    return _ent_type(l) === "water";
  }
  return function query_surroundingLigands(ctx) {
    const inner = StructureSelection.unionStructure(query2(ctx));
    const surroundings = getWholeResidues(ctx, ctx.inputStructure, getIncludeSurroundings(ctx, ctx.inputStructure, inner, { radius }));
    const prd = getPrdAsymIdx(ctx.inputStructure);
    const graph = getStructConnInfo(ctx.inputStructure);
    const l = element_exports.Location.create(surroundings);
    const includedPrdChains = /* @__PURE__ */ new Map();
    const componentResidues = new ResidueSet({ checkOperator: true });
    for (const unit2 of surroundings.units) {
      if (unit2.kind !== Unit.Kind.Atomic)
        continue;
      l.unit = unit2;
      const { elements } = unit2;
      const chainsIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.chainAtomSegments, elements);
      const residuesIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.residueAtomSegments, elements);
      while (chainsIt.hasNext) {
        const chainSegment = chainsIt.move();
        l.element = elements[chainSegment.start];
        const asym_id = StructureProperties.chain.label_asym_id(l);
        const op_name = StructureProperties.unit.operator_name(l);
        if (prd.has(asym_id)) {
          if (includedPrdChains.has(asym_id)) {
            arraySetAdd(includedPrdChains.get(asym_id), op_name);
          } else {
            includedPrdChains.set(asym_id, [op_name]);
          }
          continue;
        }
        const entityType = StructureProperties.entity.type(l);
        if (entityType === "water" || entityType === "polymer")
          continue;
        residuesIt.setSegment(chainSegment);
        while (residuesIt.hasNext) {
          const residueSegment = residuesIt.move();
          l.element = elements[residueSegment.start];
          graph.addComponent(ResidueSet.getEntryFromLocation(l), componentResidues);
        }
      }
      ctx.throwIfTimedOut();
    }
    const builder = ctx.inputStructure.subsetBuilder(true);
    for (const unit2 of ctx.inputStructure.units) {
      if (unit2.kind !== Unit.Kind.Atomic)
        continue;
      l.unit = unit2;
      const { elements } = unit2;
      const chainsIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.chainAtomSegments, elements);
      const residuesIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.residueAtomSegments, elements);
      builder.beginUnit(unit2.id);
      while (chainsIt.hasNext) {
        const chainSegment = chainsIt.move();
        l.element = elements[chainSegment.start];
        const asym_id = StructureProperties.chain.label_asym_id(l);
        const op_name = StructureProperties.unit.operator_name(l);
        if (includedPrdChains.has(asym_id) && includedPrdChains.get(asym_id).indexOf(op_name) >= 0) {
          builder.addElementRange(elements, chainSegment.start, chainSegment.end);
          continue;
        }
        if (!componentResidues.hasLabelAsymId(asym_id)) {
          continue;
        }
        residuesIt.setSegment(chainSegment);
        while (residuesIt.hasNext) {
          const residueSegment = residuesIt.move();
          l.element = elements[residueSegment.start];
          if (!componentResidues.has(l))
            continue;
          builder.addElementRange(elements, residueSegment.start, residueSegment.end);
        }
      }
      builder.commitUnit();
      ctx.throwIfTimedOut();
    }
    const components = structureUnion(ctx.inputStructure, [builder.getStructure(), inner]);
    if (includeWater) {
      const finalBuilder = new StructureUniqueSubsetBuilder(ctx.inputStructure);
      const lookup = ctx.inputStructure.lookup3d;
      for (const unit2 of components.units) {
        const c = unit2.conformation;
        const elements = unit2.elements;
        for (let i = 0, _i = elements.length; i < _i; i++) {
          const e = elements[i];
          lookup.findIntoBuilderIf(c.x(e), c.y(e), c.z(e), radius, finalBuilder, testIsWater);
          finalBuilder.addToUnit(unit2.id, e);
        }
        ctx.throwIfTimedOut();
      }
      return StructureSelection.Sequence(ctx.inputStructure, [finalBuilder.getStructure()]);
    } else {
      return StructureSelection.Sequence(ctx.inputStructure, [components]);
    }
  };
}
function getPrdAsymIdx(structure) {
  var _a;
  const model = structure.models[0];
  const ids = /* @__PURE__ */ new Set();
  if (((_a = model.sourceData) === null || _a === void 0 ? void 0 : _a.kind) !== "mmCIF")
    return ids;
  const { _rowCount, asym_id } = model.sourceData.data.db.pdbx_molecule;
  for (let i = 0; i < _rowCount; i++) {
    ids.add(asym_id.value(i));
  }
  return ids;
}
function getStructConnInfo(structure) {
  var _a, _b, _c;
  const model = structure.models[0];
  const graph = new StructConnGraph();
  if (((_a = model.sourceData) === null || _a === void 0 ? void 0 : _a.kind) !== "mmCIF")
    return graph;
  const struct_conn = model.sourceData.data.db.struct_conn;
  const { conn_type_id } = struct_conn;
  const { ptnr1_label_asym_id, ptnr1_label_comp_id, ptnr1_label_seq_id, ptnr1_symmetry, pdbx_ptnr1_label_alt_id, pdbx_ptnr1_PDB_ins_code } = struct_conn;
  const { ptnr2_label_asym_id, ptnr2_label_comp_id, ptnr2_label_seq_id, ptnr2_symmetry, pdbx_ptnr2_label_alt_id, pdbx_ptnr2_PDB_ins_code } = struct_conn;
  for (let i = 0; i < struct_conn._rowCount; i++) {
    const bondType = conn_type_id.value(i);
    if (bondType !== "covale" && bondType !== "metalc")
      continue;
    const a = {
      label_asym_id: ptnr1_label_asym_id.value(i),
      label_comp_id: ptnr1_label_comp_id.value(i),
      label_seq_id: ptnr1_label_seq_id.value(i),
      label_alt_id: pdbx_ptnr1_label_alt_id.value(i),
      ins_code: pdbx_ptnr1_PDB_ins_code.value(i),
      operator_name: (_b = ptnr1_symmetry.value(i)) !== null && _b !== void 0 ? _b : "1_555"
    };
    const b = {
      label_asym_id: ptnr2_label_asym_id.value(i),
      label_comp_id: ptnr2_label_comp_id.value(i),
      label_seq_id: ptnr2_label_seq_id.value(i),
      label_alt_id: pdbx_ptnr2_label_alt_id.value(i),
      ins_code: pdbx_ptnr2_PDB_ins_code.value(i),
      operator_name: (_c = ptnr2_symmetry.value(i)) !== null && _c !== void 0 ? _c : "1_555"
    };
    graph.addEdge(a, b);
  }
  return graph;
}
var StructConnGraph = class {
  constructor() {
    this.vertices = /* @__PURE__ */ new Map();
    this.edges = /* @__PURE__ */ new Map();
  }
  addVertex(e, label) {
    if (this.vertices.has(label))
      return;
    this.vertices.set(label, e);
    this.edges.set(label, []);
  }
  addEdge(a, b) {
    const al = ResidueSet.getLabel(a);
    const bl = ResidueSet.getLabel(b);
    this.addVertex(a, al);
    this.addVertex(b, bl);
    arraySetAdd(this.edges.get(al), bl);
    arraySetAdd(this.edges.get(bl), al);
  }
  addComponent(start, set2) {
    const startLabel = ResidueSet.getLabel(start);
    if (!this.vertices.has(startLabel)) {
      set2.add(start);
      return;
    }
    const visited = /* @__PURE__ */ new Set();
    const added = /* @__PURE__ */ new Set();
    const stack = [startLabel];
    added.add(startLabel);
    set2.add(start);
    while (stack.length > 0) {
      const a = stack.pop();
      visited.add(a);
      const u = this.vertices.get(a);
      for (const b of this.edges.get(a)) {
        if (visited.has(b))
          continue;
        stack.push(b);
        if (added.has(b))
          continue;
        added.add(b);
        const v = this.vertices.get(b);
        if (u.operator_name === v.operator_name) {
          set2.add({ ...v, operator_name: start.operator_name });
        } else {
          set2.add(v);
        }
      }
    }
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/queries/filters.js
var filters_exports = {};
__export(filters_exports, {
  areIntersectedBy: () => areIntersectedBy,
  first: () => first,
  getCurrentStructureProperties: () => getCurrentStructureProperties,
  isConnectedTo: () => isConnectedTo,
  pick: () => pick,
  withSameAtomProperties: () => withSameAtomProperties,
  within: () => within
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/utils/structure-distance.js
function checkStructureMinMaxDistance(ctx, a, b, minDist, maxDist, elementRadius) {
  if (a.elementCount === 0 || b.elementCount === 0)
    return true;
  if (a.elementCount <= b.elementCount)
    return MinMaxDist.check(ctx, a, b, minDist, maxDist, elementRadius);
  return MinMaxDist.check(ctx, b, a, minDist, maxDist, elementRadius);
}
function checkStructureMaxRadiusDistance(ctx, a, b, maxDist, elementRadius) {
  if (a.elementCount === 0 || b.elementCount === 0)
    return true;
  if (a.elementCount <= b.elementCount)
    return MaxRadiusDist.check(ctx, a, b, maxDist, elementRadius);
  return MaxRadiusDist.check(ctx, b, a, maxDist, elementRadius);
}
var MinMaxDist;
(function(MinMaxDist2) {
  let Result2;
  (function(Result3) {
    Result3[Result3["BelowMin"] = 0] = "BelowMin";
    Result3[Result3["WithinMax"] = 1] = "WithinMax";
    Result3[Result3["Miss"] = 2] = "Miss";
  })(Result2 || (Result2 = {}));
  const distVec = Vec3();
  function inUnit(ctx, unit2, p3, eRadius, minDist, maxDist, elementRadius) {
    const { elements, conformation: c } = unit2, dV = distVec;
    ctx.element.unit = unit2;
    let withinRange = false;
    for (let i = 0, _i = elements.length; i < _i; i++) {
      const e = elements[i];
      ctx.element.element = e;
      const d = Math.max(0, Vec3.distance(p3, c.position(e, dV)) - eRadius - elementRadius(ctx));
      if (d < minDist)
        return Result2.BelowMin;
      if (d < maxDist)
        withinRange = true;
    }
    return withinRange ? Result2.WithinMax : Result2.Miss;
  }
  function toPoint(ctx, s, point, radius, minDist, maxDist, elementRadius) {
    const { units } = s;
    let withinRange = false;
    for (let i = 0, _i = units.length; i < _i; i++) {
      const iu = inUnit(ctx, units[i], point, radius, minDist, maxDist, elementRadius);
      if (iu === Result2.BelowMin)
        return Result2.BelowMin;
      if (iu === Result2.WithinMax)
        withinRange = true;
    }
    return withinRange ? Result2.WithinMax : Result2.Miss;
  }
  const distPivot = Vec3();
  function check(ctx, a, b, minDist, maxDist, elementRadius) {
    if (a.elementCount === 0 || b.elementCount === 0)
      return 0;
    const { units } = a;
    let withinRange = false;
    ctx.element.structure = a;
    for (let i = 0, _i = units.length; i < _i; i++) {
      const unit2 = units[i];
      const { elements, conformation: c } = unit2;
      ctx.element.unit = unit2;
      for (let i2 = 0, _i2 = elements.length; i2 < _i2; i2++) {
        const e = elements[i2];
        ctx.element.element = e;
        const tp = toPoint(ctx, b, c.position(e, distPivot), elementRadius(ctx), minDist, maxDist, elementRadius);
        if (tp === Result2.BelowMin)
          return false;
        if (tp === Result2.WithinMax)
          withinRange = true;
      }
    }
    return withinRange;
  }
  MinMaxDist2.check = check;
})(MinMaxDist || (MinMaxDist = {}));
var MaxRadiusDist;
(function(MaxRadiusDist2) {
  const distVec = Vec3();
  function inUnit(ctx, unit2, p3, eRadius, maxDist, elementRadius) {
    const { elements, conformation: c } = unit2, dV = distVec;
    ctx.element.unit = unit2;
    for (let i = 0, _i = elements.length; i < _i; i++) {
      const e = elements[i];
      ctx.element.element = e;
      if (Math.max(0, Vec3.distance(p3, c.position(e, dV)) - eRadius - elementRadius(ctx)) <= maxDist)
        return true;
    }
    return false;
  }
  function toPoint(ctx, s, point, radius, maxDist, elementRadius) {
    const { units } = s;
    for (let i = 0, _i = units.length; i < _i; i++) {
      if (inUnit(ctx, units[i], point, radius, maxDist, elementRadius))
        return true;
    }
    return false;
  }
  const distPivot = Vec3();
  function check(ctx, a, b, maxDist, elementRadius) {
    if (a.elementCount === 0 || b.elementCount === 0)
      return 0;
    const { units } = a;
    ctx.element.structure = a;
    for (let i = 0, _i = units.length; i < _i; i++) {
      const unit2 = units[i];
      ctx.element.unit = unit2;
      const { elements, conformation: c } = unit2;
      for (let i2 = 0, _i2 = elements.length; i2 < _i2; i2++) {
        const e = elements[i2];
        ctx.element.element = e;
        if (toPoint(ctx, b, c.position(e, distPivot), elementRadius(ctx), maxDist, elementRadius))
          return true;
      }
    }
    return false;
  }
  MaxRadiusDist2.check = check;
})(MaxRadiusDist || (MaxRadiusDist = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/queries/filters.js
function pick(query2, pred) {
  return (ctx) => {
    const sel = query2(ctx);
    const ret = StructureSelection.LinearBuilder(ctx.inputStructure);
    ctx.pushCurrentElement();
    StructureSelection.forEach(sel, (s, i) => {
      ctx.currentStructure = s;
      if (pred(ctx))
        ret.add(s);
      if (i % 100)
        ctx.throwIfTimedOut();
    });
    ctx.popCurrentStructure();
    return ret.getSelection();
  };
}
function first(query2) {
  return (ctx) => {
    const sel = query2(ctx);
    const ret = StructureSelection.LinearBuilder(ctx.inputStructure);
    if (sel.kind === "singletons") {
      if (sel.structure.elementCount > 0) {
        const u = sel.structure.units[0];
        const s = Structure.create([u.getChild(SortedArray.ofSingleton(u.elements[0]))], { parent: ctx.inputStructure });
        ret.add(s);
      }
    } else {
      if (sel.structures.length > 0) {
        ret.add(sel.structures[0]);
      }
    }
    return ret.getSelection();
  };
}
function getCurrentStructureProperties(ctx, props, set2) {
  const { units } = ctx.currentStructure;
  const l = ctx.pushCurrentElement();
  l.structure = ctx.currentStructure;
  for (const unit2 of units) {
    l.unit = unit2;
    const elements = unit2.elements;
    const fn = props;
    if (!fn)
      continue;
    for (let j = 0, _j = elements.length; j < _j; j++) {
      l.element = elements[j];
      set2.add(fn(ctx));
    }
    ctx.throwIfTimedOut();
  }
  ctx.popCurrentElement();
  return set2;
}
function getSelectionProperties(ctx, query2, props) {
  const set2 = /* @__PURE__ */ new Set();
  const sel = query2(ctx);
  ctx.pushCurrentElement();
  StructureSelection.forEach(sel, (s, i) => {
    ctx.currentStructure = s;
    getCurrentStructureProperties(ctx, props, set2);
    if (i % 10)
      ctx.throwIfTimedOut();
  });
  ctx.popCurrentElement();
  return set2;
}
function withSameAtomProperties(query2, propertySource, props) {
  return (ctx) => {
    const sel = query2(ctx);
    const propSet = getSelectionProperties(ctx, propertySource, props);
    const ret = StructureSelection.LinearBuilder(ctx.inputStructure);
    ctx.pushCurrentStructure();
    StructureSelection.forEach(sel, (s, i) => {
      ctx.currentStructure = s;
      const currentProps = getCurrentStructureProperties(ctx, props, /* @__PURE__ */ new Set());
      if (SetUtils.isSuperset(propSet, currentProps)) {
        ret.add(s);
      }
      if (i % 10)
        ctx.throwIfTimedOut();
    });
    ctx.popCurrentStructure();
    return ret.getSelection();
  };
}
function areIntersectedBy(query2, by) {
  return (ctx) => {
    const mask = StructureSelection.unionStructure(by(ctx));
    const ret = StructureSelection.LinearBuilder(ctx.inputStructure);
    StructureSelection.forEach(query2(ctx), (s, i) => {
      if (structureAreIntersecting(mask, s))
        ret.add(s);
      if (i % 10)
        ctx.throwIfTimedOut();
    });
    return ret.getSelection();
  };
}
function within(params) {
  return (queryCtx) => {
    const ctx = {
      queryCtx,
      selection: params.query(queryCtx),
      target: params.target(queryCtx),
      maxRadius: params.maxRadius,
      minRadius: params.minRadius ? Math.max(0, params.minRadius) : 0,
      elementRadius: params.elementRadius,
      invert: !!params.invert
    };
    if (ctx.minRadius === 0 && typeof params.minRadius === "undefined") {
      return withinMaxRadiusLookup(ctx);
    } else if (ctx.minRadius === 0) {
      return withinMaxRadius(ctx);
    } else {
      return withinMinMaxRadius(ctx);
    }
  };
}
function withinMaxRadiusLookup({ queryCtx, selection, target, maxRadius, invert }) {
  const targetLookup = StructureSelection.unionStructure(target).lookup3d;
  const ret = StructureSelection.LinearBuilder(queryCtx.inputStructure);
  const pos = Vec3.zero();
  StructureSelection.forEach(selection, (s, sI) => {
    const { units } = s;
    let withinRadius = false;
    for (let i = 0, _i = units.length; i < _i; i++) {
      const unit2 = units[i];
      const { elements, conformation: c } = unit2;
      for (let i2 = 0, _i2 = elements.length; i2 < _i2; i2++) {
        const e = elements[i2];
        c.position(e, pos);
        if (targetLookup.check(pos[0], pos[1], pos[2], maxRadius + c.r(e))) {
          withinRadius = true;
          break;
        }
      }
      if (withinRadius)
        break;
    }
    if (invert)
      withinRadius = !withinRadius;
    if (withinRadius)
      ret.add(s);
    if (sI % 10 === 0)
      queryCtx.throwIfTimedOut();
  });
  return ret.getSelection();
}
function withinMaxRadius({ queryCtx, selection, target, maxRadius, invert, elementRadius }) {
  const targetStructure = StructureSelection.unionStructure(target);
  const ret = StructureSelection.LinearBuilder(queryCtx.inputStructure);
  queryCtx.pushCurrentElement();
  StructureSelection.forEach(selection, (s, sI) => {
    let withinRadius = checkStructureMaxRadiusDistance(queryCtx, targetStructure, s, maxRadius, elementRadius);
    if (invert)
      withinRadius = !withinRadius;
    if (withinRadius)
      ret.add(s);
    if (sI % 10 === 0)
      queryCtx.throwIfTimedOut();
  });
  queryCtx.popCurrentElement();
  return ret.getSelection();
}
function withinMinMaxRadius({ queryCtx, selection, target, minRadius, maxRadius, invert, elementRadius }) {
  const targetStructure = StructureSelection.unionStructure(target);
  const ret = StructureSelection.LinearBuilder(queryCtx.inputStructure);
  queryCtx.pushCurrentElement();
  StructureSelection.forEach(selection, (s, sI) => {
    let withinRadius = checkStructureMinMaxDistance(queryCtx, targetStructure, s, minRadius, maxRadius, elementRadius);
    if (invert)
      withinRadius = !withinRadius;
    if (withinRadius)
      ret.add(s);
    if (sI % 10 === 0)
      queryCtx.throwIfTimedOut();
  });
  queryCtx.popCurrentElement();
  return ret.getSelection();
}
function checkConnected(ctx, structure) {
  const { queryCtx, input, target, disjunct } = ctx;
  const atomicBond = queryCtx.atomicBond;
  const interBonds = input.interUnitBonds;
  atomicBond.setStructure(input);
  for (const unit2 of structure.units) {
    if (!Unit.isAtomic(unit2))
      continue;
    const inputUnit = input.unitMap.get(unit2.id);
    const { offset, b, edgeProps: { flags: flags2, order, key } } = inputUnit.bonds;
    const bondedUnits = interBonds.getConnectedUnits(unit2.id);
    const buCount = bondedUnits.length;
    const srcElements = unit2.elements;
    const inputElements = inputUnit.elements;
    for (let i = 0, _i = srcElements.length; i < _i; i++) {
      const inputIndex = SortedArray.indexOf(inputElements, srcElements[i]);
      atomicBond.a.unit = inputUnit;
      atomicBond.b.unit = inputUnit;
      for (let l = offset[inputIndex], _l = offset[inputIndex + 1]; l < _l; l++) {
        atomicBond.b.element = inputUnit.elements[b[l]];
        if (disjunct && SortedArray.has(unit2.elements, atomicBond.b.element))
          continue;
        if (!target.hasElement(atomicBond.b))
          continue;
        atomicBond.aIndex = inputIndex;
        atomicBond.a.element = srcElements[i];
        atomicBond.bIndex = b[l];
        atomicBond.type = flags2[l];
        atomicBond.order = order[l];
        atomicBond.key = key[l];
        if (atomicBond.test(queryCtx, true))
          return true;
      }
      for (let li = 0; li < buCount; li++) {
        const lu = bondedUnits[li];
        const bUnit = input.unitMap.get(lu.unitB);
        const bElements = bUnit.elements;
        const bonds = lu.getEdges(inputIndex);
        for (let bi = 0, _bi = bonds.length; bi < _bi; bi++) {
          const bond = bonds[bi];
          atomicBond.b.unit = bUnit;
          atomicBond.b.element = bElements[bond.indexB];
          if (!target.hasElement(atomicBond.b))
            continue;
          if (disjunct && structure.hasElement(atomicBond.b))
            continue;
          atomicBond.a.unit = inputUnit;
          atomicBond.aIndex = inputIndex;
          atomicBond.a.element = srcElements[i];
          atomicBond.bIndex = bond.indexB;
          atomicBond.type = bond.props.flag;
          atomicBond.order = bond.props.order;
          atomicBond.key = bond.props.key;
          if (atomicBond.test(queryCtx, true))
            return true;
        }
      }
    }
  }
  return false;
}
function isConnectedTo({ query: query2, target, disjunct, invert, bondTest }) {
  return (ctx) => {
    const targetSel = target(ctx);
    if (StructureSelection.isEmpty(targetSel))
      return targetSel;
    const selection = query2(ctx);
    if (StructureSelection.isEmpty(selection))
      return selection;
    const connCtx = {
      queryCtx: ctx,
      input: ctx.inputStructure,
      disjunct,
      target: StructureSelection.unionStructure(targetSel)
    };
    const ret = StructureSelection.LinearBuilder(ctx.inputStructure);
    ctx.pushCurrentBond();
    ctx.atomicBond.setTestFn(bondTest);
    StructureSelection.forEach(selection, (s, sI) => {
      if (checkConnected(connCtx, s)) {
        ret.add(s);
      } else if (invert) {
        ret.add(s);
      }
      if (sI % 5 === 0)
        ctx.throwIfTimedOut();
    });
    ctx.popCurrentBond();
    return ret.getSelection();
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/queries/combinators.js
var combinators_exports = {};
__export(combinators_exports, {
  intersect: () => intersect,
  merge: () => merge
});
function merge(queries) {
  if (queries.length === 0) {
    return none;
  } else if (queries.length === 1) {
    return queries[0];
  }
  return (ctx) => {
    const ret = StructureSelection.UniqueBuilder(ctx.inputStructure);
    for (let i = 0; i < queries.length; i++) {
      StructureSelection.forEach(queries[i](ctx), (s, j) => {
        ret.add(s);
        if (i % 100)
          ctx.throwIfTimedOut();
      });
    }
    return ret.getSelection();
  };
}
function intersect(queries) {
  if (queries.length === 0) {
    return none;
  } else if (queries.length === 1) {
    return queries[0];
  }
  return (ctx) => {
    const selections = [];
    for (let i = 0; i < queries.length; i++)
      selections.push(queries[i](ctx));
    let pivotIndex = 0, pivotLength = StructureSelection.structureCount(selections[0]);
    for (let i = 1; i < selections.length; i++) {
      const len = StructureSelection.structureCount(selections[i]);
      if (len < pivotLength) {
        pivotIndex = i;
        pivotLength = len;
      }
    }
    ctx.throwIfTimedOut();
    const pivotSet = HashSet((s) => s.hashCode, Structure.areUnitIdsAndIndicesEqual);
    StructureSelection.forEach(selections[pivotIndex], (s) => pivotSet.add(s));
    const ret = StructureSelection.UniqueBuilder(ctx.inputStructure);
    for (let pI = 0; pI < selections.length; pI++) {
      if (pI === pivotIndex)
        continue;
      StructureSelection.forEach(selections[pI], (s) => {
        if (pivotSet.has(s))
          ret.add(s);
      });
      ctx.throwIfTimedOut();
    }
    return ret.getSelection();
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/queries/atom-set.js
var atom_set_exports = {};
__export(atom_set_exports, {
  atomCount: () => atomCount,
  countQuery: () => countQuery,
  propertySet: () => propertySet
});
function atomCount(ctx) {
  return ctx.currentStructure.elementCount;
}
function countQuery(query2) {
  return (ctx) => {
    const sel = query2(ctx);
    return StructureSelection.structureCount(sel);
  };
}
function propertySet(prop) {
  return (ctx) => {
    const set2 = /* @__PURE__ */ new Set();
    return getCurrentStructureProperties(ctx, prop, set2);
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query/predicates.js
var Predicates;
(function(Predicates2) {
  function isSetLike(x) {
    return !!x && !!x.has;
  }
  function eq(p3, value) {
    return (l) => p3(l) === value;
  }
  Predicates2.eq = eq;
  function lt(p3, value) {
    return (l) => p3(l) < value;
  }
  Predicates2.lt = lt;
  function lte(p3, value) {
    return (l) => p3(l) <= value;
  }
  Predicates2.lte = lte;
  function gt(p3, value) {
    return (l) => p3(l) > value;
  }
  Predicates2.gt = gt;
  function gte(p3, value) {
    return (l) => p3(l) >= value;
  }
  Predicates2.gte = gte;
  function _true2(ctx) {
    return true;
  }
  function _false(ctx) {
    return false;
  }
  function inSet(p3, values) {
    if (isSetLike(values)) {
      return (l) => values.has(p3(l));
    } else {
      if (values.length === 0)
        return _false;
      const set2 = /* @__PURE__ */ new Set();
      for (let i = 0; i < values.length; i++)
        set2.add(values[i]);
      return (l) => set2.has(p3(l));
    }
  }
  Predicates2.inSet = inSet;
  function and(...ps) {
    switch (ps.length) {
      case 0:
        return _true2;
      case 1:
        return ps[0];
      case 2: {
        const a = ps[0], b = ps[1];
        return (l) => a(l) && b(l);
      }
      case 3: {
        const a = ps[0], b = ps[1], c = ps[2];
        return (l) => a(l) && b(l) && c(l);
      }
      case 4: {
        const a = ps[0], b = ps[1], c = ps[2], d = ps[3];
        return (l) => a(l) && b(l) && c(l) && d(l);
      }
      case 5: {
        const a = ps[0], b = ps[1], c = ps[2], d = ps[3], e = ps[4];
        return (l) => a(l) && b(l) && c(l) && d(l) && e(l);
      }
      case 6: {
        const a = ps[0], b = ps[1], c = ps[2], d = ps[3], e = ps[4], f = ps[5];
        return (l) => a(l) && b(l) && c(l) && d(l) && e(l) && f(l);
      }
      default: {
        const count = ps.length;
        return (l) => {
          for (let i = 0; i < count; i++)
            if (!ps[i])
              return false;
          return true;
        };
      }
    }
  }
  Predicates2.and = and;
  function or(...ps) {
    switch (ps.length) {
      case 0:
        return _false;
      case 1:
        return ps[0];
      case 2: {
        const a = ps[0], b = ps[1];
        return (l) => a(l) || b(l);
      }
      case 3: {
        const a = ps[0], b = ps[1], c = ps[2];
        return (l) => a(l) || b(l) || c(l);
      }
      case 4: {
        const a = ps[0], b = ps[1], c = ps[2], d = ps[3];
        return (l) => a(l) || b(l) || c(l) || d(l);
      }
      case 5: {
        const a = ps[0], b = ps[1], c = ps[2], d = ps[3], e = ps[4];
        return (l) => a(l) || b(l) || c(l) || d(l) || e(l);
      }
      case 6: {
        const a = ps[0], b = ps[1], c = ps[2], d = ps[3], e = ps[4], f = ps[5];
        return (l) => a(l) || b(l) || c(l) || d(l) || e(l) || f(l);
      }
      default: {
        const count = ps.length;
        return (l) => {
          for (let i = 0; i < count; i++)
            if (ps[i])
              return true;
          return false;
        };
      }
    }
  }
  Predicates2.or = or;
})(Predicates || (Predicates = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/query.js
var Queries = {
  generators: generators_exports,
  filters: filters_exports,
  modifiers: modifiers_exports,
  combinators: combinators_exports,
  pred: Predicates,
  internal: internal_exports,
  atomset: atom_set_exports
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/symmetry.js
var StructureSymmetry;
(function(StructureSymmetry2) {
  function buildAssembly(structure, asmName) {
    return Task.create("Build Assembly", async (ctx) => {
      const models = structure.models;
      if (models.length !== 1)
        throw new Error("Can only build assemblies from structures based on 1 model.");
      const assembly = Symmetry.findAssembly(models[0], asmName);
      if (!assembly)
        throw new Error(`Assembly '${asmName}' is not defined.`);
      const coordinateSystem = SymmetryOperator.create(assembly.id, Mat4.identity(), { assembly: { id: assembly.id, operId: 0, operList: [] } });
      const assembler = Structure.Builder({
        coordinateSystem,
        label: structure.label,
        dynamicBonds: structure.dynamicBonds
      });
      const queryCtx = new QueryContext(structure);
      for (const g of assembly.operatorGroups) {
        const selection = g.selector(queryCtx);
        if (StructureSelection.structureCount(selection) === 0) {
          continue;
        }
        const { units } = StructureSelection.unionStructure(selection);
        for (const oper of g.operators) {
          for (const unit2 of units) {
            assembler.addWithOperator(unit2, oper);
          }
        }
      }
      return assembler.getStructure();
    });
  }
  StructureSymmetry2.buildAssembly = buildAssembly;
  function buildSymmetryAssembly(structure, generators, symmetry) {
    return Task.create("Build Symmetry Assembly", async (ctx) => {
      const models = structure.models;
      if (models.length !== 1)
        throw new Error("Can only build symmetry assemblies from structures based on 1 model.");
      const modelCenter = Vec3();
      const assembler = Structure.Builder({
        label: structure.label,
        representativeModel: models[0],
        dynamicBonds: structure.dynamicBonds
      });
      const queryCtx = new QueryContext(structure);
      for (const g of generators) {
        const selector = getSelector(g.asymIds);
        const selection = selector(queryCtx);
        if (StructureSelection.structureCount(selection) === 0) {
          continue;
        }
        const { units } = StructureSelection.unionStructure(selection);
        for (const { index, shift: [i, j, k] } of g.operators) {
          const operators = getOperatorsForIndex(symmetry, index, i, j, k, modelCenter);
          for (const unit2 of units) {
            for (const op of operators) {
              assembler.addWithOperator(unit2, op);
            }
          }
        }
      }
      return assembler.getStructure();
    });
  }
  StructureSymmetry2.buildSymmetryAssembly = buildSymmetryAssembly;
  function builderSymmetryMates(structure, radius) {
    return Task.create("Find Symmetry Mates", (ctx) => findMatesRadius(ctx, structure, radius));
  }
  StructureSymmetry2.builderSymmetryMates = builderSymmetryMates;
  function buildSymmetryRange(structure, ijkMin, ijkMax) {
    return Task.create("Build Symmetry", (ctx) => findSymmetryRange(ctx, structure, ijkMin, ijkMax));
  }
  StructureSymmetry2.buildSymmetryRange = buildSymmetryRange;
  function buildNcs(structure) {
    return Task.create("Build NCS", (ctx) => _buildNCS(ctx, structure));
  }
  StructureSymmetry2.buildNcs = buildNcs;
  function areUnitsEquivalent(a, b) {
    return a.invariantId === b.invariantId && a.model.id === b.model.id && SortedArray.areEqual(a.elements, b.elements);
  }
  StructureSymmetry2.areUnitsEquivalent = areUnitsEquivalent;
  function UnitEquivalenceBuilder() {
    return EquivalenceClasses(Unit.hashUnit, areUnitsEquivalent);
  }
  StructureSymmetry2.UnitEquivalenceBuilder = UnitEquivalenceBuilder;
  function computeTransformGroups(s) {
    const groups = UnitEquivalenceBuilder();
    for (const u of s.units)
      groups.add(u.id, u);
    const ret = [];
    for (const eqUnits of groups.groups) {
      ret.push(Unit.SymmetryGroup(eqUnits.map((id) => s.unitMap.get(id))));
    }
    return ret;
  }
  StructureSymmetry2.computeTransformGroups = computeTransformGroups;
  function areTransformGroupsEquivalent(a, b) {
    if (a.length !== b.length)
      return false;
    for (let i = 0, il = a.length; i < il; ++i) {
      const au = a[i].units, bu = b[i].units;
      if (au.length !== bu.length)
        return false;
      if (a[i].hashCode !== b[i].hashCode)
        return false;
      for (let j = 0, _j = au.length; j < _j; j++) {
        if (au[j].conformation !== bu[j].conformation)
          return false;
      }
    }
    return true;
  }
  StructureSymmetry2.areTransformGroupsEquivalent = areTransformGroupsEquivalent;
})(StructureSymmetry || (StructureSymmetry = {}));
function getSelector(asymIds) {
  return Queries.generators.atoms({ chainTest: Queries.pred.and(Queries.pred.eq((ctx) => StructureProperties.unit.operator_name(ctx.element), SymmetryOperator.DefaultName), Queries.pred.inSet((ctx) => StructureProperties.chain.label_asym_id(ctx.element), asymIds)) });
}
function getOperatorsForIndex(symmetry, index, i, j, k, modelCenter) {
  const { spacegroup, ncsOperators } = symmetry;
  const operators = [];
  const { toFractional } = spacegroup.cell;
  const ref = Vec3.transformMat4(Vec3(), modelCenter, toFractional);
  const symOp = Spacegroup.getSymmetryOperatorRef(spacegroup, index, i, j, k, ref);
  if (ncsOperators && ncsOperators.length) {
    for (let u = 0, ul = ncsOperators.length; u < ul; ++u) {
      const ncsOp = ncsOperators[u];
      const matrix = Mat4.mul(Mat4(), symOp.matrix, ncsOp.matrix);
      const operator = SymmetryOperator.create(`${symOp.name} ${ncsOp.name}`, matrix, {
        assembly: symOp.assembly,
        ncsId: ncsOp.ncsId,
        hkl: symOp.hkl,
        spgrOp: symOp.spgrOp
      });
      operators.push(operator);
    }
  } else {
    operators.push(symOp);
  }
  return operators;
}
function getOperatorsForRange(symmetry, ijkMin, ijkMax, modelCenter) {
  const { spacegroup, ncsOperators } = symmetry;
  const ncsCount = ncsOperators && ncsOperators.length || 0;
  const operators = [];
  if (!ncsCount && ijkMin[0] <= 0 && ijkMax[0] >= 0 && ijkMin[1] <= 0 && ijkMax[1] >= 0 && ijkMin[2] <= 0 && ijkMax[2] >= 0) {
    operators[0] = Spacegroup.getSymmetryOperator(spacegroup, 0, 0, 0, 0);
  }
  for (let op = 0; op < spacegroup.operators.length; op++) {
    for (let i = ijkMin[0]; i <= ijkMax[0]; i++) {
      for (let j = ijkMin[1]; j <= ijkMax[1]; j++) {
        for (let k = ijkMin[2]; k <= ijkMax[2]; k++) {
          if (!ncsCount && op === 0 && i === 0 && j === 0 && k === 0)
            continue;
          operators.push(...getOperatorsForIndex(symmetry, op, i, j, k, modelCenter));
        }
      }
    }
  }
  return operators;
}
function getOperatorsCached333(symmetry, ref) {
  if (symmetry._operators_333 && Vec3.equals(ref, symmetry._operators_333.ref)) {
    return symmetry._operators_333.operators;
  }
  symmetry._operators_333 = {
    ref: Vec3.clone(ref),
    operators: getOperatorsForRange(symmetry, Vec3.create(-3, -3, -3), Vec3.create(3, 3, 3), ref)
  };
  return symmetry._operators_333.operators;
}
function assembleOperators(structure, operators) {
  const assembler = Structure.Builder({
    label: structure.label,
    dynamicBonds: structure.dynamicBonds
  });
  const { units } = structure;
  for (const oper of operators) {
    for (const unit2 of units) {
      assembler.addWithOperator(unit2, oper);
    }
  }
  return assembler.getStructure();
}
async function _buildNCS(ctx, structure) {
  const models = structure.models;
  if (models.length !== 1)
    throw new Error("Can only build NCS from structures based on 1 model.");
  const symmetry = ModelSymmetry.Provider.get(models[0]);
  if (!symmetry)
    return structure;
  const operators = symmetry.ncsOperators;
  if (!operators || !operators.length)
    return structure;
  return assembleOperators(structure, operators);
}
async function findSymmetryRange(ctx, structure, ijkMin, ijkMax) {
  const models = structure.models;
  if (models.length !== 1)
    throw new Error("Can only build symmetries from structures based on 1 model.");
  const symmetry = ModelSymmetry.Provider.get(models[0]);
  if (!symmetry)
    return structure;
  const { spacegroup } = symmetry;
  if (SpacegroupCell.isZero(spacegroup.cell))
    return structure;
  const modelCenter = Model.getCenter(models[0]);
  const operators = getOperatorsForRange(symmetry, ijkMin, ijkMax, modelCenter);
  return assembleOperators(structure, operators);
}
async function findMatesRadius(ctx, structure, radius) {
  const models = structure.models;
  if (models.length !== 1)
    throw new Error("Can only build symmetries from structures based on 1 model.");
  const symmetry = ModelSymmetry.Provider.get(models[0]);
  if (!symmetry)
    return structure;
  const { spacegroup } = symmetry;
  if (SpacegroupCell.isZero(spacegroup.cell))
    return structure;
  if (ctx.shouldUpdate)
    await ctx.update("Initialing...");
  const modelCenter = Model.getCenter(models[0]);
  const operators = getOperatorsCached333(symmetry, modelCenter);
  const lookup = structure.lookup3d;
  const added = /* @__PURE__ */ new Set();
  function hash(unit2, oper) {
    return `${unit2.invariantId}|${oper.name}`;
  }
  const assembler = Structure.Builder({
    label: structure.label,
    dynamicBonds: structure.dynamicBonds
  });
  const { units } = structure;
  const center = Vec3.zero();
  for (const oper of operators) {
    for (const unit2 of units) {
      const boundingSphere = unit2.lookup3d.boundary.sphere;
      Vec3.transformMat4(center, boundingSphere.center, oper.matrix);
      const closeUnits = lookup.findUnitIndices(center[0], center[1], center[2], boundingSphere.radius + radius);
      for (let uI = 0, _uI = closeUnits.count; uI < _uI; uI++) {
        const closeUnit = units[closeUnits.indices[uI]];
        if (!closeUnit.lookup3d.check(center[0], center[1], center[2], boundingSphere.radius + radius))
          continue;
        const h = hash(unit2, oper);
        if (!added.has(h)) {
          assembler.addWithOperator(unit2, oper);
          added.add(h);
        }
      }
    }
    if (ctx.shouldUpdate)
      await ctx.update("Building symmetry...");
  }
  return assembler.getStructure();
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/util/subset-builder.js
var StructureSubsetBuilder = class {
  addToUnit(parentId, e) {
    const unit2 = this.unitMap.get(parentId);
    if (!!unit2) {
      unit2[unit2.length] = e;
    } else {
      this.unitMap.set(parentId, [e]);
      this.ids[this.ids.length] = parentId;
    }
    this.elementCount++;
  }
  beginUnit(parentId) {
    this.parentId = parentId;
    this.currentUnit = this.currentUnit.length > 0 ? [] : this.currentUnit;
  }
  addElement(e) {
    this.currentUnit[this.currentUnit.length] = e;
    this.elementCount++;
  }
  addElementRange(elements, start, end) {
    for (let i = start; i < end; i++) {
      this.currentUnit[this.currentUnit.length] = elements[i];
      this.elementCount++;
    }
  }
  commitUnit() {
    if (this.currentUnit.length === 0)
      return;
    this.ids[this.ids.length] = this.parentId;
    this.unitMap.set(this.parentId, this.currentUnit);
    this.parentId = -1;
  }
  setUnit(parentId, elements) {
    this.ids[this.ids.length] = parentId;
    this.unitMap.set(parentId, elements);
    this.elementCount += elements.length;
  }
  _getStructure(deduplicateElements) {
    if (this.isEmpty)
      return Structure.Empty;
    const newUnits = [];
    sortArray(this.ids);
    const symmGroups = StructureSymmetry.UnitEquivalenceBuilder();
    for (let i = 0, _i = this.ids.length; i < _i; i++) {
      const id = this.ids[i];
      const parent = this.parent.unitMap.get(id);
      let unit2 = this.unitMap.get(id);
      let sorted = false;
      if (deduplicateElements) {
        if (!this.isSorted)
          sortArray(unit2);
        unit2 = SortedArray.deduplicate(SortedArray.ofSortedArray(this.currentUnit));
        sorted = true;
      }
      const l = unit2.length;
      if (unit2.length === parent.elements.length) {
        newUnits[newUnits.length] = parent;
        symmGroups.add(parent.id, parent);
        continue;
      }
      if (!this.isSorted && !sorted && l > 1)
        sortArray(unit2);
      let child = parent.getChild(SortedArray.ofSortedArray(unit2));
      const pivot = symmGroups.add(child.id, child);
      if (child !== pivot)
        child = pivot.applyOperator(child.id, child.conformation.operator, true);
      newUnits[newUnits.length] = child;
    }
    return Structure.create(newUnits, { parent: this.parent });
  }
  getStructure() {
    return this._getStructure(false);
  }
  getStructureDeduplicate() {
    return this._getStructure(true);
  }
  setSingletonLocation(location) {
    const id = this.ids[0];
    location.unit = this.parent.unitMap.get(id);
    location.element = this.unitMap.get(id)[0];
  }
  get isEmpty() {
    return this.elementCount === 0;
  }
  constructor(parent, isSorted) {
    this.parent = parent;
    this.isSorted = isSorted;
    this.ids = [];
    this.unitMap = IntMap.Mutable();
    this.parentId = -1;
    this.currentUnit = [];
    this.elementCount = 0;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-data/util/combination.js
function P(m, n) {
  let p3 = 1;
  while (n--)
    p3 *= m--;
  return p3;
}
function C(m, n) {
  if (n > m)
    return 0;
  return P(m, n) / P(n, n);
}
function nextIndex(n) {
  const smallest = n & -n;
  const ripple = n + smallest;
  const newSmallest = ripple & -ripple;
  const ones = (newSmallest / smallest >> 1) - 1;
  return ripple | ones;
}
var CombinationIterator = class {
  move() {
    if (this.hasNext) {
      let i = 0, j = 0, n = this.index;
      for (; n; n >>>= 1, i++) {
        if (n & 1)
          this.value[j++] = this.array[i];
      }
      this.index = nextIndex(this.index);
      this.hasNext = this.index < this.maxIndex;
    }
    return this.value;
  }
  constructor(array2, count) {
    this.array = array2;
    this.hasNext = false;
    this.index = (1 << count) - 1;
    this.size = C(array2.length, count);
    this.maxIndex = 1 << array2.length, this.value = new Array(count);
    this.hasNext = count > 0 && count <= array2.length;
  }
};
function combinations(array2, count) {
  const out = [];
  const combinationIt = new CombinationIterator(array2, count);
  while (combinationIt.hasNext)
    out.push(combinationIt.move().slice());
  return out;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/carbohydrates/data.js
var EmptyArray = [];
var EmptyCarbohydrates = {
  links: EmptyArray,
  terminalLinks: EmptyArray,
  elements: EmptyArray,
  partialElements: EmptyArray,
  getElementIndices: () => EmptyArray,
  getLinkIndices: () => EmptyArray,
  getTerminalLinkIndices: () => EmptyArray
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/carbohydrates/compute.js
var C2 = ElementSymbol("C");
var O = ElementSymbol("O");
var SugarRingFps = [
  UnitRing.elementFingerprint([C2, C2, C2, O]),
  UnitRing.elementFingerprint([C2, C2, C2, C2, O]),
  UnitRing.elementFingerprint([C2, C2, C2, C2, C2, O]),
  UnitRing.elementFingerprint([C2, C2, C2, C2, C2, C2, O])
];
function getAnomericCarbon(unit2, ringAtoms) {
  let indexHasTwoOxygen = -1, indexHasOxygenAndCarbon = -1, indexHasC1Name = -1, indexIsCarbon = -1;
  const { elements } = unit2;
  const { type_symbol, label_atom_id } = unit2.model.atomicHierarchy.atoms;
  const { b: neighbor, offset } = unit2.bonds;
  for (let i = 0, il = ringAtoms.length; i < il; ++i) {
    const ei = elements[ringAtoms[i]];
    if (type_symbol.value(ei) !== C2)
      continue;
    let linkedOxygenCount = 0;
    let linkedCarbonCount = 0;
    for (let j = offset[ringAtoms[i]], jl = offset[ringAtoms[i] + 1]; j < jl; ++j) {
      const ej = elements[neighbor[j]];
      const typeSymbol = type_symbol.value(ej);
      if (typeSymbol === O)
        ++linkedOxygenCount;
      else if (typeSymbol === C2)
        ++linkedCarbonCount;
    }
    if (linkedOxygenCount === 2) {
      indexHasTwoOxygen = ei;
      break;
    } else if (linkedOxygenCount === 1 && linkedCarbonCount === 1) {
      indexHasOxygenAndCarbon = ei;
    } else if (label_atom_id.value(ei).startsWith("C1")) {
      indexHasC1Name = ei;
    } else {
      indexIsCarbon = ei;
    }
  }
  return indexHasTwoOxygen !== -1 ? indexHasTwoOxygen : indexHasOxygenAndCarbon !== -1 ? indexHasOxygenAndCarbon : indexHasC1Name !== -1 ? indexHasC1Name : indexIsCarbon !== -1 ? indexIsCarbon : elements[ringAtoms[0]];
}
function getAltId(unit2, index) {
  const { elements } = unit2;
  const { label_alt_id } = unit2.model.atomicHierarchy.atoms;
  return label_alt_id.value(elements[index]);
}
function getDirection(direction, unit2, index, center) {
  const c = unit2.conformation;
  Vec3.normalize(direction, Vec3.sub(direction, center, c.position(index, direction)));
  return direction;
}
function getAtomId(unit2, index) {
  const { elements } = unit2;
  const { label_atom_id } = unit2.model.atomicHierarchy.atoms;
  return label_atom_id.value(elements[index]);
}
function filterFusedRings(unitRings, rings2) {
  if (!rings2 || !rings2.length)
    return;
  const { unit: unit2, all: all2 } = unitRings;
  const fusedRings = /* @__PURE__ */ new Set();
  const ringCombinations = combinations(fillSerial(new Array(rings2.length)), 2);
  for (let i = 0, il = ringCombinations.length; i < il; ++i) {
    const rc = ringCombinations[i];
    const r0 = all2[rings2[rc[0]]], r1 = all2[rings2[rc[1]]];
    if (SortedArray.areIntersecting(r0, r1) && UnitRing.getAltId(unit2, r0) === UnitRing.getAltId(unit2, r1)) {
      fusedRings.add(rings2[rc[0]]);
      fusedRings.add(rings2[rc[1]]);
    }
  }
  if (fusedRings.size) {
    const filteredRings = [];
    for (let i = 0, il = rings2.length; i < il; ++i) {
      if (!fusedRings.has(rings2[i]))
        filteredRings.push(rings2[i]);
    }
    return filteredRings;
  } else {
    return rings2;
  }
}
function getSaccharideComp(compId2, model) {
  return model.properties.saccharideComponentMap.get(compId2);
}
function computeCarbohydrates(structure) {
  if (structure.models.reduce((a, v) => a + v.properties.saccharideComponentMap.size, 0) === 0)
    return EmptyCarbohydrates;
  const links = [];
  const terminalLinks = [];
  const elements = [];
  const partialElements = [];
  const elementsWithRingMap = /* @__PURE__ */ new Map();
  function ringElementKey(residueIndex2, unitId, altId) {
    return `${residueIndex2}|${unitId}|${altId}`;
  }
  function addRingElement(key, elementIndex) {
    if (elementsWithRingMap.has(key))
      elementsWithRingMap.get(key).push(elementIndex);
    else
      elementsWithRingMap.set(key, [elementIndex]);
  }
  function fixLinkDirection(iA, iB) {
    Vec3.sub(elements[iA].geometry.direction, elements[iB].geometry.center, elements[iA].geometry.center);
    Vec3.normalize(elements[iA].geometry.direction, elements[iA].geometry.direction);
  }
  const tmpV = Vec3();
  function fixTerminalLinkDirection(iA, indexB, unitB) {
    const c = unitB.conformation, geo = elements[iA].geometry;
    Vec3.sub(geo.direction, c.position(unitB.elements[indexB], tmpV), geo.center);
    Vec3.normalize(geo.direction, geo.direction);
  }
  for (let i = 0, il = structure.units.length; i < il; ++i) {
    const unit2 = structure.units[i];
    if (!Unit.isAtomic(unit2))
      continue;
    const { model, rings: rings2 } = unit2;
    const { chainAtomSegments, residueAtomSegments, atoms: atoms2 } = model.atomicHierarchy;
    const { label_comp_id } = atoms2;
    const chainIt = Segmentation.transientSegments(chainAtomSegments, unit2.elements);
    const residueIt = Segmentation.transientSegments(residueAtomSegments, unit2.elements);
    let sugarResidueMap = void 0;
    while (chainIt.hasNext) {
      residueIt.setSegment(chainIt.move());
      while (residueIt.hasNext) {
        const { index: residueIndex2 } = residueIt.move();
        const saccharideComp = getSaccharideComp(label_comp_id.value(residueAtomSegments.offsets[residueIndex2]), model);
        if (!saccharideComp)
          continue;
        if (!sugarResidueMap) {
          sugarResidueMap = UnitRings.byFingerprintAndResidue(rings2, SugarRingFps);
        }
        const sugarRings = filterFusedRings(rings2, sugarResidueMap.get(residueIndex2));
        if (!sugarRings || !sugarRings.length) {
          partialElements.push({ unit: unit2, residueIndex: residueIndex2, component: saccharideComp });
          continue;
        }
        const ringElements = [];
        for (let j = 0, jl = sugarRings.length; j < jl; ++j) {
          const ringAtoms = rings2.all[sugarRings[j]];
          const anomericCarbon = getAnomericCarbon(unit2, ringAtoms);
          const ma = PrincipalAxes.calculateMomentsAxes(getPositions(unit2, ringAtoms));
          const a = PrincipalAxes.calculateNormalizedAxes(ma);
          const center = Vec3.copy(Vec3(), a.origin);
          const normal = Vec3.copy(Vec3(), a.dirC);
          const direction = getDirection(Vec3(), unit2, anomericCarbon, center);
          Vec3.orthogonalize(direction, normal, direction);
          const ringAltId = UnitRing.getAltId(unit2, ringAtoms);
          const elementIndex = elements.length;
          ringElements.push(elementIndex);
          addRingElement(ringElementKey(residueIndex2, unit2.id, ringAltId), elementIndex);
          if (ringAltId)
            addRingElement(ringElementKey(residueIndex2, unit2.id, ""), elementIndex);
          elements.push({
            geometry: { center, normal, direction },
            component: saccharideComp,
            ringIndex: sugarRings[j],
            altId: ringAltId,
            unit: unit2,
            residueIndex: residueIndex2
          });
        }
        const ringCombinations = combinations(fillSerial(new Array(sugarRings.length)), 2);
        for (let j = 0, jl = ringCombinations.length; j < jl; ++j) {
          const rc = ringCombinations[j];
          const r0 = rings2.all[sugarRings[rc[0]]], r1 = rings2.all[sugarRings[rc[1]]];
          if (IntAdjacencyGraph.areVertexSetsConnected(unit2.bonds, r0, r1, 3)) {
            const re0 = ringElements[rc[0]];
            const re1 = ringElements[rc[1]];
            if (elements[re0].altId === elements[re1].altId) {
              fixLinkDirection(re0, re1);
              fixLinkDirection(re1, re0);
              links.push({ carbohydrateIndexA: re0, carbohydrateIndexB: re1 });
              links.push({ carbohydrateIndexA: re1, carbohydrateIndexB: re0 });
            }
          }
        }
      }
    }
  }
  function getRingElementIndices(unit2, index) {
    return elementsWithRingMap.get(ringElementKey(unit2.getResidueIndex(index), unit2.id, getAltId(unit2, index))) || [];
  }
  for (let i = 0, il = elements.length; i < il; ++i) {
    const cA = elements[i];
    const { unit: unit2 } = cA;
    for (let j = i + 1; j < il; ++j) {
      const cB = elements[j];
      if (unit2 !== cB.unit || cA.residueIndex === cB.residueIndex)
        continue;
      const rA = unit2.rings.all[cA.ringIndex];
      const rB = unit2.rings.all[cB.ringIndex];
      if (IntAdjacencyGraph.areVertexSetsConnected(unit2.bonds, rA, rB, 3)) {
        fixLinkDirection(i, j);
        fixLinkDirection(j, i);
        links.push({ carbohydrateIndexA: i, carbohydrateIndexB: j });
        links.push({ carbohydrateIndexA: j, carbohydrateIndexB: i });
      }
    }
  }
  for (let i = 0, il = structure.units.length; i < il; ++i) {
    const unit2 = structure.units[i];
    if (!Unit.isAtomic(unit2))
      continue;
    structure.interUnitBonds.getConnectedUnits(unit2.id).forEach((pairBonds) => {
      pairBonds.connectedIndices.forEach((indexA) => {
        pairBonds.getEdges(indexA).forEach(({ props, indexB }) => {
          if (!BondType.isCovalent(props.flag))
            return;
          const unitA = structure.unitMap.get(pairBonds.unitA);
          const unitB = structure.unitMap.get(pairBonds.unitB);
          const ringElementIndicesA = getRingElementIndices(unitA, indexA);
          const ringElementIndicesB = getRingElementIndices(unitB, indexB);
          if (ringElementIndicesA.length > 0 && ringElementIndicesB.length > 0) {
            const lA = ringElementIndicesA.length;
            const lB = ringElementIndicesB.length;
            for (let j = 0, jl = Math.max(lA, lB); j < jl; ++j) {
              const ringElementIndexA = ringElementIndicesA[Math.min(j, lA - 1)];
              const ringElementIndexB = ringElementIndicesB[Math.min(j, lB - 1)];
              const atomIdA = getAtomId(unitA, indexA);
              if (atomIdA.startsWith("O1") || atomIdA.startsWith("C1")) {
                fixLinkDirection(ringElementIndexA, ringElementIndexB);
              }
              links.push({
                carbohydrateIndexA: ringElementIndexA,
                carbohydrateIndexB: ringElementIndexB
              });
            }
          } else if (ringElementIndicesB.length === 0) {
            for (const ringElementIndexA of ringElementIndicesA) {
              const atomIdA = getAtomId(unitA, indexA);
              if (atomIdA.startsWith("O1") || atomIdA.startsWith("C1")) {
                fixTerminalLinkDirection(ringElementIndexA, indexB, unitB);
              }
              terminalLinks.push({
                carbohydrateIndex: ringElementIndexA,
                elementIndex: indexB,
                elementUnit: unitB,
                fromCarbohydrate: true
              });
            }
          } else if (ringElementIndicesA.length === 0) {
            for (const ringElementIndexB of ringElementIndicesB) {
              terminalLinks.push({
                carbohydrateIndex: ringElementIndexB,
                elementIndex: indexA,
                elementUnit: unitA,
                fromCarbohydrate: false
              });
            }
          }
        });
      });
    });
  }
  return { links, terminalLinks, elements, partialElements, ...buildLookups(elements, links, terminalLinks) };
}
function buildLookups(elements, links, terminalLinks) {
  function key(unit2, element) {
    return cantorPairing(unit2.id, element);
  }
  function getIndices(map2, unit2, index) {
    const indices = [];
    const il = map2.get(key(unit2, index));
    if (il !== void 0) {
      for (const i of il)
        arraySetAdd(indices, i);
    }
    return indices;
  }
  const elementsMap = /* @__PURE__ */ new Map();
  for (let i = 0, il = elements.length; i < il; ++i) {
    const { unit: unit2, ringIndex } = elements[i];
    const ring = unit2.rings.all[ringIndex];
    for (let j = 0, jl = ring.length; j < jl; ++j) {
      const k = key(unit2, unit2.elements[ring[j]]);
      const e = elementsMap.get(k);
      if (e === void 0)
        elementsMap.set(k, [i]);
      else
        e.push(i);
    }
  }
  function getElementIndices(unit2, index) {
    return getIndices(elementsMap, unit2, index);
  }
  const linksMap = /* @__PURE__ */ new Map();
  for (let i = 0, il = links.length; i < il; ++i) {
    const l = links[i];
    const { unit: unit2, ringIndex } = elements[l.carbohydrateIndexA];
    const ring = unit2.rings.all[ringIndex];
    for (let j = 0, jl = ring.length; j < jl; ++j) {
      const k = key(unit2, unit2.elements[ring[j]]);
      const e = linksMap.get(k);
      if (e === void 0)
        linksMap.set(k, [i]);
      else
        e.push(i);
    }
  }
  function getLinkIndices(unit2, index) {
    return getIndices(linksMap, unit2, index);
  }
  const terminalLinksMap = /* @__PURE__ */ new Map();
  for (let i = 0, il = terminalLinks.length; i < il; ++i) {
    const { fromCarbohydrate, carbohydrateIndex, elementUnit, elementIndex } = terminalLinks[i];
    if (fromCarbohydrate) {
      const { unit: unit2, ringIndex } = elements[carbohydrateIndex];
      const ring = unit2.rings.all[ringIndex];
      for (let j = 0, jl = ring.length; j < jl; ++j) {
        const k = key(unit2, unit2.elements[ring[j]]);
        const e = terminalLinksMap.get(k);
        if (e === void 0)
          terminalLinksMap.set(k, [i]);
        else
          e.push(i);
      }
    } else {
      const k = key(elementUnit, elementUnit.elements[elementIndex]);
      const e = terminalLinksMap.get(k);
      if (e === void 0)
        terminalLinksMap.set(k, [i]);
      else
        e.push(i);
    }
  }
  function getTerminalLinkIndices(unit2, index) {
    return getIndices(terminalLinksMap, unit2, index);
  }
  return { getElementIndices, getLinkIndices, getTerminalLinkIndices };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/util/boundary.js
var tmpSphere = Sphere3D();
var boundaryHelperCoarse2 = new BoundaryHelper("14");
var boundaryHelperFine2 = new BoundaryHelper("98");
function getBoundaryHelper2(count) {
  return count > 500 ? boundaryHelperCoarse2 : boundaryHelperFine2;
}
function computeStructureBoundary(s) {
  const { units } = s;
  const boundaryHelper = getBoundaryHelper2(units.length);
  boundaryHelper.reset();
  for (let i = 0, _i = units.length; i < _i; i++) {
    const u = units[i];
    const invariantBoundary = u.boundary;
    const o = u.conformation.operator;
    if (o.isIdentity) {
      boundaryHelper.includeSphere(invariantBoundary.sphere);
    } else {
      Sphere3D.transform(tmpSphere, invariantBoundary.sphere, o.matrix);
      boundaryHelper.includeSphere(tmpSphere);
    }
  }
  boundaryHelper.finishedIncludeStep();
  for (let i = 0, _i = units.length; i < _i; i++) {
    const u = units[i];
    const invariantBoundary = u.boundary;
    const o = u.conformation.operator;
    if (o.isIdentity) {
      boundaryHelper.radiusSphere(invariantBoundary.sphere);
    } else {
      Sphere3D.transform(tmpSphere, invariantBoundary.sphere, o.matrix);
      boundaryHelper.radiusSphere(tmpSphere);
    }
  }
  return { box: boundaryHelper.getBox(), sphere: boundaryHelper.getSphere() };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/mapping.js
function getSerialMapping(structure) {
  const { units, elementCount, unitIndexMap } = structure;
  const cumulativeUnitElementCount = new Uint32Array(units.length);
  const unitIndices = new Uint32Array(elementCount);
  const elementIndices = new Uint32Array(elementCount);
  for (let i = 0, m = 0, il = units.length; i < il; ++i) {
    cumulativeUnitElementCount[i] = m;
    const { elements } = units[i];
    for (let j = 0, jl = elements.length; j < jl; ++j) {
      const mj = m + j;
      unitIndices[mj] = i;
      elementIndices[mj] = elements[j];
    }
    m += elements.length;
  }
  return {
    cumulativeUnitElementCount,
    unitIndices,
    elementIndices,
    getSerialIndex: (unit2, element) => cumulativeUnitElementCount[unitIndexMap.get(unit2.id)] + OrderedSet.indexOf(unit2.elements, element)
  };
}
function getIntraUnitBondMapping(structure) {
  let bondCount = 0;
  const unitGroupOffset = [];
  for (const ug of structure.unitSymmetryGroups) {
    unitGroupOffset.push(bondCount);
    const unit2 = ug.units[0];
    if (Unit.isAtomic(unit2)) {
      bondCount += unit2.bonds.edgeCount * 2 * ug.units.length;
    }
  }
  const unitIndex = new Uint32Array(bondCount);
  const unitEdgeIndex = new Uint32Array(bondCount);
  const unitGroupIndex = new Uint32Array(bondCount);
  let idx = 0;
  let unitIdx = 0;
  for (const ug of structure.unitSymmetryGroups) {
    const unit2 = ug.units[0];
    if (Unit.isAtomic(unit2)) {
      const edgeCount = unit2.bonds.edgeCount * 2;
      for (let i = 0, il = ug.units.length; i < il; ++i) {
        for (let j = 0, jl = edgeCount; j < jl; ++j) {
          unitIndex[idx] = unitIdx;
          unitEdgeIndex[idx] = j;
          unitGroupIndex[idx] = i;
          idx += 1;
        }
      }
    }
    unitIdx += 1;
  }
  return { bondCount, unitIndex, unitEdgeIndex, unitGroupIndex, unitGroupOffset };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/structure.js
var Structure = class _Structure {
  subsetBuilder(isSorted) {
    return new StructureSubsetBuilder(this, isSorted);
  }
  /** Count of all elements in the structure, i.e. the sum of the elements in the units */
  get elementCount() {
    return this.state.elementCount;
  }
  /** Count of all bonds (intra- and inter-unit) in the structure */
  get bondCount() {
    if (this.state.bondCount === -1) {
      this.state.bondCount = this.interUnitBonds.edgeCount / 2 + Bond.getIntraUnitBondCount(this);
    }
    return this.state.bondCount;
  }
  get hasCustomProperties() {
    return !!this.state.customProps && this.state.customProps.all.length > 0;
  }
  get customPropertyDescriptors() {
    if (!this.state.customProps)
      this.state.customProps = new CustomProperties();
    return this.state.customProps;
  }
  /**
   * Property data unique to this instance of the structure.
   */
  get currentPropertyData() {
    if (!this.state.propertyData)
      this.state.propertyData = /* @__PURE__ */ Object.create(null);
    return this.state.propertyData;
  }
  /**
   * Property data of the parent structure if it exists, currentPropertyData otherwise.
   */
  get inheritedPropertyData() {
    return this.parent ? this.parent.currentPropertyData : this.currentPropertyData;
  }
  /** Count of all polymer residues in the structure */
  get polymerResidueCount() {
    if (this.state.polymerResidueCount === -1) {
      this.state.polymerResidueCount = getPolymerResidueCount(this);
    }
    return this.state.polymerResidueCount;
  }
  /** Count of all polymer gaps in the structure */
  get polymerGapCount() {
    if (this.state.polymerGapCount === -1) {
      this.state.polymerGapCount = getPolymerGapCount(this);
    }
    return this.state.polymerGapCount;
  }
  get polymerUnitCount() {
    if (this.state.polymerUnitCount === -1) {
      this.state.polymerUnitCount = getPolymerUnitCount(this);
    }
    return this.state.polymerUnitCount;
  }
  get uniqueElementCount() {
    if (this.state.uniqueElementCount === -1) {
      this.state.uniqueElementCount = getUniqueElementCount(this);
    }
    return this.state.uniqueElementCount;
  }
  get atomicResidueCount() {
    if (this.state.atomicResidueCount === -1) {
      this.state.atomicResidueCount = getAtomicResidueCount(this);
    }
    return this.state.atomicResidueCount;
  }
  /**
   * True if any model the structure is based on is coarse grained.
   * @see Model.isCoarseGrained
   */
  get isCoarseGrained() {
    return this.models.some((m) => Model.isCoarseGrained(m));
  }
  get isEmpty() {
    return this.units.length === 0;
  }
  get hashCode() {
    if (this.state.hashCode !== -1)
      return this.state.hashCode;
    return this.computeHash();
  }
  /** Hash based on all unit.id values in the structure, reflecting the units transformation */
  get transformHash() {
    if (this.state.transformHash !== -1)
      return this.state.transformHash;
    this.state.transformHash = hashFnv32a(this.units.map((u) => u.id));
    return this.state.transformHash;
  }
  computeHash() {
    let hash = 23;
    for (let i = 0, _i = this.units.length; i < _i; i++) {
      const u = this.units[i];
      hash = 31 * hash + u.id | 0;
      hash = 31 * hash + SortedArray.hashCode(u.elements) | 0;
    }
    hash = 31 * hash + this.elementCount | 0;
    hash = hash1(hash);
    if (hash === -1)
      hash = 0;
    this.state.hashCode = hash;
    return hash;
  }
  /** Returns a new element location iterator */
  elementLocations() {
    return new _Structure.ElementLocationIterator(this);
  }
  /** The parent or itself in case this is the root */
  get root() {
    var _a;
    return (_a = this.state.parent) !== null && _a !== void 0 ? _a : this;
  }
  /** The root/top-most parent or `undefined` in case this is the root */
  get parent() {
    return this.state.parent;
  }
  /**
   * Conformation transformation that was applied to every unit of this structure.
   *
   * Coordinate system applies to the *current* structure only.
   * A parent structure can have a different coordinate system and thefore it has to be composed "manualy"
   * by the consumer.
   */
  get coordinateSystem() {
    return this.state.coordinateSystem;
  }
  get label() {
    return this.state.label;
  }
  get boundary() {
    if (this.state.boundary)
      return this.state.boundary;
    this.state.boundary = computeStructureBoundary(this);
    return this.state.boundary;
  }
  get lookup3d() {
    if (this.state.lookup3d)
      return this.state.lookup3d;
    this.state.lookup3d = new StructureLookup3D(this);
    return this.state.lookup3d;
  }
  get interUnitBonds() {
    if (this.state.interUnitBonds)
      return this.state.interUnitBonds;
    if (this.parent && this.state.dynamicBonds === this.parent.state.dynamicBonds && this.parent.state.interUnitBonds && this.parent.state.interUnitBonds.edgeCount === 0) {
      this.state.interUnitBonds = new InterUnitBonds(/* @__PURE__ */ new Map());
    } else {
      this.state.interUnitBonds = computeInterUnitBonds(this, {
        ignoreWater: !this.dynamicBonds,
        ignoreIon: !this.dynamicBonds,
        validUnit: this.state.interBondsValidUnit,
        validUnitPair: this.state.interBondsValidUnitPair
      });
    }
    return this.state.interUnitBonds;
  }
  get dynamicBonds() {
    return this.state.dynamicBonds;
  }
  get interBondsValidUnit() {
    return this.state.interBondsValidUnit;
  }
  get interBondsValidUnitPair() {
    return this.state.interBondsValidUnitPair;
  }
  get unitSymmetryGroups() {
    if (this.state.unitSymmetryGroups)
      return this.state.unitSymmetryGroups;
    this.state.unitSymmetryGroups = StructureSymmetry.computeTransformGroups(this);
    return this.state.unitSymmetryGroups;
  }
  /** Maps unit.id to index of SymmetryGroup in unitSymmetryGroups array */
  get unitSymmetryGroupsIndexMap() {
    if (this.state.unitSymmetryGroupsIndexMap)
      return this.state.unitSymmetryGroupsIndexMap;
    this.state.unitSymmetryGroupsIndexMap = Unit.SymmetryGroup.getUnitSymmetryGroupsIndexMap(this.unitSymmetryGroups);
    return this.state.unitSymmetryGroupsIndexMap;
  }
  get carbohydrates() {
    if (this.state.carbohydrates)
      return this.state.carbohydrates;
    this.state.carbohydrates = computeCarbohydrates(this);
    return this.state.carbohydrates;
  }
  get models() {
    if (this.state.models)
      return this.state.models;
    this.state.models = getModels(this);
    return this.state.models;
  }
  get uniqueResidueNames() {
    return this.state.uniqueResidueNames || (this.state.uniqueResidueNames = getUniqueResidueNames(this));
  }
  get uniqueElementSymbols() {
    return this.state.uniqueElementSymbols || (this.state.uniqueElementSymbols = getUniqueElementSymbols(this));
  }
  get entityIndices() {
    return this.state.entityIndices || (this.state.entityIndices = getEntityIndices(this));
  }
  get uniqueAtomicResidueIndices() {
    return this.state.uniqueAtomicResidueIndices || (this.state.uniqueAtomicResidueIndices = getUniqueAtomicResidueIndices(this));
  }
  /** Contains only atomic units */
  get isAtomic() {
    for (const u of this.units)
      if (!Unit.isAtomic(u))
        return false;
    return true;
  }
  /** Contains some atomic units */
  get hasAtomic() {
    for (const u of this.units)
      if (Unit.isAtomic(u))
        return true;
    return false;
  }
  /** Contains only coarse units */
  get isCoarse() {
    for (const u of this.units)
      if (!Unit.isCoarse(u))
        return false;
    return true;
  }
  /** Contains some coarse units */
  get hasCoarse() {
    for (const u of this.units)
      if (Unit.isCoarse(u))
        return true;
    return false;
  }
  /**
   * Provides mapping for serial element indices accross all units.
   *
   * Note that this is especially costly for structures with many units that are grouped
   * into few symmetry groups. Use only when needed and prefer `StructureElement`
   * to address elements in a structure.
   */
  get serialMapping() {
    return this.state.serialMapping || (this.state.serialMapping = getSerialMapping(this));
  }
  get intraUnitBondMapping() {
    return this.state.intraUnitBondMapping || (this.state.intraUnitBondMapping = getIntraUnitBondMapping(this));
  }
  /**
   * If the structure is based on a single model or has a master-/representative-model, return it.
   * Otherwise throw an exception.
   */
  get model() {
    if (this.state.model)
      return this.state.model;
    if (this.state.representativeModel)
      return this.state.representativeModel;
    if (this.state.masterModel)
      return this.state.masterModel;
    const models = this.models;
    if (models.length > 1) {
      throw new Error("The structure is based on multiple models and has neither a master- nor a representative-model.");
    }
    this.state.model = models[0];
    return this.state.model;
  }
  /** The master-model, other models can have bonds to it  */
  get masterModel() {
    return this.state.masterModel;
  }
  /** A representative model, e.g. the first model of a trajectory */
  get representativeModel() {
    return this.state.representativeModel;
  }
  hasElement(e) {
    if (!this.unitMap.has(e.unit.id))
      return false;
    return SortedArray.has(this.unitMap.get(e.unit.id).elements, e.element);
  }
  getModelIndex(m) {
    return this.models.indexOf(m);
  }
  remapModel(m) {
    const { dynamicBonds, interUnitBonds, parent } = this.state;
    const units = [];
    for (const ug of this.unitSymmetryGroups) {
      const unit2 = ug.units[0].remapModel(m, dynamicBonds);
      units.push(unit2);
      for (let i = 1, il = ug.units.length; i < il; ++i) {
        const u = ug.units[i];
        units.push(u.remapModel(m, dynamicBonds, unit2.props));
      }
    }
    return _Structure.create(units, {
      parent: parent === null || parent === void 0 ? void 0 : parent.remapModel(m),
      label: this.label,
      interUnitBonds: dynamicBonds ? void 0 : interUnitBonds,
      dynamicBonds,
      interBondsValidUnit: this.state.interBondsValidUnit,
      interBondsValidUnitPair: this.state.interBondsValidUnitPair,
      coordinateSystem: this.state.coordinateSystem,
      masterModel: this.state.masterModel,
      representativeModel: this.state.representativeModel
    });
  }
  /**
   * For `structure` with `parent` this returns a proxy that
   * targets `parent` and has `structure` attached as a child.
   */
  asParent() {
    if (this._proxy)
      return this._proxy;
    if (this.parent) {
      const p3 = this.parent.coordinateSystem.isIdentity ? this.parent : _Structure.transform(this.parent, this.parent.coordinateSystem.inverse);
      const s = this.coordinateSystem.isIdentity ? p3 : _Structure.transform(p3, this.coordinateSystem.matrix);
      this._proxy = new _Structure(s.units, s.unitMap, s.unitIndexMap, { ...s.state, dynamicBonds: this.dynamicBonds }, { child: this, target: this.parent });
    } else {
      this._proxy = this;
    }
    return this._proxy;
  }
  get child() {
    return this._child;
  }
  /** Get the proxy target. Usefull for equality checks. */
  get target() {
    var _a;
    return (_a = this._target) !== null && _a !== void 0 ? _a : this;
  }
  /**
   * @param units Array of all units in the structure, sorted by unit.id
   * @param unitMap Maps unit.id to index of unit in units array
   * @param unitIndexMap Array of all units in the structure, sorted by unit.id
   */
  constructor(units, unitMap, unitIndexMap, state, asParent) {
    this.units = units;
    this.unitMap = unitMap;
    this.unitIndexMap = unitIndexMap;
    this.state = state;
    this._child = asParent === null || asParent === void 0 ? void 0 : asParent.child;
    this._target = asParent === null || asParent === void 0 ? void 0 : asParent.target;
    this._proxy = void 0;
  }
};
function cmpUnits(units, i, j) {
  return units[i].id - units[j].id;
}
function getModels(s) {
  const { units } = s;
  const arr = UniqueArray.create();
  for (const u of units) {
    UniqueArray.add(arr, u.model.id, u.model);
  }
  return arr.array;
}
function getUniqueResidueNames(s) {
  const { microheterogeneityCompIds: microheterogeneityCompIds2 } = StructureProperties.residue;
  const names = /* @__PURE__ */ new Set();
  const loc = element_exports.Location.create(s);
  for (const unitGroup of s.unitSymmetryGroups) {
    const unit2 = unitGroup.units[0];
    if (!Unit.isAtomic(unit2))
      continue;
    const residues2 = Segmentation.transientSegments(unit2.model.atomicHierarchy.residueAtomSegments, unit2.elements);
    loc.unit = unit2;
    while (residues2.hasNext) {
      const seg = residues2.move();
      loc.element = unit2.elements[seg.start];
      const compIds = microheterogeneityCompIds2(loc);
      for (const compId2 of compIds)
        names.add(compId2);
    }
  }
  return names;
}
function getUniqueElementSymbols(s) {
  const prop = StructureProperties.atom.type_symbol;
  const symbols = /* @__PURE__ */ new Set();
  const loc = element_exports.Location.create(s);
  for (const unitGroup of s.unitSymmetryGroups) {
    const unit2 = unitGroup.units[0];
    if (!Unit.isAtomic(unit2))
      continue;
    loc.unit = unit2;
    for (let i = 0, il = unit2.elements.length; i < il; ++i) {
      loc.element = unit2.elements[i];
      symbols.add(prop(loc));
    }
  }
  return symbols;
}
function getEntityIndices(structure) {
  const { units } = structure;
  const l = element_exports.Location.create(structure);
  const keys = UniqueArray.create();
  for (const unit2 of units) {
    const prop = unit2.kind === Unit.Kind.Atomic ? StructureProperties.entity.key : StructureProperties.coarse.entityKey;
    l.unit = unit2;
    const elements = unit2.elements;
    const chainsIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.chainAtomSegments, elements);
    while (chainsIt.hasNext) {
      const chainSegment = chainsIt.move();
      l.element = elements[chainSegment.start];
      const key = prop(l);
      UniqueArray.add(keys, key, key);
    }
  }
  sortArray(keys.array);
  return keys.array;
}
function getUniqueAtomicResidueIndices(structure) {
  const map2 = /* @__PURE__ */ new Map();
  const modelIds = [];
  const unitGroups = structure.unitSymmetryGroups;
  for (const unitGroup of unitGroups) {
    const unit2 = unitGroup.units[0];
    if (!Unit.isAtomic(unit2))
      continue;
    let uniqueResidues;
    if (map2.has(unit2.model.id))
      uniqueResidues = map2.get(unit2.model.id);
    else {
      uniqueResidues = UniqueArray.create();
      modelIds.push(unit2.model.id);
      map2.set(unit2.model.id, uniqueResidues);
    }
    const residues2 = Segmentation.transientSegments(unit2.model.atomicHierarchy.residueAtomSegments, unit2.elements);
    while (residues2.hasNext) {
      const seg = residues2.move();
      UniqueArray.add(uniqueResidues, seg.index, seg.index);
    }
  }
  const ret = /* @__PURE__ */ new Map();
  for (const id of modelIds) {
    const array2 = map2.get(id).array;
    sortArray(array2);
    ret.set(id, array2);
  }
  return ret;
}
function getUniqueElementCount(structure) {
  const { unitSymmetryGroups } = structure;
  let uniqueElementCount = 0;
  for (let i = 0, _i = unitSymmetryGroups.length; i < _i; i++) {
    uniqueElementCount += unitSymmetryGroups[i].elements.length;
  }
  return uniqueElementCount;
}
function getPolymerResidueCount(structure) {
  const { units } = structure;
  let polymerResidueCount = 0;
  for (let i = 0, _i = units.length; i < _i; i++) {
    polymerResidueCount += units[i].polymerElements.length;
  }
  return polymerResidueCount;
}
function getPolymerGapCount(structure) {
  const { units } = structure;
  let polymerGapCount = 0;
  for (let i = 0, _i = units.length; i < _i; i++) {
    polymerGapCount += units[i].gapElements.length / 2;
  }
  return polymerGapCount;
}
function getPolymerUnitCount(structure) {
  const { units } = structure;
  let polymerUnitCount = 0;
  for (let i = 0, _i = units.length; i < _i; i++) {
    if (units[i].polymerElements.length > 0)
      polymerUnitCount += 1;
  }
  return polymerUnitCount;
}
function getAtomicResidueCount(structure) {
  const { units } = structure;
  let atomicResidueCount = 0;
  for (let i = 0, _i = units.length; i < _i; i++) {
    const unit2 = units[i];
    if (!Unit.isAtomic(unit2))
      continue;
    const { elements, residueIndex: residueIndex2 } = unit2;
    let idx = -1;
    let prevIdx = -1;
    for (let j = 0, jl = elements.length; j < jl; ++j) {
      idx = residueIndex2[elements[j]];
      if (idx !== prevIdx) {
        atomicResidueCount += 1;
        prevIdx = idx;
      }
    }
  }
  return atomicResidueCount;
}
(function(Structure2) {
  Structure2.Empty = create([]);
  function Loci2(structure) {
    return { kind: "structure-loci", structure };
  }
  Structure2.Loci = Loci2;
  function toStructureElementLoci(structure) {
    const elements = [];
    for (const unit2 of structure.units) {
      elements.push({ unit: unit2, indices: Interval.ofBounds(0, unit2.elements.length) });
    }
    return element_exports.Loci(structure, elements);
  }
  Structure2.toStructureElementLoci = toStructureElementLoci;
  function toSubStructureElementLoci(parent, structure) {
    return StructureSelection.toLociWithSourceUnits(StructureSelection.Singletons(parent, structure));
  }
  Structure2.toSubStructureElementLoci = toSubStructureElementLoci;
  function isLoci(x) {
    return !!x && x.kind === "structure-loci";
  }
  Structure2.isLoci = isLoci;
  function areLociEqual(a, b) {
    return a.structure === b.structure;
  }
  Structure2.areLociEqual = areLociEqual;
  function isLociEmpty(loci) {
    return loci.structure.isEmpty;
  }
  Structure2.isLociEmpty = isLociEmpty;
  function remapLoci(loci, structure) {
    if (structure === loci.structure)
      return loci;
    return Loci2(structure);
  }
  Structure2.remapLoci = remapLoci;
  function create(units, props = {}) {
    const unitMap = IntMap.Mutable();
    const unitIndexMap = IntMap.Mutable();
    let elementCount = 0;
    let isSorted = true;
    let lastId = units.length > 0 ? units[0].id : 0;
    for (let i = 0, _i = units.length; i < _i; i++) {
      const u = units[i];
      unitMap.set(u.id, u);
      elementCount += u.elements.length;
      if (u.id < lastId)
        isSorted = false;
      lastId = u.id;
    }
    if (!isSorted)
      sort(units, 0, units.length, cmpUnits, arraySwap);
    for (let i = 0, _i = units.length; i < _i; i++) {
      unitIndexMap.set(units[i].id, i);
    }
    const state = {
      hashCode: -1,
      transformHash: -1,
      elementCount,
      bondCount: -1,
      uniqueElementCount: -1,
      atomicResidueCount: -1,
      polymerResidueCount: -1,
      polymerGapCount: -1,
      polymerUnitCount: -1,
      dynamicBonds: false,
      coordinateSystem: SymmetryOperator.Default,
      label: ""
    };
    if (props.parent)
      state.parent = props.parent.parent || props.parent;
    if (props.interUnitBonds)
      state.interUnitBonds = props.interUnitBonds;
    if (props.interBondsValidUnit)
      state.interBondsValidUnit = props.interBondsValidUnit;
    else if (props.parent)
      state.interBondsValidUnit = props.parent.interBondsValidUnit;
    if (props.interBondsValidUnitPair)
      state.interBondsValidUnitPair = props.interBondsValidUnitPair;
    else if (props.parent)
      state.interBondsValidUnitPair = props.parent.interBondsValidUnitPair;
    if (props.dynamicBonds)
      state.dynamicBonds = props.dynamicBonds;
    else if (props.parent)
      state.dynamicBonds = props.parent.dynamicBonds;
    if (props.coordinateSystem)
      state.coordinateSystem = props.coordinateSystem;
    else if (props.parent)
      state.coordinateSystem = props.parent.coordinateSystem;
    if (props.label)
      state.label = props.label;
    else if (props.parent)
      state.label = props.parent.label;
    if (props.masterModel)
      state.masterModel = props.masterModel;
    else if (props.parent)
      state.masterModel = props.parent.masterModel;
    if (props.representativeModel)
      state.representativeModel = props.representativeModel;
    else if (props.parent)
      state.representativeModel = props.parent.representativeModel;
    return new Structure2(units, unitMap, unitIndexMap, state);
  }
  Structure2.create = create;
  async function ofTrajectory(trajectory, ctx) {
    if (trajectory.frameCount === 0)
      return Structure2.Empty;
    const units = [];
    let first2 = void 0;
    let count = 0;
    for (let i = 0, il = trajectory.frameCount; i < il; ++i) {
      const frame = await Task.resolveInContext(trajectory.getFrameAtIndex(i), ctx);
      if (!first2)
        first2 = frame;
      const structure = ofModel(frame);
      for (let j = 0, jl = structure.units.length; j < jl; ++j) {
        const u = structure.units[j];
        const invariantId = u.invariantId + count;
        const chainGroupId = u.chainGroupId + count;
        const newUnit = Unit.create(units.length, invariantId, chainGroupId, u.traits, u.kind, u.model, u.conformation.operator, u.elements);
        units.push(newUnit);
      }
      count = units.length;
    }
    return create(units, { representativeModel: first2, label: first2.label });
  }
  Structure2.ofTrajectory = ofTrajectory;
  function ofModel(model, props = {}) {
    const chains2 = model.atomicHierarchy.chainAtomSegments;
    const { index } = model.atomicHierarchy;
    const { auth_asym_id } = model.atomicHierarchy.chains;
    const { atomicChainOperatorMappinng } = model;
    const builder = new StructureBuilder({ label: model.label, ...props });
    for (let c = 0; c < chains2.count; c++) {
      const operator = atomicChainOperatorMappinng.get(c) || SymmetryOperator.Default;
      const start = chains2.offsets[c];
      let isMultiChain = false;
      let isWater = false;
      if (isWaterChain(model, c)) {
        isWater = true;
        while (c + 1 < chains2.count && isWaterChain(model, c + 1)) {
          const op1 = atomicChainOperatorMappinng.get(c);
          const op2 = atomicChainOperatorMappinng.get(c + 1);
          if (op1 !== op2)
            break;
          isMultiChain = true;
          c++;
        }
      } else {
        while (c + 1 < chains2.count && chains2.offsets[c + 1] - chains2.offsets[c] === 1 && chains2.offsets[c + 2] - chains2.offsets[c + 1] === 1) {
          const e1 = index.getEntityFromChain(c);
          const e2 = index.getEntityFromChain(c + 1);
          if (e1 !== e2)
            break;
          const a1 = auth_asym_id.value(c);
          const a2 = auth_asym_id.value(c + 1);
          if (a1 !== a2)
            break;
          const op1 = atomicChainOperatorMappinng.get(c);
          const op2 = atomicChainOperatorMappinng.get(c + 1);
          if (op1 !== op2)
            break;
          isMultiChain = true;
          c++;
        }
      }
      const elements = SortedArray.ofBounds(start, chains2.offsets[c + 1]);
      let traits = Unit.Trait.None;
      if (isMultiChain)
        traits |= Unit.Trait.MultiChain;
      if (isWater)
        traits |= Unit.Trait.Water;
      builder.addUnit(Unit.Kind.Atomic, model, operator, elements, traits);
    }
    const cs = model.coarseHierarchy;
    if (cs.isDefined) {
      if (cs.spheres.count > 0) {
        addCoarseUnits(builder, model, model.coarseHierarchy.spheres, Unit.Kind.Spheres);
      }
      if (cs.gaussians.count > 0) {
        addCoarseUnits(builder, model, model.coarseHierarchy.gaussians, Unit.Kind.Gaussians);
      }
    }
    return builder.getStructure();
  }
  Structure2.ofModel = ofModel;
  function isWaterChain(model, chainIndex2) {
    const e = model.atomicHierarchy.index.getEntityFromChain(chainIndex2);
    return model.entities.data.type.value(e) === "water";
  }
  function addCoarseUnits(builder, model, elements, kind) {
    const { chainElementSegments } = elements;
    for (let cI = 0; cI < chainElementSegments.count; cI++) {
      const elements2 = SortedArray.ofBounds(chainElementSegments.offsets[cI], chainElementSegments.offsets[cI + 1]);
      builder.addUnit(kind, model, SymmetryOperator.Default, elements2, Unit.Trait.None);
    }
  }
  function transform(s, transform2) {
    if (Mat4.isIdentity(transform2))
      return s;
    if (!Mat4.isRotationAndTranslation(transform2, SymmetryOperator.RotationTranslationEpsilon))
      throw new Error("Only rotation/translation combination can be applied.");
    const units = [];
    for (const u of s.units) {
      const old = u.conformation.operator;
      const op = SymmetryOperator.create(old.name, transform2, old);
      units.push(u.applyOperator(u.id, op));
    }
    const cs = s.coordinateSystem;
    const newCS = SymmetryOperator.compose(SymmetryOperator.create(cs.name, transform2, cs), cs);
    return create(units, { parent: s, coordinateSystem: newCS });
  }
  Structure2.transform = transform;
  class StructureBuilder {
    beginChainGroup() {
      this.chainGroupId++;
      this.inChainGroup = true;
    }
    endChainGroup() {
      this.inChainGroup = false;
    }
    addUnit(kind, model, operator, elements, traits, invariantId) {
      if (invariantId === void 0)
        invariantId = this.invariantId();
      const chainGroupId = this.inChainGroup ? this.chainGroupId : ++this.chainGroupId;
      const unit2 = Unit.create(this.units.length, invariantId, chainGroupId, traits, kind, model, operator, elements);
      return this.add(unit2);
    }
    copyUnit(unit2, options) {
      let invariantId = options === null || options === void 0 ? void 0 : options.invariantId;
      if (invariantId === void 0)
        invariantId = this.invariantId();
      const chainGroupId = this.inChainGroup ? this.chainGroupId : ++this.chainGroupId;
      const newUnit = unit2.getCopy(this.units.length, invariantId, chainGroupId, options);
      return this.add(newUnit);
    }
    add(unit2) {
      if (unit2.elements.length === 1) {
        unit2.conformation.position(unit2.elements[0], this.p);
        const hash = [unit2.invariantId, this.p[0], this.p[1], this.p[2]].join("|");
        if (this.singleElementUnits.has(hash)) {
          return this.singleElementUnits.get(hash);
        } else {
          this.singleElementUnits.set(hash, unit2);
        }
      }
      this.units.push(unit2);
      return unit2;
    }
    addWithOperator(unit2, operator, dontCompose = false) {
      return this.add(unit2.applyOperator(this.units.length, operator, dontCompose));
    }
    getStructure() {
      return create(this.units, this.props);
    }
    get isEmpty() {
      return this.units.length === 0;
    }
    constructor(props = {}) {
      this.props = props;
      this.units = [];
      this.invariantId = idFactory();
      this.chainGroupId = -1;
      this.inChainGroup = false;
      this.p = Vec3();
      this.singleElementUnits = /* @__PURE__ */ new Map();
    }
  }
  Structure2.StructureBuilder = StructureBuilder;
  function Builder(props = {}) {
    return new StructureBuilder(props);
  }
  Structure2.Builder = Builder;
  function hashCode(s) {
    return s.hashCode;
  }
  Structure2.hashCode = hashCode;
  function conformationHash(s) {
    return hashString(s.units.map((u) => Unit.conformationId(u)).join("|"));
  }
  Structure2.conformationHash = conformationHash;
  function areUnitIdsEqual(a, b) {
    if (a === b)
      return true;
    if (a.elementCount !== b.elementCount)
      return false;
    const len = a.units.length;
    if (len !== b.units.length)
      return false;
    for (let i = 0; i < len; i++) {
      if (a.units[i].id !== b.units[i].id)
        return false;
    }
    return true;
  }
  Structure2.areUnitIdsEqual = areUnitIdsEqual;
  function areUnitIdsAndIndicesEqual(a, b) {
    if (a === b)
      return true;
    if (!areUnitIdsEqual(a, b))
      return false;
    for (let i = 0, il = a.units.length; i < il; i++) {
      if (!SortedArray.areEqual(a.units[i].elements, b.units[i].elements))
        return false;
    }
    return true;
  }
  Structure2.areUnitIdsAndIndicesEqual = areUnitIdsAndIndicesEqual;
  function areHierarchiesEqual(a, b) {
    if (a.hashCode !== b.hashCode)
      return false;
    const len = a.models.length;
    if (len !== b.models.length)
      return false;
    for (let i = 0; i < len; i++) {
      if (!Model.areHierarchiesEqual(a.models[i], b.models[i]))
        return false;
    }
    return true;
  }
  Structure2.areHierarchiesEqual = areHierarchiesEqual;
  function areEquivalent(a, b) {
    return a === b || a.hashCode === b.hashCode && StructureSymmetry.areTransformGroupsEquivalent(a.unitSymmetryGroups, b.unitSymmetryGroups);
  }
  Structure2.areEquivalent = areEquivalent;
  function areRootsEquivalent(a, b) {
    return areEquivalent(a.root, b.root);
  }
  Structure2.areRootsEquivalent = areRootsEquivalent;
  function areRootsEqual(a, b) {
    return a.root === b.root;
  }
  Structure2.areRootsEqual = areRootsEqual;
  class ElementLocationIterator {
    move() {
      this.advance();
      this.current.element = this.elements[this.idx];
      return this.current;
    }
    advance() {
      if (this.idx < this.maxIdx) {
        this.idx++;
        if (this.idx === this.maxIdx)
          this.hasNext = this.unitIndex + 1 < this.structure.units.length;
        return;
      }
      this.idx = 0;
      this.unitIndex++;
      if (this.unitIndex >= this.structure.units.length) {
        this.hasNext = false;
        return;
      }
      this.current.unit = this.structure.units[this.unitIndex];
      this.elements = this.current.unit.elements;
      this.maxIdx = this.elements.length - 1;
      if (this.maxIdx === 0) {
        this.hasNext = this.unitIndex + 1 < this.structure.units.length;
      }
    }
    constructor(structure) {
      this.structure = structure;
      this.unitIndex = 0;
      this.maxIdx = 0;
      this.idx = -1;
      this.current = element_exports.Location.create(structure);
      this.hasNext = structure.elementCount > 0;
      if (this.hasNext) {
        this.elements = structure.units[0].elements;
        this.maxIdx = this.elements.length - 1;
        this.current.unit = structure.units[0];
      }
    }
  }
  Structure2.ElementLocationIterator = ElementLocationIterator;
  const distVec = Vec3();
  function unitElementMinDistance(unit2, p3, eRadius) {
    const { elements, conformation: c } = unit2, dV = distVec;
    let minD = Number.MAX_VALUE;
    for (let i = 0, _i = elements.length; i < _i; i++) {
      const e = elements[i];
      const d = Vec3.distance(p3, c.position(e, dV)) - eRadius - c.r(e);
      if (d < minD)
        minD = d;
    }
    return minD;
  }
  function minDistanceToPoint(s, point, radius) {
    const { units } = s;
    let minD = Number.MAX_VALUE;
    for (let i = 0, _i = units.length; i < _i; i++) {
      const unit2 = units[i];
      const d = unitElementMinDistance(unit2, point, radius);
      if (d < minD)
        minD = d;
    }
    return minD;
  }
  Structure2.minDistanceToPoint = minDistanceToPoint;
  const distPivot = Vec3();
  function distance(a, b) {
    if (a.elementCount === 0 || b.elementCount === 0)
      return 0;
    const { units } = a;
    let minD = Number.MAX_VALUE;
    for (let i = 0, _i = units.length; i < _i; i++) {
      const unit2 = units[i];
      const { elements, conformation: c } = unit2;
      for (let i2 = 0, _i2 = elements.length; i2 < _i2; i2++) {
        const e = elements[i2];
        const d = minDistanceToPoint(b, c.position(e, distPivot), c.r(e));
        if (d < minD)
          minD = d;
      }
    }
    return minD;
  }
  Structure2.distance = distance;
  function elementDescription(s) {
    return s.elementCount === 1 ? "1 element" : `${s.elementCount} elements`;
  }
  Structure2.elementDescription = elementDescription;
  function validUnitPair(s, a, b) {
    return s.masterModel ? a.model === b.model || a.model === s.masterModel || b.model === s.masterModel : a.model === b.model;
  }
  Structure2.validUnitPair = validUnitPair;
  function eachUnitPair(structure, callback, props) {
    const { maxRadius, validUnit, validUnitPair: validUnitPair2 } = props;
    if (!structure.units.some((u) => validUnit(u)))
      return;
    const lookup = structure.lookup3d;
    const imageCenter = Vec3();
    for (const unitA of structure.units) {
      if (!validUnit(unitA))
        continue;
      const bs = unitA.boundary.sphere;
      Vec3.transformMat4(imageCenter, bs.center, unitA.conformation.operator.matrix);
      const closeUnits = lookup.findUnitIndices(imageCenter[0], imageCenter[1], imageCenter[2], bs.radius + maxRadius);
      for (let i = 0; i < closeUnits.count; i++) {
        const unitB = structure.units[closeUnits.indices[i]];
        if (unitA.id >= unitB.id)
          continue;
        if (!validUnit(unitB) || !validUnitPair2(unitA, unitB))
          continue;
        if (unitB.elements.length >= unitA.elements.length)
          callback(unitA, unitB);
        else
          callback(unitB, unitA);
      }
    }
  }
  Structure2.eachUnitPair = eachUnitPair;
  ;
  function eachAtomicHierarchyElement(structure, { chain: chain2, residue: residue2, atom: atom2 }) {
    const l = element_exports.Location.create(structure);
    for (const unit2 of structure.units) {
      if (unit2.kind !== Unit.Kind.Atomic)
        continue;
      l.unit = unit2;
      const { elements } = unit2;
      const chainsIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.chainAtomSegments, elements);
      const residuesIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.residueAtomSegments, elements);
      while (chainsIt.hasNext) {
        const chainSegment = chainsIt.move();
        if (chain2) {
          l.element = elements[chainSegment.start];
          chain2(l);
        }
        if (!residue2 && !atom2)
          continue;
        residuesIt.setSegment(chainSegment);
        while (residuesIt.hasNext) {
          const residueSegment = residuesIt.move();
          if (residue2) {
            l.element = elements[residueSegment.start];
            residue2(l);
          }
          if (!atom2)
            continue;
          for (let j = residueSegment.start, _j = residueSegment.end; j < _j; j++) {
            l.element = elements[j];
            atom2(l);
          }
        }
      }
    }
  }
  Structure2.eachAtomicHierarchyElement = eachAtomicHierarchyElement;
  Structure2.DefaultSizeThresholds = {
    /** Must be lower to be small */
    smallResidueCount: 10,
    /** Must be lower to be medium */
    mediumResidueCount: 5e3,
    /** Must be lower to be large (big ribosomes like 4UG0 should still be `large`) */
    largeResidueCount: 3e4,
    /**
     * Structures above `largeResidueCount` are consider huge when they have
     * a `highSymmetryUnitCount` or gigantic when not
     */
    highSymmetryUnitCount: 10,
    /** Fiber-like structure are consider small when below this */
    fiberResidueCount: 15
  };
  function getPolymerSymmetryGroups(structure) {
    return structure.unitSymmetryGroups.filter((ug) => ug.units[0].polymerElements.length > 0);
  }
  function isFiberLike(structure, thresholds) {
    const polymerSymmetryGroups = getPolymerSymmetryGroups(structure);
    return polymerSymmetryGroups.length === 1 && polymerSymmetryGroups[0].units.length > 2 && polymerSymmetryGroups[0].units[0].polymerElements.length < thresholds.fiberResidueCount;
  }
  function hasHighSymmetry(structure, thresholds) {
    const polymerSymmetryGroups = getPolymerSymmetryGroups(structure);
    return polymerSymmetryGroups.length >= 1 && polymerSymmetryGroups[0].units.length > thresholds.highSymmetryUnitCount;
  }
  let Size;
  (function(Size2) {
    Size2[Size2["Small"] = 0] = "Small";
    Size2[Size2["Medium"] = 1] = "Medium";
    Size2[Size2["Large"] = 2] = "Large";
    Size2[Size2["Huge"] = 3] = "Huge";
    Size2[Size2["Gigantic"] = 4] = "Gigantic";
  })(Size = Structure2.Size || (Structure2.Size = {}));
  function getSize(structure, thresholds = {}, residueCountFactor = 1) {
    const t = { ...Structure2.DefaultSizeThresholds, ...thresholds };
    if (structure.polymerResidueCount >= t.largeResidueCount * residueCountFactor) {
      if (hasHighSymmetry(structure, t)) {
        return Size.Huge;
      } else {
        return Size.Gigantic;
      }
    } else if (isFiberLike(structure, t)) {
      return Size.Small;
    } else if (structure.polymerResidueCount < t.smallResidueCount * residueCountFactor) {
      return Size.Small;
    } else if (structure.polymerResidueCount < t.mediumResidueCount * residueCountFactor) {
      return Size.Medium;
    } else {
      return Size.Large;
    }
  }
  Structure2.getSize = getSize;
  Structure2.Index = CustomStructureProperty.createSimple("index", "root");
  Structure2.MaxIndex = CustomStructureProperty.createSimple("max_index", "root");
  const PrincipalAxesProp = "__PrincipalAxes__";
  function getPrincipalAxes2(structure) {
    if (structure.currentPropertyData[PrincipalAxesProp])
      return structure.currentPropertyData[PrincipalAxesProp];
    const principalAxes = element_exports.Loci.getPrincipalAxes(Structure2.toStructureElementLoci(structure));
    structure.currentPropertyData[PrincipalAxesProp] = principalAxes;
    return principalAxes;
  }
  Structure2.getPrincipalAxes = getPrincipalAxes2;
})(Structure || (Structure = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/runtime/query/base.js
var QueryRuntimeTable = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  removeSymbol(runtime) {
    this.map.delete(runtime.symbol.id);
  }
  addSymbol(runtime) {
    if (this.map.has(runtime.symbol.id)) {
      console.warn(`Symbol '${runtime.symbol.id}' already added. Call removeSymbol/removeCustomProps re-adding the symbol.`);
    }
    this.map.set(runtime.symbol.id, runtime);
  }
  addCustomProp(desc) {
    if (!desc.symbols)
      return;
    for (const k of Object.keys(desc.symbols)) {
      this.addSymbol(desc.symbols[k]);
    }
  }
  removeCustomProp(desc) {
    if (!desc.symbols)
      return;
    for (const k of Object.keys(desc.symbols)) {
      this.removeSymbol(desc.symbols[k]);
    }
  }
  getRuntime(id) {
    return this.map.get(id);
  }
};
var DefaultQueryRuntimeTable = new QueryRuntimeTable();
var QueryCompilerCtx = class {
  constructor(table) {
    this.table = table;
    this.constQueryContext = new QueryContext(Structure.Empty);
  }
};
var QueryCompiledSymbol;
(function(QueryCompiledSymbol2) {
  function Const(value) {
    return { kind: "const", value };
  }
  QueryCompiledSymbol2.Const = Const;
  function Dynamic(runtime) {
    return { kind: "dynamic", runtime };
  }
  QueryCompiledSymbol2.Dynamic = Dynamic;
})(QueryCompiledSymbol || (QueryCompiledSymbol = {}));
var CompiledQueryFn;
(function(CompiledQueryFn2) {
  function Const(value) {
    return { isConst: true, fn: function CompiledQueryFn_Const(ctx) {
      return value;
    } };
  }
  CompiledQueryFn2.Const = Const;
  function Dynamic(fn) {
    return { isConst: false, fn };
  }
  CompiledQueryFn2.Dynamic = Dynamic;
})(CompiledQueryFn || (CompiledQueryFn = {}));
var QueryRuntimeArguments;
(function(QueryRuntimeArguments2) {
  function forEachEval(xs, queryCtx, f, ctx) {
    if (typeof xs.length === "number") {
      for (let i = 0, _i = xs.length; i < _i; i++)
        f(xs[i](queryCtx), i, ctx);
    } else {
      let i = 0;
      for (const k of Object.keys(xs))
        f(xs[k](queryCtx), i++, ctx);
    }
    return ctx;
  }
  QueryRuntimeArguments2.forEachEval = forEachEval;
})(QueryRuntimeArguments || (QueryRuntimeArguments = {}));
var QuerySymbolRuntime;
(function(QuerySymbolRuntime2) {
  function Const(symbol2, fn) {
    return new SymbolRuntimeImpl(symbol2, fn, true);
  }
  QuerySymbolRuntime2.Const = Const;
  function Dynamic(symbol2, fn) {
    return new SymbolRuntimeImpl(symbol2, fn, false);
  }
  QuerySymbolRuntime2.Dynamic = Dynamic;
})(QuerySymbolRuntime || (QuerySymbolRuntime = {}));
var SymbolRuntimeImpl = class {
  compile(ctx, inputArgs) {
    let args, constArgs = false;
    if (!inputArgs) {
      args = void 0;
      constArgs = true;
    } else if (Expression.isArgumentsArray(inputArgs)) {
      args = [];
      constArgs = true;
      for (const arg of inputArgs) {
        const compiled = _compile(ctx, arg);
        constArgs = constArgs && compiled.isConst;
        args.push(compiled.fn);
      }
    } else {
      args = /* @__PURE__ */ Object.create(null);
      constArgs = true;
      for (const key of Object.keys(inputArgs)) {
        const compiled = _compile(ctx, inputArgs[key]);
        constArgs = constArgs && compiled.isConst;
        args[key] = compiled.fn;
      }
    }
    if (this.isConst) {
      if (this.isConst && constArgs) {
        return CompiledQueryFn.Const(this.fn(ctx.constQueryContext, args));
      }
      return CompiledQueryFn.Dynamic(createDynamicFn(this.fn, args));
    }
    return CompiledQueryFn.Dynamic(createDynamicFn(this.fn, args));
  }
  constructor(symbol2, fn, isConst) {
    this.symbol = symbol2;
    this.fn = fn;
    this.isConst = isConst;
  }
};
function createDynamicFn(fn, args) {
  return function DynamicFn(ctx) {
    return fn(ctx, args);
  };
}
function _compile(ctx, expression) {
  if (Expression.isLiteral(expression)) {
    return CompiledQueryFn.Const(expression);
  }
  if (Expression.isSymbol(expression)) {
    const runtime = ctx.table.getRuntime(expression.name);
    if (!runtime)
      return CompiledQueryFn.Const(expression.name);
    return runtime.compile(ctx);
  }
  if (!Expression.isSymbol(expression.head)) {
    throw new Error("Can only apply symbols.");
  }
  const compiler = ctx.table.getRuntime(expression.head.name);
  if (!compiler) {
    throw new Error(`Symbol '${expression.head.name}' is not implemented.`);
  }
  return compiler.compile(ctx, expression.args);
}
function compile(expression) {
  const ctx = new QueryCompilerCtx(DefaultQueryRuntimeTable);
  return _compile(ctx, expression).fn;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/element/loci.js
var itDiff = IntTuple.diff;
function Loci(structure, elements) {
  return { kind: "element-loci", structure, elements };
}
(function(Loci2) {
  function is(x) {
    return !!x && x.kind === "element-loci";
  }
  Loci2.is = is;
  function areEqual(a, b) {
    if (a.structure !== b.structure)
      return false;
    if (a.elements.length !== b.elements.length)
      return false;
    for (let i = 0, il = a.elements.length; i < il; ++i) {
      const elementA = a.elements[i];
      const elementB = b.elements[i];
      if (elementA.unit.id !== elementB.unit.id)
        return false;
      if (!OrderedSet.areEqual(elementA.indices, elementB.indices))
        return false;
    }
    return true;
  }
  Loci2.areEqual = areEqual;
  function isEmpty(loci) {
    for (const u of loci.elements) {
      if (OrderedSet.size(u.indices) > 0)
        return false;
    }
    return true;
  }
  Loci2.isEmpty = isEmpty;
  function isWholeStructure(loci) {
    return size(loci) === loci.structure.elementCount;
  }
  Loci2.isWholeStructure = isWholeStructure;
  function size(loci) {
    let s = 0;
    for (const { indices } of loci.elements) {
      if (typeof indices === "number") {
        s += itDiff(indices);
      } else {
        s += indices.length;
      }
    }
    return s;
  }
  Loci2.size = size;
  function all2(structure) {
    return Loci2(structure, structure.units.map((unit2) => ({
      unit: unit2,
      indices: OrderedSet.ofBounds(0, unit2.elements.length)
    })));
  }
  Loci2.all = all2;
  function none2(structure) {
    return Loci2(structure, []);
  }
  Loci2.none = none2;
  function fromExpression(structure, expression, queryContext) {
    let expr;
    if (typeof expression === "function") {
      expr = expression(MolScriptBuilder);
    } else {
      expr = expression;
    }
    const selection = compile(expr)(queryContext !== null && queryContext !== void 0 ? queryContext : new QueryContext(structure));
    return StructureSelection.toLociWithSourceUnits(selection);
  }
  Loci2.fromExpression = fromExpression;
  function fromQuery(structure, query2, queryContext) {
    const selection = query2(queryContext !== null && queryContext !== void 0 ? queryContext : new QueryContext(structure));
    return StructureSelection.toLociWithSourceUnits(selection);
  }
  Loci2.fromQuery = fromQuery;
  function fromSchema(structure, schema, queryContext) {
    return Schema2.toLoci(structure, schema, queryContext);
  }
  Loci2.fromSchema = fromSchema;
  function getFirstLocation(loci, e) {
    if (isEmpty(loci))
      return void 0;
    const unit2 = loci.elements[0].unit;
    const element = unit2.elements[OrderedSet.getAt(loci.elements[0].indices, 0)];
    if (e) {
      e.structure = loci.structure;
      e.unit = loci.elements[0].unit;
      e.element = element;
      return e;
    }
    return Location.create(loci.structure, unit2, element);
  }
  Loci2.getFirstLocation = getFirstLocation;
  function firstElement(loci) {
    if (isEmpty(loci))
      return loci;
    return Loci2(loci.structure, [{
      unit: loci.elements[0].unit,
      indices: OrderedSet.ofSingleton(OrderedSet.start(loci.elements[0].indices))
    }]);
  }
  Loci2.firstElement = firstElement;
  function firstResidue(loci) {
    if (isEmpty(loci))
      return loci;
    return extendToWholeResidues(firstElement(loci));
  }
  Loci2.firstResidue = firstResidue;
  function firstChain(loci) {
    if (isEmpty(loci))
      return loci;
    return extendToWholeChains(firstElement(loci));
  }
  Loci2.firstChain = firstChain;
  function toStructure(loci) {
    const units = [];
    for (const e of loci.elements) {
      const { unit: unit2, indices } = e;
      const elements = new Int32Array(OrderedSet.size(indices));
      OrderedSet.forEach(indices, (v, i) => elements[i] = unit2.elements[v]);
      units.push(unit2.getChild(SortedArray.ofSortedArray(elements)));
    }
    return Structure.create(units, { parent: loci.structure.parent });
  }
  Loci2.toStructure = toStructure;
  function forEachLocation(loci, f, location) {
    if (Loci2.isEmpty(loci))
      return;
    const loc = location ? location : Location.create(loci.structure);
    loc.structure = loci.structure;
    for (const e of loci.elements) {
      const { unit: unit2, indices } = e;
      loc.unit = unit2;
      const { elements } = e.unit;
      for (let i = 0, _i = OrderedSet.size(indices); i < _i; i++) {
        loc.element = elements[OrderedSet.getAt(indices, i)];
        f(loc);
      }
    }
  }
  Loci2.forEachLocation = forEachLocation;
  function remap(loci, structure) {
    if (structure === loci.structure)
      return loci;
    const elements = [];
    loci.elements.forEach((e) => {
      if (!structure.unitMap.has(e.unit.id))
        return;
      const unit2 = structure.unitMap.get(e.unit.id);
      const indices = OrderedSet.indexedIntersect(e.indices, e.unit.elements, unit2.elements);
      if (OrderedSet.size(indices) > 0)
        elements.push({ unit: unit2, indices });
    });
    return Loci2(structure, elements);
  }
  Loci2.remap = remap;
  function union2(xs, ys) {
    if (xs.elements.length > ys.elements.length)
      return union2(ys, xs);
    if (Loci2.isEmpty(xs))
      return ys;
    const map2 = /* @__PURE__ */ new Map();
    for (const e of xs.elements)
      map2.set(e.unit.id, e.indices);
    const elements = [];
    for (const e of ys.elements) {
      if (map2.has(e.unit.id)) {
        elements[elements.length] = { unit: e.unit, indices: OrderedSet.union(map2.get(e.unit.id), e.indices) };
        map2.delete(e.unit.id);
      } else {
        elements[elements.length] = e;
      }
    }
    map2.forEach((indices, id) => {
      elements[elements.length] = { unit: xs.structure.unitMap.get(id), indices };
    });
    return Loci2(xs.structure, elements);
  }
  Loci2.union = union2;
  function subtract(xs, ys) {
    const map2 = /* @__PURE__ */ new Map();
    for (const e of ys.elements)
      map2.set(e.unit.id, e.indices);
    const elements = [];
    for (const e of xs.elements) {
      if (map2.has(e.unit.id)) {
        const indices = OrderedSet.subtract(e.indices, map2.get(e.unit.id));
        if (OrderedSet.size(indices) === 0)
          continue;
        elements[elements.length] = { unit: e.unit, indices };
      } else {
        elements[elements.length] = e;
      }
    }
    return Loci2(xs.structure, elements);
  }
  Loci2.subtract = subtract;
  function intersect2(xs, ys) {
    const map2 = /* @__PURE__ */ new Map();
    for (const e of xs.elements)
      map2.set(e.unit.id, e.indices);
    const elements = [];
    for (const e of ys.elements) {
      if (!map2.has(e.unit.id))
        continue;
      const indices = OrderedSet.intersect(map2.get(e.unit.id), e.indices);
      if (OrderedSet.size(indices) === 0)
        continue;
      elements[elements.length] = { unit: e.unit, indices };
    }
    return Loci2(xs.structure, elements);
  }
  Loci2.intersect = intersect2;
  function areIntersecting(xs, ys) {
    if (xs.elements.length > ys.elements.length)
      return areIntersecting(ys, xs);
    if (Loci2.isEmpty(xs))
      return Loci2.isEmpty(ys);
    const map2 = /* @__PURE__ */ new Map();
    for (const e of xs.elements)
      map2.set(e.unit.id, e.indices);
    for (const e of ys.elements) {
      if (!map2.has(e.unit.id))
        continue;
      if (OrderedSet.areIntersecting(map2.get(e.unit.id), e.indices))
        return true;
    }
    return false;
  }
  Loci2.areIntersecting = areIntersecting;
  function isSubset(xs, ys) {
    if (Loci2.isEmpty(xs))
      return Loci2.isEmpty(ys);
    const map2 = /* @__PURE__ */ new Map();
    for (const e of xs.elements)
      map2.set(e.unit.id, e.indices);
    let isSubset2 = false;
    for (const e of ys.elements) {
      if (!map2.has(e.unit.id))
        return false;
      if (!OrderedSet.isSubset(map2.get(e.unit.id), e.indices))
        return false;
      else
        isSubset2 = true;
    }
    return isSubset2;
  }
  Loci2.isSubset = isSubset;
  function makeIndexSet(newIndices) {
    if (newIndices.length > 3 && SortedArray.isRange(newIndices)) {
      return Interval.ofRange(newIndices[0], newIndices[newIndices.length - 1]);
    } else {
      return SortedArray.ofSortedArray(newIndices);
    }
  }
  function extendToWholeResidues(loci, restrictToConformation) {
    const elements = [];
    const residueAltIds = /* @__PURE__ */ new Set();
    for (const lociElement of loci.elements) {
      if (isWholeUnit(lociElement)) {
        elements[elements.length] = lociElement;
        continue;
      }
      if (lociElement.unit.kind === Unit.Kind.Atomic) {
        const unitElements = lociElement.unit.elements;
        const h = lociElement.unit.model.atomicHierarchy;
        const { label_alt_id } = lociElement.unit.model.atomicHierarchy.atoms;
        const { index: residueIndex2, offsets: residueOffsets } = h.residueAtomSegments;
        const newIndices = [];
        const indices = lociElement.indices, len = OrderedSet.size(indices);
        let i = 0;
        while (i < len) {
          residueAltIds.clear();
          const eI = unitElements[OrderedSet.getAt(indices, i)];
          const rI = residueIndex2[eI];
          residueAltIds.add(label_alt_id.value(eI));
          i++;
          while (i < len) {
            const eI2 = unitElements[OrderedSet.getAt(indices, i)];
            if (residueIndex2[eI2] !== rI)
              break;
            residueAltIds.add(label_alt_id.value(eI2));
            i++;
          }
          const hasSharedAltId = residueAltIds.has("");
          for (let j = residueOffsets[rI], _j = residueOffsets[rI + 1]; j < _j; j++) {
            const idx = OrderedSet.indexOf(unitElements, j);
            if (idx >= 0) {
              const altId = label_alt_id.value(j);
              if (!restrictToConformation || hasSharedAltId || !altId || residueAltIds.has(altId)) {
                newIndices[newIndices.length] = idx;
              }
            }
          }
        }
        elements[elements.length] = { unit: lociElement.unit, indices: makeIndexSet(newIndices) };
      } else {
        elements[elements.length] = lociElement;
      }
    }
    return Loci2(loci.structure, elements);
  }
  Loci2.extendToWholeResidues = extendToWholeResidues;
  function getChainSegments(unit2) {
    switch (unit2.kind) {
      case Unit.Kind.Atomic:
        return unit2.model.atomicHierarchy.chainAtomSegments;
      case Unit.Kind.Spheres:
        return unit2.model.coarseHierarchy.spheres.chainElementSegments;
      case Unit.Kind.Gaussians:
        return unit2.model.coarseHierarchy.gaussians.chainElementSegments;
    }
  }
  function isWholeUnit(element) {
    return element.unit.elements.length === OrderedSet.size(element.indices);
  }
  function collectChains(unit2, chainIndices, elements) {
    const { index } = getChainSegments(unit2);
    const xs = unit2.elements;
    let size2 = 0;
    for (let i = 0, _i = xs.length; i < _i; i++) {
      const eI = xs[i];
      const cI = index[eI];
      if (!chainIndices.has(cI))
        continue;
      size2++;
    }
    if (size2 === unit2.elements.length) {
      elements[elements.length] = { unit: unit2, indices: Interval.ofBounds(0, size2) };
      return;
    }
    const newIndices = new Int32Array(size2);
    size2 = 0;
    for (let i = 0, _i = xs.length; i < _i; i++) {
      const eI = xs[i];
      const cI = index[eI];
      if (!chainIndices.has(cI))
        continue;
      newIndices[size2++] = i;
    }
    if (newIndices.length > 0) {
      elements[elements.length] = { unit: unit2, indices: makeIndexSet(newIndices) };
    }
  }
  function extendGroupToWholeChains(loci, start, end, isPartitioned, elements) {
    const { index: chainIndex2 } = getChainSegments(loci.elements[0].unit);
    const chainIndices = /* @__PURE__ */ new Set();
    for (let lI = start; lI < end; lI++) {
      const lociElement = loci.elements[lI];
      const indices = lociElement.indices;
      const unitElements = lociElement.unit.elements;
      for (let i = 0, _i = OrderedSet.size(indices); i < _i; i++) {
        chainIndices.add(chainIndex2[unitElements[OrderedSet.getAt(indices, i)]]);
      }
    }
    if (isPartitioned) {
      const baseUnit = loci.elements[0].unit;
      for (const unit2 of loci.structure.units) {
        if (!Unit.areSameChainOperatorGroup(unit2, baseUnit))
          continue;
        collectChains(unit2, chainIndices, elements);
      }
    } else {
      for (let lI = start; lI < end; lI++) {
        collectChains(loci.elements[lI].unit, chainIndices, elements);
      }
    }
  }
  function extendToWholeChains(loci) {
    const elements = [];
    for (let i = 0, len = loci.elements.length; i < len; i++) {
      const e = loci.elements[i];
      if (Unit.Traits.is(e.unit.traits, Unit.Trait.Partitioned)) {
        const start = i;
        while (i < len && Unit.areSameChainOperatorGroup(loci.elements[i].unit, e.unit)) {
          i++;
        }
        const end = i;
        i--;
        extendGroupToWholeChains(loci, start, end, true, elements);
      } else {
        if (isWholeUnit(e)) {
          elements[elements.length] = e;
        } else {
          extendGroupToWholeChains(loci, i, i + 1, false, elements);
        }
      }
    }
    return Loci2(loci.structure, elements);
  }
  Loci2.extendToWholeChains = extendToWholeChains;
  function entityModelKey(location) {
    return `${location.unit.model.id}|${StructureProperties.entity.id(location)}`;
  }
  function extendToWholeEntities(loci) {
    const elements = [];
    const l = Location.create(loci.structure);
    const entities = /* @__PURE__ */ new Set();
    const { units } = loci.structure;
    for (let i = 0, len = loci.elements.length; i < len; i++) {
      const e = loci.elements[i];
      l.unit = e.unit;
      l.element = e.unit.elements[0];
      entities.add(entityModelKey(l));
    }
    for (let i = 0, il = units.length; i < il; ++i) {
      const unit2 = units[i];
      l.unit = unit2;
      l.element = unit2.elements[0];
      if (entities.has(entityModelKey(l))) {
        const indices = OrderedSet.ofBounds(0, unit2.elements.length);
        elements[elements.length] = { unit: unit2, indices };
      }
    }
    return Loci2(loci.structure, elements);
  }
  Loci2.extendToWholeEntities = extendToWholeEntities;
  function extendToWholeModels(loci) {
    const elements = [];
    const models = /* @__PURE__ */ new Set();
    const { units } = loci.structure;
    for (let i = 0, len = loci.elements.length; i < len; i++) {
      const e = loci.elements[i];
      models.add(e.unit.model.id);
    }
    for (let i = 0, il = units.length; i < il; ++i) {
      const unit2 = units[i];
      if (models.has(unit2.model.id)) {
        const indices = OrderedSet.ofBounds(0, unit2.elements.length);
        elements[elements.length] = { unit: unit2, indices };
      }
    }
    return Loci2(loci.structure, elements);
  }
  Loci2.extendToWholeModels = extendToWholeModels;
  function getElementIndices(elements, indices) {
    const elementIndices = [];
    for (let i = 0, il = OrderedSet.size(indices); i < il; ++i) {
      elementIndices.push(elements[OrderedSet.getAt(indices, i)]);
    }
    return SortedArray.ofSortedArray(elementIndices);
  }
  function getUnitIndices(elements, indices) {
    if (SortedArray.isRange(elements) && SortedArray.areEqual(elements, indices)) {
      return Interval.ofLength(elements.length);
    }
    return makeIndexSet(SortedArray.indicesOf(elements, indices));
  }
  function extendToAllInstances(loci) {
    const elements = [];
    const byModel = /* @__PURE__ */ new Map();
    for (let i = 0, len = loci.elements.length; i < len; i++) {
      const e = loci.elements[i];
      const { model } = e.unit;
      const elementIndices = getElementIndices(e.unit.elements, e.indices);
      if (byModel.has(model)) {
        byModel.set(model, SortedArray.union(elementIndices, byModel.get(model)));
      } else {
        byModel.set(model, elementIndices);
      }
    }
    for (let i = 0, il = loci.structure.units.length; i < il; ++i) {
      const unit2 = loci.structure.units[i];
      const elementIndices = byModel.get(unit2.model);
      if (!elementIndices)
        continue;
      const indices = getUnitIndices(unit2.elements, elementIndices);
      if (OrderedSet.size(indices)) {
        elements[elements.length] = { unit: unit2, indices };
      }
    }
    return Loci2(loci.structure, elements);
  }
  Loci2.extendToAllInstances = extendToAllInstances;
  function extendToWholeOperators(loci) {
    const elements = [];
    const operators = /* @__PURE__ */ new Set();
    const { units } = loci.structure;
    for (let i = 0, len = loci.elements.length; i < len; i++) {
      const e = loci.elements[i];
      operators.add(e.unit.conformation.operator.name);
    }
    for (let i = 0, il = units.length; i < il; ++i) {
      const unit2 = units[i];
      if (operators.has(unit2.conformation.operator.name)) {
        const indices = OrderedSet.ofBounds(0, unit2.elements.length);
        elements[elements.length] = { unit: unit2, indices };
      }
    }
    return Loci2(loci.structure, elements);
  }
  Loci2.extendToWholeOperators = extendToWholeOperators;
  const boundaryHelper = new BoundaryHelper("98");
  const tempPosBoundary = Vec3();
  function getBoundary2(loci, transform, result2) {
    boundaryHelper.reset();
    for (const e of loci.elements) {
      const { indices } = e;
      const { elements, conformation } = e.unit;
      for (let i = 0, _i = OrderedSet.size(indices); i < _i; i++) {
        const eI = elements[OrderedSet.getAt(indices, i)];
        conformation.position(eI, tempPosBoundary);
        if (transform)
          Vec3.transformMat4(tempPosBoundary, tempPosBoundary, transform);
        boundaryHelper.includePositionRadius(tempPosBoundary, conformation.r(eI));
      }
    }
    boundaryHelper.finishedIncludeStep();
    for (const e of loci.elements) {
      const { indices } = e;
      const { elements, conformation } = e.unit;
      for (let i = 0, _i = OrderedSet.size(indices); i < _i; i++) {
        const eI = elements[OrderedSet.getAt(indices, i)];
        conformation.position(eI, tempPosBoundary);
        if (transform)
          Vec3.transformMat4(tempPosBoundary, tempPosBoundary, transform);
        boundaryHelper.radiusPositionRadius(tempPosBoundary, conformation.r(eI));
      }
    }
    if (result2) {
      if (result2.box)
        boundaryHelper.getBox(result2.box);
      if (result2.sphere)
        boundaryHelper.getSphere(result2.sphere);
      return result2;
    }
    return { box: boundaryHelper.getBox(), sphere: boundaryHelper.getSphere() };
  }
  Loci2.getBoundary = getBoundary2;
  const tempPos2 = Vec3();
  function toPositionsArray2(loci, positions, offset = 0) {
    let m = offset;
    for (const e of loci.elements) {
      const { indices } = e;
      const { elements, conformation } = e.unit;
      const indexCount = OrderedSet.size(indices);
      for (let i = 0; i < indexCount; i++) {
        const eI = elements[OrderedSet.getAt(indices, i)];
        conformation.position(eI, tempPos2);
        Vec3.toArray(tempPos2, positions, m + i * 3);
      }
      m += indexCount * 3;
    }
    return positions;
  }
  Loci2.toPositionsArray = toPositionsArray2;
  function getPrincipalAxes2(loci) {
    const elementCount = size(loci);
    const positions = toPositionsArray2(loci, new Float32Array(3 * elementCount));
    return PrincipalAxes.ofPositions(positions);
  }
  Loci2.getPrincipalAxes = getPrincipalAxes2;
  function getPrincipalAxesMany(locis) {
    let elementCount = 0;
    locis.forEach((l) => {
      elementCount += size(l);
    });
    const positions = new Float32Array(3 * elementCount);
    let offset = 0;
    locis.forEach((l) => {
      toPositionsArray2(l, positions, offset);
      offset += size(l) * 3;
    });
    return PrincipalAxes.ofPositions(positions);
  }
  Loci2.getPrincipalAxesMany = getPrincipalAxesMany;
  function sourceIndex(unit2, element) {
    return Unit.isAtomic(unit2) ? unit2.model.atomicHierarchy.atomSourceIndex.value(element) : element;
  }
  function toExpression2(loci) {
    if (Loci2.isEmpty(loci))
      return MolScriptBuilder.struct.generator.empty();
    const models = loci.structure.models;
    const sourceIndexMap = /* @__PURE__ */ new Map();
    for (const e of loci.elements) {
      const { indices } = e;
      const { elements } = e.unit;
      const key = e.unit.conformation.operator.name;
      let sourceIndices;
      if (sourceIndexMap.has(key))
        sourceIndices = sourceIndexMap.get(key).xs;
      else {
        sourceIndices = UniqueArray.create();
        sourceIndexMap.set(key, { modelLabel: e.unit.model.label, modelIndex: e.unit.model.modelNum, xs: sourceIndices });
      }
      for (let i = 0, _i = OrderedSet.size(indices); i < _i; i++) {
        const idx = sourceIndex(e.unit, elements[OrderedSet.getAt(indices, i)]);
        UniqueArray.add(sourceIndices, idx, idx);
      }
    }
    const opData = [];
    const keys = sourceIndexMap.keys();
    while (true) {
      const k = keys.next();
      if (k.done)
        break;
      const e = sourceIndexMap.get(k.value);
      opData.push(getOpData(k.value, e.xs.array, models.length > 1, e.modelLabel, e.modelIndex));
    }
    const opGroups = /* @__PURE__ */ new Map();
    for (let i = 0, il = opData.length; i < il; ++i) {
      const d = opData[i];
      const hash = hash2(hashFnv32a(d.atom.ranges), hashFnv32a(d.atom.set));
      const key = `${hash}|${d.entity ? d.entity.modelLabel + d.entity.modelIndex : ""}`;
      if (opGroups.has(key)) {
        opGroups.get(key).chain.opName.push(...d.chain.opName);
      } else {
        opGroups.set(key, d);
      }
    }
    const opQueries = [];
    opGroups.forEach((d) => {
      const { ranges, set: set2 } = d.atom;
      const { opName } = d.chain;
      const opProp = MolScriptBuilder.struct.atomProperty.core.operatorName();
      const siProp = MolScriptBuilder.struct.atomProperty.core.sourceIndex();
      const tests = [];
      if (set2.length > 0) {
        tests[tests.length] = MolScriptBuilder.core.set.has([MolScriptBuilder.core.type.set(set2), siProp]);
      }
      for (let rI = 0, _rI = ranges.length / 2; rI < _rI; rI++) {
        tests[tests.length] = MolScriptBuilder.core.rel.inRange([siProp, ranges[2 * rI], ranges[2 * rI + 1]]);
      }
      if (d.entity) {
        const { modelLabel, modelIndex } = d.entity;
        opQueries.push(MolScriptBuilder.struct.generator.atomGroups({
          "atom-test": tests.length > 1 ? MolScriptBuilder.core.logic.or(tests) : tests[0],
          "chain-test": opName.length > 1 ? MolScriptBuilder.core.set.has([MolScriptBuilder.core.type.set(opName), opProp]) : MolScriptBuilder.core.rel.eq([opProp, opName[0]]),
          "entity-test": MolScriptBuilder.core.logic.and([
            MolScriptBuilder.core.rel.eq([MolScriptBuilder.struct.atomProperty.core.modelLabel(), modelLabel]),
            MolScriptBuilder.core.rel.eq([MolScriptBuilder.struct.atomProperty.core.modelIndex(), modelIndex])
          ])
        }));
      } else {
        opQueries.push(MolScriptBuilder.struct.generator.atomGroups({
          "atom-test": tests.length > 1 ? MolScriptBuilder.core.logic.or(tests) : tests[0],
          "chain-test": opName.length > 1 ? MolScriptBuilder.core.set.has([MolScriptBuilder.core.type.set(opName), opProp]) : MolScriptBuilder.core.rel.eq([opProp, opName[0]])
        }));
      }
    });
    return MolScriptBuilder.struct.modifier.union([
      opQueries.length === 1 ? opQueries[0] : MolScriptBuilder.struct.combinator.merge(opQueries.map((q) => MolScriptBuilder.struct.modifier.union([q])))
    ]);
  }
  Loci2.toExpression = toExpression2;
  function getOpData(opName, xs, multimodel, modelLabel, modelIndex) {
    sortArray(xs);
    const ranges = [];
    const set2 = [];
    let i = 0;
    const len = xs.length;
    while (i < len) {
      const start = i;
      i++;
      while (i < len && xs[i - 1] + 1 === xs[i])
        i++;
      const end = i;
      if (end - start > 12) {
        ranges[ranges.length] = xs[start];
        ranges[ranges.length] = xs[end - 1];
      } else {
        for (let j = start; j < end; j++) {
          set2[set2.length] = xs[j];
        }
      }
    }
    return multimodel ? {
      atom: { set: set2, ranges },
      chain: { opName: [opName] },
      entity: { modelLabel, modelIndex }
    } : {
      atom: { set: set2, ranges },
      chain: { opName: [opName] }
    };
  }
})(Loci || (Loci = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/element/stats.js
var Stats;
(function(Stats2) {
  function create() {
    return {
      elementCount: 0,
      conformationCount: 0,
      residueCount: 0,
      chainCount: 0,
      unitCount: 0,
      structureCount: 0,
      firstElementLoc: Location.create(void 0),
      firstConformationLoc: Location.create(void 0),
      firstResidueLoc: Location.create(void 0),
      firstChainLoc: Location.create(void 0),
      firstUnitLoc: Location.create(void 0),
      firstStructureLoc: Location.create(void 0)
    };
  }
  Stats2.create = create;
  function addCountHelper(map2, key, inc) {
    const count = map2.get(key) || 0;
    map2.set(key, count + inc);
  }
  function handleElement(stats, structure, element) {
    const { indices, unit: unit2 } = element;
    const { elements } = unit2;
    const size = OrderedSet.size(indices);
    const lociResidueAltIdCounts = /* @__PURE__ */ new Map();
    const residueAltIdCounts = /* @__PURE__ */ new Map();
    if (size > 0) {
      Location.set(stats.firstElementLoc, structure, unit2, elements[OrderedSet.start(indices)]);
    }
    if (size === elements.length) {
      stats.unitCount += 1;
      if (stats.unitCount === 1) {
        Location.set(stats.firstUnitLoc, structure, unit2, elements[OrderedSet.start(indices)]);
      }
    } else if (size === 1) {
      if (Unit.Traits.is(unit2.traits, Unit.Trait.MultiChain)) {
        return;
      } else {
        stats.elementCount += 1;
        if (stats.elementCount === 1) {
          Location.set(stats.firstElementLoc, structure, unit2, elements[OrderedSet.start(indices)]);
        }
      }
    } else {
      if (Unit.isAtomic(unit2)) {
        const { index, offsets } = unit2.model.atomicHierarchy.residueAtomSegments;
        const { label_alt_id } = unit2.model.atomicHierarchy.atoms;
        let i = 0;
        while (i < size) {
          lociResidueAltIdCounts.clear();
          let j = 0;
          const eI = elements[OrderedSet.getAt(indices, i)];
          const rI = index[eI];
          addCountHelper(lociResidueAltIdCounts, label_alt_id.value(eI), 1);
          ++i;
          ++j;
          while (i < size) {
            const eI2 = elements[OrderedSet.getAt(indices, i)];
            if (index[eI2] !== rI)
              break;
            addCountHelper(lociResidueAltIdCounts, label_alt_id.value(eI2), 1);
            ++i;
            ++j;
          }
          if (offsets[rI + 1] - offsets[rI] === j) {
            stats.residueCount += 1;
            if (stats.residueCount === 1) {
              Location.set(stats.firstResidueLoc, structure, unit2, offsets[rI]);
            }
          } else {
            residueAltIdCounts.clear();
            for (let l = offsets[rI], _l = offsets[rI + 1]; l < _l; ++l) {
              addCountHelper(residueAltIdCounts, label_alt_id.value(l), 1);
            }
            if (residueAltIdCounts.get("") === lociResidueAltIdCounts.get("")) {
              lociResidueAltIdCounts.forEach((v, k) => {
                if (residueAltIdCounts.get(k) !== v)
                  return;
                if (k !== "") {
                  stats.conformationCount += 1;
                  if (stats.conformationCount === 1) {
                    for (let l = offsets[rI], _l = offsets[rI + 1]; l < _l; ++l) {
                      if (k === label_alt_id.value(l)) {
                        Location.set(stats.firstConformationLoc, structure, unit2, l);
                        break;
                      }
                    }
                  }
                }
                j -= v;
              });
            }
            stats.elementCount += j;
          }
        }
      } else {
        stats.elementCount += size;
        if (stats.elementCount === 1) {
          Location.set(stats.firstElementLoc, structure, unit2, elements[OrderedSet.start(indices)]);
        }
      }
    }
  }
  function handleUnitChainsSimple(stats, structure, element) {
    const { indices, unit: unit2 } = element;
    const size = OrderedSet.size(indices);
    if (size === 0)
      return;
    const { elements } = unit2;
    if (!Unit.Traits.is(unit2.traits, Unit.Trait.MultiChain)) {
      if (size === elements.length) {
        stats.chainCount += 1;
        if (stats.chainCount === 1) {
          Location.set(stats.firstChainLoc, structure, unit2, elements[OrderedSet.start(indices)]);
        }
      }
      return;
    }
    const segments = Unit.isAtomic(unit2) ? unit2.model.atomicHierarchy.chainAtomSegments : Unit.isSpheres(unit2) ? unit2.model.coarseHierarchy.spheres.chainElementSegments : Unit.isGaussians(unit2) ? unit2.model.coarseHierarchy.gaussians.chainElementSegments : void 0;
    if (!segments) {
      console.warn("StructureElement loci stats: unknown unit type");
      return;
    }
    const { index, offsets } = segments;
    let i = 0;
    while (i < size) {
      let j = 0;
      const eI = elements[OrderedSet.getAt(indices, i)];
      const cI = index[eI];
      ++i;
      ++j;
      while (i < size) {
        const eI2 = elements[OrderedSet.getAt(indices, i)];
        if (index[eI2] !== cI)
          break;
        ++i;
        ++j;
      }
      if (offsets[cI + 1] - offsets[cI] === j) {
        stats.chainCount += 1;
        if (stats.chainCount === 1) {
          Location.set(stats.firstChainLoc, structure, unit2, offsets[cI]);
        }
      } else if (size === 1) {
        stats.elementCount += 1;
        if (stats.elementCount === 1) {
          Location.set(stats.firstElementLoc, structure, unit2, eI);
        }
      }
    }
  }
  function handleUnitChainsPartitioned(stats, structure, lociElements, start, end) {
    let element = lociElements[start];
    const segments = Unit.isAtomic(element.unit) ? element.unit.model.atomicHierarchy.chainAtomSegments : Unit.isSpheres(element.unit) ? element.unit.model.coarseHierarchy.spheres.chainElementSegments : Unit.isGaussians(element.unit) ? element.unit.model.coarseHierarchy.gaussians.chainElementSegments : void 0;
    if (!segments) {
      console.warn("StructureElement loci stats: unknown unit type");
      return;
    }
    const { index, offsets } = segments;
    const chainCounts = /* @__PURE__ */ new Map();
    for (let elIndex = start; elIndex < end; elIndex++) {
      element = lociElements[elIndex];
      const { indices, unit: unit2 } = element;
      const size = OrderedSet.size(indices);
      if (size === 0)
        continue;
      const { elements } = unit2;
      if (!Unit.Traits.is(unit2.traits, Unit.Trait.MultiChain)) {
        const eI = elements[OrderedSet.start(indices)];
        addCountHelper(chainCounts, index[eI], elements.length);
        continue;
      }
      let i = 0;
      while (i < size) {
        let j = 0;
        const eI = elements[OrderedSet.getAt(indices, i)];
        const cI = index[eI];
        ++i;
        ++j;
        while (i < size) {
          const eI2 = elements[OrderedSet.getAt(indices, i)];
          if (index[eI2] !== cI)
            break;
          ++i;
          ++j;
        }
        addCountHelper(chainCounts, cI, j);
      }
    }
    let firstCI = -1;
    chainCounts.forEach((count, cI) => {
      if (offsets[cI + 1] - offsets[cI] === count) {
        stats.chainCount += 1;
        if (stats.chainCount === 1) {
          firstCI = cI;
        }
      }
    });
    if (firstCI < 0)
      return;
    for (let elIndex = start; elIndex < end; elIndex++) {
      element = lociElements[elIndex];
      const { indices, unit: unit2 } = element;
      const size = OrderedSet.size(indices);
      if (size === 0)
        continue;
      const { elements } = unit2;
      const i = 0;
      while (i < size) {
        const eI = elements[OrderedSet.getAt(indices, i)];
        const cI = index[eI];
        if (cI === firstCI) {
          Location.set(stats.firstChainLoc, structure, unit2, eI);
          return;
        }
      }
    }
  }
  function ofLoci(loci) {
    const stats = create();
    if (Loci.isEmpty(loci))
      return stats;
    let hasPartitions = false;
    if (Loci.isWholeStructure(loci)) {
      stats.structureCount += 1;
      if (stats.structureCount === 1) {
        const { unit: unit2, indices } = loci.elements[0];
        Location.set(stats.firstStructureLoc, loci.structure, unit2, unit2.elements[OrderedSet.min(indices)]);
      }
    } else {
      for (const e of loci.elements) {
        handleElement(stats, loci.structure, e);
        if (!Unit.Traits.is(e.unit.traits, Unit.Trait.Partitioned)) {
          handleUnitChainsSimple(stats, loci.structure, e);
        } else {
          hasPartitions = true;
        }
      }
    }
    if (hasPartitions) {
      for (let i = 0, len = loci.elements.length; i < len; i++) {
        const e = loci.elements[i];
        if (!Unit.Traits.is(e.unit.traits, Unit.Trait.Partitioned))
          continue;
        const start = i;
        while (i < len && Unit.areSameChainOperatorGroup(loci.elements[i].unit, e.unit)) {
          i++;
        }
        const end = i;
        i--;
        if (end - start === 1) {
          handleUnitChainsSimple(stats, loci.structure, e);
        } else {
          handleUnitChainsPartitioned(stats, loci.structure, loci.elements, start, end);
        }
      }
    }
    return stats;
  }
  Stats2.ofLoci = ofLoci;
  function add(out, a, b) {
    if (a.elementCount === 1 && b.elementCount === 0) {
      Location.copy(out.firstElementLoc, a.firstElementLoc);
    } else if (a.elementCount === 0 && b.elementCount === 1) {
      Location.copy(out.firstElementLoc, b.firstElementLoc);
    }
    if (a.conformationCount === 1 && b.conformationCount === 0) {
      Location.copy(out.firstConformationLoc, a.firstConformationLoc);
    } else if (a.conformationCount === 0 && b.conformationCount === 1) {
      Location.copy(out.firstConformationLoc, b.firstConformationLoc);
    }
    if (a.residueCount === 1 && b.residueCount === 0) {
      Location.copy(out.firstResidueLoc, a.firstResidueLoc);
    } else if (a.residueCount === 0 && b.residueCount === 1) {
      Location.copy(out.firstResidueLoc, b.firstResidueLoc);
    }
    if (a.chainCount === 1 && b.chainCount === 0) {
      Location.copy(out.firstChainLoc, a.firstChainLoc);
    } else if (a.chainCount === 0 && b.chainCount === 1) {
      Location.copy(out.firstChainLoc, b.firstChainLoc);
    }
    if (a.unitCount === 1 && b.unitCount === 0) {
      Location.copy(out.firstUnitLoc, a.firstUnitLoc);
    } else if (a.unitCount === 0 && b.unitCount === 1) {
      Location.copy(out.firstUnitLoc, b.firstUnitLoc);
    }
    if (a.structureCount === 1 && b.structureCount === 0) {
      Location.copy(out.firstStructureLoc, a.firstStructureLoc);
    } else if (a.structureCount === 0 && b.structureCount === 1) {
      Location.copy(out.firstStructureLoc, b.firstStructureLoc);
    }
    out.elementCount = a.elementCount + b.elementCount;
    out.conformationCount = a.conformationCount + b.conformationCount;
    out.residueCount = a.residueCount + b.residueCount;
    out.chainCount = a.chainCount + b.chainCount;
    out.unitCount = a.unitCount + b.unitCount;
    out.structureCount = a.structureCount + b.structureCount;
    return out;
  }
  Stats2.add = add;
})(Stats || (Stats = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/element/util.js
function property(p3) {
  return p3;
}
function _wrongUnitKind(kind) {
  throw new Error(`Property only available for ${kind} models.`);
}
function atomicProperty(p3) {
  return property((l) => Unit.isAtomic(l.unit) ? p3(l) : _wrongUnitKind("atomic"));
}
function coarseProperty(p3) {
  return property((l) => Unit.isCoarse(l.unit) ? p3(l) : _wrongUnitKind("coarse"));
}
function residueIndex(e) {
  if (Unit.isAtomic(e.unit)) {
    return e.unit.residueIndex[e.element];
  } else {
    return -1;
  }
}
function chainIndex(e) {
  if (Unit.isAtomic(e.unit)) {
    return e.unit.chainIndex[e.element];
  } else {
    return -1;
  }
}
function entityIndex(l) {
  return StructureProperties.entity.key(l);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/common/text/tokenizer.js
function Tokenizer(data) {
  return {
    data,
    position: 0,
    length: data.length,
    lineNumber: 1,
    tokenStart: 0,
    tokenEnd: 0
  };
}
(function(Tokenizer2) {
  function getTokenString2(state) {
    return state.data.substring(state.tokenStart, state.tokenEnd);
  }
  Tokenizer2.getTokenString = getTokenString2;
  function reset(state) {
    state.position = 0;
    state.lineNumber = 1;
    state.tokenStart = 0;
    state.tokenEnd = 0;
  }
  Tokenizer2.reset = reset;
  function eatLine(state) {
    const { data } = state;
    while (state.position < state.length) {
      switch (data.charCodeAt(state.position)) {
        case 10:
          state.tokenEnd = state.position;
          ++state.position;
          ++state.lineNumber;
          return true;
        case 13:
          state.tokenEnd = state.position;
          ++state.position;
          ++state.lineNumber;
          if (data.charCodeAt(state.position) === 10) {
            ++state.position;
          }
          return true;
        default:
          ++state.position;
          break;
      }
    }
    state.tokenEnd = state.position;
    return state.tokenStart !== state.tokenEnd;
  }
  Tokenizer2.eatLine = eatLine;
  function markStart(state) {
    state.tokenStart = state.position;
  }
  Tokenizer2.markStart = markStart;
  function markLine(state) {
    state.tokenStart = state.position;
    return eatLine(state);
  }
  Tokenizer2.markLine = markLine;
  function readLine(state) {
    markLine(state);
    return getTokenString2(state);
  }
  Tokenizer2.readLine = readLine;
  function readLineTrim(state) {
    markLine(state);
    const position = state.position;
    trim(state, state.tokenStart, state.tokenEnd);
    state.position = position;
    return getTokenString2(state);
  }
  Tokenizer2.readLineTrim = readLineTrim;
  function readLinesChunk(state, count, tokens) {
    let read = 0;
    for (let i = 0; i < count; i++) {
      if (!markLine(state))
        return read;
      TokenBuilder.addUnchecked(tokens, state.tokenStart, state.tokenEnd);
      read++;
    }
    return read;
  }
  function markLines(state, count) {
    const lineTokens = TokenBuilder.create(state.data, count * 2);
    readLinesChunk(state, count, lineTokens);
    return lineTokens;
  }
  Tokenizer2.markLines = markLines;
  function readLines(state, count) {
    const ret = [];
    for (let i = 0; i < count; i++) {
      ret.push(Tokenizer2.readLine(state));
    }
    return ret;
  }
  Tokenizer2.readLines = readLines;
  async function readLinesAsync(state, count, ctx, initialLineCount = 1e5) {
    const lineTokens = TokenBuilder.create(state.data, count * 2);
    let linesAlreadyRead = 0;
    await chunkedSubtask(ctx, initialLineCount, state, (chunkSize, state2) => {
      const linesToRead = Math.min(count - linesAlreadyRead, chunkSize);
      readLinesChunk(state2, linesToRead, lineTokens);
      linesAlreadyRead += linesToRead;
      return linesToRead;
    }, (ctx2, state2) => ctx2.update({ message: "Parsing...", current: state2.position, max: state2.length }));
    return lineTokens;
  }
  Tokenizer2.readLinesAsync = readLinesAsync;
  function readAllLines(data) {
    const state = Tokenizer2(data);
    const tokens = TokenBuilder.create(state.data, Math.max(data.length / 80, 2));
    while (markLine(state)) {
      TokenBuilder.add(tokens, state.tokenStart, state.tokenEnd);
    }
    return tokens;
  }
  Tokenizer2.readAllLines = readAllLines;
  function readLinesChunkChecked(state, count, tokens) {
    let read = 0;
    for (let i = 0; i < count; i++) {
      if (!markLine(state))
        return read;
      TokenBuilder.add(tokens, state.tokenStart, state.tokenEnd);
      read++;
    }
    return read;
  }
  async function readAllLinesAsync(data, ctx, chunkSize = 1e5) {
    const state = Tokenizer2(data);
    const tokens = TokenBuilder.create(state.data, Math.max(data.length / 80, 2));
    await chunkedSubtask(ctx, chunkSize, state, (chunkSize2, state2) => {
      readLinesChunkChecked(state2, chunkSize2, tokens);
      return state2.position < state2.length ? chunkSize2 : 0;
    }, (ctx2, state2) => ctx2.update({ message: "Parsing...", current: state2.position, max: state2.length }));
    return tokens;
  }
  Tokenizer2.readAllLinesAsync = readAllLinesAsync;
  function eatValue2(state) {
    while (state.position < state.length) {
      switch (state.data.charCodeAt(state.position)) {
        case 9:
        case 10:
        case 13:
        case 32:
          state.tokenEnd = state.position;
          return;
        default:
          ++state.position;
          break;
      }
    }
    state.tokenEnd = state.position;
  }
  Tokenizer2.eatValue = eatValue2;
  function skipWhitespace2(state) {
    let prev = -1;
    while (state.position < state.length) {
      const c = state.data.charCodeAt(state.position);
      switch (c) {
        case 9:
        case 32:
          prev = c;
          ++state.position;
          break;
        case 10:
          if (prev !== 13) {
            ++state.lineNumber;
          }
          prev = c;
          ++state.position;
          break;
        case 13:
          prev = c;
          ++state.position;
          ++state.lineNumber;
          break;
        default:
          return prev;
      }
    }
    return prev;
  }
  Tokenizer2.skipWhitespace = skipWhitespace2;
  function skipStrictWhitespace(state) {
    let prev = -1;
    while (state.position < state.length) {
      const c = state.data.charCodeAt(state.position);
      switch (c) {
        case 9:
        case 32:
          prev = c;
          ++state.position;
          break;
        default:
          return prev;
      }
    }
    return prev;
  }
  Tokenizer2.skipStrictWhitespace = skipStrictWhitespace;
  function trim(state, start, end) {
    const { data } = state;
    let s = start, e = end - 1;
    let c = data.charCodeAt(s);
    while ((c === 9 || c === 32) && s <= e)
      c = data.charCodeAt(++s);
    c = data.charCodeAt(e);
    while ((c === 9 || c === 32) && e >= s)
      c = data.charCodeAt(--e);
    state.tokenStart = s;
    state.tokenEnd = e + 1;
    state.position = end;
    return state;
  }
  Tokenizer2.trim = trim;
})(Tokenizer || (Tokenizer = {}));
function trimStr(data, start, end) {
  let s = start, e = end - 1;
  let c = data.charCodeAt(s);
  while ((c === 9 || c === 32) && s <= e)
    c = data.charCodeAt(++s);
  c = data.charCodeAt(e);
  while ((c === 9 || c === 32) && e >= s)
    c = data.charCodeAt(--e);
  return data.substring(s, e + 1);
}
var TokenBuilder;
(function(TokenBuilder2) {
  function resize(builder) {
    const newBuffer = new Uint32Array(1.61 * builder.indices.length | 0);
    newBuffer.set(builder.indices);
    builder.indices = newBuffer;
    builder.indicesLenMinus2 = newBuffer.length - 2 | 0;
  }
  function add(tokens, start, end) {
    const builder = tokens;
    if (builder.offset > builder.indicesLenMinus2) {
      resize(builder);
    }
    builder.indices[builder.offset++] = start;
    builder.indices[builder.offset++] = end;
    tokens.count++;
  }
  TokenBuilder2.add = add;
  function addToken(tokens, tokenizer) {
    add(tokens, tokenizer.tokenStart, tokenizer.tokenEnd);
  }
  TokenBuilder2.addToken = addToken;
  function addUnchecked(tokens, start, end) {
    tokens.indices[tokens.offset++] = start;
    tokens.indices[tokens.offset++] = end;
    tokens.count++;
  }
  TokenBuilder2.addUnchecked = addUnchecked;
  function create(data, size) {
    size = Math.max(10, size);
    return {
      data,
      indicesLenMinus2: size - 2 | 0,
      count: 0,
      offset: 0,
      indices: new Uint32Array(size)
    };
  }
  TokenBuilder2.create = create;
})(TokenBuilder || (TokenBuilder = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/result.js
var ReaderResult;
(function(ReaderResult2) {
  function error2(message, line = -1) {
    return new Error2(message, line);
  }
  ReaderResult2.error = error2;
  function success(result2, warnings = []) {
    return new Success(result2, warnings);
  }
  ReaderResult2.success = success;
  class Error2 {
    toString() {
      if (this.line >= 0) {
        return `[Line ${this.line}] ${this.message}`;
      }
      return this.message;
    }
    constructor(message, line) {
      this.message = message;
      this.line = line;
      this.isError = true;
    }
  }
  ReaderResult2.Error = Error2;
  class Success {
    constructor(result2, warnings) {
      this.result = result2;
      this.warnings = warnings;
      this.isError = false;
    }
  }
  ReaderResult2.Success = Success;
})(ReaderResult || (ReaderResult = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/text/parser.js
var CifTokenType;
(function(CifTokenType2) {
  CifTokenType2[CifTokenType2["Data"] = 0] = "Data";
  CifTokenType2[CifTokenType2["Save"] = 1] = "Save";
  CifTokenType2[CifTokenType2["Loop"] = 2] = "Loop";
  CifTokenType2[CifTokenType2["Value"] = 3] = "Value";
  CifTokenType2[CifTokenType2["ColumnName"] = 4] = "ColumnName";
  CifTokenType2[CifTokenType2["Comment"] = 5] = "Comment";
  CifTokenType2[CifTokenType2["End"] = 6] = "End";
})(CifTokenType || (CifTokenType = {}));
function eatValue(state) {
  while (state.position < state.length) {
    switch (state.data.charCodeAt(state.position)) {
      case 9:
      case 10:
      case 13:
      case 32:
        state.tokenEnd = state.position;
        return;
      default:
        ++state.position;
        break;
    }
  }
  state.tokenEnd = state.position;
}
function eatEscaped(state, esc) {
  let next, c;
  ++state.position;
  while (state.position < state.length) {
    c = state.data.charCodeAt(state.position);
    if (c === esc) {
      next = state.data.charCodeAt(state.position + 1);
      switch (next) {
        case 9:
        case 10:
        case 13:
        case 32:
          state.tokenStart++;
          state.tokenEnd = state.position;
          state.isEscaped = true;
          ++state.position;
          return;
        default:
          if (next === void 0) {
            state.tokenStart++;
            state.tokenEnd = state.position;
            state.isEscaped = true;
            ++state.position;
            return;
          }
          ++state.position;
          break;
      }
    } else {
      if (c === 10 || c === 13) {
        state.tokenEnd = state.position;
        return;
      }
      ++state.position;
    }
  }
  state.tokenEnd = state.position;
}
function eatTripleQuote(state) {
  state.position += 3;
  while (state.position < state.length) {
    if (state.data.charCodeAt(state.position) === 39 && isTripleQuoteAtPosition(state)) {
      state.tokenStart += 3;
      state.tokenEnd = state.position;
      state.isEscaped = true;
      state.position += 3;
      return;
    }
    ++state.position;
  }
  state.tokenEnd = state.position;
}
function eatMultiline(state) {
  let prev = 59, pos = state.position + 1, c;
  while (pos < state.length) {
    c = state.data.charCodeAt(pos);
    if (c === 59 && (prev === 10 || prev === 13)) {
      state.position = pos + 1;
      state.tokenStart++;
      pos--;
      c = state.data.charCodeAt(pos);
      while (c === 10 || c === 13) {
        pos--;
        c = state.data.charCodeAt(pos);
      }
      state.tokenEnd = pos + 1;
      state.isEscaped = true;
      return;
    } else {
      if (c === 13) {
        state.lineNumber++;
      } else if (c === 10 && prev !== 13) {
        state.lineNumber++;
      }
      prev = c;
      ++pos;
    }
  }
  state.position = pos;
  return prev;
}
function eatImportGet(state) {
  while (state.position < state.length) {
    switch (state.data.charCodeAt(state.position)) {
      case 93:
        ++state.position;
        state.tokenEnd = state.position;
        state.isImportGet = false;
        return;
      default:
        ++state.position;
        break;
    }
  }
}
function skipCommentLine(state) {
  while (state.position < state.length) {
    const c = state.data.charCodeAt(state.position);
    if (c === 10 || c === 13) {
      return;
    }
    ++state.position;
  }
}
function skipWhitespace(state) {
  let prev = 10;
  while (state.position < state.length) {
    const c = state.data.charCodeAt(state.position);
    switch (c) {
      case 9:
      case 32:
        prev = c;
        ++state.position;
        break;
      case 10:
        if (prev !== 13) {
          ++state.lineNumber;
        }
        prev = c;
        ++state.position;
        break;
      case 13:
        prev = c;
        ++state.position;
        ++state.lineNumber;
        break;
      default:
        return prev;
    }
  }
  return prev;
}
function isTripleQuoteAtPosition(state) {
  if (state.length - state.position < 2)
    return false;
  if (state.data.charCodeAt(state.position + 1) !== 39)
    return false;
  if (state.data.charCodeAt(state.position + 2) !== 39)
    return false;
  return true;
}
function isData(state) {
  let c = state.data.charCodeAt(state.tokenStart);
  if (c !== 68 && c !== 100)
    return false;
  c = state.data.charCodeAt(state.tokenStart + 1);
  if (c !== 65 && c !== 97)
    return false;
  c = state.data.charCodeAt(state.tokenStart + 2);
  if (c !== 84 && c !== 116)
    return false;
  c = state.data.charCodeAt(state.tokenStart + 3);
  if (c !== 65 && c !== 97)
    return false;
  return true;
}
function isSave(state) {
  let c = state.data.charCodeAt(state.tokenStart);
  if (c !== 83 && c !== 115)
    return false;
  c = state.data.charCodeAt(state.tokenStart + 1);
  if (c !== 65 && c !== 97)
    return false;
  c = state.data.charCodeAt(state.tokenStart + 2);
  if (c !== 86 && c !== 118)
    return false;
  c = state.data.charCodeAt(state.tokenStart + 3);
  if (c !== 69 && c !== 101)
    return false;
  return true;
}
function isLoop(state) {
  if (state.tokenEnd - state.tokenStart !== 5)
    return false;
  let c = state.data.charCodeAt(state.tokenStart);
  if (c !== 76 && c !== 108)
    return false;
  c = state.data.charCodeAt(state.tokenStart + 1);
  if (c !== 79 && c !== 111)
    return false;
  c = state.data.charCodeAt(state.tokenStart + 2);
  if (c !== 79 && c !== 111)
    return false;
  c = state.data.charCodeAt(state.tokenStart + 3);
  if (c !== 80 && c !== 112)
    return false;
  return true;
}
function isImportGet(state) {
  if (state.tokenEnd - state.tokenStart !== 11)
    return false;
  if (state.data.charCodeAt(state.tokenStart + 1) !== 105)
    return false;
  if (state.data.charCodeAt(state.tokenStart + 2) !== 109)
    return false;
  if (state.data.charCodeAt(state.tokenStart + 3) !== 112)
    return false;
  if (state.data.charCodeAt(state.tokenStart + 4) !== 111)
    return false;
  if (state.data.charCodeAt(state.tokenStart + 5) !== 114)
    return false;
  if (state.data.charCodeAt(state.tokenStart + 6) !== 116)
    return false;
  if (state.data.charCodeAt(state.tokenStart + 7) !== 46)
    return false;
  if (state.data.charCodeAt(state.tokenStart + 8) !== 103)
    return false;
  if (state.data.charCodeAt(state.tokenStart + 9) !== 101)
    return false;
  if (state.data.charCodeAt(state.tokenStart + 10) !== 116)
    return false;
  return true;
}
function isNamespace(state, start, end) {
  let i;
  const nsLen = end - start;
  const offset = state.tokenStart - start;
  const tokenLen = state.tokenEnd - state.tokenStart;
  if (tokenLen < nsLen)
    return false;
  for (i = start; i < end; ++i) {
    if (state.data.charCodeAt(i) !== state.data.charCodeAt(i + offset))
      return false;
  }
  if (nsLen === tokenLen)
    return true;
  if (state.data.charCodeAt(i + offset) === 46) {
    return true;
  }
  return false;
}
function getNamespaceEnd(state) {
  let i;
  for (i = state.tokenStart; i < state.tokenEnd; ++i) {
    if (state.data.charCodeAt(i) === 46)
      return i;
  }
  return i;
}
function getNamespace(state, endIndex) {
  return state.data.substring(state.tokenStart, endIndex);
}
function isFlatNamespace(state) {
  let i;
  for (i = state.tokenStart; i < state.tokenEnd; ++i) {
    if (state.data.charCodeAt(i) === 46)
      return false;
  }
  return true;
}
function getTokenString(state) {
  return state.data.substring(state.tokenStart, state.tokenEnd);
}
function moveNextInternal(state) {
  const prev = skipWhitespace(state);
  if (state.position >= state.length) {
    state.tokenType = CifTokenType.End;
    return;
  }
  state.tokenStart = state.position;
  state.tokenEnd = state.position;
  state.isEscaped = false;
  const c = state.data.charCodeAt(state.position);
  switch (c) {
    case 35:
      skipCommentLine(state);
      state.tokenType = CifTokenType.Comment;
      break;
    case 39:
      if (isTripleQuoteAtPosition(state)) {
        eatTripleQuote(state);
        state.tokenType = CifTokenType.Value;
        break;
      }
    case 34:
      eatEscaped(state, c);
      state.tokenType = CifTokenType.Value;
      break;
    case 59:
      if (prev === 10 || prev === 13) {
        eatMultiline(state);
      } else {
        eatValue(state);
      }
      state.tokenType = CifTokenType.Value;
      break;
    default:
      if (state.isImportGet) {
        eatImportGet(state);
      } else {
        eatValue(state);
      }
      if (state.isEscaped) {
        state.tokenType = CifTokenType.Value;
      } else if (state.data.charCodeAt(state.tokenStart) === 95) {
        if (state.inSaveFrame && isImportGet(state)) {
          state.isImportGet = true;
        }
        state.tokenType = CifTokenType.ColumnName;
      } else if (state.tokenEnd - state.tokenStart >= 5 && state.data.charCodeAt(state.tokenStart + 4) === 95) {
        if (isData(state))
          state.tokenType = CifTokenType.Data;
        else if (isSave(state))
          state.tokenType = CifTokenType.Save;
        else if (isLoop(state))
          state.tokenType = CifTokenType.Loop;
        else
          state.tokenType = CifTokenType.Value;
      } else {
        state.tokenType = CifTokenType.Value;
      }
      break;
  }
}
function moveNext(state) {
  moveNextInternal(state);
  while (state.tokenType === CifTokenType.Comment)
    moveNextInternal(state);
}
function createTokenizer(data, runtimeCtx) {
  return {
    data,
    length: data.length,
    position: 0,
    tokenStart: 0,
    tokenEnd: 0,
    tokenType: CifTokenType.End,
    lineNumber: 1,
    isEscaped: false,
    isImportGet: false,
    inSaveFrame: false,
    runtimeCtx
  };
}
function FrameContext() {
  return { categoryNames: [], categoryData: /* @__PURE__ */ Object.create(null) };
}
function CifCategories(categoryNames, categoryData) {
  const categories = /* @__PURE__ */ Object.create(null);
  for (const name of categoryNames) {
    const d = categoryData[name];
    categories[name] = CifCategory(d.name, d.rowCount, d.fieldNames, d.fields);
  }
  return categories;
}
function CifBlock2(ctx, header, saveFrames) {
  return CifBlock(ctx.categoryNames, CifCategories(ctx.categoryNames, ctx.categoryData), header, saveFrames);
}
function CifSaveFrame2(ctx, header) {
  return CifBlock(ctx.categoryNames, CifCategories(ctx.categoryNames, ctx.categoryData), header);
}
function addFields(ctx, name, rowCount, fieldNames, fields) {
  if (name in ctx.categoryData) {
    const cat = ctx.categoryData[name];
    cat.fieldNames.push(...fieldNames);
    Object.assign(cat.fields, fields);
  } else {
    ctx.categoryData[name] = { name, rowCount, fieldNames, fields };
    ctx.categoryNames.push(name);
  }
}
function handleSingle(tokenizer, ctx) {
  const nsStart = tokenizer.tokenStart, nsEnd = getNamespaceEnd(tokenizer);
  const name = getNamespace(tokenizer, nsEnd);
  const fields = /* @__PURE__ */ Object.create(null);
  const fieldNames = [];
  let readingNames = true;
  while (readingNames) {
    if (tokenizer.tokenType !== CifTokenType.ColumnName || !isNamespace(tokenizer, nsStart, nsEnd)) {
      readingNames = false;
      break;
    }
    const fieldName = getTokenString(tokenizer).substring(name.length + 1);
    moveNext(tokenizer);
    if (tokenizer.tokenType !== CifTokenType.Value) {
      return {
        hasError: true,
        errorLine: tokenizer.lineNumber,
        errorMessage: "Expected value."
      };
    }
    fields[fieldName] = CifField.ofTokens({ data: tokenizer.data, indices: [tokenizer.tokenStart, tokenizer.tokenEnd], count: 1 });
    fieldNames[fieldNames.length] = fieldName;
    moveNext(tokenizer);
  }
  addFields(ctx, name.substr(1), 1, fieldNames, fields);
  return {
    hasError: false,
    errorLine: 0,
    errorMessage: ""
  };
}
function readLoopChunk(chunkSize, state) {
  const { tokenizer, tokens, fieldCount } = state;
  let tokenCount = state.tokenCount;
  let counter = 0;
  while (tokenizer.tokenType === CifTokenType.Value && counter < chunkSize) {
    TokenBuilder.add(tokens[tokenCount++ % fieldCount], tokenizer.tokenStart, tokenizer.tokenEnd);
    moveNext(tokenizer);
    counter++;
  }
  state.tokenCount = tokenCount;
  return counter;
}
function updateLoopChunk(ctx, state) {
  return ctx.update({ message: "Parsing...", current: state.tokenizer.position, max: state.tokenizer.data.length });
}
async function handleLoop(tokenizer, ctx) {
  const loopLine = tokenizer.lineNumber;
  moveNext(tokenizer);
  const name = getNamespace(tokenizer, getNamespaceEnd(tokenizer));
  const isFlat = isFlatNamespace(tokenizer);
  const fieldNames = [];
  while (tokenizer.tokenType === CifTokenType.ColumnName) {
    fieldNames[fieldNames.length] = isFlat ? getTokenString(tokenizer) : getTokenString(tokenizer).substring(name.length + 1);
    moveNext(tokenizer);
  }
  const rowCountEstimate = name === "_atom_site" ? tokenizer.data.length / 100 | 0 : 32;
  const tokens = [];
  const fieldCount = fieldNames.length;
  for (let i = 0; i < fieldCount; i++)
    tokens[i] = TokenBuilder.create(tokenizer.data, rowCountEstimate);
  const state = {
    fieldCount,
    tokenCount: 0,
    tokenizer,
    tokens
  };
  await chunkedSubtask(tokenizer.runtimeCtx, 1e6, state, readLoopChunk, updateLoopChunk);
  if (state.tokenCount % fieldCount !== 0) {
    return {
      hasError: true,
      errorLine: tokenizer.lineNumber,
      errorMessage: `The number of values for loop starting at line ${loopLine} is not a multiple of the number of columns.`
    };
  }
  const rowCount = state.tokenCount / fieldCount | 0;
  if (isFlat) {
    for (let i = 0; i < fieldCount; i++) {
      const fields = { "": CifField.ofTokens(tokens[i]) };
      addFields(ctx, fieldNames[i].substr(1), rowCount, [""], fields);
    }
  } else {
    const fields = /* @__PURE__ */ Object.create(null);
    for (let i = 0; i < fieldCount; i++) {
      fields[fieldNames[i]] = CifField.ofTokens(tokens[i]);
    }
    addFields(ctx, name.substr(1), rowCount, fieldNames, fields);
  }
  return {
    hasError: false,
    errorLine: 0,
    errorMessage: ""
  };
}
function error(line, message) {
  return ReaderResult.error(message, line);
}
function result(data) {
  return ReaderResult.success(data);
}
async function parseInternal(data, runtimeCtx) {
  const dataBlocks = [];
  const tokenizer = createTokenizer(data, runtimeCtx);
  let blockHeader = "";
  let blockCtx = FrameContext();
  let saveFrames = [];
  let saveCtx = FrameContext();
  const saveFrame = CifSaveFrame(saveCtx.categoryNames, CifCategories(saveCtx.categoryNames, saveCtx.categoryData), "");
  let saveHeader = "";
  runtimeCtx.update({ message: "Parsing...", current: 0, max: data.length });
  moveNext(tokenizer);
  while (tokenizer.tokenType !== CifTokenType.End) {
    const token = tokenizer.tokenType;
    if (token === CifTokenType.Data) {
      if (tokenizer.inSaveFrame) {
        return error(tokenizer.lineNumber, "Unexpected data block inside a save frame.");
      }
      if (blockCtx.categoryNames.length > 0) {
        dataBlocks.push(CifBlock2(blockCtx, blockHeader, saveFrames));
      }
      blockHeader = data.substring(tokenizer.tokenStart + 5, tokenizer.tokenEnd);
      blockCtx = FrameContext();
      saveFrames = [];
      moveNext(tokenizer);
    } else if (token === CifTokenType.Save) {
      if (tokenizer.tokenEnd - tokenizer.tokenStart === 5) {
        if (saveCtx.categoryNames.length > 0) {
          saveFrames[saveFrames.length] = CifSaveFrame2(saveCtx, saveHeader);
        }
        tokenizer.inSaveFrame = false;
      } else {
        if (tokenizer.inSaveFrame) {
          return error(tokenizer.lineNumber, "Save frames cannot be nested.");
        }
        tokenizer.inSaveFrame = true;
        saveHeader = data.substring(tokenizer.tokenStart + 5, tokenizer.tokenEnd);
        saveCtx = FrameContext();
      }
      moveNext(tokenizer);
    } else if (token === CifTokenType.Loop) {
      const cat = await handleLoop(tokenizer, tokenizer.inSaveFrame ? saveCtx : blockCtx);
      if (cat.hasError) {
        return error(cat.errorLine, cat.errorMessage);
      }
    } else if (token === CifTokenType.ColumnName) {
      const cat = handleSingle(tokenizer, tokenizer.inSaveFrame ? saveCtx : blockCtx);
      if (cat.hasError) {
        return error(cat.errorLine, cat.errorMessage);
      }
    } else {
      console.log(tokenizer.tokenType, Tokenizer.getTokenString(tokenizer));
      return error(tokenizer.lineNumber, "Unexpected token. Expected data_, loop_, or data name.");
    }
  }
  if (tokenizer.inSaveFrame) {
    return error(tokenizer.lineNumber, `Unfinished save frame (${saveFrame.header}).`);
  }
  if (blockCtx.categoryNames.length > 0 || saveFrames.length > 0) {
    dataBlocks.push(CifBlock2(blockCtx, blockHeader, saveFrames));
  }
  return result(CifFile(dataBlocks));
}
function parseCifText(data) {
  return Task.create("Parse CIF", async (ctx) => {
    return await parseInternal(data, ctx);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/binary/field.js
function Field2(column) {
  const mask = column.mask ? decode(column.mask) : void 0;
  const data = decode(column.data);
  const isNumeric = column_helpers_exports.isTypedArray(data);
  const str9 = isNumeric ? mask ? (row) => mask[row] === Column.ValueKinds.Present ? "" + data[row] : "" : (row) => "" + data[row] : mask ? (row) => mask[row] === Column.ValueKinds.Present ? data[row] : "" : (row) => data[row];
  const int7 = isNumeric ? (row) => data[row] : (row) => {
    const v = data[row];
    return parseInt2(v, 0, v.length);
  };
  const float7 = isNumeric ? (row) => data[row] : (row) => {
    const v = data[row];
    return parseFloat2(v, 0, v.length);
  };
  const valueKind = mask ? (row) => mask[row] : (row) => Column.ValueKinds.Present;
  const rowCount = data.length;
  return {
    __array: data,
    binaryEncoding: column.data.encoding,
    isDefined: true,
    rowCount,
    str: str9,
    int: int7,
    float: float7,
    valueKind,
    areValuesEqual: (rowA, rowB) => data[rowA] === data[rowB],
    toStringArray: (params) => column_helpers_exports.createAndFillArray(rowCount, str9, params),
    toIntArray: isNumeric ? (params) => column_helpers_exports.typedArrayWindow(data, params) : (params) => column_helpers_exports.createAndFillArray(rowCount, int7, params),
    toFloatArray: isNumeric ? (params) => column_helpers_exports.typedArrayWindow(data, params) : (params) => column_helpers_exports.createAndFillArray(rowCount, float7, params)
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/msgpack/decode.js
function decodeMsgPack(buffer) {
  return parse({ buffer, offset: 0, dataView: new DataView(buffer.buffer) });
}
function map(state, length) {
  const value = {};
  for (let i = 0; i < length; i++) {
    const key = parse(state);
    value[key] = parse(state);
  }
  return value;
}
function bin(state, length) {
  const value = new Uint8Array(length);
  const o = state.offset;
  for (let i = 0; i < length; i++)
    value[i] = state.buffer[i + o];
  state.offset += length;
  return value;
}
function str3(state, length) {
  const value = utf8Read(state.buffer, state.offset, length);
  state.offset += length;
  return value;
}
function array(state, length) {
  const value = new Array(length);
  for (let i = 0; i < length; i++) {
    value[i] = parse(state);
  }
  return value;
}
function parse(state) {
  const type3 = state.buffer[state.offset];
  let value, length;
  if ((type3 & 128) === 0) {
    state.offset++;
    return type3;
  }
  if ((type3 & 240) === 128) {
    length = type3 & 15;
    state.offset++;
    return map(state, length);
  }
  if ((type3 & 240) === 144) {
    length = type3 & 15;
    state.offset++;
    return array(state, length);
  }
  if ((type3 & 224) === 160) {
    length = type3 & 31;
    state.offset++;
    return str3(state, length);
  }
  if ((type3 & 224) === 224) {
    value = state.dataView.getInt8(state.offset);
    state.offset++;
    return value;
  }
  switch (type3) {
    case 192:
      state.offset++;
      return null;
    case 194:
      state.offset++;
      return false;
    case 195:
      state.offset++;
      return true;
    case 196:
      length = state.dataView.getUint8(state.offset + 1);
      state.offset += 2;
      return bin(state, length);
    case 197:
      length = state.dataView.getUint16(state.offset + 1);
      state.offset += 3;
      return bin(state, length);
    case 198:
      length = state.dataView.getUint32(state.offset + 1);
      state.offset += 5;
      return bin(state, length);
    case 202:
      value = state.dataView.getFloat32(state.offset + 1);
      state.offset += 5;
      return value;
    case 203:
      value = state.dataView.getFloat64(state.offset + 1);
      state.offset += 9;
      return value;
    case 204:
      value = state.buffer[state.offset + 1];
      state.offset += 2;
      return value;
    case 205:
      value = state.dataView.getUint16(state.offset + 1);
      state.offset += 3;
      return value;
    case 206:
      value = state.dataView.getUint32(state.offset + 1);
      state.offset += 5;
      return value;
    case 208:
      value = state.dataView.getInt8(state.offset + 1);
      state.offset += 2;
      return value;
    case 209:
      value = state.dataView.getInt16(state.offset + 1);
      state.offset += 3;
      return value;
    case 210:
      value = state.dataView.getInt32(state.offset + 1);
      state.offset += 5;
      return value;
    case 217:
      length = state.dataView.getUint8(state.offset + 1);
      state.offset += 2;
      return str3(state, length);
    case 218:
      length = state.dataView.getUint16(state.offset + 1);
      state.offset += 3;
      return str3(state, length);
    case 219:
      length = state.dataView.getUint32(state.offset + 1);
      state.offset += 5;
      return str3(state, length);
    case 220:
      length = state.dataView.getUint16(state.offset + 1);
      state.offset += 3;
      return array(state, length);
    case 221:
      length = state.dataView.getUint32(state.offset + 1);
      state.offset += 5;
      return array(state, length);
    case 222:
      length = state.dataView.getUint16(state.offset + 1);
      state.offset += 3;
      return map(state, length);
    case 223:
      length = state.dataView.getUint32(state.offset + 1);
      state.offset += 5;
      return map(state, length);
  }
  throw new Error("Unknown type 0x" + type3.toString(16));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/binary/parser.js
function checkVersions(min, current) {
  for (let i = 0; i < 2; i++) {
    if (min[i] > current[i])
      return false;
  }
  return true;
}
function Category2(data) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const cache = /* @__PURE__ */ Object.create(null);
  for (const col of data.columns)
    map2[col.name] = col;
  return {
    rowCount: data.rowCount,
    name: data.name.substring(1),
    fieldNames: data.columns.map((c) => c.name),
    getField(name) {
      const col = map2[name];
      if (!col)
        return void 0;
      if (!!cache[name])
        return cache[name];
      cache[name] = Field2(col);
      return cache[name];
    }
  };
}
function parseCifBinary(data) {
  return Task.create("Parse BinaryCIF", async (ctx) => {
    const minVersion = [0, 3];
    try {
      const unpacked = decodeMsgPack(data);
      if (!checkVersions(minVersion, unpacked.version.match(/(\d)\.(\d)\.\d/).slice(1).map((v) => +v))) {
        return ReaderResult.error(`Unsupported format version. Current ${unpacked.version}, required ${minVersion.join(".")}.`);
      }
      const file = CifFile(unpacked.dataBlocks.map((block) => {
        const cats = /* @__PURE__ */ Object.create(null);
        for (const cat of block.categories)
          cats[cat.name.substring(1)] = Category2(cat);
        return CifBlock(block.categories.map((c) => c.name.substring(1)), cats, block.header);
      }));
      return ReaderResult.success(file);
    } catch (e) {
      return ReaderResult.error("" + e);
    }
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/schema/ccd.js
var Schema3 = Column.Schema;
var str4 = Schema3.str;
var float2 = Schema3.float;
var List2 = Schema3.List;
var lstr2 = Schema3.lstr;
var Aliased2 = Schema3.Aliased;
var int2 = Schema3.int;
var coord2 = Schema3.coord;
var CCD_Schema = {
  /**
   * Data items in the CHEM_COMP category give details about each
   * of the chemical components from which the relevant chemical
   * structures can be constructed, such as name, mass or charge.
   *
   * The related categories CHEM_COMP_ATOM, CHEM_COMP_BOND,
   * CHEM_COMP_ANGLE etc. describe the detailed geometry of these
   * chemical components.
   */
  chem_comp: {
    /**
     * The formula for the chemical component. Formulae are written
     * according to the following rules:
     *
     * (1) Only recognized element symbols may be used.
     *
     * (2) Each element symbol is followed by a 'count' number. A count
     * of '1' may be omitted.
     *
     * (3) A space or parenthesis must separate each cluster of
     * (element symbol + count), but in general parentheses are
     * not used.
     *
     * (4) The order of elements depends on whether carbon is
     * present or not. If carbon is present, the order should be:
     * C, then H, then the other elements in alphabetical order
     * of their symbol. If carbon is not present, the elements
     * are listed purely in alphabetic order of their symbol. This
     * is the 'Hill' system used by Chemical Abstracts.
     */
    formula: str4,
    /**
     * Formula mass in daltons of the chemical component.
     */
    formula_weight: float2,
    /**
     * The value of _chem_comp.id must uniquely identify each item in
     * the CHEM_COMP list.
     *
     * For protein polymer entities, this is the three-letter code for
     * the amino acid.
     *
     * For nucleic acid polymer entities, this is the one-letter code
     * for the base.
     */
    id: str4,
    /**
     * The identifier for the parent component of the nonstandard
     * component. May be be a comma separated list if this component
     * is derived from multiple components.
     *
     * Items in this indirectly point to _chem_comp.id in
     * the CHEM_COMP category.
     */
    mon_nstd_parent_comp_id: List2(",", (x) => x),
    /**
     * The full name of the component.
     */
    name: str4,
    /**
     * For standard polymer components, the one-letter code for
     * the component.   For non-standard polymer components, the
     * one-letter code for parent component if this exists;
     * otherwise, the one-letter code should be given as 'X'.
     *
     * Components that derived from multiple parents components
     * are described by a sequence of one-letter-codes.
     */
    one_letter_code: str4,
    /**
     * For standard polymer components, the common three-letter code for
     * the component.   Non-standard polymer components and non-polymer
     * components are also assigned three-letter-codes.
     *
     * For ambiguous polymer components three-letter code should
     * be given as 'UNK'.  Ambiguous ions are assigned the code 'UNX'.
     * Ambiguous non-polymer components are assigned the code 'UNL'.
     */
    three_letter_code: str4,
    /**
     * For standard polymer components, the type of the monomer.
     * Note that monomers that will form polymers are of three types:
     * linking monomers, monomers with some type of N-terminal (or 5')
     * cap and monomers with some type of C-terminal (or 3') cap.
     */
    type: Aliased2(lstr2),
    /**
     * Synonym list for the component.
     */
    pdbx_synonyms: List2(";", (x) => x),
    /**
     * A preliminary classification used by PDB.
     */
    pdbx_type: str4,
    /**
     * A preliminary classification used by PDB to indicate
     * that the chemistry of this component while described
     * as clearly as possible is still ambiguous.  Software
     * tools may not be able to process this component
     * definition.
     */
    pdbx_ambiguous_flag: str4,
    /**
     * Identifies the _chem_comp.id of the component that
     * has replaced this component.
     */
    pdbx_replaced_by: str4,
    /**
     * Identifies the _chem_comp.id's of the components
     * which have been replaced by this component.
     * Multiple id codes should be separated by commas.
     */
    pdbx_replaces: str4,
    /**
     * The net integer charge assigned to this component. This is the
     * formal charge assignment normally found in chemical diagrams.
     */
    pdbx_formal_charge: int2,
    /**
     * This data item provides additional details about the model coordinates
     * in the component definition.
     */
    pdbx_model_coordinates_details: str4,
    /**
     * This data item identifies the PDB database code from which the heavy
     * atom model coordinates were obtained.
     */
    pdbx_model_coordinates_db_code: str4,
    /**
     * This data item identifies the source of the ideal coordinates in the
     * component definition.
     */
    pdbx_ideal_coordinates_details: str4,
    /**
     * This data item identifies if ideal coordinates are missing in this definition.
     */
    pdbx_ideal_coordinates_missing_flag: Aliased2(lstr2),
    /**
     * This data item identifies if model coordinates are missing in this definition.
     */
    pdbx_model_coordinates_missing_flag: Aliased2(lstr2),
    /**
     * Date component was added to database.
     */
    pdbx_initial_date: str4,
    /**
     * Date component was last modified.
     */
    pdbx_modified_date: str4,
    /**
     * This data item holds the current release status for the component.
     */
    pdbx_release_status: Aliased2(str4),
    /**
     * This data item identifies the deposition site that processed
     * this chemical component defintion.
     */
    pdbx_processing_site: Aliased2(str4)
  },
  /**
   * Data items in the CHEM_COMP_ATOM category record details about
   * the atoms in a chemical component. Specifying the atomic
   * coordinates for the components in this category is an
   * alternative to specifying the structure of the component
   * via bonds, angles, planes etc. in the appropriate
   * CHEM_COMP subcategories.
   */
  chem_comp_atom: {
    /**
     * An alternative identifier for the atom. This data item would be
     * used in cases where alternative nomenclatures exist for labelling
     * atoms in a group.
     */
    alt_atom_id: str4,
    /**
     * The value of _chem_comp_atom.atom_id must uniquely identify
     * each atom in each monomer in the CHEM_COMP_ATOM list.
     *
     * The atom identifiers need not be unique over all atoms in the
     * data block; they need only be unique for each atom in a
     * component.
     *
     * Note that this item need not be a number; it can be any unique
     * identifier.
     */
    atom_id: str4,
    /**
     * The net integer charge assigned to this atom. This is the
     * formal charge assignment normally found in chemical diagrams.
     */
    charge: int2,
    /**
     * The x component of the coordinates for this atom in this
     * component specified as orthogonal angstroms. The choice of
     * reference axis frame for the coordinates is arbitrary.
     *
     * The set of coordinates input for the entity here is intended to
     * correspond to the atomic model used to generate restraints for
     * structure refinement, not to atom sites in the ATOM_SITE
     * list.
     */
    model_Cartn_x: coord2,
    /**
     * The y component of the coordinates for this atom in this
     * component specified as orthogonal angstroms. The choice of
     * reference axis frame for the coordinates is arbitrary.
     *
     * The set of coordinates input for the entity here is intended to
     * correspond to the atomic model used to generate restraints for
     * structure refinement, not to atom sites in the ATOM_SITE
     * list.
     */
    model_Cartn_y: coord2,
    /**
     * The z component of the coordinates for this atom in this
     * component specified as orthogonal angstroms. The choice of
     * reference axis frame for the coordinates is arbitrary.
     *
     * The set of coordinates input for the entity here is intended to
     * correspond to the atomic model used to generate restraints for
     * structure refinement, not to atom sites in the ATOM_SITE
     * list.
     */
    model_Cartn_z: coord2,
    /**
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP
     * category.
     */
    comp_id: str4,
    /**
     * The code used to identify the atom species representing
     * this atom type. Normally this code is the element
     * symbol.
     */
    type_symbol: str4,
    /**
     * Atom name alignment offset in PDB atom field.
     */
    pdbx_align: int2,
    /**
     * Ordinal index for the component atom list.
     */
    pdbx_ordinal: int2,
    /**
     * An alternative x component of the coordinates for this atom in this
     * component specified as orthogonal angstroms.
     */
    pdbx_model_Cartn_x_ideal: coord2,
    /**
     * An alternative y component of the coordinates for this atom in this
     * component specified as orthogonal angstroms.
     */
    pdbx_model_Cartn_y_ideal: coord2,
    /**
     * An alternative z component of the coordinates for this atom in this
     * component specified as orthogonal angstroms.
     */
    pdbx_model_Cartn_z_ideal: coord2,
    /**
     * The chiral configuration of the atom that is a chiral center.
     */
    pdbx_stereo_config: Aliased2(lstr2),
    /**
     * A flag indicating an aromatic atom.
     */
    pdbx_aromatic_flag: Aliased2(lstr2),
    /**
     * A flag indicating a leaving atom.
     */
    pdbx_leaving_atom_flag: Aliased2(lstr2)
  },
  /**
   * Data items in the CHEM_COMP_BOND category record details about
   * the bonds between atoms in a chemical component. Target values
   * may be specified as bond orders, as a distance between the two
   * atoms, or both.
   */
  chem_comp_bond: {
    /**
     * The ID of the first of the two atoms that define the bond.
     *
     * This data item is a pointer to _chem_comp_atom.atom_id in the
     * CHEM_COMP_ATOM category.
     */
    atom_id_1: str4,
    /**
     * The ID of the second of the two atoms that define the bond.
     *
     * This data item is a pointer to _chem_comp_atom.atom_id in the
     * CHEM_COMP_ATOM category.
     */
    atom_id_2: str4,
    /**
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP
     * category.
     */
    comp_id: str4,
    /**
     * The value that should be taken as the target for the chemical
     * bond associated with the specified atoms, expressed as a bond
     * order.
     */
    value_order: Aliased2(lstr2),
    /**
     * Ordinal index for the component bond list.
     */
    pdbx_ordinal: int2,
    /**
     * Stereochemical configuration across a double bond.
     */
    pdbx_stereo_config: Aliased2(lstr2),
    /**
     * A flag indicating an aromatic bond.
     */
    pdbx_aromatic_flag: Aliased2(lstr2)
  },
  /**
   * Data items in the CHEM_COMP_DESCRIPTOR category provide
   * string descriptors of component chemical structure.
   */
  pdbx_chem_comp_descriptor: {
    /**
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP
     * category.
     */
    comp_id: str4,
    /**
     * This data item contains the descriptor value for this
     * component.
     */
    descriptor: str4,
    /**
     * This data item contains the descriptor type.
     */
    type: Aliased2(lstr2),
    /**
     * This data item contains the name of the program
     * or library used to compute the descriptor.
     */
    program: str4,
    /**
     * This data item contains the version of the program
     * or library used to compute the descriptor.
     */
    program_version: str4
  },
  /**
   * Data items in the CHEM_COMP_IDENTIFIER category provide
   * identifiers for chemical components.
   */
  pdbx_chem_comp_identifier: {
    /**
     * This data item is a pointer to _chem_comp.id in the CHEM_COMP
     * category.
     */
    comp_id: str4,
    /**
     * This data item contains the identifier value for this
     * component.
     */
    identifier: str4,
    /**
     * This data item contains the identifier type.
     */
    type: Aliased2(str4),
    /**
     * This data item contains the name of the program
     * or library used to compute the identifier.
     */
    program: str4,
    /**
     * This data item contains the version of the program
     * or library used to compute the identifier.
     */
    program_version: str4
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/schema/bird.js
var Schema4 = Column.Schema;
var str5 = Schema4.str;
var float3 = Schema4.float;
var lstr3 = Schema4.lstr;
var Aliased3 = Schema4.Aliased;
var int3 = Schema4.int;
var BIRD_Schema = {
  /**
   * Data items in the PDBX_REFERENCE_MOLECULE category record
   * reference information about small polymer molecules.
   */
  pdbx_reference_molecule: {
    /**
     * The value of _pdbx_reference_molecule.prd_id is the unique identifier
     * for the reference molecule in this family.
     *
     * By convention this ID uniquely identifies the reference molecule in
     * in the PDB reference dictionary.
     *
     * The ID has the template form PRD_dddddd (e.g. PRD_000001)
     */
    prd_id: str5,
    /**
     * Formula mass in daltons of the entity.
     */
    formula_weight: float3,
    /**
     * The formula for the reference entity. Formulae are written
     * according to the rules:
     *
     * 1. Only recognised element symbols may be used.
     *
     * 2. Each element symbol is followed by a 'count' number. A count
     * of '1' may be omitted.
     *
     * 3. A space or parenthesis must separate each element symbol and
     * its count, but in general parentheses are not used.
     *
     * 4. The order of elements depends on whether or not carbon is
     * present. If carbon is present, the order should be: C, then
     * H, then the other elements in alphabetical order of their
     * symbol. If carbon is not present, the elements are listed
     * purely in alphabetic order of their symbol. This is the
     * 'Hill' system used by Chemical Abstracts.
     */
    formula: str5,
    /**
     * Defines the structural classification of the entity.
     */
    type: Aliased3(lstr3),
    /**
     * Evidence for the assignment of _pdbx_reference_molecule.type
     */
    type_evidence_code: str5,
    /**
     * Broadly defines the function of the entity.
     */
    class: Aliased3(lstr3),
    /**
     * Evidence for the assignment of _pdbx_reference_molecule.class
     */
    class_evidence_code: str5,
    /**
     * A name of the entity.
     */
    name: str5,
    /**
     * Defines how this entity is represented in PDB data files.
     */
    represent_as: Aliased3(lstr3),
    /**
     * For entities represented as single molecules, the identifier
     * corresponding to the chemical definition for the molecule.
     */
    chem_comp_id: str5,
    /**
     * Special details about this molecule.
     */
    compound_details: str5,
    /**
     * Description of this molecule.
     */
    description: str5,
    /**
     * The PDB accession code for the entry containing a representative example of this molecule.
     */
    representative_PDB_id_code: str5,
    /**
     * Defines the current PDB release status for this molecule definition.
     */
    release_status: Aliased3(lstr3),
    /**
     * Assigns the identifier for the reference molecule which have been replaced
     * by this reference molecule.
     * Multiple molecule identifier codes should be separated by commas.
     */
    replaces: str5,
    /**
     * Assigns the identifier of the reference molecule that has replaced this molecule.
     */
    replaced_by: str5
  },
  /**
   * Data items in the PDBX_REFERENCE_ENTITY_LIST category record
   * the list of entities within each reference molecule.
   */
  pdbx_reference_entity_list: {
    /**
     * The value of _pdbx_reference_entity_list.prd_id is a reference
     * _pdbx_reference_molecule.prd_id in the PDBX_REFERENCE_MOLECULE category.
     */
    prd_id: str5,
    /**
     * The value of _pdbx_reference_entity_list.ref_entity_id is a unique identifier
     * the a constituent entity within this reference molecule.
     */
    ref_entity_id: str5,
    /**
     * Defines the polymer characteristic of the entity.
     */
    type: Aliased3(lstr3),
    /**
     * Additional details about this entity.
     */
    details: str5,
    /**
     * The component number of this entity within the molecule.
     */
    component_id: int3
  },
  /**
   * Data items in the PDBX_REFERENCE_ENTITY_NONPOLY category record
   * the list of entities within each reference molecule.
   */
  pdbx_reference_entity_nonpoly: {
    /**
     * The value of _pdbx_reference_entity_nonpoly.prd_id is a reference
     * _pdbx_reference_entity_list.prd_id in the PDBX_REFERENCE_ENTITY_LIST category.
     */
    prd_id: str5,
    /**
     * The value of _pdbx_reference_entity_nonpoly.ref_entity_id is a reference
     * to _pdbx_reference_entity_list.ref_entity_id in PDBX_REFERENCE_ENTITY_LIST category.
     */
    ref_entity_id: str5,
    /**
     * A name of the non-polymer entity.
     */
    name: str5,
    /**
     * For non-polymer entities, the identifier corresponding
     * to the chemical definition for the molecule.
     */
    chem_comp_id: str5
  },
  /**
   * Data items in the PDBX_REFERENCE_ENTITY_LINK category give details about
   * the linkages between entities within reference molecules.
   */
  pdbx_reference_entity_link: {
    /**
     * The value of _pdbx_reference_entity_link.link_id uniquely identifies
     * linkages between entities with a molecule.
     */
    link_id: int3,
    /**
     * The value of _pdbx_reference_entity_link.prd_id is a reference
     * _pdbx_reference_entity_list.prd_id in the PDBX_REFERENCE_ENTITY_LIST category.
     */
    prd_id: str5,
    /**
     * A description of special aspects of a linkage between
     * chemical components in the structure.
     */
    details: str5,
    /**
     * The reference entity id of the first of the two entities joined by the
     * linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_list.ref_entity_id
     * in the PDBX_REFERENCE_ENTITY_LIST category.
     */
    ref_entity_id_1: str5,
    /**
     * The reference entity id of the second of the two entities joined by the
     * linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_list.ref_entity_id
     * in the PDBX_REFERENCE_ENTITY_LIST category.
     */
    ref_entity_id_2: str5,
    /**
     * For a polymer entity, the sequence number in the first of
     * the two entities containing the linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.num
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    entity_seq_num_1: int3,
    /**
     * For a polymer entity, the sequence number in the second of
     * the two entities containing the linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.num
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    entity_seq_num_2: int3,
    /**
     * The component identifier in the first of the two entities containing the linkage.
     *
     * For polymer entities, this data item is a pointer to _pdbx_reference_entity_poly_seq.mon_id
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     *
     * For non-polymer entities, this data item is a pointer to
     * _pdbx_reference_entity_nonpoly.chem_comp_id in the
     * PDBX_REFERENCE_ENTITY_NONPOLY category.
     */
    comp_id_1: str5,
    /**
     * The component identifier in the second of the two entities containing the linkage.
     *
     * For polymer entities, this data item is a pointer to _pdbx_reference_entity_poly_seq.mon_id
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     *
     * For non-polymer entities, this data item is a pointer to
     * _pdbx_reference_entity_nonpoly.chem_comp_id in the
     * PDBX_REFERENCE_ENTITY_NONPOLY category.
     */
    comp_id_2: str5,
    /**
     * The atom identifier/name in the first of the two entities containing the linkage.
     */
    atom_id_1: str5,
    /**
     * The atom identifier/name in the second of the two entities containing the linkage.
     */
    atom_id_2: str5,
    /**
     * The bond order target for the chemical linkage.
     */
    value_order: Aliased3(lstr3),
    /**
     * The entity component identifier for the first of two entities containing the linkage.
     */
    component_1: int3,
    /**
     * The entity component identifier for the second of two entities containing the linkage.
     */
    component_2: int3,
    /**
     * A code indicating the entity types involved in the linkage.
     */
    link_class: Aliased3(str5)
  },
  /**
   * Data items in the PDBX_REFERENCE_ENTITY_POLY_LINK category give details about
   * polymer linkages including both standard and non-standard linkages between
   * polymer componnents.
   */
  pdbx_reference_entity_poly_link: {
    /**
     * The value of _pdbx_reference_entity_poly_link.link_id uniquely identifies
     * a linkage within a polymer entity.
     */
    link_id: int3,
    /**
     * The value of _pdbx_reference_entity_poly_link.prd_id is a reference
     * _pdbx_reference_entity_list.prd_id in the PDBX_REFERENCE_ENTITY_POLY category.
     */
    prd_id: str5,
    /**
     * The reference entity id of the polymer entity containing the linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly.ref_entity_id
     * in the PDBX_REFERENCE_ENTITY_POLY category.
     */
    ref_entity_id: str5,
    /**
     * The entity component identifier entity containing the linkage.
     */
    component_id: int3,
    /**
     * For a polymer entity, the sequence number in the first of
     * the two components making the linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.num
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    entity_seq_num_1: int3,
    /**
     * For a polymer entity, the sequence number in the second of
     * the two components making the linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.num
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    entity_seq_num_2: int3,
    /**
     * The component identifier in the first of the two components making the
     * linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.mon_id
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    comp_id_1: str5,
    /**
     * The component identifier in the second of the two components making the
     * linkage.
     *
     * This data item is a pointer to _pdbx_reference_entity_poly_seq.mon_id
     * in the PDBX_REFERENCE_ENTITY_POLY_SEQ category.
     */
    comp_id_2: str5,
    /**
     * The atom identifier/name in the first of the two components making
     * the linkage.
     */
    atom_id_1: str5,
    /**
     * The atom identifier/name in the second of the two components making
     * the linkage.
     */
    atom_id_2: str5,
    /**
     * The bond order target for the non-standard linkage.
     */
    value_order: Aliased3(lstr3)
  },
  /**
   * Data items in the PDBX_REFERENCE_ENTITY_POLY category record details about
   * the polymer, such as the type of the polymer, the number of
   * monomers and whether it has nonstandard features.
   */
  pdbx_reference_entity_poly: {
    /**
     * The value of _pdbx_reference_entity_poly.prd_id is a reference
     * _pdbx_reference_entity_list.prd_id in the  PDBX_REFERENCE_ENTITY_LIST category.
     */
    prd_id: str5,
    /**
     * The value of _pdbx_reference_entity_poly.ref_entity_id is a reference
     * to _pdbx_reference_entity_list.ref_entity_id in PDBX_REFERENCE_ENTITY_LIST category.
     */
    ref_entity_id: str5,
    /**
     * The type of the polymer.
     */
    type: Aliased3(str5),
    /**
     * The database code for this source information
     */
    db_code: str5,
    /**
     * The database name for this source information
     */
    db_name: str5
  },
  /**
   * Data items in the PDBX_REFERENCE_ENTITY_POLY_SEQ category specify the sequence
   * of monomers in a polymer.
   */
  pdbx_reference_entity_poly_seq: {
    /**
     * The value of _pdbx_reference_entity_poly_seq.prd_id is a reference
     * _pdbx_reference_entity_poly.prd_id in the  PDBX_REFERENCE_ENTITY_POLY category.
     */
    prd_id: str5,
    /**
     * The value of _pdbx_reference_entity_poly_seq.ref_entity_id is a reference
     * to _pdbx_reference_entity_poly.ref_entity_id in PDBX_REFERENCE_ENTITY_POLY category.
     */
    ref_entity_id: str5,
    /**
     * This data item is the chemical component identifier of monomer.
     */
    mon_id: str5,
    /**
     * This data item is the chemical component identifier for the parent component corresponding to this monomer.
     */
    parent_mon_id: str5,
    /**
     * The value of _pdbx_reference_entity_poly_seq.num must uniquely and sequentially
     * identify a record in the PDBX_REFERENCE_ENTITY_POLY_SEQ list.
     *
     * This value is conforms to author numbering conventions and does not map directly
     * to the numbering conventions used for _entity_poly_seq.num.
     */
    num: int3,
    /**
     * A flag to indicate that this monomer is observed in the instance example.
     */
    observed: Aliased3(lstr3),
    /**
     * A flag to indicate that sequence heterogeneity at this monomer position.
     */
    hetero: Aliased3(lstr3)
  },
  /**
   * Additional features associated with the reference entity.
   */
  pdbx_reference_entity_sequence: {
    /**
     * The value of _pdbx_reference_entity_sequence.prd_id is a reference
     * _pdbx_reference_entity_list.prd_id in the  PDBX_REFERENCE_ENTITY_LIST category.
     */
    prd_id: str5,
    /**
     * The value of _pdbx_reference_entity_sequence.ref_entity_id is a reference
     * to _pdbx_reference_entity_list.ref_entity_id in PDBX_REFERENCE_ENTITY_LIST category.
     */
    ref_entity_id: str5,
    /**
     * The monomer type for the sequence.
     */
    type: Aliased3(str5),
    /**
     * A flag to indicate a non-ribosomal entity.
     */
    NRP_flag: Aliased3(str5),
    /**
     * The one-letter-code sequence for this entity.  Non-standard monomers are represented as 'X'.
     */
    one_letter_codes: str5
  },
  /**
   * Data items in the PDBX_REFERENCE_ENTITY_SRC_NAT category record
   * details of the source from which the entity was obtained.
   */
  pdbx_reference_entity_src_nat: {
    /**
     * The value of _pdbx_reference_entity_src_nat.prd_id is a reference
     * _pdbx_reference_entity_list.prd_id in the  PDBX_REFERENCE_ENTITY_LIST category.
     */
    prd_id: str5,
    /**
     * The value of _pdbx_reference_entity_src_nat.ref_entity_id is a reference
     * to _pdbx_reference_entity_list.ref_entity_id in PDBX_REFERENCE_ENTITY_LIST category.
     */
    ref_entity_id: str5,
    /**
     * The value of _pdbx_reference_entity_src_nat.ordinal distinguishes
     * source details for this entity.
     */
    ordinal: int3,
    /**
     * The scientific name of the organism from which the entity was isolated.
     */
    organism_scientific: str5,
    /**
     * The NCBI TaxId of the organism from which the entity was isolated.
     */
    taxid: str5,
    /**
     * The database code for this source information
     */
    db_code: str5,
    /**
     * The database name for this source information
     */
    db_name: str5
  },
  /**
   * Data items in the PDBX_PRD_AUDIT category records
   * the status and tracking information for this molecule.
   */
  pdbx_prd_audit: {
    /**
     * This data item is a pointer to _pdbx_reference_molecule.prd_id in the
     * pdbx_reference_molecule category.
     */
    prd_id: str5,
    /**
     * The date associated with this audit record.
     */
    date: str5,
    /**
     * An identifier for the wwPDB site creating or modifying the molecule.
     */
    processing_site: Aliased3(str5),
    /**
     * The action associated with this audit record.
     */
    action_type: Aliased3(str5)
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/schema/dic.js
var Schema5 = Column.Schema;
var str6 = Schema5.str;
var float4 = Schema5.float;
var datablock = {
  id: str6,
  description: str6
};
var dictionary = {
  title: str6,
  datablock_id: str6,
  version: str6
};
var dictionary_history = {
  version: str6,
  update: str6,
  revision: str6
};
var sub_category = {
  id: str6,
  description: str6
};
var category_group_list = {
  id: str6,
  parent_id: str6,
  description: str6
};
var item_type_list = {
  code: str6,
  primitive_code: str6,
  construct: str6,
  detail: str6
};
var item_units_list = {
  code: str6,
  detail: str6
};
var item_units_conversion = {
  from_code: str6,
  to_code: str6,
  operator: str6,
  factor: float4
};
var dic_Schema = {
  datablock,
  dictionary,
  dictionary_history,
  sub_category,
  category_group_list,
  item_type_list,
  item_units_list,
  item_units_conversion
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/schema/density-server.js
var Schema6 = Column.Schema;
var str7 = Schema6.str;
var int4 = Schema6.int;
var float5 = Schema6.float;
var Aliased4 = Schema6.Aliased;
var Vector2 = Schema6.Vector;
var DensityServer_Header_Schema = {
  density_server_result: {
    "server_version": str7,
    "datetime_utc": str7,
    "guid": str7,
    "is_empty": Aliased4(str7),
    "has_error": Aliased4(str7),
    "error": str7,
    "query_source_id": str7,
    "query_type": Aliased4(str7),
    "query_box_type": Aliased4(str7),
    "query_box_a": Vector2(3),
    "query_box_b": Vector2(3)
  }
};
var DensityServer_Data_Schema = {
  volume_data_3d_info: {
    "name": str7,
    // zero indexed axis order of the data
    "axis_order": Vector2(3, int4),
    // Origin in fractional coords
    "origin": Vector2(3),
    // Dimension in fractional coords
    "dimensions": Vector2(3),
    "sample_rate": int4,
    // number of samples along each axis
    "sample_count": Vector2(3, int4),
    "spacegroup_number": int4,
    "spacegroup_cell_size": Vector2(3),
    // angles in degrees
    "spacegroup_cell_angles": Vector2(3),
    "mean_source": float5,
    "mean_sampled": float5,
    "sigma_source": float5,
    "sigma_sampled": float5,
    "min_source": float5,
    "min_sampled": float5,
    "max_source": float5,
    "max_sampled": float5
  },
  volume_data_3d: {
    values: float5
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/schema/cif-core.js
var Schema7 = Column.Schema;
var float6 = Schema7.float;
var int5 = Schema7.int;
var str8 = Schema7.str;
var Matrix3 = Schema7.Matrix;
var CifCore_Schema = {
  /**
   * The category of data items used to describe the parameters of
   * the crystal unit cell.
   */
  cell: {
    /**
     * The angle between the bounding cell axes.
     */
    angle_alpha: float6,
    /**
     * The angle between the bounding cell axes.
     */
    angle_beta: float6,
    /**
     * The angle between the bounding cell axes.
     */
    angle_gamma: float6,
    /**
     * The number of the formula units in the unit cell as specified
     * by _chemical_formula.structural, _chemical_formula.moiety or
     * _chemical_formula.sum.
     */
    formula_units_z: int5,
    /**
     * The length of each cell axis.
     */
    length_a: float6,
    /**
     * The length of each cell axis.
     */
    length_b: float6,
    /**
     * The length of each cell axis.
     */
    length_c: float6,
    /**
     * Volume of the crystal unit cell.
     */
    volume: float6
  },
  /**
   * The category of data items which describe the composition and
   * chemical properties of the compound under study. The formula data
   * items must be consistent with the density, unit-cell and Z values.
   */
  chemical: {
    /**
     * The temperature at which a crystalline solid changes to a liquid.
     */
    melting_point: float6,
    /**
     * Trivial name by which the compound is commonly known.
     */
    name_common: str8,
    /**
     * IUPAC or Chemical Abstracts full name of compound.
     */
    name_systematic: str8
  },
  /**
   * The category of data items which specify the composition and chemical
   * properties of the compound. The formula data items must agree
   * with those that specify the density, unit-cell and Z values.
   *
   * The following rules apply to the construction of the data items
   * _chemical_formula.analytical, *.structural and *.sum. For the
   * data item *.moiety the formula construction is broken up into
   * residues or moieties, i.e. groups of atoms that form a molecular
   * unit or molecular ion. The rules given below apply within each
   * moiety, but different requirements apply to the way that moieties
   * are connected (see _chemical_formula.moiety).
   *
   * 1. Only recognized element symbols may be used.
   *
   * 2. Each element symbol is followed by a 'count' number. A count of
   * '1' may be omitted.
   *
   * 3. A space or parenthesis must separate each cluster of (element
   * symbol + count).
   *
   * 4. Where a group of elements is enclosed in parentheses, the
   * multiplier for the group must follow the closing parentheses.
   * That is, all element and group multipliers are assumed to be
   * printed as subscripted numbers. [An exception to this rule
   * exists for *.moiety formulae where pre- and post-multipliers
   * are permitted for molecular units].
   *
   * 5. Unless the elements are ordered in a manner that corresponds to
   * their chemical structure, as in _chemical_formula.structural,
   * the order of the elements within any group or moiety
   * depends on whether or not carbon is present. If carbon is
   * present, the order should be: C, then H, then the other
   * elements in alphabetical order of their symbol. If carbon is
   * not present, the elements are listed purely in alphabetical order
   * of their symbol. This is the 'Hill' system used by Chemical
   * Abstracts. This ordering is used in _chemical_formula.moiety
   * and _chemical_formula.sum.
   *
   * _chemical_formula.IUPAC      '[Mo (C O)4 (C18 H33 P)2]'
   * _chemical_formula.moiety     'C40 H66 Mo O4 P2'
   * _chemical_formula.structural '((C O)4 (P (C6 H11)3)2)Mo'
   * _chemical_formula.sum         'C40 H66 Mo O4 P2'
   * _chemical_formula.weight      768.81
   */
  chemical_formula: {
    /**
     * Formula with each discrete bonded residue or ion shown as a
     * separate moiety. See above CHEMICAL_FORMULA for rules
     * for writing chemical formulae. In addition to the general
     * formulae requirements, the following rules apply:
     * 1. Moieties are separated by commas ','.
     * 2. The order of elements within a moiety follows general rule
     * 5 in CHEMICAL_FORMULA.
     * 3. Parentheses are not used within moieties but may surround
     * a moiety. Parentheses may not be nested.
     * 4. Charges should be placed at the end of the moiety. The
     * charge '+' or '-' may be preceded by a numerical multiplier
     * and should be separated from the last (element symbol +
     * count) by a space. Pre- or post-multipliers may be used for
     * individual moieties.
     */
    moiety: str8,
    /**
     * Chemical formulae in which all discrete bonded residues and ions are
     * summed over the constituent elements, following the ordering given
     * in rule 5 of the category description. Parentheses normally not used.
     */
    sum: str8,
    /**
     * Mass corresponding to the formulae _chemical_formula.structural,
     * *_IUPAC, *_moiety or *_sum and, together with the Z value and cell
     * parameters yield the density given as _exptl_crystal.density_diffrn.
     */
    weight: float6
  },
  /**
   * The category of data items used to specify space group
   * information about the crystal used in the diffraction measurements.
   *
   * Space-group types are identified by their number as listed in
   * International Tables for Crystallography Volume A, or by their
   * Schoenflies symbol. Specific settings of the space groups can
   * be identified by their Hall symbol, by specifying their
   * symmetry operations or generators, or by giving the
   * transformation that relates the specific setting to the
   * reference setting based on International Tables Volume A and
   * stored in this dictionary.
   *
   * The commonly used Hermann-Mauguin symbol determines the
   * space-group type uniquely, but several different Hermann-Mauguin
   * symbols may refer to the same space-group type. A
   * Hermann-Mauguin symbol contains information on the choice of
   * the basis, but not on the choice of origin.
   *
   * Ref: International Tables for Crystallography (2002). Volume A,
   * Space-group symmetry, edited by Th. Hahn, 5th ed.
   * Dordrecht: Kluwer Academic Publishers.
   */
  space_group: {
    /**
     * The name of the system of geometric crystal classes of space
     * groups (crystal system) to which the space group belongs.
     * Note that rhombohedral space groups belong to the
     * trigonal system.
     */
    crystal_system: str8,
    /**
     * The number as assigned in International Tables for Crystallography
     * Vol. A, specifying the proper affine class (i.e. the orientation
     * preserving affine class) of space groups (crystallographic space
     * group type) to which the space group belongs. This number defines
     * the space group type but not the coordinate system expressed.
     */
    it_number: int5,
    /**
     * The full international Hermann-Mauguin space-group symbol as
     * defined in Section 2.2.3 and given as the second item of the
     * second line of each of the space-group tables of Part 7 of
     * International Tables for Crystallography Volume A (2002).
     *
     * Each component of the space-group name is separated by a
     * space or an underscore character. The use of a space is
     * strongly recommended.  The underscore is only retained
     * because it was used in old CIFs. It should not be used in
     * new CIFs.
     *
     * Subscripts should appear without special symbols. Bars should
     * be given as negative signs before the numbers to which they
     * apply. The commonly used Hermann-Mauguin symbol determines the
     * space-group type uniquely, but a given space-group type may
     * be described by more than one Hermann-Mauguin symbol. The
     * space-group type is best described using
     * _space_group.IT_number or _space_group.name_Schoenflies. The
     * full international Hermann-Mauguin symbol contains information
     * about the choice of basis for monoclinic and orthorhombic
     * space groups, but does not give information about the choice
     * of origin. To define the setting uniquely use
     * _space_group.name_Hall, or list the symmetry operations
     * or generators.
     *
     * Ref: International Tables for Crystallography (2002). Volume A,
     * Space-group symmetry, edited by Th. Hahn, 5th ed.
     * Dordrecht: Kluwer Academic Publishers.
     */
    "name_h-m_full": str8
  },
  /**
   * The category of data items used to describe symmetry equivalent sites
   * in the crystal unit cell.
   */
  space_group_symop: {
    /**
     * A parsable string giving one of the symmetry operations of the
     * space group in algebraic form.  If W is a matrix representation
     * of the rotational part of the symmetry operation defined by the
     * positions and signs of x, y and z, and w is a column of
     * translations defined by fractions, an equivalent position
     * X' is generated from a given position X by the equation
     *
     * X' = WX + w.
     *
     * (Note: X is used to represent bold_italics_x in International
     * Tables for Crystallography Vol. A, Part 5.)
     *
     * When a list of symmetry operations is given, it must contain
     * a complete set of coordinate representatives which generates
     * all the operations of the space group by the addition of
     * all primitive translations of the space group. Such
     * representatives are to be found as the coordinates of
     * the general-equivalent position in International Tables for
     * Crystallography Vol. A (2002), to which it is necessary to
     * add any centring translations shown above the
     * general-equivalent position.
     *
     * That is to say, it is necessary to list explicitly all the
     * symmetry operations required to generate all the atoms in
     * the unit cell defined by the setting used.
     */
    operation_xyz: str8
  },
  /**
   * The category of data items used to specify the geometry bonds in the
   * structural model as derived from the atomic sites.
   */
  geom_bond: {
    /**
     * This label is a unique identifier for a particular site in the
     * asymmetric unit of the crystal unit cell.
     */
    atom_site_label_1: str8,
    /**
     * This label is a unique identifier for a particular site in the
     * asymmetric unit of the crystal unit cell.
     */
    atom_site_label_2: str8,
    /**
     * Intramolecular bond distance between the sites identified
     * by _geom_bond.id
     */
    distance: float6,
    /**
     * This code signals whether the angle is referred to in a
     * publication or should be placed in a table of significant angles.
     */
    publ_flag: str8,
    /**
     * Data item specifying the symmetry operation codes applied to the atom
     * sites involved in a specific geometric configuration or other correlated
     * behaviour.
     *
     * The symmetry code of each atom site as the symmetry-equivalent position
     * number 'n' and the cell translation number 'pqr'. These numbers are
     * combined to form the code 'n pqr' or n_pqr.
     *
     * The character string n_pqr is composed as follows:
     *
     * n refers to the symmetry operation that is applied to the
     * coordinates stored in _atom_site.fract_xyz. It must match
     * a number given in _space_group_symop.id (or one of its
     * aliases, such as _symmetry_equiv_pos_site_id).
     *
     * p, q and r refer to the translations that are subsequently
     * applied to the symmetry transformed coordinates to generate
     * the related atom position. These translations (x,y,z) are related
     * to (p,q,r) by the relations
     * p = 5 + x
     * q = 5 + y
     * r = 5 + z
     */
    site_symmetry_1: str8,
    /**
     * Data item specifying the symmetry operation codes applied to the atom
     * sites involved in a specific geometric configuration or other correlated
     * behaviour.
     *
     * The symmetry code of each atom site as the symmetry-equivalent position
     * number 'n' and the cell translation number 'pqr'. These numbers are
     * combined to form the code 'n pqr' or n_pqr.
     *
     * The character string n_pqr is composed as follows:
     *
     * n refers to the symmetry operation that is applied to the
     * coordinates stored in _atom_site.fract_xyz. It must match
     * a number given in _space_group_symop.id (or one of its
     * aliases, such as _symmetry_equiv_pos_site_id).
     *
     * p, q and r refer to the translations that are subsequently
     * applied to the symmetry transformed coordinates to generate
     * the related atom position. These translations (x,y,z) are related
     * to (p,q,r) by the relations
     * p = 5 + x
     * q = 5 + y
     * r = 5 + z
     */
    site_symmetry_2: str8,
    /**
     * Bond valence calculated from the bond distance.
     */
    valence: float6
  },
  /**
   * The category of data items used to record details about the
   * creation and subsequent updating of the data block.
   */
  audit: {
    /**
     * The digital object identifier (DOI) registered to identify
     * the data set publication represented by the current
     * data block. This can be used as a unique identifier for
     * the data block so long as the code used is a valid DOI
     * (i.e. begins with a valid publisher prefix assigned by a
     * Registration Agency and a suffix guaranteed to be unique
     * by the publisher) and has had its metadata deposited
     * with a DOI Registration Agency.
     *
     * A DOI is a unique character string identifying any
     * object of intellectual property. It provides a
     * persistent identifier for an object on a digital network
     * and permits the association of related current data in a
     * structured extensible way. A DOI is an implementation
     * of the Internet concepts of Uniform Resource Name and
     * Universal Resource Locator managed according to the
     * specifications of the International DOI Foundation
     * (see https://www.doi.org/).
     */
    block_doi: str8
  },
  /**
   * The category of data items recording database deposition. These data items
   * are assigned by database managers and should only appear in a CIF if they
   * originate from that source.
   */
  database_code: {
    /**
     * Code assigned by the Crystallography Open Database (COD).
     */
    cod: str8,
    /**
     * Code assigned by the Cambridge Structural Database.
     */
    csd: str8,
    /**
     * Deposition numbers assigned by the Cambridge Crystallographic
     * Data Centre (CCDC) to files containing structural information
     * archived by the CCDC.
     */
    depnum_ccdc_archive: str8,
    /**
     * Deposition numbers assigned by the Fachinformationszentrum
     * Karlsruhe (FIZ) to files containing structural information
     * archived by the Cambridge Crystallographic Data Centre (CCDC).
     */
    depnum_ccdc_fiz: str8,
    /**
     * Code assigned by the Inorganic Crystal Structure Database.
     */
    icsd: str8,
    /**
     * Code assigned in the Metals Data File.
     */
    mdf: str8,
    /**
     * Code assigned by the NBS (NIST) Crystal Data Database.
     */
    nbs: str8
  },
  /**
   * The category of data items used to describe atom site information
   * used in crystallographic structure studies.
   */
  atom_site: {
    /**
     * Code for type of atomic displacement parameters used for the site.
     */
    adp_type: str8,
    /**
     * A standard code to signal if the site coordinates have been
     * determined from the intensities or calculated from the geometry
     * of surrounding sites, or have been assigned dummy coordinates.
     */
    calc_flag: str8,
    /**
     * A code which identifies a cluster of atoms that show long range disorder
     * but are locally ordered. Within each such cluster of atoms,
     * _atom_site.disorder_group is used to identify the sites that are
     * simultaneously occupied. This field is only needed if there is more than
     * one cluster of disordered atoms showing independent local order.
     */
    disorder_assembly: str8,
    /**
     * A code that identifies a group of disordered atom sites that are locally
     * simultaneously occupied. Atoms that are positionally disordered over two or
     * more sites (e.g. the H atoms of a methyl group that exists in two
     * orientations) should be assigned to two or more groups. Similarly, atoms
     * that describe a specific alternative composition of a compositionally
     * disordered site should be assigned to a distinct disorder group (e.g. a site
     * that is partially occupied by Mg and Mn atoms should be described by
     * assigning the Mg atom to one group and the Mn atom to another group). Sites
     * belonging to the same group are simultaneously occupied, but those belonging
     * to different groups are not. A minus prefix (e.g. "-1") is used to indicate
     * sites disordered about a special position.
     */
    disorder_group: str8,
    /**
     * Atom site coordinates as fractions of the cell length values.
     */
    fract_x: float6,
    /**
     * Atom site coordinates as fractions of the cell length values.
     */
    fract_y: float6,
    /**
     * Atom site coordinates as fractions of the cell length values.
     */
    fract_z: float6,
    /**
     * This label is a unique identifier for a particular site in the
     * asymmetric unit of the crystal unit cell. It is made up of
     * components, _atom_site.label_component_0 to *_6, which may be
     * specified as separate data items. Component 0 usually matches one
     * of the specified _atom_type.symbol codes. This is not mandatory
     * if an _atom_site.type_symbol item is included in the atom site
     * list. The _atom_site.type_symbol always takes precedence over
     * an _atom_site.label in the identification of the atom type. The
     * label components 1 to 6 are optional, and normally only
     * components 0 and 1 are used. Note that components 0 and 1 are
     * concatenated, while all other components, if specified, are
     * separated by an underline character. Underline separators are
     * only used if higher-order components exist. If an intermediate
     * component is not used it may be omitted provided the underline
     * separators are inserted. For example the label 'C233__ggg' is
     * acceptable and represents the components C, 233, '', and ggg.
     * Each label may have a different number of components.
     */
    label: str8,
    /**
     * The fraction of the atom type present at this site.
     * The sum of the occupancies of all the atom types at this site
     * may not significantly exceed 1.0 unless it is a dummy site. The
     * value must lie in the 99.97% Gaussian confidence interval
     * -3u =< x =< 1 + 3u. The _enumeration.range of 0.0:1.0 is thus
     * correctly interpreted as meaning (0.0 - 3u) =< x =< (1.0 + 3u).
     */
    occupancy: float6,
    /**
     * A concatenated series of single-letter codes which indicate the
     * refinement restraints or constraints applied to this site. This
     * item should not be used. It has been replaced by
     * _atom_site.refinement_flags_posn, _ADP and _occupancy. It is
     * retained in this dictionary only to provide compatibility with
     * legacy CIFs.
     */
    refinement_flags: str8,
    /**
     * The number of different sites that are generated by the
     * application of the space-group symmetry to the coordinates
     * given for this site. It is equal to the multiplicity given
     * for this Wyckoff site in International Tables for Cryst.
     * Vol. A (2002). It is equal to the multiplicity of the general
     * position divided by the order of the site symmetry given in
     * _atom_site.site_symmetry_order.
     *
     * The _atom_site_symmetry_multiplicity form of this data name is
     * deprecated because of historical inconsistencies in practice among
     * structure refinement software packages and should not be used.
     */
    site_symmetry_multiplicity: int5,
    /**
     * A code to identify the atom specie(s) occupying this site.
     * This code must match a corresponding _atom_type.symbol. The
     * specification of this code is optional if component_0 of the
     * _atom_site.label is used for this purpose. See _atom_type.symbol.
     */
    type_symbol: str8,
    /**
     * Isotropic atomic displacement parameter, or equivalent isotropic
     * atomic displacement parameter, U(equiv), in angstroms squared,
     * calculated from anisotropic atomic displacement parameters.
     *
     * U(equiv) = (1/3) sum~i~[sum~j~(U^ij^ a*~i~ a*~j~ a~i~.a~j~)]
     *
     * a  = the real-space cell vectors
     * a* = the reciprocal-space cell lengths
     * Ref: Fischer, R. X. & Tillmanns, E. (1988). Acta Cryst. C44, 775-776.
     */
    u_iso_or_equiv: float6
  },
  /**
   * The category of data items used to describe the anisotropic atomic
   * displacement parameters of the atomic sites in a crystal structure.
   */
  atom_site_aniso: {
    /**
     * Anisotropic atomic displacement parameters are usually looped in
     * a separate list. If this is the case, this code must match the
     * _atom_site.label of the associated atom in the atom coordinate
     * list and conform with the same rules described in _atom_site.label.
     */
    label: str8,
    /**
     * These are the standard anisotropic atomic displacement components in
     * angstroms squared which appear in the structure-factor term
     *
     * T = exp{ -2π^2^ sum~i~ [ sum~j~ (U^ij^ h~i~ h~j~ a*~i~ a*~j~) ] }
     *
     * h = the Miller indices
     * a* = the reciprocal-space cell lengths
     *
     * The unique elements of the real symmetric matrix are entered by row.
     *
     * The IUCr Commission on Nomenclature recommends the use of U for reporting
     * atomic displacement parameters.
     *
     * Note that U^ij^ = β^ij^/(2 π^2^ a*~i~ a*~j~) = B^ij^/(8 π^2^).
     *
     * Ref: Trueblood, K. N. et al. (1996). Acta Cryst. A52, 770-781.
     */
    u_11: float6,
    /**
     * These are the standard anisotropic atomic displacement components in
     * angstroms squared which appear in the structure-factor term
     *
     * T = exp{ -2π^2^ sum~i~ [ sum~j~ (U^ij^ h~i~ h~j~ a*~i~ a*~j~) ] }
     *
     * h = the Miller indices
     * a* = the reciprocal-space cell lengths
     *
     * The unique elements of the real symmetric matrix are entered by row.
     *
     * The IUCr Commission on Nomenclature recommends the use of U for reporting
     * atomic displacement parameters.
     *
     * Note that U^ij^ = β^ij^/(2 π^2^ a*~i~ a*~j~) = B^ij^/(8 π^2^).
     *
     * Ref: Trueblood, K. N. et al. (1996). Acta Cryst. A52, 770-781.
     */
    u: Matrix3(3, 3),
    /**
     * These are the standard anisotropic atomic displacement components in
     * angstroms squared which appear in the structure-factor term
     *
     * T = exp{ -2π^2^ sum~i~ [ sum~j~ (U^ij^ h~i~ h~j~ a*~i~ a*~j~) ] }
     *
     * h = the Miller indices
     * a* = the reciprocal-space cell lengths
     *
     * The unique elements of the real symmetric matrix are entered by row.
     *
     * The IUCr Commission on Nomenclature recommends the use of U for reporting
     * atomic displacement parameters.
     *
     * Note that U^ij^ = β^ij^/(2 π^2^ a*~i~ a*~j~) = B^ij^/(8 π^2^).
     *
     * Ref: Trueblood, K. N. et al. (1996). Acta Cryst. A52, 770-781.
     */
    u_12: float6,
    /**
     * These are the standard anisotropic atomic displacement components in
     * angstroms squared which appear in the structure-factor term
     *
     * T = exp{ -2π^2^ sum~i~ [ sum~j~ (U^ij^ h~i~ h~j~ a*~i~ a*~j~) ] }
     *
     * h = the Miller indices
     * a* = the reciprocal-space cell lengths
     *
     * The unique elements of the real symmetric matrix are entered by row.
     *
     * The IUCr Commission on Nomenclature recommends the use of U for reporting
     * atomic displacement parameters.
     *
     * Note that U^ij^ = β^ij^/(2 π^2^ a*~i~ a*~j~) = B^ij^/(8 π^2^).
     *
     * Ref: Trueblood, K. N. et al. (1996). Acta Cryst. A52, 770-781.
     */
    u_13: float6,
    /**
     * These are the standard anisotropic atomic displacement components in
     * angstroms squared which appear in the structure-factor term
     *
     * T = exp{ -2π^2^ sum~i~ [ sum~j~ (U^ij^ h~i~ h~j~ a*~i~ a*~j~) ] }
     *
     * h = the Miller indices
     * a* = the reciprocal-space cell lengths
     *
     * The unique elements of the real symmetric matrix are entered by row.
     *
     * The IUCr Commission on Nomenclature recommends the use of U for reporting
     * atomic displacement parameters.
     *
     * Note that U^ij^ = β^ij^/(2 π^2^ a*~i~ a*~j~) = B^ij^/(8 π^2^).
     *
     * Ref: Trueblood, K. N. et al. (1996). Acta Cryst. A52, 770-781.
     */
    u_22: float6,
    /**
     * These are the standard anisotropic atomic displacement components in
     * angstroms squared which appear in the structure-factor term
     *
     * T = exp{ -2π^2^ sum~i~ [ sum~j~ (U^ij^ h~i~ h~j~ a*~i~ a*~j~) ] }
     *
     * h = the Miller indices
     * a* = the reciprocal-space cell lengths
     *
     * The unique elements of the real symmetric matrix are entered by row.
     *
     * The IUCr Commission on Nomenclature recommends the use of U for reporting
     * atomic displacement parameters.
     *
     * Note that U^ij^ = β^ij^/(2 π^2^ a*~i~ a*~j~) = B^ij^/(8 π^2^).
     *
     * Ref: Trueblood, K. N. et al. (1996). Acta Cryst. A52, 770-781.
     */
    u_23: float6,
    /**
     * These are the standard anisotropic atomic displacement components in
     * angstroms squared which appear in the structure-factor term
     *
     * T = exp{ -2π^2^ sum~i~ [ sum~j~ (U^ij^ h~i~ h~j~ a*~i~ a*~j~) ] }
     *
     * h = the Miller indices
     * a* = the reciprocal-space cell lengths
     *
     * The unique elements of the real symmetric matrix are entered by row.
     *
     * The IUCr Commission on Nomenclature recommends the use of U for reporting
     * atomic displacement parameters.
     *
     * Note that U^ij^ = β^ij^/(2 π^2^ a*~i~ a*~j~) = B^ij^/(8 π^2^).
     *
     * Ref: Trueblood, K. N. et al. (1996). Acta Cryst. A52, 770-781.
     */
    u_33: float6
  },
  /**
   * The category of data items used to describe atomic type information
   * used in crystallographic structure studies.
   */
  atom_type: {
    /**
     * A description of the atom(s) designated by this atom type. In
     * most cases this will be the element name and oxidation state of
     * a single atom species. For disordered or nonstoichiometric
     * structures it will describe a combination of atom species.
     */
    description: str8,
    /**
     * The identity of the atom specie(s) representing this atom type.
     * Normally this code is the element symbol followed by the charge
     * if there is one. The symbol may be composed of any character except
     * an underline or a blank, with the proviso that digits designate an
     * oxidation state and must be followed by a + or - character.
     */
    symbol: str8
  },
  /**
   * The category of data items used to describe atomic scattering
   * information used in crystallographic structure studies.
   */
  atom_type_scat: {
    /**
     * The imaginary component of the anomalous dispersion scattering factors
     * for this atom type and radiation by _diffrn_radiation_wavelength.value
     */
    dispersion_imag: float6,
    /**
     * The real component of the anomalous dispersion scattering factors
     * for this atom type and radiation by _diffrn_radiation_wavelength.value
     */
    dispersion_real: float6,
    /**
     * Reference to source of scattering factors used for this atom type.
     */
    source: str8
  }
};
var CifCore_Aliases = {
  "cell.formula_units_z": [
    "cell_formula_units_Z"
  ],
  "space_group.it_number": [
    "space_group_IT_number",
    "symmetry_Int_Tables_number"
  ],
  "space_group.name_h-m_full": [
    "symmetry_space_group_name_H-M"
  ],
  "space_group_symop.operation_xyz": [
    "symmetry_equiv_pos_as_xyz"
  ],
  "geom_bond.atom_site_label_1": [
    "geom_bond_atom_site_id_1"
  ],
  "geom_bond.atom_site_label_2": [
    "geom_bond_atom_site_id_2"
  ],
  "geom_bond.distance": [
    "geom_bond_dist"
  ],
  "audit.block_doi": [
    "audit_block_DOI"
  ],
  "database_code.cod": [
    "database_code_COD"
  ],
  "database_code.csd": [
    "database_code_CSD"
  ],
  "database_code.depnum_ccdc_archive": [
    "database_code_depnum_CCDC_archive"
  ],
  "database_code.depnum_ccdc_fiz": [
    "database_code_depnum_CCDC_fiz"
  ],
  "database_code.icsd": [
    "database_code_ICSD"
  ],
  "database_code.mdf": [
    "database_code_MDF"
  ],
  "database_code.nbs": [
    "database_code_NBS"
  ],
  "atom_site.adp_type": [
    "atom_site_ADP_type",
    "atom_site_thermal_displace_type"
  ],
  "atom_site.label": [
    "atom_site_id"
  ],
  "atom_site.site_symmetry_multiplicity": [
    "atom_site_symmetry_multiplicity"
  ],
  "atom_site.u_iso_or_equiv": [
    "atom_site_U_iso_or_equiv"
  ],
  "atom_site_aniso.label": [
    "atom_site_anisotrop_id"
  ],
  "atom_site_aniso.u_11": [
    "atom_site_aniso_U_11",
    "atom_site_anisotrop_U_11"
  ],
  "atom_site_aniso.u_12": [
    "atom_site_aniso_U_12",
    "atom_site_anisotrop_U_12"
  ],
  "atom_site_aniso.u_13": [
    "atom_site_aniso_U_13",
    "atom_site_anisotrop_U_13"
  ],
  "atom_site_aniso.u_22": [
    "atom_site_aniso_U_22",
    "atom_site_anisotrop_U_22"
  ],
  "atom_site_aniso.u_23": [
    "atom_site_aniso_U_23",
    "atom_site_anisotrop_U_23"
  ],
  "atom_site_aniso.u_33": [
    "atom_site_aniso_U_33",
    "atom_site_anisotrop_U_33"
  ]
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/schema/segmentation.js
var Schema8 = Column.Schema;
var int6 = Schema8.int;
var Segmentation_Data_Schema = {
  volume_data_3d_info: DensityServer_Data_Schema.volume_data_3d_info,
  segmentation_data_table: {
    set_id: int6,
    segment_id: int6
  },
  segmentation_data_3d: {
    values: int6
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif.js
var CIF = {
  parse: (data) => StringLike.is(data) ? parseCifText(data) : parseCifBinary(data),
  parseText: parseCifText,
  parseBinary: parseCifBinary,
  toDatabaseCollection,
  toDatabase,
  schema: {
    mmCIF: (frame) => toDatabase(mmCIF_Schema, frame),
    CCD: (frame) => toDatabase(CCD_Schema, frame),
    BIRD: (frame) => toDatabase(BIRD_Schema, frame),
    dic: (frame) => toDatabase(dic_Schema, frame),
    cifCore: (frame) => toDatabase(CifCore_Schema, frame, CifCore_Aliases),
    densityServer: (frame) => toDatabase(DensityServer_Data_Schema, frame),
    segmentation: (frame) => toDatabase(Segmentation_Data_Schema, frame)
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/property/anisotropic.js
var Anisotrop = {
  U: mmCIF_Schema.atom_site_anisotrop.U,
  U_esd: mmCIF_Schema.atom_site_anisotrop.U_esd
};
var AtomSiteAnisotrop;
(function(AtomSiteAnisotrop2) {
  AtomSiteAnisotrop2.Schema = Anisotrop;
  AtomSiteAnisotrop2.Descriptor = {
    name: "atom_site_anisotrop",
    cifExport: {
      prefix: "",
      categories: [{
        name: "atom_site_anisotrop",
        instance(ctx) {
          const p3 = AtomSiteAnisotrop2.Provider.get(ctx.firstModel);
          if (!p3)
            return CifWriter.Category.Empty;
          if (!MmcifFormat.is(ctx.firstModel.sourceData))
            return CifWriter.Category.Empty;
          return CifWriter.Category.ofTable(ctx.firstModel.sourceData.data.db.atom_site_anisotrop);
        }
      }]
    }
  };
  AtomSiteAnisotrop2.Provider = FormatPropertyProvider.create(AtomSiteAnisotrop2.Descriptor);
  function getElementToAnsiotrop(atomId, ansioId) {
    const atomIdToElement = new Int32Array(atomId.rowCount);
    atomIdToElement.fill(-1);
    for (let i = 0, il = atomId.rowCount; i < il; i++) {
      atomIdToElement[atomId.value(i)] = i;
    }
    const elementToAnsiotrop = new Int32Array(atomId.rowCount);
    elementToAnsiotrop.fill(-1);
    for (let i = 0, il = ansioId.rowCount; i < il; ++i) {
      const ei = atomIdToElement[ansioId.value(i)];
      if (ei !== -1)
        elementToAnsiotrop[ei] = i;
    }
    return elementToAnsiotrop;
  }
  AtomSiteAnisotrop2.getElementToAnsiotrop = getElementToAnsiotrop;
  function getElementToAnsiotropFromLabel(atomLabel, ansioLabel) {
    const atomLabelToElement = {};
    for (let i = 0, il = atomLabel.rowCount; i < il; i++) {
      atomLabelToElement[atomLabel.value(i)] = i;
    }
    const elementToAnsiotrop = new Int32Array(atomLabel.rowCount);
    elementToAnsiotrop.fill(-1);
    for (let i = 0, il = ansioLabel.rowCount; i < il; ++i) {
      const ei = atomLabelToElement[ansioLabel.value(i)];
      if (ei !== void 0)
        elementToAnsiotrop[ei] = i;
    }
    return elementToAnsiotrop;
  }
  AtomSiteAnisotrop2.getElementToAnsiotropFromLabel = getElementToAnsiotropFromLabel;
})(AtomSiteAnisotrop || (AtomSiteAnisotrop = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/global-transform.js
var GlobalModelTransformInfo;
(function(GlobalModelTransformInfo2) {
  const CategoryName = "molstar_global_model_transform_info";
  GlobalModelTransformInfo2.Schema = {
    [CategoryName]: {
      matrix: Column.Schema.Matrix(4, 4, Column.Schema.float)
    }
  };
  GlobalModelTransformInfo2.Descriptor = CustomPropertyDescriptor({
    name: CategoryName,
    cifExport: {
      categories: [{
        name: CategoryName,
        instance(ctx) {
          const mat = get(ctx.firstModel);
          if (!mat)
            return CifWriter.Category.Empty;
          const table = Table.ofRows(GlobalModelTransformInfo2.Schema.molstar_global_model_transform_info, [{ matrix: mat }]);
          return CifWriter.Category.ofTable(table);
        }
      }],
      prefix: "molstar"
    }
  });
  GlobalModelTransformInfo2.Provider = FormatPropertyProvider.create(GlobalModelTransformInfo2.Descriptor);
  function attach(model, matrix) {
    if (!model.customProperties.has(GlobalModelTransformInfo2.Descriptor)) {
      model.customProperties.add(GlobalModelTransformInfo2.Descriptor);
    }
    GlobalModelTransformInfo2.Provider.set(model, matrix);
  }
  GlobalModelTransformInfo2.attach = attach;
  function get(model) {
    return GlobalModelTransformInfo2.Provider.get(model);
  }
  GlobalModelTransformInfo2.get = get;
  function fromMmCif(model) {
    if (!MmcifFormat.is(model.sourceData))
      return;
    const cat = model.sourceData.data.frame.categories[CategoryName];
    if (!cat)
      return;
    const table = toTable(GlobalModelTransformInfo2.Schema[CategoryName], cat);
    if (table._rowCount === 0)
      return;
    return table.matrix.value(0);
  }
  GlobalModelTransformInfo2.fromMmCif = fromMmCif;
  function hasData(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    const cat = model.sourceData.data.frame.categories[CategoryName];
    return !!cat && cat.rowCount > 0;
  }
  GlobalModelTransformInfo2.hasData = hasData;
  function writeMmCif(encoder, matrix) {
    encoder.writeCategory({
      name: CategoryName,
      instance() {
        const table = Table.ofRows(GlobalModelTransformInfo2.Schema.molstar_global_model_transform_info, [{ matrix }]);
        return CifWriter.Category.ofTable(table);
      }
    });
  }
  GlobalModelTransformInfo2.writeMmCif = writeMmCif;
})(GlobalModelTransformInfo || (GlobalModelTransformInfo = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cif/schema/mmcif-extras.js
var mmCIF_residueId_schema = {
  label_comp_id: mmCIF_Schema.atom_site.label_comp_id,
  label_seq_id: mmCIF_Schema.atom_site.label_seq_id,
  pdbx_PDB_ins_code: mmCIF_Schema.atom_site.pdbx_PDB_ins_code,
  label_asym_id: mmCIF_Schema.atom_site.label_asym_id,
  label_entity_id: mmCIF_Schema.atom_site.label_entity_id,
  auth_comp_id: mmCIF_Schema.atom_site.auth_atom_id,
  auth_seq_id: mmCIF_Schema.atom_site.auth_seq_id,
  auth_asym_id: mmCIF_Schema.atom_site.auth_asym_id
};
var mmCIF_chemCompBond_schema = {
  ...mmCIF_Schema.chem_comp_bond,
  /** Indicates if the bond entry was taken from the protonation variant dictionary */
  molstar_protonation_variant: Column.Schema.Str()
};
var mmCIF_chemComp_schema = {
  ...mmCIF_Schema.chem_comp,
  type: Column.Schema.Aliased(Column.Schema.str)
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/basic/util.js
function getModelGroupName(model_id, data) {
  const { ihm_model_group, ihm_model_group_link } = data;
  const link = Table.pickRow(ihm_model_group_link, (i) => ihm_model_group_link.model_id.value(i) === model_id);
  if (link) {
    const group = Table.pickRow(ihm_model_group, (i) => ihm_model_group.id.value(i) === link.group_id);
    if (group)
      return group.name;
  }
  return "";
}
function hasPresentValues(column) {
  for (let i = 0, il = column.rowCount; i < il; i++) {
    if (column.valueKind(i) === Column.ValueKinds.Present)
      return true;
  }
  return false;
}
function substUndefinedColumn(table, a, b) {
  if (!table[a].isDefined || !hasPresentValues(table[a]))
    table[a] = table[b];
  if (!table[b].isDefined || !hasPresentValues(table[b]))
    table[b] = table[a];
}
function getNormalizedAtomSite(atom_site) {
  const normalized = Table.ofColumns(atom_site._schema, atom_site);
  substUndefinedColumn(normalized, "label_atom_id", "auth_atom_id");
  substUndefinedColumn(normalized, "label_comp_id", "auth_comp_id");
  substUndefinedColumn(normalized, "label_seq_id", "auth_seq_id");
  substUndefinedColumn(normalized, "label_asym_id", "auth_asym_id");
  substUndefinedColumn(normalized, "label_entity_id", "label_asym_id");
  return normalized;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/basic/schema.js
var BasicSchema = {
  entry: mmCIF_Schema.entry,
  struct: mmCIF_Schema.struct,
  struct_asym: mmCIF_Schema.struct_asym,
  ihm_model_list: mmCIF_Schema.ihm_model_list,
  ihm_model_group: mmCIF_Schema.ihm_model_group,
  ihm_model_group_link: mmCIF_Schema.ihm_model_group_link,
  entity: mmCIF_Schema.entity,
  entity_poly: mmCIF_Schema.entity_poly,
  entity_poly_seq: mmCIF_Schema.entity_poly_seq,
  pdbx_entity_branch: mmCIF_Schema.pdbx_entity_branch,
  chem_comp: mmCIF_chemComp_schema,
  pdbx_chem_comp_identifier: mmCIF_Schema.pdbx_chem_comp_identifier,
  atom_site: mmCIF_Schema.atom_site,
  ihm_sphere_obj_site: mmCIF_Schema.ihm_sphere_obj_site,
  ihm_gaussian_obj_site: mmCIF_Schema.ihm_gaussian_obj_site,
  pdbx_unobs_or_zero_occ_residues: mmCIF_Schema.pdbx_unobs_or_zero_occ_residues,
  pdbx_molecule: mmCIF_Schema.pdbx_molecule
};
function createBasic(data, normalize = false) {
  const basic = /* @__PURE__ */ Object.create(null);
  for (const name of Object.keys(BasicSchema)) {
    if (name in data) {
      basic[name] = data[name];
    } else {
      basic[name] = Table.ofUndefinedColumns(BasicSchema[name], 0);
    }
  }
  if (normalize) {
    basic.atom_site = getNormalizedAtomSite(basic.atom_site);
  }
  return basic;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/common/entity.js
var EntityBuilder = class {
  constructor() {
    this.count = 0;
    this.ids = [];
    this.types = [];
    this.descriptions = [];
    this.compoundsMap = /* @__PURE__ */ new Map();
    this.namesMap = /* @__PURE__ */ new Map();
    this.heteroMap = /* @__PURE__ */ new Map();
    this.chainMap = /* @__PURE__ */ new Map();
  }
  set(type3, description) {
    this.count += 1;
    this.ids.push(`${this.count}`);
    this.types.push(type3);
    this.descriptions.push([description]);
  }
  getEntityId(compId2, moleculeType, chainId, options) {
    if (moleculeType === MoleculeType.Water) {
      if (this.waterId === void 0) {
        this.set("water", (options === null || options === void 0 ? void 0 : options.customName) || "Water");
        this.waterId = `${this.count}`;
      }
      return this.waterId;
    } else if (isPolymer(moleculeType)) {
      if (this.compoundsMap.has(chainId)) {
        return this.compoundsMap.get(chainId);
      } else {
        if (!this.chainMap.has(chainId)) {
          this.set("polymer", (options === null || options === void 0 ? void 0 : options.customName) || `Polymer ${this.chainMap.size + 1}`);
          this.chainMap.set(chainId, `${this.count}`);
        }
        return this.chainMap.get(chainId);
      }
    } else {
      if (!this.heteroMap.has(compId2)) {
        this.set("non-polymer", (options === null || options === void 0 ? void 0 : options.customName) || this.namesMap.get(compId2) || compId2);
        this.heteroMap.set(compId2, `${this.count}`);
      }
      return this.heteroMap.get(compId2);
    }
  }
  getEntityTable() {
    return Table.ofPartialColumns(BasicSchema.entity, {
      id: Column.ofStringArray(this.ids),
      type: Column.ofStringAliasArray(this.types),
      pdbx_description: Column.ofStringListArray(this.descriptions)
    }, this.count);
  }
  setCompounds(compounds) {
    for (let i = 0, il = compounds.length; i < il; ++i) {
      const { chains: chains2, description } = compounds[i];
      this.set("polymer", description);
      for (let j = 0, jl = chains2.length; j < jl; ++j) {
        this.compoundsMap.set(chains2[j], `${this.count}`);
      }
    }
  }
  setNames(names) {
    names.forEach((n) => this.namesMap.set(n[0], n[1]));
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/common/component.js
var ProteinAtomIdsList = [
  /* @__PURE__ */ new Set(["CA"]),
  /* @__PURE__ */ new Set(["C"]),
  /* @__PURE__ */ new Set(["N"])
];
var RnaAtomIdsList = [
  /* @__PURE__ */ new Set(["P", "O3'", "O3*"]),
  /* @__PURE__ */ new Set(["C4'", "C4*"]),
  /* @__PURE__ */ new Set(["O2'", "O2*", "F2'", "F2*"])
];
var DnaAtomIdsList = [
  /* @__PURE__ */ new Set(["P", "O3'", "O3*"]),
  /* @__PURE__ */ new Set(["C3'", "C3*"]),
  /* @__PURE__ */ new Set(["O2'", "O2*", "F2'", "F2*"])
];
var NonPolymerNames = /* @__PURE__ */ new Set([
  "FMN",
  "NCN",
  "FNS",
  "FMA",
  "ATP",
  "ADP",
  "AMP",
  "GTP",
  "GDP",
  "GMP",
  // Mononucleotides
  "LIG"
]);
var StandardComponents = function() {
  const map2 = /* @__PURE__ */ new Map();
  const components = [
    { id: "HIS", name: "HISTIDINE", type: "l-peptide linking" },
    { id: "ARG", name: "ARGININE", type: "l-peptide linking" },
    { id: "LYS", name: "LYSINE", type: "l-peptide linking" },
    { id: "ILE", name: "ISOLEUCINE", type: "l-peptide linking" },
    { id: "PHE", name: "PHENYLALANINE", type: "l-peptide linking" },
    { id: "LEU", name: "LEUCINE", type: "l-peptide linking" },
    { id: "TRP", name: "TRYPTOPHAN", type: "l-peptide linking" },
    { id: "ALA", name: "ALANINE", type: "l-peptide linking" },
    { id: "MET", name: "METHIONINE", type: "l-peptide linking" },
    { id: "CYS", name: "CYSTEINE", type: "l-peptide linking" },
    { id: "ASN", name: "ASPARAGINE", type: "l-peptide linking" },
    { id: "VAL", name: "VALINE", type: "l-peptide linking" },
    { id: "GLY", name: "GLYCINE", type: "peptide linking" },
    { id: "SER", name: "SERINE", type: "l-peptide linking" },
    { id: "GLN", name: "GLUTAMINE", type: "l-peptide linking" },
    { id: "TYR", name: "TYROSINE", type: "l-peptide linking" },
    { id: "ASP", name: "ASPARTIC ACID", type: "l-peptide linking" },
    { id: "GLU", name: "GLUTAMIC ACID", type: "l-peptide linking" },
    { id: "THR", name: "THREONINE", type: "l-peptide linking" },
    { id: "PRO", name: "PROLINE", type: "l-peptide linking" },
    { id: "SEC", name: "SELENOCYSTEINE", type: "l-peptide linking" },
    { id: "PYL", name: "PYRROLYSINE", type: "l-peptide linking" },
    { id: "MSE", name: "SELENOMETHIONINE", type: "l-peptide linking" },
    { id: "SEP", name: "PHOSPHOSERINE", type: "l-peptide linking" },
    { id: "TPO", name: "PHOSPHOTHREONINE", type: "l-peptide linking" },
    { id: "PTR", name: "O-PHOSPHOTYROSINE", type: "l-peptide linking" },
    { id: "PCA", name: "PYROGLUTAMIC ACID", type: "l-peptide linking" },
    { id: "A", name: "ADENOSINE-5'-MONOPHOSPHATE", type: "rna linking" },
    { id: "C", name: "CYTIDINE-5'-MONOPHOSPHATE", type: "rna linking" },
    { id: "T", name: "THYMIDINE-5'-MONOPHOSPHATE", type: "rna linking" },
    { id: "G", name: "GUANOSINE-5'-MONOPHOSPHATE", type: "rna linking" },
    { id: "I", name: "INOSINIC ACID", type: "rna linking" },
    { id: "U", name: "URIDINE-5'-MONOPHOSPHATE", type: "rna linking" },
    { id: "DA", name: "2'-DEOXYADENOSINE-5'-MONOPHOSPHATE", type: "dna linking" },
    { id: "DC", name: "2'-DEOXYCYTIDINE-5'-MONOPHOSPHATE", type: "dna linking" },
    { id: "DT", name: "THYMIDINE-5'-MONOPHOSPHATE", type: "dna linking" },
    { id: "DG", name: "2'-DEOXYGUANOSINE-5'-MONOPHOSPHATE", type: "dna linking" },
    { id: "DI", name: "2'-DEOXYINOSINE-5'-MONOPHOSPHATE", type: "dna linking" },
    { id: "DU", name: "2'-DEOXYURIDINE-5'-MONOPHOSPHATE", type: "dna linking" }
  ];
  components.forEach((c) => map2.set(c.id, c));
  return map2;
}();
var CharmmIonComponents = function() {
  const map2 = /* @__PURE__ */ new Map();
  const components = [
    { id: "ZN2", name: "ZINC ION", type: "ion" },
    { id: "SOD", name: "SODIUM ION", type: "ion" },
    { id: "CES", name: "CESIUM ION", type: "ion" },
    { id: "CLA", name: "CHLORIDE ION", type: "ion" },
    { id: "CAL", name: "CALCIUM ION", type: "ion" },
    { id: "POT", name: "POTASSIUM ION", type: "ion" }
  ];
  components.forEach((c) => map2.set(c.id, c));
  return map2;
}();
var ComponentBuilder = class {
  set(c) {
    this.comps.set(c.id, c);
    this.ids.push(c.id);
    this.names.push(c.name);
    this.types.push(c.type);
    this.mon_nstd_flags.push(PolymerNames.has(c.id) ? "y" : "n");
  }
  getAtomIds(index) {
    const atomIds = /* @__PURE__ */ new Set();
    const prevSeqId = this.seqId.value(index);
    while (index < this.seqId.rowCount) {
      const seqId2 = this.seqId.value(index);
      if (seqId2 !== prevSeqId)
        break;
      atomIds.add(this.atomId.value(index));
      prevSeqId - seqId2;
      index += 1;
    }
    return atomIds;
  }
  hasAtomIds(atomIds, atomIdsList) {
    for (let i = 0, il = atomIdsList.length; i < il; ++i) {
      if (!SetUtils.areIntersecting(atomIds, atomIdsList[i])) {
        return false;
      }
    }
    return true;
  }
  getType(atomIds) {
    if (this.hasAtomIds(atomIds, ProteinAtomIdsList)) {
      return "peptide linking";
    } else if (this.hasAtomIds(atomIds, RnaAtomIdsList)) {
      return "rna linking";
    } else if (this.hasAtomIds(atomIds, DnaAtomIdsList)) {
      return "dna linking";
    } else {
      return "other";
    }
  }
  has(compId2) {
    return this.comps.has(compId2);
  }
  get(compId2) {
    return this.comps.get(compId2);
  }
  add(compId2, index) {
    if (!this.has(compId2)) {
      if (StandardComponents.has(compId2)) {
        this.set(StandardComponents.get(compId2));
      } else if (WaterNames.has(compId2)) {
        this.set({ id: compId2, name: "WATER", type: "non-polymer" });
      } else if (NonPolymerNames.has(compId2.toUpperCase())) {
        this.set({ id: compId2, name: this.namesMap.get(compId2) || compId2, type: "non-polymer" });
      } else if (SaccharideCompIdMap.has(compId2.toUpperCase())) {
        this.set({ id: compId2, name: this.namesMap.get(compId2) || compId2, type: "saccharide" });
      } else {
        const atomIds = this.getAtomIds(index);
        if (atomIds.size === 1 && CharmmIonComponents.has(compId2)) {
          this.set(CharmmIonComponents.get(compId2));
        } else {
          const type3 = this.getType(atomIds);
          this.set({ id: compId2, name: this.namesMap.get(compId2) || compId2, type: type3 });
        }
      }
    }
    return this.get(compId2);
  }
  getChemCompTable() {
    return Table.ofPartialColumns(BasicSchema.chem_comp, {
      id: Column.ofStringArray(this.ids),
      name: Column.ofStringArray(this.names),
      type: Column.ofStringAliasArray(this.types),
      mon_nstd_flag: Column.ofStringAliasArray(this.mon_nstd_flags)
    }, this.ids.length);
  }
  setNames(names) {
    names.forEach((n) => this.namesMap.set(n[0], n[1]));
  }
  constructor(seqId2, atomId) {
    this.seqId = seqId2;
    this.atomId = atomId;
    this.namesMap = /* @__PURE__ */ new Map();
    this.comps = /* @__PURE__ */ new Map();
    this.ids = [];
    this.names = [];
    this.types = [];
    this.mon_nstd_flags = [];
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/export/categories/molstar_bond_site.js
function molstar_bond_site(ctx) {
  const entries = getEntries(ctx);
  if (entries.length === 0)
    return;
  return [Category3, entries, { ignoreFilter: true }];
}
var MolstarBondSiteSchema = {
  molstar_bond_site: {
    atom_id_1: Column.Schema.int,
    atom_id_2: Column.Schema.int,
    value_order: Column.Schema.Aliased(Column.Schema.lstr),
    type_id: Column.Schema.Aliased(Column.Schema.lstr)
  }
};
var Fields = CifWriter.fields().int("atom_id_1", (i, xs) => xs[i].atom_id_1).int("atom_id_2", (i, xs) => xs[i].atom_id_2).str("value_order", (i, xs) => {
  var _a;
  return (_a = xs[i].value_order) !== null && _a !== void 0 ? _a : "";
}, {
  valueKind: (i, xs) => xs[i].value_order === void 0 ? Column.ValueKinds.NotPresent : Column.ValueKinds.Present
}).str("type_id", (i, xs) => {
  var _a;
  return (_a = xs[i].type_id) !== null && _a !== void 0 ? _a : "";
}, {
  valueKind: (i, xs) => xs[i].type_id === void 0 ? Column.ValueKinds.NotPresent : Column.ValueKinds.Present
}).getFields();
var Category3 = {
  name: "molstar_bond_site",
  instance(entries) {
    return { fields: Fields, source: [{ data: entries, rowCount: entries.length }] };
  }
};
function assignValueOrder(order, flags2, out) {
  out[0] = void 0;
  out[1] = void 0;
  if (order === 1)
    out[0] = "sing";
  else if (order === 2)
    out[0] = "doub";
  else if (order === 3)
    out[0] = "trip";
  else if (order === 4)
    out[0] = "quad";
  if (BondType.is(flags2, BondType.Flag.Aromatic))
    out[0] = "arom";
  if (BondType.is(flags2, BondType.Flag.Disulfide))
    out[1] = "disulf";
  else if (BondType.is(flags2, BondType.Flag.Covalent))
    out[1] = "covale";
  else if (BondType.is(flags2, BondType.Flag.MetallicCoordination))
    out[1] = "metalc";
  else if (BondType.is(flags2, BondType.Flag.HydrogenBond))
    out[1] = "hydrog";
}
function getEntries(ctx) {
  const entries = [];
  const added = /* @__PURE__ */ new Set();
  const loc = element_exports.Location.create();
  const { id: atom_id } = StructureProperties.atom;
  const info = [void 0, void 0];
  const add = (a, b) => {
    const key = sortedCantorPairing(a, b);
    if (added.has(key))
      return;
    added.add(key);
    if (a > b) {
      entries.push({ atom_id_1: b, atom_id_2: a, value_order: info[0], type_id: info[1] });
    } else {
      entries.push({ atom_id_1: a, atom_id_2: b, value_order: info[0], type_id: info[1] });
    }
  };
  for (const s of ctx.structures) {
    loc.structure = s;
    for (const u of s.units) {
      if (!Unit.isAtomic(u))
        continue;
      const { elements } = u;
      const { a, b, edgeProps } = u.bonds;
      loc.unit = u;
      for (let i = 0; i < a.length; i++) {
        loc.element = elements[a[i]];
        const atom_id_1 = atom_id(loc);
        loc.element = elements[b[i]];
        const atom_id_2 = atom_id(loc);
        assignValueOrder(edgeProps.order[i], edgeProps.flags[i], info);
        add(atom_id_1, atom_id_2);
      }
    }
    s.interUnitBonds.edges.forEach((e) => {
      let u = s.unitMap.get(e.unitA);
      loc.unit = u;
      loc.element = u.elements[e.indexA];
      const atom_id_1 = atom_id(loc);
      u = s.unitMap.get(e.unitB);
      loc.unit = u;
      loc.element = u.elements[e.indexB];
      const atom_id_2 = atom_id(loc);
      assignValueOrder(e.props.order, e.props.flag, info);
      add(atom_id_1, atom_id_2);
    });
  }
  entries.sort((a, b) => {
    if (a.atom_id_1 !== b.atom_id_1)
      return a.atom_id_1 - b.atom_id_1;
    if (a.atom_id_2 !== b.atom_id_2)
      return a.atom_id_2 - b.atom_id_2;
    return 0;
  });
  return entries;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/mmcif.js
function modelSymmetryFromMmcif(model) {
  if (!MmcifFormat.is(model.sourceData))
    return;
  return ModelSymmetry.fromData(model.sourceData.data.db);
}
ModelSymmetry.Provider.formatRegistry.add("mmCIF", modelSymmetryFromMmcif);
function secondaryStructureFromMmcif(model) {
  if (!MmcifFormat.is(model.sourceData))
    return;
  const { struct_conf, struct_sheet_range } = model.sourceData.data.db;
  return ModelSecondaryStructure.fromStruct(struct_conf, struct_sheet_range, model.atomicHierarchy);
}
ModelSecondaryStructure.Provider.formatRegistry.add("mmCIF", secondaryStructureFromMmcif);
function atomSiteAnisotropFromMmcif(model) {
  if (!MmcifFormat.is(model.sourceData))
    return;
  const { atom_site_anisotrop } = model.sourceData.data.db;
  const data = Table.ofColumns(AtomSiteAnisotrop.Schema, atom_site_anisotrop);
  const elementToAnsiotrop = AtomSiteAnisotrop.getElementToAnsiotrop(model.atomicConformation.atomId, atom_site_anisotrop.id);
  return { data, elementToAnsiotrop };
}
function atomSiteAnisotropApplicableMmcif(model) {
  if (!MmcifFormat.is(model.sourceData))
    return false;
  return model.sourceData.data.db.atom_site_anisotrop.U.isDefined;
}
AtomSiteAnisotrop.Provider.formatRegistry.add("mmCIF", atomSiteAnisotropFromMmcif, atomSiteAnisotropApplicableMmcif);
function componentBondFromMmcif(model) {
  if (!MmcifFormat.is(model.sourceData))
    return;
  const { chem_comp_bond } = model.sourceData.data.db;
  if (chem_comp_bond._rowCount === 0)
    return;
  return {
    data: chem_comp_bond,
    entries: ComponentBond.getEntriesFromChemCompBond(chem_comp_bond)
  };
}
ComponentBond.Provider.formatRegistry.add("mmCIF", componentBondFromMmcif);
function structConnFromMmcif(model) {
  if (!MmcifFormat.is(model.sourceData))
    return;
  const { struct_conn } = model.sourceData.data.db;
  if (struct_conn._rowCount === 0)
    return;
  const entries = StructConn.getEntriesFromStructConn(struct_conn, model);
  const residueCantorPairs = /* @__PURE__ */ new Set();
  for (const e of entries) {
    if (e.partnerA.residueIndex !== e.partnerB.residueIndex) {
      residueCantorPairs.add(sortedCantorPairing(e.partnerA.residueIndex, e.partnerB.residueIndex));
    }
  }
  return {
    data: struct_conn,
    byAtomIndex: StructConn.getAtomIndexFromEntries(entries),
    residueCantorPairs,
    entries
  };
}
StructConn.Provider.formatRegistry.add("mmCIF", structConnFromMmcif);
function indexPairBondsFromMolstarBondSite(model) {
  if (!MmcifFormat.is(model.sourceData))
    return;
  const { molstar_bond_site: entries } = toDatabase(MolstarBondSiteSchema, model.sourceData.data.frame);
  if (entries._rowCount === 0)
    return;
  const idToIndex = /* @__PURE__ */ new Map();
  const { atomId } = model.atomicConformation;
  for (let i = 0; i < atomId.rowCount; i++) {
    idToIndex.set(atomId.value(i), i);
  }
  const indexA = [];
  const indexB = [];
  const orders = [];
  const flags2 = [];
  const { atom_id_1, atom_id_2, value_order, type_id } = entries;
  for (let i = 0; i < entries._rowCount; i++) {
    indexA.push(idToIndex.get(atom_id_1.value(i)));
    indexB.push(idToIndex.get(atom_id_2.value(i)));
    let flag = BondType.Flag.None;
    let order = 1;
    switch (value_order.value(i)) {
      case "sing":
        order = 1;
        break;
      case "doub":
        order = 2;
        break;
      case "trip":
        order = 3;
        break;
      case "quad":
        order = 4;
        break;
      case "arom":
        order = 1;
        flag = BondType.Flag.Aromatic;
        break;
      default:
        break;
    }
    switch (type_id.value(i)) {
      case "covale":
        flag |= BondType.Flag.Covalent;
        break;
      case "disulf":
        flag |= BondType.Flag.Covalent | BondType.Flag.Disulfide;
        break;
      case "hydrog":
        flag |= BondType.Flag.HydrogenBond;
        break;
      case "metalc":
        flag |= BondType.Flag.MetallicCoordination;
        break;
    }
    orders.push(order);
    flags2.push(flag);
  }
  const pairBonds = IndexPairBonds.fromData({
    pairs: {
      indexA: Column.ofIntArray(indexA),
      indexB: Column.ofIntArray(indexB),
      order: Column.ofIntArray(orders),
      flag: Column.ofArray({ array: flags2, schema: Column.Schema.int })
    },
    count: model.atomicHierarchy.atoms._rowCount
  }, { maxDistance: Infinity });
  return pairBonds;
}
IndexPairBonds.Provider.formatRegistry.add("mmCIF", indexPairBondsFromMolstarBondSite);
GlobalModelTransformInfo.Provider.formatRegistry.add("mmCIF", GlobalModelTransformInfo.fromMmCif, GlobalModelTransformInfo.hasData);
var MmcifFormat;
(function(MmcifFormat2) {
  function is(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "mmCIF";
  }
  MmcifFormat2.is = is;
  function fromFrame(frame, db, source, file) {
    if (!db)
      db = CIF.schema.mmCIF(frame);
    return { kind: "mmCIF", name: db._name, data: { db, file, frame, source } };
  }
  MmcifFormat2.fromFrame = fromFrame;
})(MmcifFormat || (MmcifFormat = {}));
function trajectoryFromMmCIF(frame, file) {
  const format = MmcifFormat.fromFrame(frame, void 0, void 0, file);
  const basic = createBasic(format.data.db, true);
  return Task.create("Create mmCIF Model", (ctx) => createModels(basic, format, ctx));
}
var CCDFormat;
(function(CCDFormat2) {
  const CoordinateTypeProp = "__CcdCoordinateType__";
  CCDFormat2.CoordinateType = {
    get(model) {
      return model._staticPropertyData[CoordinateTypeProp];
    },
    set(model, type3) {
      return model._staticPropertyData[CoordinateTypeProp] = type3;
    }
  };
  function is(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "CCD";
  }
  CCDFormat2.is = is;
  function fromFrame(frame, db) {
    if (!db)
      db = CIF.schema.CCD(frame);
    return { kind: "CCD", name: db._name, data: { db, frame } };
  }
  CCDFormat2.fromFrame = fromFrame;
})(CCDFormat || (CCDFormat = {}));
function trajectoryFromCCD(frame) {
  const format = CCDFormat.fromFrame(frame);
  return Task.create("Create CCD Models", (ctx) => createCcdModels(format.data.db, CCDFormat.fromFrame(frame), ctx));
}
async function createCcdModels(data, format, ctx) {
  const ideal = await createCcdModel(data, format, { coordinateType: "ideal", cartn_x: "pdbx_model_Cartn_x_ideal", cartn_y: "pdbx_model_Cartn_y_ideal", cartn_z: "pdbx_model_Cartn_z_ideal" }, ctx);
  const model = await createCcdModel(data, format, { coordinateType: "model", cartn_x: "model_Cartn_x", cartn_y: "model_Cartn_y", cartn_z: "model_Cartn_z" }, ctx);
  const models = [];
  if (ideal)
    models.push(ideal);
  if (model)
    models.push(model);
  for (let i = 0, il = models.length; i < il; ++i) {
    Model.TrajectoryInfo.set(models[i], { index: i, size: models.length });
  }
  return new ArrayTrajectory(models);
}
async function createCcdModel(data, format, props, ctx) {
  const { chem_comp, chem_comp_atom, chem_comp_bond } = data;
  const { coordinateType, cartn_x, cartn_y, cartn_z } = props;
  const name = chem_comp.name.value(0);
  const id = chem_comp.id.value(0);
  const { atom_id, charge, comp_id, pdbx_ordinal, type_symbol } = chem_comp_atom;
  const atomCount2 = chem_comp_atom._rowCount;
  const filteredRows = [];
  for (let i = 0; i < atomCount2; i++) {
    if (chem_comp_atom[cartn_x].valueKind(i) > 0)
      continue;
    filteredRows[filteredRows.length] = i;
  }
  const filteredRowCount = filteredRows.length;
  const A = Column.ofConst("A", filteredRowCount, Column.Schema.str);
  const seq_id = Column.ofConst(1, filteredRowCount, Column.Schema.int);
  const entity_id = Column.ofConst("1", filteredRowCount, Column.Schema.str);
  const occupancy = Column.ofConst(1, filteredRowCount, Column.Schema.float);
  const model_num = Column.ofConst(1, filteredRowCount, Column.Schema.int);
  const filteredAtomId = Column.view(atom_id, filteredRows);
  const filteredCompId = Column.view(comp_id, filteredRows);
  const filteredX = Column.view(chem_comp_atom[cartn_x], filteredRows);
  const filteredY = Column.view(chem_comp_atom[cartn_y], filteredRows);
  const filteredZ = Column.view(chem_comp_atom[cartn_z], filteredRows);
  const filteredId = Column.view(pdbx_ordinal, filteredRows);
  const filteredTypeSymbol = Column.view(type_symbol, filteredRows);
  const filteredCharge = Column.view(charge, filteredRows);
  const model_atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
    auth_asym_id: A,
    auth_atom_id: filteredAtomId,
    auth_comp_id: filteredCompId,
    auth_seq_id: seq_id,
    Cartn_x: filteredX,
    Cartn_y: filteredY,
    Cartn_z: filteredZ,
    id: filteredId,
    label_asym_id: A,
    label_atom_id: filteredAtomId,
    label_comp_id: filteredCompId,
    label_seq_id: seq_id,
    label_entity_id: entity_id,
    occupancy,
    type_symbol: filteredTypeSymbol,
    pdbx_PDB_model_num: model_num,
    pdbx_formal_charge: filteredCharge
  }, filteredRowCount);
  const entityBuilder = new EntityBuilder();
  entityBuilder.setNames([[id, `${name} (${coordinateType})`]]);
  entityBuilder.getEntityId(id, MoleculeType.Unknown, "A");
  const componentBuilder = new ComponentBuilder(seq_id, type_symbol);
  componentBuilder.setNames([[id, `${name} (${coordinateType})`]]);
  componentBuilder.add(id, 0);
  const basicModel = createBasic({
    entity: entityBuilder.getEntityTable(),
    chem_comp: componentBuilder.getChemCompTable(),
    atom_site: model_atom_site
  });
  const models = await createModels(basicModel, format, ctx);
  if (!models.representative)
    return;
  const first2 = models.representative;
  const entries = ComponentBond.getEntriesFromChemCompBond(chem_comp_bond);
  ComponentBond.Provider.set(first2, { data: chem_comp_bond, entries });
  CCDFormat.CoordinateType.set(first2, coordinateType);
  return models.representative;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/common/custom-model-property.js
var CustomModelProperty;
(function(CustomModelProperty2) {
  function createProvider(builder) {
    const descriptorName = builder.descriptor.name;
    const propertyDataName = builder.type === "static" ? "_staticPropertyData" : "_dynamicPropertyData";
    const get = (data) => {
      if (!(descriptorName in data[propertyDataName])) {
        data[propertyDataName][descriptorName] = {
          props: { ...ParamDefinition.getDefaultValues(builder.getParams(data)) },
          data: ValueBox.create(void 0)
        };
      }
      return data[propertyDataName][descriptorName];
    };
    const set2 = (data, props, value) => {
      const property2 = get(data);
      data[propertyDataName][descriptorName] = {
        props,
        data: ValueBox.withValue(property2.data, value)
      };
    };
    return {
      label: builder.label,
      descriptor: builder.descriptor,
      isHidden: builder.isHidden,
      getParams: (data) => {
        const params = ParamDefinition.clone(builder.getParams(data));
        ParamDefinition.setDefaultValues(params, get(data).props);
        return params;
      },
      defaultParams: builder.defaultParams,
      isApplicable: builder.isApplicable,
      attach: async (ctx, data, props = {}, addRef) => {
        if (addRef)
          data.customProperties.reference(builder.descriptor, true);
        const property2 = get(data);
        const p3 = ParamDefinition.merge(builder.defaultParams, property2.props, props);
        if (property2.data.value && ParamDefinition.areEqual(builder.defaultParams, property2.props, p3))
          return;
        const { value, assets } = await builder.obtain(ctx, data, p3);
        data.customProperties.add(builder.descriptor);
        data.customProperties.assets(builder.descriptor, assets);
        set2(data, p3, value);
      },
      ref: (data, add) => data.customProperties.reference(builder.descriptor, add),
      get: (data) => {
        var _a;
        return (_a = get(data)) === null || _a === void 0 ? void 0 : _a.data;
      },
      set: (data, props = {}, value) => {
        const property2 = get(data);
        const p3 = ParamDefinition.merge(builder.defaultParams, property2.props, props);
        if (!ParamDefinition.areEqual(builder.defaultParams, property2.props, p3)) {
          set2(data, p3, value);
          data.customProperties.assets(builder.descriptor);
        }
      },
      props: (data) => get(data).props
    };
  }
  CustomModelProperty2.createProvider = createProvider;
  function createSimple(name, type3, defaultValue) {
    const defaultParams = { value: ParamDefinition.Value(defaultValue, { isHidden: true }) };
    return createProvider({
      label: stringToWords(name),
      descriptor: CustomPropertyDescriptor({ name }),
      isHidden: true,
      type: type3,
      defaultParams,
      getParams: () => ({ value: ParamDefinition.Value(defaultValue, { isHidden: true }) }),
      isApplicable: () => true,
      obtain: async (ctx, data, props) => {
        return { ...ParamDefinition.getDefaultValues(defaultParams), ...props };
      }
    });
  }
  CustomModelProperty2.createSimple = createSimple;
})(CustomModelProperty || (CustomModelProperty = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/sequence/sifts-mapping.js
var SIFTSMapping;
(function(SIFTSMapping2) {
  SIFTSMapping2.Provider = CustomModelProperty.createProvider({
    label: "SIFTS Mapping",
    descriptor: CustomPropertyDescriptor({
      name: "sifts_sequence_mapping"
    }),
    type: "static",
    defaultParams: {},
    getParams: () => ({}),
    isApplicable: (data) => isAvailable(data),
    obtain: async (ctx, data) => {
      return { value: fromCif(data) };
    }
  });
  function isAvailable(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    const { pdbx_sifts_xref_db_name: db_name, pdbx_sifts_xref_db_acc: db_acc, pdbx_sifts_xref_db_num: db_num, pdbx_sifts_xref_db_res: db_res } = model.sourceData.data.db.atom_site;
    return db_name.isDefined && db_acc.isDefined && db_num.isDefined && db_res.isDefined;
  }
  SIFTSMapping2.isAvailable = isAvailable;
  function getKey(loc) {
    const model = loc.unit.model;
    const data = SIFTSMapping2.Provider.get(model).value;
    if (!data)
      return "";
    const rI = model.atomicHierarchy.residueAtomSegments.index[loc.element];
    return data.accession[rI];
  }
  SIFTSMapping2.getKey = getKey;
  function getLabel(loc) {
    const model = loc.unit.model;
    const data = SIFTSMapping2.Provider.get(model).value;
    if (!data)
      return;
    const rI = model.atomicHierarchy.residueAtomSegments.index[loc.element];
    const dbName = data.dbName[rI];
    if (!dbName)
      return;
    return `${dbName} ${data.accession[rI]} ${data.num[rI]} ${data.residue[rI]}`;
  }
  SIFTSMapping2.getLabel = getLabel;
  function fromCif(model) {
    if (!MmcifFormat.is(model.sourceData))
      return;
    const { pdbx_sifts_xref_db_name: db_name, pdbx_sifts_xref_db_acc: db_acc, pdbx_sifts_xref_db_num: db_num, pdbx_sifts_xref_db_res: db_res } = model.sourceData.data.db.atom_site;
    if (!db_name.isDefined || !db_acc.isDefined || !db_num.isDefined || !db_res.isDefined)
      return;
    const { atomSourceIndex } = model.atomicHierarchy;
    const { count, offsets: residueOffsets } = model.atomicHierarchy.residueAtomSegments;
    const dbName = new Array(count);
    const accession = new Array(count);
    const num = new Array(count);
    const residue2 = new Array(count);
    for (let i = 0; i < count; i++) {
      const row = atomSourceIndex.value(residueOffsets[i]);
      if (db_name.valueKind(row) !== Column.ValueKinds.Present) {
        dbName[i] = "";
        accession[i] = "";
        num[i] = "";
        residue2[i] = "";
        continue;
      }
      dbName[i] = db_name.value(row);
      accession[i] = db_acc.value(row);
      num[i] = db_num.value(row);
      residue2[i] = db_res.value(row);
    }
    return { dbName, accession, num, residue: residue2 };
  }
})(SIFTSMapping || (SIFTSMapping = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/export/categories/atom_site.js
var CifField2 = CifWriter.Field;
var E = CifWriter.Encodings;
function atom_site_label_asym_id(e) {
  const l = StructureProperties.chain.label_asym_id(e);
  const suffix = e.unit.conformation.operator.suffix;
  if (!suffix)
    return l;
  return l + suffix;
}
function atom_site_auth_asym_id(e) {
  const l = StructureProperties.chain.auth_asym_id(e);
  const suffix = e.unit.conformation.operator.suffix;
  if (!suffix)
    return l;
  return l + suffix;
}
var atom_site_pdbx_label_index = {
  shouldInclude(s) {
    var _a;
    return !!((_a = s.atom_site) === null || _a === void 0 ? void 0 : _a.pdbx_label_index.isDefined);
  },
  value(e, d) {
    const srcIndex = d.sourceIndex.value(e.element);
    return d.atom_site.pdbx_label_index.value(srcIndex);
  }
};
var SIFTS = {
  shouldInclude(s) {
    return SIFTSMapping.isAvailable(s.structure.models[0]);
  },
  pdbx_sifts_xref_db_name: {
    value(e, d) {
      const srcIndex = d.sourceIndex.value(e.element);
      return d.atom_site.pdbx_sifts_xref_db_name.value(srcIndex);
    },
    valueKind(e, d) {
      const srcIndex = d.sourceIndex.value(e.element);
      return d.atom_site.pdbx_sifts_xref_db_name.valueKind(srcIndex);
    }
  },
  pdbx_sifts_xref_db_acc: {
    value(e, d) {
      const srcIndex = d.sourceIndex.value(e.element);
      return d.atom_site.pdbx_sifts_xref_db_acc.value(srcIndex);
    },
    valueKind(e, d) {
      const srcIndex = d.sourceIndex.value(e.element);
      return d.atom_site.pdbx_sifts_xref_db_acc.valueKind(srcIndex);
    }
  },
  pdbx_sifts_xref_db_num: {
    value(e, d) {
      const srcIndex = d.sourceIndex.value(e.element);
      return d.atom_site.pdbx_sifts_xref_db_num.value(srcIndex);
    },
    valueKind(e, d) {
      const srcIndex = d.sourceIndex.value(e.element);
      return d.atom_site.pdbx_sifts_xref_db_num.valueKind(srcIndex);
    }
  },
  pdbx_sifts_xref_db_res: {
    value(e, d) {
      const srcIndex = d.sourceIndex.value(e.element);
      return d.atom_site.pdbx_sifts_xref_db_res.value(srcIndex);
    },
    valueKind(e, d) {
      const srcIndex = d.sourceIndex.value(e.element);
      return d.atom_site.pdbx_sifts_xref_db_res.valueKind(srcIndex);
    }
  }
};
var atom_site_fields = (keepId) => {
  const fields = CifWriter.fields();
  fields.str("group_PDB", StructureProperties.residue.group_PDB);
  if (keepId) {
    fields.int("id", StructureProperties.atom.id);
  } else {
    fields.index("id");
  }
  fields.str("type_symbol", StructureProperties.atom.type_symbol).str("label_atom_id", StructureProperties.atom.label_atom_id).str("label_comp_id", StructureProperties.atom.label_comp_id).int("label_seq_id", StructureProperties.residue.label_seq_id, {
    encoder: E.deltaRLE,
    valueKind: (k, d) => {
      const m = k.unit.model;
      return m.atomicHierarchy.residues.label_seq_id.valueKind(m.atomicHierarchy.residueAtomSegments.index[k.element]);
    }
  }).str("label_alt_id", StructureProperties.atom.label_alt_id).str("pdbx_PDB_ins_code", StructureProperties.residue.pdbx_PDB_ins_code).str("label_asym_id", atom_site_label_asym_id).str("label_entity_id", StructureProperties.chain.label_entity_id).float("Cartn_x", StructureProperties.atom.x, { digitCount: 3, encoder: E.fixedPoint3 }).float("Cartn_y", StructureProperties.atom.y, { digitCount: 3, encoder: E.fixedPoint3 }).float("Cartn_z", StructureProperties.atom.z, { digitCount: 3, encoder: E.fixedPoint3 }).float("occupancy", StructureProperties.atom.occupancy, { digitCount: 2, encoder: E.fixedPoint2 }).float("B_iso_or_equiv", StructureProperties.atom.B_iso_or_equiv, { digitCount: 2, encoder: E.fixedPoint2 }).int("pdbx_formal_charge", StructureProperties.atom.pdbx_formal_charge, {
    encoder: E.deltaRLE,
    valueKind: (k, d) => k.unit.model.atomicHierarchy.atoms.pdbx_formal_charge.valueKind(k.element)
  }).str("auth_atom_id", StructureProperties.atom.auth_atom_id).str("auth_comp_id", StructureProperties.atom.auth_comp_id).int("auth_seq_id", StructureProperties.residue.auth_seq_id, { encoder: E.deltaRLE }).str("auth_asym_id", atom_site_auth_asym_id).int("pdbx_PDB_model_num", StructureProperties.unit.model_num, { encoder: E.deltaRLE }).int("pdbx_label_index", atom_site_pdbx_label_index.value, { shouldInclude: atom_site_pdbx_label_index.shouldInclude }).str("pdbx_sifts_xref_db_name", SIFTS.pdbx_sifts_xref_db_name.value, { shouldInclude: SIFTS.shouldInclude, valueKind: SIFTS.pdbx_sifts_xref_db_name.valueKind }).str("pdbx_sifts_xref_db_acc", SIFTS.pdbx_sifts_xref_db_acc.value, { shouldInclude: SIFTS.shouldInclude, valueKind: SIFTS.pdbx_sifts_xref_db_acc.valueKind }).str("pdbx_sifts_xref_db_num", SIFTS.pdbx_sifts_xref_db_num.value, { shouldInclude: SIFTS.shouldInclude, valueKind: SIFTS.pdbx_sifts_xref_db_num.valueKind }).str("pdbx_sifts_xref_db_res", SIFTS.pdbx_sifts_xref_db_res.value, { shouldInclude: SIFTS.shouldInclude, valueKind: SIFTS.pdbx_sifts_xref_db_res.valueKind });
  return fields.getFields();
};
var _atom_site = (options) => ({
  name: "atom_site",
  instance({ structures }) {
    return {
      fields: atom_site_fields(options === null || options === void 0 ? void 0 : options.keepId),
      source: structures.map((s) => ({
        data: {
          structure: s,
          sourceIndex: s.model.atomicHierarchy.atomSourceIndex,
          atom_site: MmcifFormat.is(s.model.sourceData) ? s.model.sourceData.data.db.atom_site : void 0
        },
        rowCount: s.elementCount,
        keys: () => s.elementLocations()
      }))
    };
  }
});
function prepostfixed(prefix, name) {
  if (prefix)
    return `${prefix}_${name}`;
  return name;
}
function prefixedInsCode(prefix) {
  if (!prefix)
    return "pdbx_PDB_ins_code";
  return `pdbx_${prefix}_PDB_ins_code`;
}
function mappedProp(loc, prop) {
  return (k, d) => prop(loc(k, d));
}
function addModelNum(fields, getLocation, options) {
  if (options && options.includeModelNum) {
    fields.int("pdbx_PDB_model_num", mappedProp(getLocation, StructureProperties.unit.model_num));
  }
}
function residueIdFields(getLocation, options) {
  const prefix = options && options.prefix;
  const ret = CifWriter.fields().str(prepostfixed(prefix, `label_comp_id`), mappedProp(getLocation, StructureProperties.atom.label_comp_id)).int(prepostfixed(prefix, `label_seq_id`), mappedProp(getLocation, StructureProperties.residue.label_seq_id), {
    encoder: E.deltaRLE,
    valueKind: (k, d) => {
      const e = getLocation(k, d);
      const m = e.unit.model;
      return m.atomicHierarchy.residues.label_seq_id.valueKind(m.atomicHierarchy.residueAtomSegments.index[e.element]);
    }
  }).str(prefixedInsCode(prefix), mappedProp(getLocation, StructureProperties.residue.pdbx_PDB_ins_code)).str(prepostfixed(prefix, `label_asym_id`), mappedProp(getLocation, StructureProperties.chain.label_asym_id)).str(prepostfixed(prefix, `label_entity_id`), mappedProp(getLocation, StructureProperties.chain.label_entity_id)).str(prepostfixed(prefix, `auth_comp_id`), mappedProp(getLocation, StructureProperties.atom.auth_comp_id)).int(prepostfixed(prefix, `auth_seq_id`), mappedProp(getLocation, StructureProperties.residue.auth_seq_id), { encoder: E.deltaRLE }).str(prepostfixed(prefix, `auth_asym_id`), mappedProp(getLocation, StructureProperties.chain.auth_asym_id));
  addModelNum(ret, getLocation, options);
  return ret.getFields();
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/export/categories/secondary-structure.js
var CifField3 = CifWriter.Field;
var _struct_conf = {
  name: "struct_conf",
  instance(ctx) {
    const elements = findElements(ctx, "helix");
    return {
      fields: struct_conf_fields(),
      source: [{ data: elements, rowCount: elements.length }]
    };
  }
};
var _struct_sheet_range = {
  name: "struct_sheet_range",
  instance(ctx) {
    const elements = findElements(ctx, "sheet").sort(compare_ssr);
    return {
      fields: struct_sheet_range_fields(),
      source: [{ data: elements, rowCount: elements.length }]
    };
  }
};
function compare_ssr(x, y) {
  const a = x.element, b = y.element;
  return a.sheet_id < b.sheet_id ? -1 : a.sheet_id === b.sheet_id ? x.start.element - y.start.element : 1;
}
var struct_conf_fields = () => [
  CifField3.str("conf_type_id", (i, data) => data[i].element.type_id),
  CifField3.str("id", (i, data, idx) => `${data[i].element.type_id}${idx + 1}`),
  ...residueIdFields((i, e) => e[i].start, { prefix: "beg" }),
  ...residueIdFields((i, e) => e[i].end, { prefix: "end" }),
  CifField3.str("pdbx_PDB_helix_class", (i, data) => data[i].element.helix_class),
  CifField3.str("details", (i, data) => data[i].element.details || "", {
    valueKind: (i, d) => !!d[i].element.details ? Column.ValueKinds.Present : Column.ValueKinds.Unknown
  }),
  CifField3.int("pdbx_PDB_helix_length", (i, data) => data[i].length)
];
var struct_sheet_range_fields = () => [
  CifField3.str("sheet_id", (i, data) => data[i].element.sheet_id),
  CifField3.index("id"),
  ...residueIdFields((i, e) => e[i].start, { prefix: "beg" }),
  ...residueIdFields((i, e) => e[i].end, { prefix: "end" }),
  CifField3.str("symmetry", (i, data) => "", { valueKind: (i, d) => Column.ValueKinds.Unknown })
];
function findElements(ctx, kind) {
  const secondaryStructure = ModelSecondaryStructure.Provider.get(ctx.firstModel);
  if (!secondaryStructure)
    return [];
  const { key, elements } = secondaryStructure;
  const ssElements = [];
  const structure = ctx.structures[0];
  for (const { units } of structure.unitSymmetryGroups) {
    const u = units[0];
    if (!Unit.isAtomic(u))
      continue;
    const segs = u.model.atomicHierarchy.residueAtomSegments;
    const residues2 = Segmentation.transientSegments(segs, u.elements);
    let current, move = true;
    while (residues2.hasNext) {
      if (move)
        current = residues2.move();
      const start = current.index;
      const startIdx = key[start];
      const element = elements[startIdx];
      if (element.kind !== kind) {
        move = true;
        continue;
      }
      let prev = start;
      while (residues2.hasNext) {
        prev = current.index;
        current = residues2.move();
        if (startIdx !== key[current.index]) {
          move = false;
          ssElements[ssElements.length] = {
            start: element_exports.Location.create(structure, u, segs.offsets[start]),
            end: element_exports.Location.create(structure, u, segs.offsets[prev]),
            length: prev - start + 1,
            element
          };
          break;
        }
      }
    }
  }
  return ssElements;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/export/categories/utils.js
function getModelMmCifCategory(model, name) {
  if (!MmcifFormat.is(model.sourceData))
    return;
  return model.sourceData.data.db[name];
}
function getUniqueResidueNamesFromStructures(structures) {
  return SetUtils.unionMany(...structures.map((s) => s.uniqueResidueNames));
}
function getUniqueEntityIdsFromStructures(structures) {
  if (structures.length === 0)
    return /* @__PURE__ */ new Set();
  const names = structures[0].model.entities.data.id;
  return new Set(getUniqueEntityIndicesFromStructures(structures).map((i) => names.value(i)));
}
function getUniqueEntityIndicesFromStructures(structures) {
  if (structures.length === 0)
    return [];
  if (structures.length === 1)
    return structures[0].entityIndices;
  const ret = UniqueArray.create();
  for (const s of structures) {
    for (const e of s.entityIndices) {
      UniqueArray.add(ret, e, e);
    }
  }
  sortArray(ret.array);
  return ret.array;
}
function copy_mmCif_category(name, condition) {
  return {
    name,
    instance({ structures }) {
      if (condition && !condition(structures[0]))
        return CifWriter.Category.Empty;
      const model = structures[0].model;
      if (!MmcifFormat.is(model.sourceData))
        return CifWriter.Category.Empty;
      const table = model.sourceData.data.db[name];
      if (!table || !table._rowCount)
        return CifWriter.Category.Empty;
      return CifWriter.Category.ofTable(table);
    }
  };
}
function copy_source_mmCifCategory(encoder, ctx, category) {
  if (!MmcifFormat.is(ctx.firstModel.sourceData))
    return;
  const fs = CifWriter.fields();
  if (encoder.isBinary) {
    for (const f of category.fieldNames) {
      const field = classifyField(f, category.getField(f));
      fs.add(field);
    }
  } else {
    for (const f of category.fieldNames) {
      const field = category.getField(f);
      fs.str(f, (row) => field.str(row));
    }
  }
  const fields = fs.getFields();
  return {
    name: category.name,
    instance() {
      return { fields, source: [{ data: void 0, rowCount: category.rowCount }] };
    }
  };
}
function classifyField(name, field) {
  const type3 = getCifFieldType(field);
  if (type3["@type"] === "str") {
    return { name, type: CifWriter.Field.Type.Str, value: field.str, valueKind: field.valueKind };
  } else if (type3["@type"] === "float") {
    return CifWriter.Field.float(name, field.float, { valueKind: field.valueKind, typedArray: Float64Array });
  } else {
    return CifWriter.Field.int(name, field.int, { valueKind: field.valueKind, typedArray: Int32Array });
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/export/categories/misc.js
var CifCategory2 = CifWriter.Category;
var _chem_comp = {
  name: "chem_comp",
  instance({ firstModel, structures, cache }) {
    const chem_comp = getModelMmCifCategory(structures[0].model, "chem_comp");
    if (!chem_comp)
      return CifCategory2.Empty;
    const { id } = chem_comp;
    const names = cache.uniqueResidueNames || (cache.uniqueResidueNames = getUniqueResidueNamesFromStructures(structures));
    const indices = Column.indicesOf(id, (id2) => names.has(id2));
    return CifCategory2.ofTable(chem_comp, indices);
  }
};
var _chem_comp_bond = {
  name: "chem_comp_bond",
  instance({ firstModel, structures, cache }) {
    const chem_comp_bond = getModelMmCifCategory(structures[0].model, "chem_comp_bond");
    if (!chem_comp_bond)
      return CifCategory2.Empty;
    const { comp_id } = chem_comp_bond;
    const names = cache.uniqueResidueNames || (cache.uniqueResidueNames = getUniqueResidueNamesFromStructures(structures));
    const indices = Column.indicesOf(comp_id, (id) => names.has(id));
    return CifCategory2.ofTable(chem_comp_bond, indices);
  }
};
var _pdbx_chem_comp_identifier = {
  name: "pdbx_chem_comp_identifier",
  instance({ firstModel, structures, cache }) {
    const pdbx_chem_comp_identifier = getModelMmCifCategory(firstModel, "pdbx_chem_comp_identifier");
    if (!pdbx_chem_comp_identifier)
      return CifCategory2.Empty;
    const { comp_id } = pdbx_chem_comp_identifier;
    const names = cache.uniqueResidueNames || (cache.uniqueResidueNames = getUniqueResidueNamesFromStructures(structures));
    const indices = Column.indicesOf(comp_id, (id) => names.has(id));
    return CifCategory2.ofTable(pdbx_chem_comp_identifier, indices);
  }
};
var _pdbx_nonpoly_scheme = {
  name: "pdbx_nonpoly_scheme",
  instance({ firstModel, structures, cache }) {
    const pdbx_nonpoly_scheme = getModelMmCifCategory(firstModel, "pdbx_nonpoly_scheme");
    if (!pdbx_nonpoly_scheme)
      return CifCategory2.Empty;
    return CifCategory2.ofTable(pdbx_nonpoly_scheme);
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/export/categories/sequence.js
var CifCategory3 = CifWriter.Category;
var _struct_asym = createCategory("struct_asym");
var _entity_poly = createCategory("entity_poly");
var _entity_poly_seq = createCategory("entity_poly_seq");
function createCategory(categoryName) {
  return {
    name: categoryName,
    instance({ structures, cache }) {
      return getCategoryInstance(structures, categoryName, cache);
    }
  };
}
function getCategoryInstance(structures, categoryName, cache) {
  const category = getModelMmCifCategory(structures[0].model, categoryName);
  if (!category)
    return CifCategory3.Empty;
  const { entity_id } = category;
  const names = cache.uniqueEntityIds || (cache.uniqueEntityIds = getUniqueEntityIdsFromStructures(structures));
  const indices = Column.indicesOf(entity_id, (id) => names.has(id));
  return CifCategory3.ofTable(category, indices);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/export/mmcif.js
var CifCategory4 = CifWriter.Category;
var CifExportContext;
(function(CifExportContext2) {
  function create(structures) {
    const structureArray = Array.isArray(structures) ? structures : [structures];
    return {
      structures: structureArray,
      firstModel: structureArray[0].model,
      cache: /* @__PURE__ */ Object.create(null)
    };
  }
  CifExportContext2.create = create;
})(CifExportContext || (CifExportContext = {}));
var _entity = {
  name: "entity",
  instance({ structures }) {
    const indices = getUniqueEntityIndicesFromStructures(structures);
    return CifCategory4.ofTable(structures[0].model.entities.data, indices);
  }
};
function isWithoutSymmetry(structure) {
  return structure.units.every((u) => u.conformation.operator.isIdentity);
}
function isWithoutOperator(structure) {
  return isWithoutSymmetry(structure) && structure.units.every((u) => !u.conformation.operator.assembly && !u.conformation.operator.suffix);
}
var Categories = (options) => [
  // Basics
  copy_mmCif_category("entry"),
  copy_mmCif_category("exptl"),
  _entity,
  // Symmetry
  copy_mmCif_category("cell", isWithoutSymmetry),
  copy_mmCif_category("symmetry", isWithoutSymmetry),
  // Assemblies
  copy_mmCif_category("pdbx_struct_assembly", isWithoutOperator),
  copy_mmCif_category("pdbx_struct_assembly_gen", isWithoutOperator),
  copy_mmCif_category("pdbx_struct_oper_list", isWithoutOperator),
  // Secondary structure
  _struct_conf,
  _struct_sheet_range,
  // Sequence
  _struct_asym,
  _entity_poly,
  _entity_poly_seq,
  // Branch
  copy_mmCif_category("pdbx_entity_branch"),
  copy_mmCif_category("pdbx_entity_branch_link"),
  copy_mmCif_category("pdbx_branch_scheme"),
  // Struct conn
  copy_mmCif_category("struct_conn"),
  // Misc
  _chem_comp,
  _chem_comp_bond,
  _pdbx_chem_comp_identifier,
  copy_mmCif_category("atom_sites"),
  _pdbx_nonpoly_scheme,
  // Atoms
  _atom_site({ keepId: options === null || options === void 0 ? void 0 : options.keepAtomSiteId })
];
var _Filters;
(function(_Filters2) {
  _Filters2.AtomSitePositionsFieldNames = /* @__PURE__ */ new Set(["id", "Cartn_x", "Cartn_y", "Cartn_z"]);
})(_Filters || (_Filters = {}));
var mmCIF_Export_Filters = {
  onlyPositions: {
    includeCategory(name) {
      return name === "atom_site";
    },
    includeField(cat, field) {
      return _Filters.AtomSitePositionsFieldNames.has(field);
    }
  }
};
function getCustomPropCategories(customProp, ctx, params) {
  var _a;
  if (!customProp.cifExport || customProp.cifExport.categories.length === 0)
    return [];
  const prefix = customProp.cifExport.prefix;
  const cats = customProp.cifExport.categories;
  let propCtx = ctx;
  if (customProp.cifExport.context) {
    const propId = CustomPropertyDescriptor.getUUID(customProp);
    if (ctx.cache[propId + "__ctx"])
      propCtx = ctx.cache[propId + "__ctx"];
    else {
      propCtx = customProp.cifExport.context(ctx) || ctx;
      ctx.cache[propId + "__ctx"] = propCtx;
    }
  }
  const ret = [];
  for (const cat of cats) {
    if ((_a = params === null || params === void 0 ? void 0 : params.skipCategoryNames) === null || _a === void 0 ? void 0 : _a.has(cat.name))
      continue;
    if ((params === null || params === void 0 ? void 0 : params.includedCategoryNames) && !params.includedCategoryNames.has(cat.name))
      continue;
    if (cat.name.indexOf(prefix) !== 0)
      throw new Error(`Custom category '${cat.name}' name must start with prefix '${prefix}.'`);
    ret.push([cat, propCtx]);
  }
  return ret;
}
function encode_mmCIF_categories(encoder, structures, params) {
  const first2 = Array.isArray(structures) ? structures[0] : structures;
  const models = first2.models;
  if (models.length !== 1)
    throw new Error("Can't export stucture composed from multiple models.");
  const ctx = (params === null || params === void 0 ? void 0 : params.exportCtx) || CifExportContext.create(structures);
  if ((params === null || params === void 0 ? void 0 : params.copyAllCategories) && MmcifFormat.is(models[0].sourceData)) {
    encode_mmCIF_categories_copyAll(encoder, ctx, params);
  } else {
    encode_mmCIF_categories_default(encoder, ctx, params);
  }
}
function encode_mmCIF_categories_default(encoder, ctx, params) {
  var _a, _b, _c;
  for (const cat of Categories({
    keepAtomSiteId: ((_a = params === null || params === void 0 ? void 0 : params.extensions) === null || _a === void 0 ? void 0 : _a.molstar_bond_site) || (params === null || params === void 0 ? void 0 : params.doNotReindexAtomSiteId)
  })) {
    if ((params === null || params === void 0 ? void 0 : params.skipCategoryNames) && (params === null || params === void 0 ? void 0 : params.skipCategoryNames.has(cat.name)))
      continue;
    if ((params === null || params === void 0 ? void 0 : params.includedCategoryNames) && !params.includedCategoryNames.has(cat.name))
      continue;
    encoder.writeCategory(cat, ctx);
  }
  if (!((_b = params === null || params === void 0 ? void 0 : params.skipCategoryNames) === null || _b === void 0 ? void 0 : _b.has("atom_site")) && encoder.isCategoryIncluded("atom_site")) {
    const info = atom_site_operator_mapping(ctx);
    if (info)
      encoder.writeCategory(info[0], info[1], info[2]);
  }
  if ((_c = params === null || params === void 0 ? void 0 : params.extensions) === null || _c === void 0 ? void 0 : _c.molstar_bond_site) {
    const info = molstar_bond_site(ctx);
    if (info)
      encoder.writeCategory(info[0], info[1], info[2]);
  }
  const _params = params || {};
  for (const customProp of ctx.firstModel.customProperties.all) {
    for (const [cat, propCtx] of getCustomPropCategories(customProp, ctx, _params)) {
      encoder.writeCategory(cat, propCtx);
    }
  }
  if (params === null || params === void 0 ? void 0 : params.customProperties) {
    for (const customProp of params === null || params === void 0 ? void 0 : params.customProperties) {
      for (const [cat, propCtx] of getCustomPropCategories(customProp, ctx, _params)) {
        encoder.writeCategory(cat, propCtx);
      }
    }
  }
  for (const s of ctx.structures) {
    if (!s.hasCustomProperties)
      continue;
    for (const customProp of s.customPropertyDescriptors.all) {
      for (const [cat, propCtx] of getCustomPropCategories(customProp, ctx, _params)) {
        encoder.writeCategory(cat, propCtx);
      }
    }
  }
}
function encode_mmCIF_categories_copyAll(encoder, ctx, params) {
  var _a, _b;
  const providedCategories = /* @__PURE__ */ new Map();
  for (const cat of Categories({
    keepAtomSiteId: ((_a = params === null || params === void 0 ? void 0 : params.extensions) === null || _a === void 0 ? void 0 : _a.molstar_bond_site) || (params === null || params === void 0 ? void 0 : params.doNotReindexAtomSiteId)
  })) {
    providedCategories.set(cat.name, [cat, ctx]);
  }
  const mapping = atom_site_operator_mapping(ctx);
  if (mapping)
    providedCategories.set(mapping[0].name, mapping);
  const _params = params || {};
  for (const customProp of ctx.firstModel.customProperties.all) {
    for (const info of getCustomPropCategories(customProp, ctx, _params)) {
      providedCategories.set(info[0].name, info);
    }
  }
  if (params === null || params === void 0 ? void 0 : params.customProperties) {
    for (const customProp of params === null || params === void 0 ? void 0 : params.customProperties) {
      for (const info of getCustomPropCategories(customProp, ctx, _params)) {
        providedCategories.set(info[0].name, info);
      }
    }
  }
  for (const s of ctx.structures) {
    if (!s.hasCustomProperties)
      continue;
    for (const customProp of s.customPropertyDescriptors.all) {
      for (const info of getCustomPropCategories(customProp, ctx)) {
        providedCategories.set(info[0].name, info);
      }
    }
  }
  const handled = /* @__PURE__ */ new Set();
  const data = ctx.firstModel.sourceData.data;
  for (const catName of data.frame.categoryNames) {
    handled.add(catName);
    if (providedCategories.has(catName)) {
      const info = providedCategories.get(catName);
      encoder.writeCategory(info[0], info[1], info[2]);
    } else {
      if (data.db[catName]) {
        const cat = copy_mmCif_category(catName);
        encoder.writeCategory(cat, ctx);
      } else {
        const cat = copy_source_mmCifCategory(encoder, ctx, data.frame.categories[catName]);
        if (cat)
          encoder.writeCategory(cat);
      }
    }
  }
  providedCategories.forEach((info, name) => {
    if (!handled.has(name))
      encoder.writeCategory(info[0], info[1], info[2]);
  });
  if ((_b = params === null || params === void 0 ? void 0 : params.extensions) === null || _b === void 0 ? void 0 : _b.molstar_bond_site) {
    const info = molstar_bond_site(ctx);
    if (info)
      encoder.writeCategory(info[0], info[1], info[2]);
  }
}
function to_mmCIF(name, structure, asBinary = false, params) {
  var _a;
  const enc = (_a = params === null || params === void 0 ? void 0 : params.encoder) !== null && _a !== void 0 ? _a : CifWriter.createEncoder({ binary: asBinary });
  enc.startDataBlock(name);
  encode_mmCIF_categories(enc, structure, params);
  return enc.getData();
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/export/categories/atom_site_operator_mapping.js
function atom_site_operator_mapping(ctx) {
  const entries = getEntries2(ctx);
  if (entries.length === 0)
    return;
  return [Category4, entries, { ignoreFilter: true }];
}
var AtomSiteOperatorMappingSchema = {
  molstar_atom_site_operator_mapping: {
    label_asym_id: Column.Schema.Str(),
    auth_asym_id: Column.Schema.Str(),
    operator_name: Column.Schema.Str(),
    suffix: Column.Schema.Str(),
    // assembly
    assembly_id: Column.Schema.Str(),
    assembly_operator_id: Column.Schema.Int(),
    // symmetry
    symmetry_operator_index: Column.Schema.Int(),
    symmetry_hkl: Column.Schema.Vector(3),
    // NCS
    ncs_id: Column.Schema.Int()
  }
};
var asmValueKind = (i, xs) => typeof xs[i].operator.assembly === "undefined" ? Column.ValueKinds.NotPresent : Column.ValueKinds.Present;
var symmetryValueKind = (i, xs) => xs[i].operator.spgrOp === -1 ? Column.ValueKinds.NotPresent : Column.ValueKinds.Present;
var Fields2 = CifWriter.fields().str("label_asym_id", (i, xs) => xs[i].label_asym_id).str("auth_asym_id", (i, xs) => xs[i].auth_asym_id).str("operator_name", (i, xs) => xs[i].operator.name).str("suffix", (i, xs) => xs[i].operator.suffix).str("assembly_id", (i, xs) => {
  var _a;
  return ((_a = xs[i].operator.assembly) === null || _a === void 0 ? void 0 : _a.id) || "";
}, { valueKind: asmValueKind }).int("assembly_operator_id", (i, xs) => {
  var _a;
  return ((_a = xs[i].operator.assembly) === null || _a === void 0 ? void 0 : _a.operId) || 0;
}, { valueKind: asmValueKind }).int("symmetry_operator_index", (i, xs) => xs[i].operator.spgrOp, { valueKind: symmetryValueKind }).vec("symmetry_hkl", [(i, xs) => xs[i].operator.hkl[0], (i, xs) => xs[i].operator.hkl[1], (i, xs) => xs[i].operator.hkl[2]], { valueKind: symmetryValueKind }).int("ncs_id", (i, xs) => xs[i].operator.ncsId, { valueKind: symmetryValueKind }).getFields();
var Category4 = {
  name: "molstar_atom_site_operator_mapping",
  instance(entries) {
    return { fields: Fields2, source: [{ data: entries, rowCount: entries.length }] };
  }
};
function getEntries2(ctx) {
  const existing = /* @__PURE__ */ new Set();
  const entries = [];
  for (const s of ctx.structures) {
    const l = element_exports.Location.create(s);
    for (const unit2 of s.units) {
      const operator = unit2.conformation.operator;
      if (!operator.suffix || unit2.kind !== Unit.Kind.Atomic)
        continue;
      l.unit = unit2;
      const { elements } = unit2;
      const chainsIt = Segmentation.transientSegments(unit2.model.atomicHierarchy.chainAtomSegments, elements);
      while (chainsIt.hasNext) {
        const chainSegment = chainsIt.move();
        l.element = elements[chainSegment.start];
        const label_asym_id = StructureProperties.chain.label_asym_id(l);
        const key = `${label_asym_id}${operator.suffix}`;
        if (existing.has(key))
          continue;
        existing.add(key);
        const auth_asym_id = StructureProperties.chain.label_asym_id(l);
        entries.push({ label_asym_id, auth_asym_id, operator });
      }
    }
  }
  return entries;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/utils/atomic-derived.js
function getAtomicDerivedData(data, segments, index, chemicalComponentMap) {
  const { label_comp_id, type_symbol, _rowCount: atomCount2 } = data.atoms;
  const { _rowCount: residueCount } = data.residues;
  const { offsets } = segments.residueAtomSegments;
  const atomicNumber = new Uint8Array(atomCount2);
  for (let i = 0; i < atomCount2; ++i) {
    atomicNumber[i] = AtomNumber(type_symbol.value(i));
  }
  const traceElementIndex = new Int32Array(residueCount);
  const directionFromElementIndex = new Int32Array(residueCount);
  const directionToElementIndex = new Int32Array(residueCount);
  const moleculeType = new Uint8Array(residueCount);
  const polymerType = new Uint8Array(residueCount);
  const moleculeTypeMap = /* @__PURE__ */ new Map();
  const polymerTypeMap = /* @__PURE__ */ new Map();
  for (let i = 0; i < residueCount; ++i) {
    const compId2 = label_comp_id.value(offsets[i]);
    const chemCompMap = chemicalComponentMap;
    let molType;
    let polyType;
    if (moleculeTypeMap.has(compId2)) {
      molType = moleculeTypeMap.get(compId2);
      polyType = polymerTypeMap.get(compId2);
    } else {
      let type3;
      if (chemCompMap.has(compId2)) {
        type3 = chemCompMap.get(compId2).type;
      } else {
        if (!isProductionMode)
          console.info("chemComp not found", compId2);
        type3 = getComponentType(compId2);
      }
      molType = getMoleculeType(type3, compId2);
      polyType = getPolymerType(type3, molType);
      moleculeTypeMap.set(compId2, molType);
      polymerTypeMap.set(compId2, polyType);
    }
    moleculeType[i] = molType;
    polymerType[i] = polyType;
    const traceAtomId = getAtomIdForAtomRole(polyType, "trace");
    let traceIndex = index.findAtomsOnResidue(i, traceAtomId);
    if (traceIndex === -1) {
      const coarseAtomId = getAtomIdForAtomRole(polyType, "coarseBackbone");
      traceIndex = index.findAtomsOnResidue(i, coarseAtomId);
      if (traceIndex === -1 && isPolymer(molType)) {
        traceIndex = index.findElementOnResidue(i, ElementSymbol("C"));
      }
    }
    traceElementIndex[i] = traceIndex;
    const directionFromAtomId = getAtomIdForAtomRole(polyType, "directionFrom");
    directionFromElementIndex[i] = index.findAtomsOnResidue(i, directionFromAtomId);
    const directionToAtomId = getAtomIdForAtomRole(polyType, "directionTo");
    directionToElementIndex[i] = index.findAtomsOnResidue(i, directionToAtomId);
  }
  return {
    atom: {
      atomicNumber
    },
    residue: {
      traceElementIndex,
      directionFromElementIndex,
      directionToElementIndex,
      moleculeType,
      polymerType
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/utils/atomic-index.js
function getResidueId(seq_id, ins_code) {
  if (!ins_code)
    return seq_id;
  if (ins_code.length === 1)
    return cantorPairing(ins_code.charCodeAt(0), seq_id);
  if (ins_code.length === 2)
    return cantorPairing(ins_code.charCodeAt(0), cantorPairing(ins_code.charCodeAt(1), seq_id));
  return `${seq_id} ${ins_code}`;
}
function updateMapMapIndex(map2, key0, key1, index) {
  if (map2.has(key0)) {
    const submap = map2.get(key0);
    if (!submap.has(key1)) {
      submap.set(key1, index);
    }
  } else {
    const submap = /* @__PURE__ */ new Map();
    map2.set(key0, submap);
    submap.set(key1, index);
  }
}
function missingEntity(k) {
  throw new Error(`Missing entity entry for entity id '${k}'.`);
}
function createMapping(entities, data, segments) {
  return {
    entities,
    segments,
    label_seq_id: SortedArray.ofSortedArray(data.residues.label_seq_id.toArray({ array: Int32Array })),
    label_atom_id: data.atoms.label_atom_id,
    auth_atom_id: data.atoms.auth_atom_id,
    label_alt_id: data.atoms.label_alt_id,
    type_symbol: data.atoms.type_symbol,
    chain_index_entity_index: new Int32Array(data.chains._rowCount),
    entity_index_label_asym_id: /* @__PURE__ */ new Map(),
    chain_index_label_seq_id: /* @__PURE__ */ new Map(),
    auth_asym_id_auth_seq_id: /* @__PURE__ */ new Map(),
    chain_index_auth_seq_id: /* @__PURE__ */ new Map(),
    label_asym_id: /* @__PURE__ */ new Map()
  };
}
var _tempResidueKey = AtomicIndex.EmptyResidueKey();
var Index = class {
  getEntityFromChain(cI) {
    return this.map.chain_index_entity_index[cI];
  }
  findEntity(label_asym_id) {
    const entityIndex2 = this.map.label_asym_id.get(label_asym_id);
    return entityIndex2 !== void 0 ? entityIndex2 : -1;
  }
  findChainLabel(key) {
    const eI = this.entityIndex(key.label_entity_id);
    if (eI < 0 || !this.map.entity_index_label_asym_id.has(eI))
      return -1;
    const cm = this.map.entity_index_label_asym_id.get(eI);
    if (!cm)
      return -1;
    return cm.has(key.label_asym_id) ? cm.get(key.label_asym_id) : -1;
  }
  findChainAuth(key) {
    if (!this.map.auth_asym_id_auth_seq_id.has(key.auth_asym_id))
      return -1;
    const rm = this.map.auth_asym_id_auth_seq_id.get(key.auth_asym_id);
    return rm.has(key.auth_seq_id) ? rm.get(key.auth_seq_id) : -1;
  }
  findResidue(label_entity_id_or_key, label_asym_id, auth_seq_id, pdbx_PDB_ins_code) {
    let key;
    if (arguments.length === 1) {
      key = label_entity_id_or_key;
    } else {
      _tempResidueKey.label_entity_id = label_entity_id_or_key;
      _tempResidueKey.label_asym_id = label_asym_id;
      _tempResidueKey.auth_seq_id = auth_seq_id;
      _tempResidueKey.pdbx_PDB_ins_code = pdbx_PDB_ins_code;
      key = _tempResidueKey;
    }
    const cI = this.findChainLabel(key);
    if (cI < 0)
      return -1;
    const rm = this.map.chain_index_auth_seq_id.get(cI);
    const id = getResidueId(key.auth_seq_id, key.pdbx_PDB_ins_code || "");
    return rm.has(id) ? rm.get(id) : -1;
  }
  findResidueLabel(key) {
    const cI = this.findChainLabel(key);
    if (cI < 0)
      return -1;
    const rm = this.map.chain_index_label_seq_id.get(cI);
    const id = getResidueId(key.label_seq_id, key.pdbx_PDB_ins_code || "");
    return rm.has(id) ? rm.get(id) : -1;
  }
  findResidueAuth(key) {
    const cI = this.findChainAuth(key);
    if (cI < 0)
      return -1;
    const rm = this.map.chain_index_auth_seq_id.get(cI);
    const id = getResidueId(key.auth_seq_id, key.pdbx_PDB_ins_code || "");
    return rm.has(id) ? rm.get(id) : -1;
  }
  findResidueInsertion(key) {
    const cI = this.findChainLabel(key);
    if (cI < 0)
      return -1;
    const rm = this.map.chain_index_label_seq_id.get(cI);
    const id = getResidueId(key.label_seq_id, key.pdbx_PDB_ins_code || "");
    if (rm.has(id))
      return rm.get(id);
    const idx = SortedArray.findPredecessorIndex(this.map.label_seq_id, key.label_seq_id);
    const start = AtomicHierarchy.chainStartResidueIndex(this.map.segments, cI);
    if (idx < start)
      return start;
    const end = AtomicHierarchy.chainEndResidueIndexExcl(this.map.segments, cI) - 1;
    if (idx >= end)
      return end;
    return idx;
  }
  findAtom(key) {
    const rI = this.findResidue(key);
    if (rI < 0)
      return -1;
    if (typeof key.label_alt_id === "undefined") {
      return findAtomByName(this.residueOffsets[rI], this.residueOffsets[rI + 1], this.map.label_atom_id, key.label_atom_id);
    }
    return findAtomByNameAndAltLoc(this.residueOffsets[rI], this.residueOffsets[rI + 1], this.map.label_atom_id, this.map.label_alt_id, key.label_atom_id, key.label_alt_id);
  }
  findAtomAuth(key) {
    const rI = this.findResidueAuth(key);
    if (rI < 0)
      return -1;
    if (typeof key.label_alt_id === "undefined") {
      return findAtomByName(this.residueOffsets[rI], this.residueOffsets[rI + 1], this.map.auth_atom_id, key.auth_atom_id);
    }
    return findAtomByNameAndAltLoc(this.residueOffsets[rI], this.residueOffsets[rI + 1], this.map.auth_atom_id, this.map.label_alt_id, key.auth_atom_id, key.label_alt_id);
  }
  findAtomOnResidue(rI, label_atom_id, label_alt_id) {
    if (typeof label_alt_id === "undefined") {
      return findAtomByName(this.residueOffsets[rI], this.residueOffsets[rI + 1], this.map.label_atom_id, label_atom_id);
    }
    return findAtomByNameAndAltLoc(this.residueOffsets[rI], this.residueOffsets[rI + 1], this.map.label_atom_id, this.map.label_alt_id, label_atom_id, label_alt_id);
  }
  findAtomsOnResidue(rI, label_atom_ids) {
    return findAtomByNames(this.residueOffsets[rI], this.residueOffsets[rI + 1], this.map.label_atom_id, label_atom_ids);
  }
  findElementOnResidue(rI, type_symbol) {
    return findAtomByElement(this.residueOffsets[rI], this.residueOffsets[rI + 1], this.map.type_symbol, type_symbol);
  }
  constructor(map2) {
    this.map = map2;
    this.entityIndex = map2.entities.getEntityIndex;
    this.residueOffsets = this.map.segments.residueAtomSegments.offsets;
  }
};
function findAtomByName(start, end, data, atomName) {
  for (let i = start; i < end; i++) {
    if (data.value(i) === atomName)
      return i;
  }
  return -1;
}
function findAtomByNames(start, end, data, atomNames) {
  for (let i = start; i < end; i++) {
    if (atomNames.has(data.value(i)))
      return i;
  }
  return -1;
}
function findAtomByNameAndAltLoc(start, end, nameData, altLocData, atomName, altLoc) {
  for (let i = start; i < end; i++) {
    if (nameData.value(i) === atomName && altLocData.value(i) === altLoc)
      return i;
  }
  return -1;
}
function findAtomByElement(start, end, data, typeSymbol) {
  for (let i = start; i < end; i++) {
    if (data.value(i) === typeSymbol)
      return i;
  }
  return -1;
}
function getAtomicIndex(data, entities, segments) {
  const map2 = createMapping(entities, data, segments);
  const { label_seq_id, auth_seq_id, pdbx_PDB_ins_code } = data.residues;
  const { label_entity_id, label_asym_id, auth_asym_id } = data.chains;
  const atomSet2 = Interval.ofBounds(0, data.atoms._rowCount);
  const chainsIt = Segmentation.transientSegments(segments.chainAtomSegments, atomSet2);
  while (chainsIt.hasNext) {
    const chainSegment = chainsIt.move();
    const chainIndex2 = chainSegment.index;
    const entityIndex2 = entities.getEntityIndex(label_entity_id.value(chainIndex2));
    if (entityIndex2 < 0)
      missingEntity(label_entity_id.value(chainIndex2));
    map2.chain_index_entity_index[chainIndex2] = entityIndex2;
    const authAsymId = auth_asym_id.value(chainIndex2);
    let auth_asym_id_auth_seq_id = map2.auth_asym_id_auth_seq_id.get(authAsymId);
    if (!auth_asym_id_auth_seq_id) {
      auth_asym_id_auth_seq_id = /* @__PURE__ */ new Map();
      map2.auth_asym_id_auth_seq_id.set(authAsymId, auth_asym_id_auth_seq_id);
    }
    const labelAsymId = label_asym_id.value(chainIndex2);
    if (!map2.label_asym_id.has(labelAsymId))
      map2.label_asym_id.set(labelAsymId, entityIndex2);
    updateMapMapIndex(map2.entity_index_label_asym_id, entityIndex2, labelAsymId, chainIndex2);
    const chain_index_label_seq_id = /* @__PURE__ */ new Map();
    const chain_index_auth_seq_id = /* @__PURE__ */ new Map();
    map2.chain_index_label_seq_id.set(chainIndex2, chain_index_label_seq_id);
    map2.chain_index_auth_seq_id.set(chainIndex2, chain_index_auth_seq_id);
    const residuesIt = Segmentation.transientSegments(segments.residueAtomSegments, atomSet2, chainSegment);
    while (residuesIt.hasNext) {
      const residueSegment = residuesIt.move();
      const rI = residueSegment.index;
      const authSeqId = auth_seq_id.value(rI);
      const insCode = pdbx_PDB_ins_code.value(rI);
      chain_index_label_seq_id.set(getResidueId(label_seq_id.value(rI), insCode), rI);
      chain_index_auth_seq_id.set(getResidueId(authSeqId, insCode), rI);
      auth_asym_id_auth_seq_id.set(authSeqId, chainIndex2);
    }
  }
  return new Index(map2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/basic/atomic.js
function findHierarchyOffsets(atom_site) {
  if (atom_site._rowCount === 0)
    return { residues: [], chains: [] };
  const start = 0, end = atom_site._rowCount;
  const residues2 = [start], chains2 = [start];
  const { label_entity_id, label_asym_id, label_seq_id, auth_seq_id, pdbx_PDB_ins_code } = atom_site;
  for (let i = start + 1; i < end; i++) {
    const newChain = !label_entity_id.areValuesEqual(i - 1, i) || !label_asym_id.areValuesEqual(i - 1, i);
    const newResidue = newChain || !label_seq_id.areValuesEqual(i - 1, i) || !auth_seq_id.areValuesEqual(i - 1, i) || !pdbx_PDB_ins_code.areValuesEqual(i - 1, i);
    if (newResidue)
      residues2[residues2.length] = i;
    if (newChain)
      chains2[chains2.length] = i;
  }
  return { residues: residues2, chains: chains2 };
}
function createHierarchyData(atom_site, sourceIndex, offsets) {
  const atoms2 = Table.ofColumns(AtomsSchema, {
    type_symbol: Column.ofArray({ array: Column.mapToArray(atom_site.type_symbol, ElementSymbol), schema: Column.Schema.Aliased(Column.Schema.str) }),
    label_atom_id: atom_site.label_atom_id,
    auth_atom_id: atom_site.auth_atom_id,
    label_alt_id: atom_site.label_alt_id,
    label_comp_id: atom_site.label_comp_id,
    auth_comp_id: atom_site.auth_comp_id,
    pdbx_formal_charge: atom_site.pdbx_formal_charge
  });
  const residues2 = Table.view(atom_site, ResiduesSchema, offsets.residues);
  const chains2 = Table.view(atom_site, ChainsSchema, offsets.chains);
  if (!residues2.label_seq_id.isDefined) {
    const seqIds = new Int32Array(residues2.label_seq_id.rowCount);
    const { residues: residueOffsets, chains: chainOffsets } = offsets;
    let cI = 0;
    let seqId2 = 0;
    for (let i = 0, il = seqIds.length; i < il; ++i) {
      if (residueOffsets[i] >= chainOffsets[cI + 1]) {
        cI += 1;
        seqId2 = 0;
      }
      seqIds[i] = ++seqId2;
    }
    residues2.label_seq_id = Column.ofIntArray(seqIds);
  }
  Table.columnToArray(residues2, "label_seq_id", Int32Array);
  Table.columnToArray(residues2, "auth_seq_id", Int32Array);
  return { atoms: atoms2, residues: residues2, chains: chains2, atomSourceIndex: sourceIndex };
}
function getConformation(atom_site) {
  return {
    id: UUID.create22(),
    atomId: atom_site.id,
    occupancy: atom_site.occupancy.isDefined ? atom_site.occupancy : Column.ofConst(1, atom_site._rowCount, Column.Schema.float),
    B_iso_or_equiv: atom_site.B_iso_or_equiv,
    xyzDefined: atom_site.Cartn_x.isDefined && atom_site.Cartn_y.isDefined && atom_site.Cartn_z.isDefined,
    x: atom_site.Cartn_x.toArray({ array: Float32Array }),
    y: atom_site.Cartn_y.toArray({ array: Float32Array }),
    z: atom_site.Cartn_z.toArray({ array: Float32Array })
  };
}
function isHierarchyDataEqual(a, b) {
  return Table.areEqual(a.chains, b.chains) && Table.areEqual(a.residues, b.residues) && Table.areEqual(a.atoms, b.atoms);
}
function createChainOperatorMappingAndSubstituteNames(hierarchy, format) {
  const mapping = /* @__PURE__ */ new Map();
  if (!MmcifFormat.is(format))
    return mapping;
  const { molstar_atom_site_operator_mapping: entries } = toDatabase(AtomSiteOperatorMappingSchema, format.data.frame);
  if (entries._rowCount === 0)
    return mapping;
  const labelMap = /* @__PURE__ */ new Map();
  const authMap = /* @__PURE__ */ new Map();
  for (let i = 0; i < entries._rowCount; i++) {
    const assembly = entries.assembly_operator_id.valueKind(i) === Column.ValueKinds.Present ? { id: entries.assembly_id.value(i), operList: [], operId: entries.assembly_operator_id.value(i) } : void 0;
    const operator = SymmetryOperator.create(entries.operator_name.value(i), Mat4.identity(), {
      assembly,
      spgrOp: entries.symmetry_operator_index.valueKind(i) === Column.ValueKinds.Present ? entries.symmetry_operator_index.value(i) : void 0,
      hkl: Vec3.ofArray(entries.symmetry_hkl.value(i)),
      ncsId: entries.ncs_id.value(i)
    });
    const suffix = entries.suffix.value(i);
    const label = entries.label_asym_id.value(i);
    labelMap.set(`${label}${suffix}`, { name: label, operator });
    const auth = entries.auth_asym_id.value(i);
    authMap.set(`${auth}${suffix}`, auth);
  }
  const { label_asym_id, auth_asym_id } = hierarchy.chains;
  const mappedLabel = new Array(label_asym_id.rowCount);
  const mappedAuth = new Array(label_asym_id.rowCount);
  for (let i = 0; i < label_asym_id.rowCount; i++) {
    const label = label_asym_id.value(i), auth = auth_asym_id.value(i);
    if (!labelMap.has(label)) {
      mappedLabel[i] = label;
      mappedAuth[i] = auth;
      continue;
    }
    const { name, operator } = labelMap.get(label);
    mapping.set(i, operator);
    mappedLabel[i] = name;
    mappedAuth[i] = authMap.get(auth) || auth;
  }
  hierarchy.chains.label_asym_id = Column.ofArray({ array: mappedLabel, valueKind: hierarchy.chains.label_asym_id.valueKind, schema: hierarchy.chains.label_asym_id.schema });
  hierarchy.chains.auth_asym_id = Column.ofArray({ array: mappedAuth, valueKind: hierarchy.chains.auth_asym_id.valueKind, schema: hierarchy.chains.auth_asym_id.schema });
  return mapping;
}
function getAtomicHierarchy(atom_site, sourceIndex, entities, chemicalComponentMap, format, previous) {
  const hierarchyOffsets = findHierarchyOffsets(atom_site);
  const hierarchyData = createHierarchyData(atom_site, sourceIndex, hierarchyOffsets);
  const chainOperatorMapping = createChainOperatorMappingAndSubstituteNames(hierarchyData, format);
  if (previous && isHierarchyDataEqual(previous.atomicHierarchy, hierarchyData)) {
    return {
      sameAsPrevious: true,
      hierarchy: previous.atomicHierarchy,
      chainOperatorMapping
    };
  }
  const hierarchySegments = {
    residueAtomSegments: Segmentation.ofOffsets(hierarchyOffsets.residues, Interval.ofBounds(0, atom_site._rowCount)),
    chainAtomSegments: Segmentation.ofOffsets(hierarchyOffsets.chains, Interval.ofBounds(0, atom_site._rowCount))
  };
  const index = getAtomicIndex(hierarchyData, entities, hierarchySegments);
  const derived = getAtomicDerivedData(hierarchyData, hierarchySegments, index, chemicalComponentMap);
  const hierarchy = { ...hierarchyData, ...hierarchySegments, index, derived };
  return { sameAsPrevious: false, hierarchy, chainOperatorMapping };
}
function getAtomicHierarchyAndConformation(atom_site, sourceIndex, entities, chemicalComponentMap, format, previous) {
  const { sameAsPrevious, hierarchy, chainOperatorMapping } = getAtomicHierarchy(atom_site, sourceIndex, entities, chemicalComponentMap, format, previous);
  const conformation = getConformation(atom_site);
  return { sameAsPrevious, hierarchy, conformation, chainOperatorMapping };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/utils/coarse-index.js
function getCoarseIndex(data) {
  return new Index2(data);
}
var EmptyIndex = class {
  findElement(key, out) {
    out.kind = void 0;
    out.index = -1;
    return false;
  }
  findSphereElement(key) {
    return -1;
  }
  findGaussianElement(key) {
    return -1;
  }
};
var EmptyCoarseIndex = new EmptyIndex();
var Index2 = class {
  get sphereMapping() {
    if (!this._sphereMapping)
      this._sphereMapping = buildMapping(this.data.spheres);
    return this._sphereMapping;
  }
  get gaussianMapping() {
    if (!this._gaussianMapping)
      this._gaussianMapping = buildMapping(this.data.gaussians);
    return this._gaussianMapping;
  }
  findSphereElement(key) {
    var _a;
    const mapping = this.sphereMapping;
    let xs = mapping[key.label_entity_id];
    if (!xs)
      return -1;
    xs = xs[key.label_asym_id];
    if (!xs)
      return -1;
    return (_a = xs[key.label_seq_id]) !== null && _a !== void 0 ? _a : -1;
  }
  findGaussianElement(key) {
    var _a;
    const mapping = this.gaussianMapping;
    let xs = mapping[key.label_entity_id];
    if (!xs)
      return -1;
    xs = xs[key.label_asym_id];
    if (!xs)
      return -1;
    return (_a = xs[key.label_seq_id]) !== null && _a !== void 0 ? _a : -1;
  }
  findElement(key, out) {
    const sphere = this.findSphereElement(key);
    if (sphere >= 0) {
      out.kind = "spheres";
      out.index = sphere;
      return true;
    }
    const gaussian = this.findGaussianElement(key);
    if (gaussian >= 0) {
      out.kind = "gaussians";
      out.index = gaussian;
      return true;
    }
    return false;
  }
  constructor(data) {
    this.data = data;
    this._sphereMapping = void 0;
    this._gaussianMapping = void 0;
  }
};
function buildMapping({ count, entity_id, asym_id, seq_id_begin, seq_id_end }) {
  const ret = {};
  for (let i = 0; i < count; i++) {
    const entityId = entity_id.value(i);
    const asymId = asym_id.value(i);
    if (!ret[entityId])
      ret[entityId] = {};
    if (!ret[entityId][asymId])
      ret[entityId][asymId] = {};
    const elements = ret[entityId][asymId];
    const seqIdBegin = seq_id_begin.value(i);
    const seqIdEnd = seq_id_end.value(i);
    for (let seqId2 = seqIdBegin; seqId2 <= seqIdEnd; seqId2++) {
      elements[seqId2] = i;
    }
  }
  return ret;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/coarse/hierarchy.js
var EmptyCoarseElements = {
  chainKey: [],
  entityKey: [],
  findSequenceKey: () => -1,
  findChainKey: () => -1,
  getEntityFromChain: () => -1,
  count: 0,
  entity_id: Column.Undefined(0, Column.Schema.str),
  asym_id: Column.Undefined(0, Column.Schema.str),
  seq_id_begin: Column.Undefined(0, Column.Schema.int),
  seq_id_end: Column.Undefined(0, Column.Schema.int),
  chainElementSegments: Segmentation.create([]),
  polymerRanges: SortedRanges.ofSortedRanges([]),
  gapRanges: SortedRanges.ofSortedRanges([])
};
var CoarseHierarchy;
(function(CoarseHierarchy2) {
  CoarseHierarchy2.Empty = {
    isDefined: false,
    spheres: EmptyCoarseElements,
    gaussians: EmptyCoarseElements,
    index: EmptyCoarseIndex
  };
})(CoarseHierarchy || (CoarseHierarchy = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/utils/coarse-keys.js
function getElementKey(map2, key, counter) {
  if (map2.has(key))
    return map2.get(key);
  const ret = counter.index++;
  map2.set(key, ret);
  return ret;
}
function getElementSubstructureKeyMap(map2, key) {
  if (map2.has(key))
    return map2.get(key);
  const ret = /* @__PURE__ */ new Map();
  map2.set(key, ret);
  return ret;
}
function createLookUp(entities, chain2, seq) {
  const getEntKey = entities.getEntityIndex;
  const findChainKey = (e, c) => {
    const eKey = getEntKey(e);
    if (eKey < 0)
      return -1;
    const cm = chain2.get(eKey);
    if (!cm.has(c))
      return -1;
    return cm.get(c);
  };
  const findSequenceKey = (e, c, s) => {
    const eKey = getEntKey(e);
    if (eKey < 0)
      return -1;
    const cm = chain2.get(eKey);
    if (cm === void 0)
      return -1;
    const cKey = cm.get(c);
    if (cKey === void 0)
      return -1;
    const sm = seq.get(cKey);
    const { elementIndices, seqRanges } = sm;
    const idx = SortedRanges.firstIntersectionIndex(seqRanges, OrderedSet.ofSingleton(s));
    return idx !== -1 ? elementIndices[idx] : -1;
  };
  return { findChainKey, findSequenceKey };
}
function missingEntity2(k) {
  throw new Error(`Missing entity entry for entity id '${k}'.`);
}
function getCoarseKeys(data, entities) {
  const { entity_id, asym_id, seq_id_begin, seq_id_end, count, chainElementSegments } = data;
  const seqMaps = /* @__PURE__ */ new Map();
  const chainMaps = /* @__PURE__ */ new Map(), chainCounter = { index: 0 };
  const chainKey = new Int32Array(count);
  const entityKey = new Int32Array(count);
  const chainToEntity = new Int32Array(chainElementSegments.count);
  for (let i = 0; i < count; i++) {
    entityKey[i] = entities.getEntityIndex(entity_id.value(i));
    if (entityKey[i] < 0)
      missingEntity2(entity_id.value(i));
  }
  for (let cI = 0; cI < chainElementSegments.count; cI++) {
    const start = chainElementSegments.offsets[cI];
    const end = chainElementSegments.offsets[cI + 1];
    const eK2 = entityKey[start];
    chainToEntity[cI] = eK2;
    const map2 = getElementSubstructureKeyMap(chainMaps, eK2);
    const key = getElementKey(map2, asym_id.value(start), chainCounter);
    for (let i = start; i < end; i++)
      chainKey[i] = key;
    const elementIndices = [];
    const seqRanges = [];
    for (let i = start; i < end; i++) {
      const seqStart = seq_id_begin.value(i);
      const seqEnd = seq_id_end.value(i);
      elementIndices.push(i);
      seqRanges.push(seqStart, seqEnd);
    }
    const seqMap = { elementIndices, seqRanges: SortedRanges.ofSortedRanges(seqRanges) };
    seqMaps.set(key, seqMap);
  }
  const { findChainKey, findSequenceKey } = createLookUp(entities, chainMaps, seqMaps);
  const getEntityFromChain = (c) => {
    return chainToEntity[c];
  };
  return { chainKey, entityKey, findSequenceKey, findChainKey, getEntityFromChain };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/utils/coarse-ranges.js
function getCoarseRanges(data, chemicalComponentMap) {
  const polymerRanges = [];
  const gapRanges = [];
  const chainIt = Segmentation.transientSegments(data.chainElementSegments, Interval.ofBounds(0, data.count));
  const { seq_id_begin, seq_id_end } = data;
  while (chainIt.hasNext) {
    const { start, end } = chainIt.move();
    let startIndex = -1;
    let prevSeqEnd = -1;
    for (let i = start; i < end; ++i) {
      const seqEnd = seq_id_end.value(i);
      if (i === start) {
        startIndex = i;
        prevSeqEnd = seq_id_end.value(i);
      } else {
        if (seq_id_begin.value(i) - prevSeqEnd > 1) {
          polymerRanges.push(startIndex, i - 1);
          gapRanges.push(i - 1, i);
          startIndex = i;
        }
      }
      if (i === end - 1) {
        polymerRanges.push(startIndex, i);
      }
      prevSeqEnd = seqEnd;
    }
  }
  return {
    polymerRanges: SortedRanges.ofSortedRanges(polymerRanges),
    gapRanges: SortedRanges.ofSortedRanges(gapRanges)
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/basic/coarse.js
var EmptyCoarse = { hierarchy: CoarseHierarchy.Empty, conformation: void 0 };
function getCoarse(data, chemicalComponentMap) {
  const { ihm_sphere_obj_site, ihm_gaussian_obj_site } = data;
  if (ihm_sphere_obj_site._rowCount === 0 && ihm_gaussian_obj_site._rowCount === 0)
    return EmptyCoarse;
  const sphereData = getData(ihm_sphere_obj_site);
  const sphereConformation = getSphereConformation(ihm_sphere_obj_site);
  const sphereKeys = getCoarseKeys(sphereData, data.entities);
  const sphereRanges = getCoarseRanges(sphereData, chemicalComponentMap);
  const gaussianData = getData(ihm_gaussian_obj_site);
  const gaussianConformation = getGaussianConformation(ihm_gaussian_obj_site);
  const gaussianKeys = getCoarseKeys(gaussianData, data.entities);
  const gaussianRanges = getCoarseRanges(gaussianData, chemicalComponentMap);
  return {
    hierarchy: {
      isDefined: true,
      spheres: { ...sphereData, ...sphereKeys, ...sphereRanges },
      gaussians: { ...gaussianData, ...gaussianKeys, ...gaussianRanges },
      index: getCoarseIndex({ spheres: sphereData, gaussians: gaussianData })
    },
    conformation: {
      id: UUID.create22(),
      spheres: sphereConformation,
      gaussians: gaussianConformation
    }
  };
}
function getSphereConformation(data) {
  return {
    x: data.Cartn_x.toArray({ array: Float32Array }),
    y: data.Cartn_y.toArray({ array: Float32Array }),
    z: data.Cartn_z.toArray({ array: Float32Array }),
    radius: data.object_radius.toArray({ array: Float32Array }),
    rmsf: data.rmsf.toArray({ array: Float32Array })
  };
}
function getGaussianConformation(data) {
  const matrix_space = BasicSchema.ihm_gaussian_obj_site.covariance_matrix.space;
  const covariance_matrix = [];
  const { covariance_matrix: cm } = data;
  for (let i = 0, _i = cm.rowCount; i < _i; i++) {
    covariance_matrix[i] = Tensor.toMat3(Mat3(), matrix_space, cm.value(i));
  }
  return {
    x: data.mean_Cartn_x.toArray({ array: Float32Array }),
    y: data.mean_Cartn_y.toArray({ array: Float32Array }),
    z: data.mean_Cartn_z.toArray({ array: Float32Array }),
    weight: data.weight.toArray({ array: Float32Array }),
    covariance_matrix
  };
}
function getSegments(asym_id, seq_id_begin, seq_id_end) {
  const chainOffsets = [0];
  for (let i = 1, _i = asym_id.rowCount; i < _i; i++) {
    const newChain = !asym_id.areValuesEqual(i - 1, i);
    if (newChain)
      chainOffsets[chainOffsets.length] = i;
  }
  return {
    chainElementSegments: Segmentation.ofOffsets(chainOffsets, Interval.ofBounds(0, asym_id.rowCount))
  };
}
function getData(data) {
  const { entity_id, seq_id_begin, seq_id_end, asym_id } = data;
  return { count: entity_id.rowCount, entity_id, asym_id, seq_id_begin, seq_id_end, ...getSegments(asym_id, seq_id_begin, seq_id_end) };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/sequence/constants.js
var ProteinOneLetterCodes = {
  "HIS": "H",
  "ARG": "R",
  "LYS": "K",
  "ILE": "I",
  "PHE": "F",
  "LEU": "L",
  "TRP": "W",
  "ALA": "A",
  "MET": "M",
  "PRO": "P",
  "CYS": "C",
  "ASN": "N",
  "VAL": "V",
  "GLY": "G",
  "SER": "S",
  "GLN": "Q",
  "TYR": "Y",
  "ASP": "D",
  "GLU": "E",
  "THR": "T",
  "SEC": "U",
  // as per IUPAC definition
  "PYL": "O",
  // as per IUPAC definition
  // charmm ff
  "HSD": "H",
  "HSE": "H",
  "HSP": "H",
  "LSN": "K",
  "ASPP": "D",
  "GLUP": "E",
  // amber ff
  "HID": "H",
  "HIE": "H",
  "HIP": "H",
  "LYN": "K",
  "ASH": "D",
  "GLH": "E"
};
var DnaOneLetterCodes = {
  "DA": "A",
  "DC": "C",
  "DG": "G",
  "DT": "T",
  "DU": "U"
};
var RnaOneLetterCodes = {
  "A": "A",
  "C": "C",
  "G": "G",
  "T": "T",
  "U": "U"
};
function getProteinOneLetterCode(residueName) {
  const code = ProteinOneLetterCodes[residueName];
  return code || "X";
}
function getRnaOneLetterCode(residueName) {
  const code = RnaOneLetterCodes[residueName];
  return code || "X";
}
function getDnaOneLetterCode(residueName) {
  const code = DnaOneLetterCodes[residueName];
  return code || "X";
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/sequence/sequence.js
var Sequence;
(function(Sequence2) {
  let Kind;
  (function(Kind2) {
    Kind2["Protein"] = "protein";
    Kind2["RNA"] = "RNA";
    Kind2["DNA"] = "DNA";
    Kind2["Generic"] = "generic";
  })(Kind = Sequence2.Kind || (Sequence2.Kind = {}));
  function getSequenceString(seq) {
    const array2 = seq.code.toArray();
    return (array2 instanceof Array ? array2 : Array.from(array2)).join("");
  }
  Sequence2.getSequenceString = getSequenceString;
  function determineKind(names) {
    for (let i = 0, _i = Math.min(names.rowCount, 10); i < _i; i++) {
      const name = names.value(i) || "";
      if (getProteinOneLetterCode(name) !== "X")
        return Kind.Protein;
      if (getRnaOneLetterCode(name) !== "X")
        return Kind.RNA;
      if (getDnaOneLetterCode(name) !== "X")
        return Kind.DNA;
    }
    return Kind.Generic;
  }
  function codeProvider(kind, map2) {
    let code;
    switch (kind) {
      case Kind.Protein:
        code = getProteinOneLetterCode;
        break;
      case Kind.DNA:
        code = getDnaOneLetterCode;
        break;
      case Kind.RNA:
        code = getRnaOneLetterCode;
        break;
      case Kind.Generic:
        code = () => "X";
        break;
      default:
        assertUnreachable(kind);
    }
    if (map2 && map2.size > 0) {
      return (name) => {
        const ret = code(name);
        if (ret !== "X" || !map2.has(name))
          return ret;
        return code(map2.get(name));
      };
    }
    return code;
  }
  function ofResidueNames(compId2, seqId2) {
    if (seqId2.rowCount === 0)
      throw new Error("cannot be empty");
    const kind = determineKind(compId2);
    return new ResidueNamesImpl(kind, compId2, seqId2);
  }
  Sequence2.ofResidueNames = ofResidueNames;
  class ResidueNamesImpl {
    index(seqId2) {
      return this.indexMap.get(seqId2);
    }
    constructor(kind, compId2, seqId2) {
      this.kind = kind;
      this.microHet = /* @__PURE__ */ new Map();
      const codeFromName = codeProvider(kind);
      const codes = [];
      const compIds = [];
      const seqIds = [];
      const microHet = /* @__PURE__ */ new Map();
      let idx = 0;
      const indexMap = /* @__PURE__ */ new Map();
      for (let i = 0, il = seqId2.rowCount; i < il; ++i) {
        const seq_id = seqId2.value(i);
        if (!indexMap.has(seq_id)) {
          indexMap.set(seq_id, idx);
          const comp_id = compId2.value(i);
          compIds[idx] = comp_id;
          seqIds[idx] = seq_id;
          codes[idx] = codeFromName(comp_id);
          idx += 1;
        } else {
          if (!microHet.has(seq_id)) {
            microHet.set(seq_id, [compIds[indexMap.get(seq_id)], compId2.value(i)]);
          } else {
            microHet.get(seq_id).push(compId2.value(i));
          }
        }
      }
      const labels = [];
      for (let i = 0, il = idx; i < il; ++i) {
        const mh = microHet.get(seqIds[i]);
        if (mh) {
          const l = mh.map((id) => {
            const c = codeFromName(id);
            return c === "X" ? id : c;
          });
          labels[i] = `(${l.join("|")})`;
        } else {
          labels[i] = codes[i] === "X" ? compIds[i] : codes[i];
        }
      }
      this.length = idx;
      this.code = Column.ofStringArray(codes);
      this.compId = Column.ofStringArray(compIds);
      this.seqId = Column.ofIntArray(seqIds);
      this.label = Column.ofStringArray(labels);
      this.microHet = microHet;
      this.indexMap = indexMap;
    }
  }
  function ofSequenceRanges(seqIdBegin, seqIdEnd) {
    const kind = Kind.Generic;
    return new SequenceRangesImpl(kind, seqIdBegin, seqIdEnd);
  }
  Sequence2.ofSequenceRanges = ofSequenceRanges;
  class SequenceRangesImpl {
    index(seqId2) {
      return seqId2 - this.minSeqId;
    }
    constructor(kind, seqIdStart, seqIdEnd) {
      this.kind = kind;
      this.seqIdStart = seqIdStart;
      this.seqIdEnd = seqIdEnd;
      this.microHet = /* @__PURE__ */ new Map();
      let maxSeqId = 0, minSeqId = Number.MAX_SAFE_INTEGER;
      for (let i = 0, _i = this.seqIdStart.rowCount; i < _i; i++) {
        const idStart = this.seqIdStart.value(i);
        const idEnd = this.seqIdEnd.value(i);
        if (idStart < minSeqId)
          minSeqId = idStart;
        if (maxSeqId < idEnd)
          maxSeqId = idEnd;
      }
      const count = maxSeqId - minSeqId + 1;
      this.code = Column.ofConst("X", count, Column.Schema.str);
      this.label = Column.ofConst("", count, Column.Schema.str);
      this.seqId = Column.ofLambda({
        value: (row) => row + minSeqId + 1,
        rowCount: count,
        schema: Column.Schema.int
      });
      this.compId = Column.ofConst("", count, Column.Schema.str);
      this.length = count;
      this.minSeqId = minSeqId;
    }
  }
})(Sequence || (Sequence = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/sequence.js
var StructureSequence;
(function(StructureSequence2) {
  const Empty = { byEntityKey: {}, sequences: [] };
  function merge2(...entitySeqs) {
    const sequences = [];
    const byEntityKey = {};
    for (let i = 0, il = entitySeqs.length; i < il; ++i) {
      sequences.push(...entitySeqs[i].sequences);
      Object.assign(byEntityKey, entitySeqs[i].byEntityKey);
    }
    return { sequences, byEntityKey };
  }
  function fromHierarchy(entities, atomicHierarchy, coarseHierarchy) {
    const atomic = fromAtomicHierarchy(entities, atomicHierarchy);
    const coarse2 = coarseHierarchy.isDefined ? fromCoarseHierarchy(entities, coarseHierarchy) : Empty;
    return merge2(atomic, coarse2);
  }
  StructureSequence2.fromHierarchy = fromHierarchy;
  function fromAtomicHierarchy(entities, hierarchy) {
    const { label_comp_id } = hierarchy.atoms;
    const { label_seq_id } = hierarchy.residues;
    const { chainAtomSegments, residueAtomSegments } = hierarchy;
    const { count, offsets } = chainAtomSegments;
    const byEntityKey = {};
    const sequences = [];
    if (count === 1 && offsets[0] === 0 && offsets[1] === 0) {
      return { byEntityKey, sequences };
    }
    for (let cI = 0, _cI = hierarchy.chains._rowCount; cI < _cI; cI++) {
      const entityKey = hierarchy.index.getEntityFromChain(cI);
      if (byEntityKey[entityKey] !== void 0 || entities.data.type.value(entityKey) !== "polymer")
        continue;
      const start = cI;
      cI++;
      while (cI < _cI && entityKey === hierarchy.index.getEntityFromChain(cI) && entities.data.type.value(entityKey) !== "polymer") {
        cI++;
      }
      cI--;
      const rStart = residueAtomSegments.index[offsets[start]];
      const rEnd = residueAtomSegments.index[offsets[cI + 1] - 1] + 1;
      const seqId2 = Column.window(label_seq_id, rStart, rEnd);
      const _compId = [];
      for (let rI = rStart; rI < rEnd; ++rI) {
        _compId.push(label_comp_id.value(residueAtomSegments.offsets[rI]));
      }
      const compId2 = Column.ofStringArray(_compId);
      byEntityKey[entityKey] = {
        entityId: entities.data.id.value(entityKey),
        sequence: Sequence.ofResidueNames(compId2, seqId2)
      };
      sequences.push(byEntityKey[entityKey]);
    }
    return { byEntityKey, sequences };
  }
  StructureSequence2.fromAtomicHierarchy = fromAtomicHierarchy;
  function fromCoarseHierarchy(entities, hierarchy) {
    const spheres2 = fromCoarseElements(entities, hierarchy.spheres);
    const gaussians = fromCoarseElements(entities, hierarchy.gaussians);
    return merge2(spheres2, gaussians);
  }
  StructureSequence2.fromCoarseHierarchy = fromCoarseHierarchy;
  function fromCoarseElements(entities, elements) {
    const { chainElementSegments, seq_id_begin, seq_id_end } = elements;
    const { count, offsets } = chainElementSegments;
    const byEntityKey = {};
    const sequences = [];
    if (count === 1 && offsets[0] === 0 && offsets[1] === 0) {
      return { byEntityKey, sequences };
    }
    for (let cI = 0, _cI = count; cI < _cI; cI++) {
      const eK2 = elements.getEntityFromChain(cI);
      if (byEntityKey[eK2] !== void 0)
        continue;
      const start = cI;
      cI++;
      while (cI < _cI && eK2 === elements.getEntityFromChain(cI)) {
        cI++;
      }
      cI--;
      const eStart = offsets[start];
      const eEnd = offsets[cI + 1] - 1;
      const seqIdBegin = Column.window(seq_id_begin, eStart, eEnd);
      const seqIdEnd = Column.window(seq_id_end, eStart, eEnd);
      byEntityKey[eK2] = {
        entityId: entities.data.id.value(eK2),
        sequence: Sequence.ofSequenceRanges(seqIdBegin, seqIdEnd)
      };
      sequences.push(byEntityKey[eK2]);
    }
    return { byEntityKey, sequences };
  }
  StructureSequence2.fromCoarseElements = fromCoarseElements;
})(StructureSequence || (StructureSequence = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/basic/sequence.js
function getSequence(data, entities, atomicHierarchy, coarseHierarchy) {
  if (!data.entity_poly_seq || !data.entity_poly_seq._rowCount) {
    return StructureSequence.fromHierarchy(entities, atomicHierarchy, coarseHierarchy);
  }
  const { entity_id, num, mon_id } = data.entity_poly_seq;
  const byEntityKey = {};
  const sequences = [];
  const count = entity_id.rowCount;
  let i = 0;
  while (i < count) {
    const start = i;
    while (i < count - 1 && entity_id.areValuesEqual(i, i + 1))
      i++;
    i++;
    const id = entity_id.value(start);
    const compId2 = Column.window(mon_id, start, i);
    const seqId2 = Column.window(num, start, i);
    const entityKey = entities.getEntityIndex(id);
    byEntityKey[entityKey] = {
      entityId: id,
      sequence: Sequence.ofResidueNames(compId2, seqId2)
    };
    sequences.push(byEntityKey[entityKey]);
  }
  return { byEntityKey, sequences };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/basic/sort.js
async function sortAtomSite(ctx, atom_site, start, end) {
  const indices = createRangeArray(start, end - 1);
  const { label_entity_id, label_asym_id, label_seq_id } = atom_site;
  const entityBuckets = makeBuckets(indices, label_entity_id.value);
  if (ctx.shouldUpdate)
    await ctx.update();
  for (let ei = 0, _eI = entityBuckets.length - 1; ei < _eI; ei++) {
    const chainBuckets = makeBuckets(indices, label_asym_id.value, { start: entityBuckets[ei], end: entityBuckets[ei + 1] });
    for (let cI = 0, _cI = chainBuckets.length - 1; cI < _cI; cI++) {
      const aI = chainBuckets[cI];
      if (label_seq_id.valueKind(aI) !== Column.ValueKinds.Present)
        continue;
      makeBuckets(indices, label_seq_id.value, { sort: true, start: aI, end: chainBuckets[cI + 1] });
      if (ctx.shouldUpdate)
        await ctx.update();
    }
    if (ctx.shouldUpdate)
      await ctx.update();
  }
  if (arrayIsIdentity(indices) && indices.length === atom_site._rowCount) {
    return { atom_site, sourceIndex: Column.ofIntArray(indices) };
  }
  return {
    atom_site: Table.view(atom_site, atom_site._schema, indices),
    sourceIndex: Column.ofIntArray(indices)
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/utils/atomic-ranges.js
function areBackboneConnected(riStart, riEnd, conformation, index, derived) {
  const { polymerType, traceElementIndex, directionFromElementIndex, directionToElementIndex } = derived.residue;
  const ptStart = polymerType[riStart];
  const ptEnd = polymerType[riEnd];
  if (ptStart === PolymerType.NA || ptEnd === PolymerType.NA)
    return false;
  if (traceElementIndex[riStart] === -1 || traceElementIndex[riEnd] === -1)
    return false;
  let eiStart = index.findAtomsOnResidue(riStart, getAtomIdForAtomRole(ptStart, "backboneStart"));
  let eiEnd = index.findAtomsOnResidue(riEnd, getAtomIdForAtomRole(ptEnd, "backboneEnd"));
  if (eiStart === -1 || eiEnd === -1) {
    eiStart = index.findAtomsOnResidue(riStart, getAtomIdForAtomRole(ptStart, "coarseBackbone"));
    eiEnd = index.findAtomsOnResidue(riEnd, getAtomIdForAtomRole(ptEnd, "coarseBackbone"));
  }
  const { x, y, z } = conformation;
  const pStart = Vec3.create(x[eiStart], y[eiStart], z[eiStart]);
  const pEnd = Vec3.create(x[eiEnd], y[eiEnd], z[eiEnd]);
  const isCoarse = directionFromElementIndex[riStart] === -1 || directionToElementIndex[riStart] === -1 || directionFromElementIndex[riEnd] === -1 || directionToElementIndex[riEnd] === -1;
  return Vec3.distance(pStart, pEnd) < (isCoarse ? 10 : 3);
}
function getAtomicRanges(hierarchy, entities, conformation, sequence) {
  const polymerRanges = [];
  const gapRanges = [];
  const cyclicPolymerMap = /* @__PURE__ */ new Map();
  const chainIt = Segmentation.transientSegments(hierarchy.chainAtomSegments, Interval.ofBounds(0, hierarchy.atoms._rowCount));
  const residueIt = Segmentation.transientSegments(hierarchy.residueAtomSegments, Interval.ofBounds(0, hierarchy.atoms._rowCount));
  const { index, derived } = hierarchy;
  const { label_seq_id } = hierarchy.residues;
  const { label_entity_id } = hierarchy.chains;
  const { moleculeType, traceElementIndex } = derived.residue;
  let prevSeqId;
  let prevStart;
  let prevEnd;
  let startIndex;
  while (chainIt.hasNext) {
    const chainSegment = chainIt.move();
    residueIt.setSegment(chainSegment);
    prevSeqId = -1;
    prevStart = -1;
    prevEnd = -1;
    startIndex = -1;
    const eI = entities.getEntityIndex(label_entity_id.value(chainSegment.index));
    const seq = sequence.byEntityKey[eI];
    const maxSeqId = seq ? seq.sequence.seqId.value(seq.sequence.seqId.rowCount - 1) : -1;
    const riStart = hierarchy.residueAtomSegments.index[chainSegment.start];
    const riEnd = hierarchy.residueAtomSegments.index[chainSegment.end - 1];
    const seqIdStart = label_seq_id.value(riStart);
    const seqIdEnd = label_seq_id.value(riEnd);
    if (seqIdStart === 1 && seqIdEnd === maxSeqId && conformation.xyzDefined && areBackboneConnected(riStart, riEnd, conformation, index, derived)) {
      cyclicPolymerMap.set(riStart, riEnd);
      cyclicPolymerMap.set(riEnd, riStart);
    }
    while (residueIt.hasNext) {
      const residueSegment = residueIt.move();
      const residueIndex2 = residueSegment.index;
      const seqId2 = label_seq_id.value(residueIndex2);
      if (isPolymer(moleculeType[residueIndex2]) && traceElementIndex[residueIndex2] !== -1) {
        if (startIndex !== -1) {
          if (seqId2 !== prevSeqId + 1) {
            polymerRanges.push(startIndex, prevEnd - 1);
            gapRanges.push(prevStart, residueSegment.end - 1);
            startIndex = residueSegment.start;
          } else if (!residueIt.hasNext) {
            polymerRanges.push(startIndex, residueSegment.end - 1);
          } else {
            const riStart2 = hierarchy.residueAtomSegments.index[residueSegment.start];
            const riEnd2 = hierarchy.residueAtomSegments.index[prevEnd - 1];
            if (conformation.xyzDefined && !areBackboneConnected(riStart2, riEnd2, conformation, hierarchy.index, derived)) {
              polymerRanges.push(startIndex, prevEnd - 1);
              gapRanges.push(prevStart, residueSegment.end - 1);
              startIndex = residueSegment.start;
            }
          }
        } else {
          startIndex = residueSegment.start;
        }
      } else {
        if (startIndex !== -1) {
          polymerRanges.push(startIndex, prevEnd - 1);
          startIndex = -1;
        }
      }
      prevStart = residueSegment.start;
      prevEnd = residueSegment.end;
      prevSeqId = seqId2;
    }
  }
  return {
    polymerRanges: SortedRanges.ofSortedRanges(polymerRanges),
    gapRanges: SortedRanges.ofSortedRanges(gapRanges),
    cyclicPolymerMap
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/basic/properties.js
function getMissingResidues(data) {
  const map2 = /* @__PURE__ */ new Map();
  const getKey = (model_num, asym_id, seq_id) => {
    return `${model_num}|${asym_id}|${seq_id}`;
  };
  const c = data.pdbx_unobs_or_zero_occ_residues;
  for (let i = 0, il = c._rowCount; i < il; ++i) {
    const key = getKey(c.PDB_model_num.value(i), c.label_asym_id.value(i), c.label_seq_id.value(i));
    map2.set(key, { polymer_flag: c.polymer_flag.value(i), occupancy_flag: c.occupancy_flag.value(i) });
  }
  return {
    has: (model_num, asym_id, seq_id) => {
      return map2.has(getKey(model_num, asym_id, seq_id));
    },
    get: (model_num, asym_id, seq_id) => {
      return map2.get(getKey(model_num, asym_id, seq_id));
    },
    size: map2.size
  };
}
function getChemicalComponentMap(data) {
  const map2 = /* @__PURE__ */ new Map();
  if (data.chem_comp._rowCount > 0) {
    const { id } = data.chem_comp;
    for (let i = 0, il = id.rowCount; i < il; ++i) {
      map2.set(id.value(i), Table.getRow(data.chem_comp, i));
    }
  } else {
    const uniqueNames = getUniqueComponentNames(data);
    uniqueNames.forEach((n) => {
      map2.set(n, getDefaultChemicalComponent(n));
    });
  }
  return map2;
}
function getSaccharideComponentMap(data) {
  const map2 = /* @__PURE__ */ new Map();
  if (data.pdbx_chem_comp_identifier._rowCount > 0) {
    const { comp_id, type: type3, identifier } = data.pdbx_chem_comp_identifier;
    for (let i = 0, il = comp_id.rowCount; i < il; ++i) {
      if (type3.value(i) === "SNFG CARBOHYDRATE SYMBOL" || type3.value(i) === "SNFG CARB SYMBOL") {
        const snfgName = identifier.value(i);
        const saccharideComp = SaccharidesSnfgMap.get(snfgName);
        if (saccharideComp) {
          map2.set(comp_id.value(i), saccharideComp);
        } else {
          console.warn(`Unknown SNFG name '${snfgName}'`);
        }
      }
    }
  }
  if (data.chem_comp._rowCount > 0) {
    const { id, type: type3 } = data.chem_comp;
    for (let i = 0, il = id.rowCount; i < il; ++i) {
      const _id = id.value(i);
      if (map2.has(_id))
        continue;
      const _type = type3.value(i);
      if (SaccharideCompIdMap.has(_id)) {
        map2.set(_id, SaccharideCompIdMap.get(_id));
      } else if (getMoleculeType(_type, _id) === MoleculeType.Saccharide) {
        map2.set(_id, UnknownSaccharideComponent);
      }
    }
  } else {
    const uniqueNames = getUniqueComponentNames(data);
    SaccharideCompIdMap.forEach((v, k) => {
      if (!map2.has(k) && uniqueNames.has(k))
        map2.set(k, v);
    });
  }
  return map2;
}
var getUniqueComponentNames = memoize1((data) => {
  const uniqueNames = /* @__PURE__ */ new Set();
  const { label_comp_id, auth_comp_id } = data.atom_site;
  const comp_id = label_comp_id.isDefined ? label_comp_id : auth_comp_id;
  for (let i = 0, il = comp_id.rowCount; i < il; ++i) {
    uniqueNames.add(comp_id.value(i));
  }
  return uniqueNames;
});
function getStructAsymMap(atomic, data) {
  const map2 = /* @__PURE__ */ new Map();
  const { auth_asym_id, label_asym_id, label_entity_id } = atomic.chains;
  for (let i = 0, _i = atomic.chains._rowCount; i < _i; i++) {
    const id = label_asym_id.value(i);
    map2.set(id, { id, auth_id: auth_asym_id.value(i), entity_id: label_entity_id.value(i) });
  }
  if (data === null || data === void 0 ? void 0 : data.struct_asym._rowCount) {
    const { id, entity_id } = data.struct_asym;
    for (let i = 0, il = id.rowCount; i < il; ++i) {
      const _id = id.value(i);
      if (!map2.has(_id)) {
        map2.set(_id, {
          id: _id,
          auth_id: "",
          entity_id: entity_id.value(i)
        });
      }
    }
  }
  return map2;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/common.js
var EntitySubtype = Column.Schema.Aliased(Column.Schema.Str());

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/basic/entities.js
function getEntityData(data) {
  let entityData;
  if (!data.entity.id.isDefined) {
    const entityIds2 = /* @__PURE__ */ new Set();
    const ids = [];
    const types = [];
    const { label_entity_id, label_comp_id } = data.atom_site;
    for (let i = 0, il = data.atom_site._rowCount; i < il; i++) {
      const entityId = label_entity_id.value(i);
      if (!entityIds2.has(entityId)) {
        ids.push(entityId);
        types.push(getEntityType(label_comp_id.value(i)));
        entityIds2.add(entityId);
      }
    }
    const { entity_id: sphere_entity_id } = data.ihm_sphere_obj_site;
    for (let i = 0, il = data.ihm_sphere_obj_site._rowCount; i < il; i++) {
      const entityId = sphere_entity_id.value(i);
      if (!entityIds2.has(entityId)) {
        ids.push(entityId);
        types.push("polymer");
        entityIds2.add(entityId);
      }
    }
    const { entity_id: gaussian_entity_id } = data.ihm_gaussian_obj_site;
    for (let i = 0, il = data.ihm_gaussian_obj_site._rowCount; i < il; i++) {
      const entityId = gaussian_entity_id.value(i);
      if (!entityIds2.has(entityId)) {
        ids.push(entityId);
        types.push("polymer");
        entityIds2.add(entityId);
      }
    }
    entityData = Table.ofPartialColumns(BasicSchema.entity, {
      id: Column.ofArray({ array: ids, schema: BasicSchema.entity.id }),
      type: Column.ofArray({ array: types, schema: BasicSchema.entity.type })
    }, ids.length);
  } else {
    entityData = data.entity;
  }
  const getEntityIndex = Column.createIndexer(entityData.id);
  const subtypes = new Array(entityData._rowCount);
  subtypes.fill("other");
  const entityIds = /* @__PURE__ */ new Set();
  let assignSubtype = false;
  if (data.entity_poly && data.entity_poly.type.isDefined) {
    const { entity_id, type: type3, _rowCount } = data.entity_poly;
    for (let i = 0; i < _rowCount; ++i) {
      const entityId = entity_id.value(i);
      subtypes[getEntityIndex(entityId)] = type3.value(i);
      entityIds.add(entityId);
    }
  } else {
    assignSubtype = true;
  }
  if (data.pdbx_entity_branch && data.pdbx_entity_branch.entity_id.isDefined) {
    const { entity_id, type: type3, _rowCount } = data.pdbx_entity_branch;
    for (let i = 0; i < _rowCount; ++i) {
      const entityId = entity_id.value(i);
      subtypes[getEntityIndex(entityId)] = type3.value(i);
      entityIds.add(entityId);
    }
  } else {
    assignSubtype = true;
  }
  if (entityIds.size < subtypes.length) {
    assignSubtype = true;
  }
  if (assignSubtype) {
    const chemCompType = /* @__PURE__ */ new Map();
    if (data.chem_comp) {
      const { id, type: type3 } = data.chem_comp;
      for (let i = 0, il = data.chem_comp._rowCount; i < il; i++) {
        chemCompType.set(id.value(i), type3.value(i));
      }
    }
    if (data.atom_site) {
      const { label_entity_id, label_comp_id } = data.atom_site;
      for (let i = 0, il = data.atom_site._rowCount; i < il; i++) {
        const entityId = label_entity_id.value(i);
        if (!entityIds.has(entityId)) {
          const compId2 = label_comp_id.value(i);
          const compType = chemCompType.get(compId2) || "other";
          subtypes[getEntityIndex(entityId)] = getEntitySubtype(compId2, compType);
          entityIds.add(entityId);
        }
      }
    }
  }
  const subtypeColumn = Column.ofArray({ array: subtypes, schema: EntitySubtype });
  return {
    data: entityData,
    subtype: subtypeColumn,
    getEntityIndex
  };
}
function getEntitiesWithPRD(data, entities, structAsymMap) {
  var _a;
  if (!data.pdbx_molecule || !data.pdbx_molecule.prd_id.isDefined) {
    return entities;
  }
  const prdIds = new Array(entities.data._rowCount);
  prdIds.fill("");
  const { asym_id, prd_id, _rowCount } = data.pdbx_molecule;
  for (let i = 0; i < _rowCount; ++i) {
    const asymId = asym_id.value(i);
    const entityId = (_a = structAsymMap.get(asymId)) === null || _a === void 0 ? void 0 : _a.entity_id;
    if (entityId !== void 0) {
      prdIds[entities.getEntityIndex(entityId)] = prd_id.value(i);
    }
  }
  const prdIdColumn = Column.ofArray({ array: prdIds, schema: Column.Schema.str });
  return {
    ...entities,
    prd_id: prdIdColumn
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/trajectory.js
var ArrayTrajectory = class {
  getFrameAtIndex(i) {
    return this.frames[i];
  }
  constructor(frames) {
    this.frames = frames;
    this.frameCount = frames.length;
    this.representative = frames[0];
    this.duration = frames.length;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/basic/parser.js
async function createModels(data, format, ctx) {
  const properties = getCommonProperties(data, format);
  const models = data.ihm_model_list._rowCount > 0 ? await readIntegrative(ctx, data, properties, format) : await readStandard(ctx, data, properties, format);
  for (let i = 0; i < models.length; i++) {
    Model.TrajectoryInfo.set(models[i], { index: i, size: models.length });
  }
  return new ArrayTrajectory(models);
}
function getCommonProperties(data, format) {
  return {
    missingResidues: getMissingResidues(data),
    chemicalComponentMap: getChemicalComponentMap(data),
    saccharideComponentMap: getSaccharideComponentMap(data)
  };
}
function createStandardModel(data, atom_site, sourceIndex, entities, properties, format, previous) {
  const atomic = getAtomicHierarchyAndConformation(atom_site, sourceIndex, entities, properties.chemicalComponentMap, format, previous);
  const modelNum = atom_site.pdbx_PDB_model_num.value(0);
  if (previous && atomic.sameAsPrevious) {
    return {
      ...previous,
      id: UUID.create22(),
      modelNum,
      atomicConformation: atomic.conformation,
      _dynamicPropertyData: /* @__PURE__ */ Object.create(null)
    };
  }
  const coarse2 = EmptyCoarse;
  const sequence = getSequence(data, entities, atomic.hierarchy, coarse2.hierarchy);
  const atomicRanges = getAtomicRanges(atomic.hierarchy, entities, atomic.conformation, sequence);
  const structAsymMap = getStructAsymMap(atomic.hierarchy);
  const entry = data.entry.id.valueKind(0) === Column.ValueKinds.Present ? data.entry.id.value(0) : format.name;
  const label = [];
  if (entry)
    label.push(entry);
  if (data.struct.title.valueKind(0) === Column.ValueKinds.Present)
    label.push(data.struct.title.value(0));
  return {
    id: UUID.create22(),
    entryId: entry,
    label: label.join(" | "),
    entry,
    sourceData: format,
    modelNum,
    parent: void 0,
    entities: getEntitiesWithPRD(data, entities, structAsymMap),
    sequence,
    atomicHierarchy: atomic.hierarchy,
    atomicConformation: atomic.conformation,
    atomicRanges,
    atomicChainOperatorMappinng: atomic.chainOperatorMapping,
    coarseHierarchy: coarse2.hierarchy,
    coarseConformation: coarse2.conformation,
    properties: {
      ...properties,
      structAsymMap
    },
    customProperties: new CustomProperties(),
    _staticPropertyData: /* @__PURE__ */ Object.create(null),
    _dynamicPropertyData: /* @__PURE__ */ Object.create(null)
  };
}
function createIntegrativeModel(data, ihm, properties, format) {
  const atomic = getAtomicHierarchyAndConformation(ihm.atom_site, ihm.atom_site_sourceIndex, ihm.entities, properties.chemicalComponentMap, format);
  const coarse2 = getCoarse(ihm, properties.chemicalComponentMap);
  const sequence = getSequence(data, ihm.entities, atomic.hierarchy, coarse2.hierarchy);
  const atomicRanges = getAtomicRanges(atomic.hierarchy, ihm.entities, atomic.conformation, sequence);
  const entry = data.entry.id.valueKind(0) === Column.ValueKinds.Present ? data.entry.id.value(0) : format.name;
  const label = [];
  if (entry)
    label.push(entry);
  if (data.struct.title.valueKind(0) === Column.ValueKinds.Present)
    label.push(data.struct.title.value(0));
  if (ihm.model_name)
    label.push(ihm.model_name);
  if (ihm.model_group_name)
    label.push(ihm.model_group_name);
  const structAsymMap = getStructAsymMap(atomic.hierarchy, data);
  return {
    id: UUID.create22(),
    entryId: entry,
    label: label.join(" | "),
    entry,
    sourceData: format,
    modelNum: ihm.model_id,
    parent: void 0,
    entities: getEntitiesWithPRD(data, ihm.entities, structAsymMap),
    sequence,
    atomicHierarchy: atomic.hierarchy,
    atomicConformation: atomic.conformation,
    atomicRanges,
    atomicChainOperatorMappinng: atomic.chainOperatorMapping,
    coarseHierarchy: coarse2.hierarchy,
    coarseConformation: coarse2.conformation,
    properties: {
      ...properties,
      structAsymMap
    },
    customProperties: new CustomProperties(),
    _staticPropertyData: /* @__PURE__ */ Object.create(null),
    _dynamicPropertyData: /* @__PURE__ */ Object.create(null)
  };
}
function findModelEnd(num, startIndex) {
  const rowCount = num.rowCount;
  if (!num.isDefined)
    return rowCount;
  let endIndex = startIndex + 1;
  while (endIndex < rowCount && num.areValuesEqual(startIndex, endIndex))
    endIndex++;
  return endIndex;
}
async function readStandard(ctx, data, properties, format) {
  const models = [];
  if (data.atom_site) {
    const atomCount2 = data.atom_site.id.rowCount;
    const entities = getEntityData(data);
    let modelStart = 0;
    while (modelStart < atomCount2) {
      const modelEnd = findModelEnd(data.atom_site.pdbx_PDB_model_num, modelStart);
      const { atom_site, sourceIndex } = await sortAtomSite(ctx, data.atom_site, modelStart, modelEnd);
      const model = createStandardModel(data, atom_site, sourceIndex, entities, properties, format, models.length > 0 ? models[models.length - 1] : void 0);
      models.push(model);
      modelStart = modelEnd;
    }
  }
  return models;
}
function splitTable(table, col) {
  const ret = /* @__PURE__ */ new Map();
  const rowCount = table._rowCount;
  let modelStart = 0;
  while (modelStart < rowCount) {
    const modelEnd = findModelEnd(col, modelStart);
    const id = col.value(modelStart);
    ret.set(id, {
      table: Table.window(table, table._schema, modelStart, modelEnd),
      start: modelStart,
      end: modelEnd
    });
    modelStart = modelEnd;
  }
  return ret;
}
async function readIntegrative(ctx, data, properties, format) {
  const entities = getEntityData(data);
  const atom_sites_modelColumn = data.atom_site.ihm_model_id.isDefined ? data.atom_site.ihm_model_id : data.atom_site.pdbx_PDB_model_num;
  const atom_sites = splitTable(data.atom_site, atom_sites_modelColumn);
  const sphere_sites = splitTable(data.ihm_sphere_obj_site, data.ihm_sphere_obj_site.model_id);
  const gauss_sites = splitTable(data.ihm_gaussian_obj_site, data.ihm_gaussian_obj_site.model_id);
  const models = [];
  if (data.ihm_model_list) {
    const { model_id, model_name } = data.ihm_model_list;
    for (let i = 0; i < data.ihm_model_list._rowCount; i++) {
      const id = model_id.value(i);
      let atom_site, atom_site_sourceIndex;
      if (atom_sites.has(id)) {
        const e = atom_sites.get(id);
        const { atom_site: sorted, sourceIndex } = await sortAtomSite(ctx, data.atom_site, e.start, e.end);
        atom_site = sorted;
        atom_site_sourceIndex = sourceIndex;
      } else {
        atom_site = Table.window(data.atom_site, data.atom_site._schema, 0, 0);
        atom_site_sourceIndex = Column.ofIntArray([]);
      }
      const ihm = {
        model_id: id,
        model_name: model_name.value(i),
        model_group_name: getModelGroupName(id, data),
        entities,
        atom_site,
        atom_site_sourceIndex,
        ihm_sphere_obj_site: sphere_sites.has(id) ? sphere_sites.get(id).table : Table.window(data.ihm_sphere_obj_site, data.ihm_sphere_obj_site._schema, 0, 0),
        ihm_gaussian_obj_site: gauss_sites.has(id) ? gauss_sites.get(id).table : Table.window(data.ihm_gaussian_obj_site, data.ihm_gaussian_obj_site._schema, 0, 0)
      };
      const model = createIntegrativeModel(data, ihm, properties, format);
      models.push(model);
    }
  }
  return models;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/model.js
{
}
var Model;
(function(Model2) {
  function _trajectoryFromModelAndCoordinates(model, coordinates) {
    const trajectory = [];
    const { frames } = coordinates;
    const srcIndexArray = getSourceIndexArray(model);
    const coarseGrained = isCoarseGrained(model);
    const elementCount = model.atomicHierarchy.atoms._rowCount;
    for (let i = 0, il = frames.length; i < il; ++i) {
      const f = frames[i];
      if (f.elementCount !== elementCount) {
        throw new Error(`Frame element count mismatch, got ${f.elementCount} but expected ${elementCount}.`);
      }
      const m = {
        ...model,
        id: UUID.create22(),
        modelNum: i,
        atomicConformation: getAtomicConformationFromFrame(model, f),
        // TODO: add support for supplying sphere and gaussian coordinates in addition to atomic coordinates?
        // coarseConformation: coarse.conformation,
        customProperties: new CustomProperties(),
        _staticPropertyData: /* @__PURE__ */ Object.create(null),
        _dynamicPropertyData: /* @__PURE__ */ Object.create(null)
      };
      if (f.cell) {
        const symmetry = ModelSymmetry.fromCell(f.cell.size, f.cell.anglesInRadians);
        ModelSymmetry.Provider.set(m, symmetry);
      }
      Model2.TrajectoryInfo.set(m, { index: i, size: frames.length });
      Model2.CoarseGrained.set(m, coarseGrained);
      trajectory.push(m);
    }
    return { trajectory, srcIndexArray };
  }
  function getSourceIndexArray(model) {
    const srcIndex = model.atomicHierarchy.atomSourceIndex;
    let srcIndexArray = void 0;
    if ("__srcIndexArray__" in model._staticPropertyData) {
      srcIndexArray = model._dynamicPropertyData.__srcIndexArray__;
    } else {
      srcIndexArray = Column.isIdentity(srcIndex) ? void 0 : srcIndex.toArray({ array: Int32Array });
      model._dynamicPropertyData.__srcIndexArray__ = srcIndexArray;
    }
    return srcIndexArray;
  }
  function trajectoryFromModelAndCoordinates(model, coordinates) {
    return new ArrayTrajectory(_trajectoryFromModelAndCoordinates(model, coordinates).trajectory);
  }
  Model2.trajectoryFromModelAndCoordinates = trajectoryFromModelAndCoordinates;
  function trajectoryFromTopologyAndCoordinates(topology, coordinates) {
    return Task.create("Create Trajectory", async (ctx) => {
      const models = await createModels(topology.basic, topology.sourceData, ctx);
      if (models.frameCount === 0)
        throw new Error("found no model");
      const model = models.representative;
      const { trajectory } = _trajectoryFromModelAndCoordinates(model, coordinates);
      const bondData = { pairs: topology.bonds, count: model.atomicHierarchy.atoms._rowCount };
      const indexPairBonds = IndexPairBonds.fromData(bondData);
      const coarseGrained = isCoarseGrained(model);
      let index = 0;
      for (const m of trajectory) {
        IndexPairBonds.Provider.set(m, indexPairBonds);
        Model2.TrajectoryInfo.set(m, { index: index++, size: trajectory.length });
        Model2.CoarseGrained.set(m, coarseGrained);
      }
      return new ArrayTrajectory(trajectory);
    });
  }
  Model2.trajectoryFromTopologyAndCoordinates = trajectoryFromTopologyAndCoordinates;
  function getAtomicConformationFromFrame(model, frame) {
    return Coordinates.getAtomicConformation(frame, {
      atomId: model.atomicConformation.atomId,
      occupancy: model.atomicConformation.occupancy,
      B_iso_or_equiv: model.atomicConformation.B_iso_or_equiv
    }, getSourceIndexArray(model));
  }
  Model2.getAtomicConformationFromFrame = getAtomicConformationFromFrame;
  const CenterProp = "__Center__";
  function getCenter(model) {
    if (model._dynamicPropertyData[CenterProp])
      return model._dynamicPropertyData[CenterProp];
    const center = calcModelCenter(model.atomicConformation, model.coarseConformation);
    model._dynamicPropertyData[CenterProp] = center;
    return center;
  }
  Model2.getCenter = getCenter;
  function invertIndex(xs) {
    const invertedIndex = new Int32Array(xs.rowCount);
    let isIdentity = false;
    for (let i = 0, _i = xs.rowCount; i < _i; i++) {
      const x = xs.value(i);
      if (x !== i)
        isIdentity = false;
      invertedIndex[x] = i;
    }
    return { isIdentity, invertedIndex };
  }
  const InvertedAtomSrcIndexProp = "__InvertedAtomSrcIndex__";
  function getInvertedAtomSourceIndex(model) {
    if (model._staticPropertyData[InvertedAtomSrcIndexProp])
      return model._staticPropertyData[InvertedAtomSrcIndexProp];
    const index = invertIndex(model.atomicHierarchy.atomSourceIndex);
    model._staticPropertyData[InvertedAtomSrcIndexProp] = index;
    return index;
  }
  Model2.getInvertedAtomSourceIndex = getInvertedAtomSourceIndex;
  const TrajectoryInfoProp = "__TrajectoryInfo__";
  Model2.TrajectoryInfo = {
    get(model) {
      return model._dynamicPropertyData[TrajectoryInfoProp] || { index: 0, size: 1 };
    },
    set(model, trajectoryInfo) {
      return model._dynamicPropertyData[TrajectoryInfoProp] = trajectoryInfo;
    }
  };
  const AsymIdCountProp = "__AsymIdCount__";
  Model2.AsymIdCount = {
    get(model) {
      if (model._dynamicPropertyData[AsymIdCountProp])
        return model._dynamicPropertyData[AsymIdCountProp];
      const asymIdCount = getAsymIdCount(model);
      model._dynamicPropertyData[AsymIdCountProp] = asymIdCount;
      return asymIdCount;
    }
  };
  Model2.AsymIdOffset = CustomModelProperty.createSimple("asym_id_offset", "static");
  Model2.Index = CustomModelProperty.createSimple("index", "static");
  Model2.MaxIndex = CustomModelProperty.createSimple("max_index", "static");
  function getRoot(model) {
    return model.parent || model;
  }
  Model2.getRoot = getRoot;
  function areHierarchiesEqual(a, b) {
    return a.atomicHierarchy === b.atomicHierarchy && a.coarseHierarchy === b.coarseHierarchy;
  }
  Model2.areHierarchiesEqual = areHierarchiesEqual;
  const CoordinatesHistoryProp = "__CoordinatesHistory__";
  Model2.CoordinatesHistory = {
    get(model) {
      return model._staticPropertyData[CoordinatesHistoryProp];
    },
    set(model, coordinatesHistory) {
      return model._staticPropertyData[CoordinatesHistoryProp] = coordinatesHistory;
    }
  };
  const CoarseGrainedProp = "__CoarseGrained__";
  Model2.CoarseGrained = {
    get(model) {
      return model._staticPropertyData[CoarseGrainedProp];
    },
    set(model, coarseGrained) {
      return model._staticPropertyData[CoarseGrainedProp] = coarseGrained;
    }
  };
  function isCoarseGrained(model) {
    let coarseGrained = Model2.CoarseGrained.get(model);
    if (coarseGrained === void 0) {
      let polymerResidueCount = 0;
      let polymerDirectionCount = 0;
      const { polymerType, directionToElementIndex } = model.atomicHierarchy.derived.residue;
      for (let i = 0; i < polymerType.length; ++i) {
        if (polymerType[i] !== PolymerType.NA) {
          polymerResidueCount += 1;
          if (directionToElementIndex[i] !== -1)
            polymerDirectionCount += 1;
        }
      }
      let hasBB = false, hasSC1 = false;
      const { label_atom_id, _rowCount: atomCount2 } = model.atomicHierarchy.atoms;
      for (let i = 0; i < atomCount2; ++i) {
        const atomName = label_atom_id.value(i);
        if (!hasBB && atomName === "BB")
          hasBB = true;
        if (!hasSC1 && atomName === "SC1")
          hasSC1 = true;
        if (hasBB && hasSC1)
          break;
      }
      coarseGrained = false;
      if (atomCount2 > 0 && polymerResidueCount > 0) {
        if (hasBB && hasSC1) {
          coarseGrained = true;
        } else if (atomCount2 / polymerResidueCount < 3) {
          coarseGrained = true;
        } else if (polymerDirectionCount === 0) {
          coarseGrained = true;
        }
      }
      Model2.CoarseGrained.set(model, coarseGrained);
    }
    return coarseGrained;
  }
  Model2.isCoarseGrained = isCoarseGrained;
  function hasCarbohydrate(model) {
    return model.properties.saccharideComponentMap.size > 0;
  }
  Model2.hasCarbohydrate = hasCarbohydrate;
  function hasProtein(model) {
    const { subtype } = model.entities;
    for (let i = 0, il = subtype.rowCount; i < il; ++i) {
      if (subtype.value(i).startsWith("polypeptide"))
        return true;
    }
    return false;
  }
  Model2.hasProtein = hasProtein;
  function hasNucleic(model) {
    const { subtype } = model.entities;
    for (let i = 0, il = subtype.rowCount; i < il; ++i) {
      const s = subtype.value(i);
      if (s.endsWith("ribonucleotide hybrid") || s.endsWith("ribonucleotide"))
        return true;
    }
    return false;
  }
  Model2.hasNucleic = hasNucleic;
  function isFromPdbArchive(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    const { db } = model.sourceData.data;
    for (let i = 0, il = db.database_2.database_id.rowCount; i < il; ++i) {
      if (db.database_2.database_id.value(i) === "pdb")
        return true;
    }
    return false;
  }
  Model2.isFromPdbArchive = isFromPdbArchive;
  function hasPdbId(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    return (
      // 4 character PDB id
      model.entryId.match(/^[1-9][a-z0-9]{3,3}$/i) !== null || // long PDB id
      model.entryId.match(/^pdb_[0-9]{4,4}[1-9][a-z0-9]{3,3}$/i) !== null
    );
  }
  Model2.hasPdbId = hasPdbId;
  function hasSecondaryStructure(model) {
    if (MmcifFormat.is(model.sourceData)) {
      const { db } = model.sourceData.data;
      return db.struct_conf.id.isDefined || db.struct_sheet_range.id.isDefined;
    } else {
      return ModelSecondaryStructure.Provider.isApplicable(model);
    }
  }
  Model2.hasSecondaryStructure = hasSecondaryStructure;
  const tmpAngles90 = Vec3.create(1.5707963, 1.5707963, 1.5707963);
  const tmpLengths1 = Vec3.create(1, 1, 1);
  function hasCrystalSymmetry(model) {
    var _a;
    const spacegroup = (_a = ModelSymmetry.Provider.get(model)) === null || _a === void 0 ? void 0 : _a.spacegroup;
    return !!spacegroup && !(spacegroup.num === 1 && Vec3.equals(spacegroup.cell.anglesInRadians, tmpAngles90) && Vec3.equals(spacegroup.cell.size, tmpLengths1));
  }
  Model2.hasCrystalSymmetry = hasCrystalSymmetry;
  function isFromXray(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    const { db } = model.sourceData.data;
    for (let i = 0; i < db.exptl.method.rowCount; i++) {
      const v = db.exptl.method.value(i).toUpperCase();
      if (v.indexOf("DIFFRACTION") >= 0)
        return true;
    }
    return false;
  }
  Model2.isFromXray = isFromXray;
  function isFromEm(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    const { db } = model.sourceData.data;
    for (let i = 0; i < db.exptl.method.rowCount; i++) {
      const v = db.exptl.method.value(i).toUpperCase();
      if (v.indexOf("MICROSCOPY") >= 0)
        return true;
    }
    return false;
  }
  Model2.isFromEm = isFromEm;
  function isFromNmr(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    const { db } = model.sourceData.data;
    for (let i = 0; i < db.exptl.method.rowCount; i++) {
      const v = db.exptl.method.value(i).toUpperCase();
      if (v.indexOf("NMR") >= 0)
        return true;
    }
    return false;
  }
  Model2.isFromNmr = isFromNmr;
  function isExperimental(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    const { db } = model.sourceData.data;
    for (let i = 0; i < db.struct.pdbx_structure_determination_methodology.rowCount; i++) {
      if (db.struct.pdbx_structure_determination_methodology.value(i).toLowerCase() === "experimental")
        return true;
    }
    return false;
  }
  Model2.isExperimental = isExperimental;
  function isIntegrative(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    const { db } = model.sourceData.data;
    for (let i = 0; i < db.struct.pdbx_structure_determination_methodology.rowCount; i++) {
      if (db.struct.pdbx_structure_determination_methodology.value(i).toLowerCase() === "integrative")
        return true;
    }
    return false;
  }
  Model2.isIntegrative = isIntegrative;
  function isComputational(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    const { db } = model.sourceData.data;
    for (let i = 0; i < db.struct.pdbx_structure_determination_methodology.rowCount; i++) {
      if (db.struct.pdbx_structure_determination_methodology.value(i).toLowerCase() === "computational")
        return true;
    }
    return false;
  }
  Model2.isComputational = isComputational;
  function hasXrayMap(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    if (!isFromXray(model))
      return false;
    const { db } = model.sourceData.data;
    const { status_code_sf } = db.pdbx_database_status;
    return status_code_sf.isDefined && status_code_sf.value(0) === "REL";
  }
  Model2.hasXrayMap = hasXrayMap;
  function hasEmMap(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    const { db } = model.sourceData.data;
    const { db_name, content_type } = db.pdbx_database_related;
    for (let i = 0, il = db.pdbx_database_related._rowCount; i < il; ++i) {
      if (db_name.value(i).toUpperCase() === "EMDB" && content_type.value(i) === "associated EM volume") {
        return true;
      }
    }
    return false;
  }
  Model2.hasEmMap = hasEmMap;
  function hasDensityMap(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    return hasXrayMap(model) || hasEmMap(model);
  }
  Model2.hasDensityMap = hasDensityMap;
  function probablyHasDensityMap(model) {
    if (!MmcifFormat.is(model.sourceData))
      return false;
    if (Model2.isIntegrative(model))
      return false;
    const { db } = model.sourceData.data;
    return hasDensityMap(model) || // check if from pdb archive but missing relevant meta data
    hasPdbId(model) && (!db.exptl.method.isDefined || isFromXray(model) && (!db.pdbx_database_status.status_code_sf.isDefined || db.pdbx_database_status.status_code_sf.valueKind(0) === Column.ValueKinds.Unknown) || isFromEm(model) && !db.pdbx_database_related.db_name.isDefined);
  }
  Model2.probablyHasDensityMap = probablyHasDensityMap;
})(Model || (Model = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/model/properties/custom/indexed.js
var IndexedCustomProperty;
(function(IndexedCustomProperty2) {
  function getCifDataSource(structure, prop, cache) {
    if (!prop)
      return { rowCount: 0 };
    if (cache && cache[prop.id])
      return cache[prop.id];
    const data = prop.getElements(structure);
    const ret = { data, rowCount: data.elements.length };
    if (cache)
      cache[prop.id] = ret;
    return ret;
  }
  IndexedCustomProperty2.getCifDataSource = getCifDataSource;
  function fromAtomMap(map2) {
    return new ElementMappedCustomProperty(map2);
  }
  IndexedCustomProperty2.fromAtomMap = fromAtomMap;
  function fromAtomArray(array2) {
    return new ElementMappedCustomProperty(arrayToMap(array2));
  }
  IndexedCustomProperty2.fromAtomArray = fromAtomArray;
  const getResidueSegments = (model) => model.atomicHierarchy.residueAtomSegments;
  function fromResidueMap(map2) {
    return new SegmentedMappedIndexedCustomProperty("residue", map2, getResidueSegments, Unit.Kind.Atomic);
  }
  IndexedCustomProperty2.fromResidueMap = fromResidueMap;
  function fromResidueArray(array2) {
    return new SegmentedMappedIndexedCustomProperty("residue", arrayToMap(array2), getResidueSegments, Unit.Kind.Atomic);
  }
  IndexedCustomProperty2.fromResidueArray = fromResidueArray;
  const getChainSegments = (model) => model.atomicHierarchy.chainAtomSegments;
  function fromChainMap(map2) {
    return new SegmentedMappedIndexedCustomProperty("chain", map2, getChainSegments, Unit.Kind.Atomic);
  }
  IndexedCustomProperty2.fromChainMap = fromChainMap;
  function fromChainArray(array2) {
    return new SegmentedMappedIndexedCustomProperty("chain", arrayToMap(array2), getChainSegments, Unit.Kind.Atomic);
  }
  IndexedCustomProperty2.fromChainArray = fromChainArray;
  function fromEntityMap(map2) {
    return new EntityMappedCustomProperty(map2);
  }
  IndexedCustomProperty2.fromEntityMap = fromEntityMap;
})(IndexedCustomProperty || (IndexedCustomProperty = {}));
function arrayToMap(array2) {
  const ret = /* @__PURE__ */ new Map();
  for (let i = 0, _i = array2.length; i < _i; i++)
    ret.set(i, array2[i]);
  return ret;
}
var SegmentedMappedIndexedCustomProperty = class {
  has(idx) {
    return this.map.has(idx);
  }
  get(idx) {
    return this.map.get(idx);
  }
  getStructureElements(structure) {
    const models = structure.models;
    if (models.length !== 1)
      throw new Error(`Only works on structures with a single model.`);
    const seenIndices = /* @__PURE__ */ new Set();
    const unitGroups = structure.unitSymmetryGroups;
    const loci = [];
    const segments = this.segmentGetter(models[0]);
    for (const unitGroup of unitGroups) {
      const unit2 = unitGroup.units[0];
      if (unit2.kind !== this.kind) {
        continue;
      }
      const chains2 = Segmentation.transientSegments(segments, unit2.elements);
      while (chains2.hasNext) {
        const seg = chains2.move();
        if (!this.has(seg.index) || seenIndices.has(seg.index))
          continue;
        seenIndices.add(seg.index);
        loci[loci.length] = element_exports.Location.create(structure, unit2, unit2.elements[seg.start]);
      }
    }
    loci.sort((x, y) => x.element - y.element);
    return loci;
  }
  getElements(structure) {
    const index = this.segmentGetter(structure.model).index;
    const elements = this.getStructureElements(structure);
    return { elements, property: (i) => this.get(index[elements[i].element]) };
  }
  constructor(level, map2, segmentGetter, kind) {
    this.level = level;
    this.map = map2;
    this.segmentGetter = segmentGetter;
    this.id = UUID.create22();
    this.kind = kind;
  }
};
var ElementMappedCustomProperty = class {
  has(idx) {
    return this.map.has(idx);
  }
  get(idx) {
    return this.map.get(idx);
  }
  getStructureElements(structure) {
    const models = structure.models;
    if (models.length !== 1)
      throw new Error(`Only works on structures with a single model.`);
    const seenIndices = /* @__PURE__ */ new Set();
    const unitGroups = structure.unitSymmetryGroups;
    const loci = [];
    for (const unitGroup of unitGroups) {
      const unit2 = unitGroup.units[0];
      if (unit2.kind !== this.kind) {
        continue;
      }
      const elements = unit2.elements;
      for (let i = 0, _i = elements.length; i < _i; i++) {
        const e = elements[i];
        if (!this.has(e) || seenIndices.has(e))
          continue;
        seenIndices.add(elements[i]);
        loci[loci.length] = element_exports.Location.create(structure, unit2, e);
      }
    }
    loci.sort((x, y) => x.element - y.element);
    return loci;
  }
  getElements(structure) {
    const elements = this.getStructureElements(structure);
    return { elements, property: (i) => this.get(elements[i].element) };
  }
  constructor(map2) {
    this.map = map2;
    this.id = UUID.create22();
    this.level = "atom";
    this.kind = Unit.Kind.Atomic;
  }
};
var EntityMappedCustomProperty = class {
  has(idx) {
    return this.map.has(idx);
  }
  get(idx) {
    return this.map.get(idx);
  }
  getStructureElements(structure) {
    const models = structure.models;
    if (models.length !== 1)
      throw new Error(`Only works on structures with a single model.`);
    const index = models[0].atomicHierarchy.index;
    const seenIndices = /* @__PURE__ */ new Set();
    const unitGroups = structure.unitSymmetryGroups;
    const loci = [];
    const segments = models[0].atomicHierarchy.chainAtomSegments;
    for (const unitGroup of unitGroups) {
      const unit2 = unitGroup.units[0];
      if (unit2.kind !== this.kind) {
        continue;
      }
      const chains2 = Segmentation.transientSegments(segments, unit2.elements);
      while (chains2.hasNext) {
        const seg = chains2.move();
        const eI = index.getEntityFromChain(seg.index);
        if (!this.has(eI) || seenIndices.has(eI))
          continue;
        seenIndices.add(eI);
        loci[loci.length] = element_exports.Location.create(structure, unit2, unit2.elements[seg.start]);
      }
    }
    loci.sort((x, y) => x.element - y.element);
    return loci;
  }
  getElements(structure) {
    const elements = this.getStructureElements(structure);
    const chainIndex2 = structure.model.atomicHierarchy.chainAtomSegments.index;
    const index = structure.model.atomicHierarchy.index;
    return { elements, property: (i) => this.get(index.getEntityFromChain(chainIndex2[elements[i].element])) };
  }
  constructor(map2) {
    this.map = map2;
    this.id = UUID.create22();
    this.level = "entity";
    this.kind = Unit.Kind.Atomic;
  }
};

export {
  StringLike,
  utf8Write,
  utf8Read,
  utf8ReadLong,
  utf8ByteCount,
  Scheduler,
  isProductionMode,
  isDebugMode,
  isTimingMode,
  addConsoleStatsProvider,
  removeConsoleStatsProvider,
  CreateObservableCtx,
  ExecuteInContext,
  Task,
  chunkedSubtask,
  RUNNING_IN_NODEJS,
  unzip,
  ungzip,
  Zip,
  readFromFile,
  ajaxGet,
  ajaxGetMany,
  Asset,
  AssetManager,
  ParamDefinition,
  arrayMax,
  arrayMin,
  arrayMinMax,
  arraySum,
  arrayMean,
  arrayRms,
  fillSerial,
  arrayRemoveInPlace,
  arrayRemoveAtInPlace,
  arraySetAdd,
  arraySetRemove,
  arrayIntersectionSize,
  arrayEqual2 as arrayEqual,
  arrayMapUpsert,
  range,
  arrayExtend,
  sortIfNeeded,
  filterInPlace,
  arrayDistinct,
  LinkedList,
  UniqueArray,
  Axes3D,
  Matrix,
  PrincipalAxes,
  Sphere3D,
  Box3D,
  memoizeLatest,
  memoize1,
  GridLookup3D,
  Time,
  Coordinates,
  Topology,
  CustomPropertyDescriptor,
  CustomProperties,
  IntAdjacencyGraph,
  FormatPropertyProvider,
  SaccharideShape,
  SaccharideColors,
  getSaccharideShape,
  MonosaccharidesColorTable,
  setSaccharideCompIdMapType,
  SetUtils,
  ElementSymbol,
  getElementFromAtomicNumber,
  MoleculeType,
  ProteinBackboneAtoms,
  NucleicBackboneAtoms,
  WaterNames,
  AminoAcidNamesL,
  AminoAcidNames,
  CommonProteinCaps,
  RnaBaseNames,
  DnaBaseNames,
  BaseNames,
  isPurineBase,
  isPyrimidineBase,
  PolymerNames,
  getMoleculeType,
  isPolymer,
  isNucleic,
  SecondaryStructureType,
  BondType,
  ResidueHydrophobicity,
  types_exports,
  IndexPairBonds,
  TokenColumnProvider,
  TokenColumn,
  areTokensEmpty,
  CifFile,
  CifBlock,
  CifCategory,
  CifField,
  toTable,
  fillGridDim,
  SymmetryOperator,
  SpacegroupCell,
  Spacegroup,
  Type,
  Expression,
  Argument,
  Arguments,
  MSymbol,
  CustomPropSymbol,
  Types2 as Types,
  MolScriptSymbolTable,
  MolScriptBuilder,
  CentroidHelper,
  InterUnitGraph,
  MetalsSet,
  getElementIdx,
  isHydrogen,
  uint8ToString,
  integerDigitCount,
  isInteger,
  getPrecision,
  toPrecision,
  StructConn,
  Bond,
  AtomicNumbers,
  VdwRadius,
  AtomWeight,
  AtomNumber,
  Elements,
  ElementNames,
  isHalogen,
  isTransitionMetal,
  isMetal,
  getElementMoleculeType,
  UnitRings,
  UnitRing,
  SortedRanges,
  BoundaryHelper,
  getBoundary,
  Symmetry,
  ModelSymmetry,
  Unit,
  StructureLookup3DResultContext,
  structureUnion,
  structureAreEqual,
  structureAreIntersecting,
  structureIntersect,
  structureSubtract,
  StructureSelection,
  bundleElementImpl,
  bundleGenerator,
  QueryContext,
  StructureQuery,
  CustomStructureProperty,
  SecondaryStructureProvider,
  StructureProperties,
  Queries,
  StructureSymmetry,
  Structure,
  DefaultQueryRuntimeTable,
  QueryRuntimeArguments,
  QuerySymbolRuntime,
  compile,
  element_exports,
  Tokenizer,
  trimStr,
  TokenBuilder,
  ReaderResult,
  decodeMsgPack,
  CIF,
  AtomSiteAnisotrop,
  GlobalModelTransformInfo,
  BasicSchema,
  createBasic,
  EntityBuilder,
  ComponentBuilder,
  MmcifFormat,
  trajectoryFromMmCIF,
  trajectoryFromCCD,
  CustomModelProperty,
  SIFTSMapping,
  CifExportContext,
  mmCIF_Export_Filters,
  encode_mmCIF_categories,
  to_mmCIF,
  StructureSequence,
  ArrayTrajectory,
  createModels,
  Model,
  IndexedCustomProperty
};
//# sourceMappingURL=chunk-HZ3UTCAK.js.map
