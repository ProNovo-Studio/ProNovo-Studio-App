import {
  AminoAcidNamesL,
  Argument,
  Arguments,
  ArrayTrajectory,
  Asset,
  AtomNumber,
  AtomSiteAnisotrop,
  AtomWeight,
  AtomicNumbers,
  Axes3D,
  BasicSchema,
  Bond,
  BondType,
  BoundaryHelper,
  Box3D,
  CIF,
  CentroidHelper,
  CifCategory,
  CifField,
  CommonProteinCaps,
  ComponentBuilder,
  Coordinates,
  CustomProperties,
  DefaultQueryRuntimeTable,
  DnaBaseNames,
  ElementNames,
  ElementSymbol,
  Elements,
  EntityBuilder,
  Expression,
  FormatPropertyProvider,
  GridLookup3D,
  IndexPairBonds,
  LinkedList,
  MSymbol,
  MmcifFormat,
  Model,
  ModelSymmetry,
  MolScriptBuilder,
  MolScriptSymbolTable,
  MoleculeType,
  MonosaccharidesColorTable,
  NucleicBackboneAtoms,
  ParamDefinition,
  PolymerNames,
  ProteinBackboneAtoms,
  Queries,
  QueryContext,
  QueryRuntimeArguments,
  QuerySymbolRuntime,
  RUNNING_IN_NODEJS,
  ReaderResult,
  ResidueHydrophobicity,
  RnaBaseNames,
  SaccharideColors,
  Scheduler,
  SecondaryStructureProvider,
  SecondaryStructureType,
  SetUtils,
  Spacegroup,
  SpacegroupCell,
  Sphere3D,
  StringLike,
  Structure,
  StructureLookup3DResultContext,
  StructureProperties,
  StructureSelection,
  StructureSymmetry,
  Symmetry,
  SymmetryOperator,
  Task,
  Time,
  TokenBuilder,
  TokenColumn,
  TokenColumnProvider,
  Tokenizer,
  Topology,
  Type,
  Types,
  UniqueArray,
  Unit,
  UnitRing,
  VdwRadius,
  WaterNames,
  Zip,
  addConsoleStatsProvider,
  ajaxGetMany,
  areTokensEmpty,
  arrayEqual,
  arrayMapUpsert,
  arrayMax,
  arrayMean,
  arrayMin,
  arrayMinMax,
  arrayRemoveInPlace,
  arrayRms,
  arraySetAdd,
  arraySetRemove,
  bundleElementImpl,
  bundleGenerator,
  chunkedSubtask,
  compile,
  createBasic,
  createModels,
  decodeMsgPack,
  element_exports,
  fillSerial,
  getBoundary,
  getElementFromAtomicNumber,
  getElementMoleculeType,
  getMoleculeType,
  getPrecision,
  integerDigitCount,
  isDebugMode,
  isInteger,
  isTimingMode,
  memoize1,
  readFromFile,
  removeConsoleStatsProvider,
  toPrecision,
  trajectoryFromCCD,
  trajectoryFromMmCIF,
  trimStr,
  uint8ToString,
  ungzip,
  utf8ByteCount,
  utf8Read,
  utf8ReadLong,
  utf8Write
} from "./chunk-HZ3UTCAK.js";
import {
  ColorNames
} from "./chunk-Y4JRF7OT.js";
import {
  BitFlags,
  ChunkedArray,
  Color,
  ColorLists,
  ColorMap,
  ColorScale,
  Column,
  EPSILON,
  Hcl,
  IntMap,
  Interval,
  Lab,
  Mat3,
  Mat4,
  ObjectKeys,
  OrderedSet,
  Quat,
  Segmentation,
  SortedArray,
  Table,
  TableLegend,
  Tensor,
  UUID,
  ValueCell,
  Vec2,
  Vec3,
  Vec4,
  absMax,
  arcLength,
  assertUnreachable,
  assignIfUndefined,
  camelCaseToWords,
  cantorPairing,
  capitalize,
  clamp,
  column_helpers_exports,
  deepClone,
  deepEqual,
  defaults,
  degToRad,
  equalEps,
  escapeRegExp,
  formatTimespan,
  getAdjustedColorMap,
  getColorListFromName,
  halfPI,
  hash1,
  hash2,
  hashFnv32a,
  hashString,
  idFactory,
  interpolate,
  invertCantorPairing,
  isPowerOfTwo,
  isPromiseLike,
  lerp,
  noop,
  normalize,
  now,
  objectForEach,
  parseFloat as parseFloat2,
  parseFloatSkipLeadingWhitespace,
  parseIntSkipLeadingWhitespace,
  radToDeg,
  shallowEqual,
  shallowEqual2,
  shallowEqualObjects,
  shallowMergeArray,
  smoothstep,
  sortedCantorPairing,
  spiral2d,
  spline,
  stringToWords,
  stripTags,
  substringStartsWith,
  upperCaseAny
} from "./chunk-TA3F3DCY.js";
import {
  __export
} from "./chunk-WOOG5QLI.js";

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-state/object.js
var StateObject;
(function(StateObject2) {
  function factory() {
    return (type) => create(type);
  }
  StateObject2.factory = factory;
  function create(type) {
    var _a;
    return _a = class O {
      static is(obj) {
        return !!obj && type === obj.type;
      }
      constructor(data, props) {
        this.data = data;
        this.id = UUID.create22();
        this.type = type;
        this.label = props && props.label || type.name;
        this.description = props && props.description;
      }
    }, _a.type = type, _a;
  }
  StateObject2.create = create;
  function hasTag(o, t2) {
    if (!o.tags)
      return false;
    for (const s of o.tags) {
      if (s === t2)
        return true;
    }
    return false;
  }
  StateObject2.hasTag = hasTag;
  StateObject2.Null = {
    id: UUID.create22(),
    type: { name: "Null", typeClass: "Null" },
    data: void 0,
    label: "Null"
  };
})(StateObject || (StateObject = {}));
var StateObjectCell;
(function(StateObjectCell2) {
  function is3(o) {
    const c5 = o;
    return !!c5 && !!c5.transform && !!c5.parent && !!c5.status;
  }
  StateObjectCell2.is = is3;
  function resolve(state, refOrCellOrSelector) {
    const ref = typeof refOrCellOrSelector === "string" ? refOrCellOrSelector : StateObjectCell2.is(refOrCellOrSelector) ? refOrCellOrSelector.transform.ref : refOrCellOrSelector.ref;
    return state.cells.get(ref);
  }
  StateObjectCell2.resolve = resolve;
})(StateObjectCell || (StateObjectCell = {}));
var StateObjectSelector = class {
  get cell() {
    var _a;
    return (_a = this.state) === null || _a === void 0 ? void 0 : _a.cells.get(this.ref);
  }
  get obj() {
    var _a, _b;
    return (_b = (_a = this.state) === null || _a === void 0 ? void 0 : _a.cells.get(this.ref)) === null || _b === void 0 ? void 0 : _b.obj;
  }
  get data() {
    var _a;
    return (_a = this.obj) === null || _a === void 0 ? void 0 : _a.data;
  }
  update(params, builder) {
    if (!this.state)
      throw new Error(`To use update() from StateObjectSelector, 'state' must be defined.`);
    if (!builder)
      builder = this.state.build();
    (builder || this.state.build()).to(this).update(params);
    return builder;
  }
  /** Checks if the object exists. If not throw an error. */
  checkValid() {
    if (!this.state) {
      throw new Error("Unassigned State.");
    }
    const cell = this.cell;
    if (!cell) {
      throw new Error(`Not created at all. Did you await/then the corresponding state update?`);
    }
    if (cell.status === "ok")
      return true;
    if (cell.status === "error")
      throw new Error(cell.errorText);
    if (cell.obj === StateObject.Null)
      throw new Error("The object is Null.");
    throw new Error(`Unresolved. Did you await/then the corresponding state update?`);
  }
  get isOk() {
    const cell = this.cell;
    return cell && cell.status === "ok" && cell.obj !== StateObject.Null;
  }
  constructor(ref, state) {
    this.ref = ref;
    this.state = state;
  }
};
var StateObjectRef;
(function(StateObjectRef2) {
  function resolveRef(ref) {
    var _a;
    if (!ref)
      return;
    if (typeof ref === "string")
      return ref;
    if (StateObjectCell.is(ref))
      return ref.transform.ref;
    return (_a = ref.cell) === null || _a === void 0 ? void 0 : _a.transform.ref;
  }
  StateObjectRef2.resolveRef = resolveRef;
  function resolve(state, ref) {
    if (!ref)
      return;
    if (StateObjectCell.is(ref))
      return ref;
    if (typeof ref === "string")
      return state.cells.get(ref);
    return ref.cell;
  }
  StateObjectRef2.resolve = resolve;
  function resolveAndCheck(state, ref) {
    const cell = resolve(state, ref);
    if (!cell || !cell.obj || cell.status !== "ok")
      return;
    return cell;
  }
  StateObjectRef2.resolveAndCheck = resolveAndCheck;
})(StateObjectRef || (StateObjectRef = {}));

// ../node_modules/.pnpm/immutable@5.1.4/node_modules/immutable/dist/immutable.es.js
var IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
function isIndexed(maybeIndexed) {
  return Boolean(maybeIndexed && // @ts-expect-error: maybeIndexed is typed as `{}`, need to change in 6.0 to `maybeIndexed && typeof maybeIndexed === 'object' && IS_INDEXED_SYMBOL in maybeIndexed`
  maybeIndexed[IS_INDEXED_SYMBOL]);
}
var IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
function isKeyed(maybeKeyed) {
  return Boolean(maybeKeyed && // @ts-expect-error: maybeKeyed is typed as `{}`, need to change in 6.0 to `maybeKeyed && typeof maybeKeyed === 'object' && IS_KEYED_SYMBOL in maybeKeyed`
  maybeKeyed[IS_KEYED_SYMBOL]);
}
function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isCollection(maybeCollection) {
  return Boolean(maybeCollection && // @ts-expect-error: maybeCollection is typed as `{}`, need to change in 6.0 to `maybeCollection && typeof maybeCollection === 'object' && IS_COLLECTION_SYMBOL in maybeCollection`
  maybeCollection[IS_COLLECTION_SYMBOL]);
}
var Collection = function Collection2(value) {
  return isCollection(value) ? value : Seq(value);
};
var KeyedCollection = function(Collection3) {
  function KeyedCollection2(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }
  if (Collection3) KeyedCollection2.__proto__ = Collection3;
  KeyedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  KeyedCollection2.prototype.constructor = KeyedCollection2;
  return KeyedCollection2;
}(Collection);
var IndexedCollection = function(Collection3) {
  function IndexedCollection2(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }
  if (Collection3) IndexedCollection2.__proto__ = Collection3;
  IndexedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  IndexedCollection2.prototype.constructor = IndexedCollection2;
  return IndexedCollection2;
}(Collection);
var SetCollection = function(Collection3) {
  function SetCollection2(value) {
    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
  }
  if (Collection3) SetCollection2.__proto__ = Collection3;
  SetCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  SetCollection2.prototype.constructor = SetCollection2;
  return SetCollection2;
}(Collection);
Collection.Keyed = KeyedCollection;
Collection.Indexed = IndexedCollection;
Collection.Set = SetCollection;
var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;
var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = "@@iterator";
var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
var Iterator2 = function Iterator3(next) {
  this.next = next;
};
Iterator2.prototype.toString = function toString() {
  return "[Iterator]";
};
Iterator2.KEYS = ITERATE_KEYS;
Iterator2.VALUES = ITERATE_VALUES;
Iterator2.ENTRIES = ITERATE_ENTRIES;
Iterator2.prototype.inspect = Iterator2.prototype.toSource = function() {
  return this.toString();
};
Iterator2.prototype[ITERATOR_SYMBOL] = function() {
  return this;
};
function iteratorValue(type, k, v3, iteratorResult) {
  var value = type === ITERATE_KEYS ? k : type === ITERATE_VALUES ? v3 : [k, v3];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    // @ts-expect-error ensure value is not undefined
    value,
    done: false
  };
  return iteratorResult;
}
function iteratorDone() {
  return { value: void 0, done: true };
}
function hasIterator(maybeIterable) {
  if (Array.isArray(maybeIterable)) {
    return true;
  }
  return !!getIteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
  return !!(maybeIterator && // @ts-expect-error: maybeIterator is typed as `{}`
  typeof maybeIterator.next === "function");
}
function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}
function getIteratorFn(iterable) {
  var iteratorFn = iterable && // @ts-expect-error: maybeIterator is typed as `{}`
  (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || // @ts-expect-error: maybeIterator is typed as `{}`
  iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === "function") {
    return iteratorFn;
  }
}
function isEntriesIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.entries;
}
function isKeysIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.keys;
}
var DELETE = "delete";
var SHIFT = 5;
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;
var NOT_SET = {};
function MakeRef() {
  return { value: false };
}
function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}
function OwnerID() {
}
function ensureSize(iter) {
  if (iter.size === void 0) {
    iter.size = iter.__iterate(returnTrue);
  }
  return iter.size;
}
function wrapIndex(iter, index) {
  if (typeof index !== "number") {
    var uint32Index = index >>> 0;
    if ("" + uint32Index !== index || uint32Index === 4294967295) {
      return NaN;
    }
    index = uint32Index;
  }
  return index < 0 ? ensureSize(iter) + index : index;
}
function returnTrue() {
  return true;
}
function wholeSlice(begin, end, size) {
  return (begin === 0 && !isNeg(begin) || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
}
function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}
function resolveEnd(end, size) {
  return resolveIndex(end, size, size);
}
function resolveIndex(index, size, defaultIndex) {
  return index === void 0 ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === void 0 || size === index ? index : Math.min(size, index) | 0;
}
function isNeg(value) {
  return value < 0 || value === 0 && 1 / value === -Infinity;
}
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
function isRecord(maybeRecord) {
  return Boolean(maybeRecord && // @ts-expect-error: maybeRecord is typed as `{}`, need to change in 6.0 to `maybeRecord && typeof maybeRecord === 'object' && IS_RECORD_SYMBOL in maybeRecord`
  maybeRecord[IS_RECORD_SYMBOL]);
}
function isImmutable(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}
var IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
function isOrdered(maybeOrdered) {
  return Boolean(maybeOrdered && // @ts-expect-error: maybeOrdered is typed as `{}`, need to change in 6.0 to `maybeOrdered && typeof maybeOrdered === 'object' && IS_ORDERED_SYMBOL in maybeOrdered`
  maybeOrdered[IS_ORDERED_SYMBOL]);
}
var IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
function isSeq(maybeSeq) {
  return Boolean(maybeSeq && // @ts-expect-error: maybeSeq is typed as `{}`, need to change in 6.0 to `maybeSeq && typeof maybeSeq === 'object' && MAYBE_SEQ_SYMBOL in maybeSeq`
  maybeSeq[IS_SEQ_SYMBOL]);
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isArrayLike(value) {
  if (Array.isArray(value) || typeof value === "string") {
    return true;
  }
  return value && typeof value === "object" && // @ts-expect-error check that `'length' in value &&`
  Number.isInteger(value.length) && // @ts-expect-error check that `'length' in value &&`
  value.length >= 0 && // @ts-expect-error check that `'length' in value &&`
  (value.length === 0 ? (
    // Only {length: 0} is considered Array-like.
    Object.keys(value).length === 1
  ) : (
    // An object is only Array-like if it has a property where the last value
    // in the array-like may be found (which could be undefined).
    // @ts-expect-error check that `'length' in value &&`
    value.hasOwnProperty(value.length - 1)
  ));
}
var Seq = function(Collection3) {
  function Seq2(value) {
    return value === void 0 || value === null ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
  }
  if (Collection3) Seq2.__proto__ = Collection3;
  Seq2.prototype = Object.create(Collection3 && Collection3.prototype);
  Seq2.prototype.constructor = Seq2;
  Seq2.prototype.toSeq = function toSeq3() {
    return this;
  };
  Seq2.prototype.toString = function toString5() {
    return this.__toString("Seq {", "}");
  };
  Seq2.prototype.cacheResult = function cacheResult() {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }
    return this;
  };
  Seq2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i = 0;
      while (i !== size) {
        var entry = cache[reverse3 ? size - ++i : i++];
        if (fn(entry[1], entry[0], this) === false) {
          break;
        }
      }
      return i;
    }
    return this.__iterateUncached(fn, reverse3);
  };
  Seq2.prototype.__iterator = function __iterator2(type, reverse3) {
    var cache = this._cache;
    if (cache) {
      var size = cache.length;
      var i = 0;
      return new Iterator2(function() {
        if (i === size) {
          return iteratorDone();
        }
        var entry = cache[reverse3 ? size - ++i : i++];
        return iteratorValue(type, entry[0], entry[1]);
      });
    }
    return this.__iteratorUncached(type, reverse3);
  };
  return Seq2;
}(Collection);
var KeyedSeq = function(Seq2) {
  function KeyedSeq2(value) {
    return value === void 0 || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
  }
  if (Seq2) KeyedSeq2.__proto__ = Seq2;
  KeyedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  KeyedSeq2.prototype.constructor = KeyedSeq2;
  KeyedSeq2.prototype.toKeyedSeq = function toKeyedSeq3() {
    return this;
  };
  return KeyedSeq2;
}(Seq);
var IndexedSeq = function(Seq2) {
  function IndexedSeq2(value) {
    return value === void 0 || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
  }
  if (Seq2) IndexedSeq2.__proto__ = Seq2;
  IndexedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  IndexedSeq2.prototype.constructor = IndexedSeq2;
  IndexedSeq2.of = function of2() {
    return IndexedSeq2(arguments);
  };
  IndexedSeq2.prototype.toIndexedSeq = function toIndexedSeq2() {
    return this;
  };
  IndexedSeq2.prototype.toString = function toString5() {
    return this.__toString("Seq [", "]");
  };
  return IndexedSeq2;
}(Seq);
var SetSeq = function(Seq2) {
  function SetSeq2(value) {
    return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
  }
  if (Seq2) SetSeq2.__proto__ = Seq2;
  SetSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  SetSeq2.prototype.constructor = SetSeq2;
  SetSeq2.of = function of2() {
    return SetSeq2(arguments);
  };
  SetSeq2.prototype.toSetSeq = function toSetSeq2() {
    return this;
  };
  return SetSeq2;
}(Seq);
Seq.isSeq = isSeq;
Seq.Keyed = KeyedSeq;
Seq.Set = SetSeq;
Seq.Indexed = IndexedSeq;
Seq.prototype[IS_SEQ_SYMBOL] = true;
var ArraySeq = function(IndexedSeq2) {
  function ArraySeq2(array) {
    this._array = array;
    this.size = array.length;
  }
  if (IndexedSeq2) ArraySeq2.__proto__ = IndexedSeq2;
  ArraySeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ArraySeq2.prototype.constructor = ArraySeq2;
  ArraySeq2.prototype.get = function get11(index, notSetValue) {
    return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
  };
  ArraySeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var array = this._array;
    var size = array.length;
    var i = 0;
    while (i !== size) {
      var ii = reverse3 ? size - ++i : i++;
      if (fn(array[ii], ii, this) === false) {
        break;
      }
    }
    return i;
  };
  ArraySeq2.prototype.__iterator = function __iterator2(type, reverse3) {
    var array = this._array;
    var size = array.length;
    var i = 0;
    return new Iterator2(function() {
      if (i === size) {
        return iteratorDone();
      }
      var ii = reverse3 ? size - ++i : i++;
      return iteratorValue(type, ii, array[ii]);
    });
  };
  return ArraySeq2;
}(IndexedSeq);
var ObjectSeq = function(KeyedSeq2) {
  function ObjectSeq2(object) {
    var keys2 = Object.keys(object).concat(
      Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []
    );
    this._object = object;
    this._keys = keys2;
    this.size = keys2.length;
  }
  if (KeyedSeq2) ObjectSeq2.__proto__ = KeyedSeq2;
  ObjectSeq2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ObjectSeq2.prototype.constructor = ObjectSeq2;
  ObjectSeq2.prototype.get = function get11(key2, notSetValue) {
    if (notSetValue !== void 0 && !this.has(key2)) {
      return notSetValue;
    }
    return this._object[key2];
  };
  ObjectSeq2.prototype.has = function has6(key2) {
    return hasOwnProperty.call(this._object, key2);
  };
  ObjectSeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var object = this._object;
    var keys2 = this._keys;
    var size = keys2.length;
    var i = 0;
    while (i !== size) {
      var key2 = keys2[reverse3 ? size - ++i : i++];
      if (fn(object[key2], key2, this) === false) {
        break;
      }
    }
    return i;
  };
  ObjectSeq2.prototype.__iterator = function __iterator2(type, reverse3) {
    var object = this._object;
    var keys2 = this._keys;
    var size = keys2.length;
    var i = 0;
    return new Iterator2(function() {
      if (i === size) {
        return iteratorDone();
      }
      var key2 = keys2[reverse3 ? size - ++i : i++];
      return iteratorValue(type, key2, object[key2]);
    });
  };
  return ObjectSeq2;
}(KeyedSeq);
ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
var CollectionSeq = function(IndexedSeq2) {
  function CollectionSeq2(collection) {
    this._collection = collection;
    this.size = collection.length || collection.size;
  }
  if (IndexedSeq2) CollectionSeq2.__proto__ = IndexedSeq2;
  CollectionSeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  CollectionSeq2.prototype.constructor = CollectionSeq2;
  CollectionSeq2.prototype.__iterateUncached = function __iterateUncached(fn, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var collection = this._collection;
    var iterator2 = getIterator(collection);
    var iterations = 0;
    if (isIterator(iterator2)) {
      var step;
      while (!(step = iterator2.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
    }
    return iterations;
  };
  CollectionSeq2.prototype.__iteratorUncached = function __iteratorUncached(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var collection = this._collection;
    var iterator2 = getIterator(collection);
    if (!isIterator(iterator2)) {
      return new Iterator2(iteratorDone);
    }
    var iterations = 0;
    return new Iterator2(function() {
      var step = iterator2.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    });
  };
  return CollectionSeq2;
}(IndexedSeq);
var EMPTY_SEQ;
function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
function keyedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of [k, v] entries, or keyed object: " + value
  );
}
function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  throw new TypeError(
    "Expected Array or collection object of values: " + value
  );
}
function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of values, or keyed object: " + value
  );
}
function maybeIndexedSeqFromValue(value) {
  return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : void 0;
}
function asImmutable() {
  return this.__ensureOwner();
}
function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}
var imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a5, b5) {
  a5 |= 0;
  b5 |= 0;
  var c5 = a5 & 65535;
  var d3 = b5 & 65535;
  return c5 * d3 + ((a5 >>> 16) * d3 + c5 * (b5 >>> 16) << 16 >>> 0) | 0;
};
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
var defaultValueOf = Object.prototype.valueOf;
function hash(o) {
  if (o == null) {
    return hashNullish(o);
  }
  if (typeof o.hashCode === "function") {
    return smi(o.hashCode(o));
  }
  var v3 = valueOf(o);
  if (v3 == null) {
    return hashNullish(v3);
  }
  switch (typeof v3) {
    case "boolean":
      return v3 ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v3);
    case "string":
      return v3.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v3) : hashString2(v3);
    case "object":
    case "function":
      return hashJSObj(v3);
    case "symbol":
      return hashSymbol(v3);
    default:
      if (typeof v3.toString === "function") {
        return hashString2(v3.toString());
      }
      throw new Error("Value type " + typeof v3 + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function hashNumber(n) {
  if (n !== n || n === Infinity) {
    return 0;
  }
  var hash3 = n | 0;
  if (hash3 !== n) {
    hash3 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    n /= 4294967295;
    hash3 ^= n;
  }
  return smi(hash3);
}
function cachedHashString(string) {
  var hashed = stringHashCache[string];
  if (hashed === void 0) {
    hashed = hashString2(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string] = hashed;
  }
  return hashed;
}
function hashString2(string) {
  var hashed = 0;
  for (var ii = 0; ii < string.length; ii++) {
    hashed = 31 * hashed + string.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  var hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  var hashed;
  if (usingWeakMap) {
    hashed = weakMap.get(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = obj[UID_HASH_KEY];
  if (hashed !== void 0) {
    return hashed;
  }
  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hashed !== void 0) {
      return hashed;
    }
    hashed = getIENodeHash(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = nextHash();
  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
    throw new Error("Non-extensible objects are not allowed as keys.");
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed
    });
  } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(
        this,
        // eslint-disable-next-line prefer-rest-params
        arguments
      );
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== void 0) {
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error("Unable to set a non-enumerable property on object.");
  }
  return hashed;
}
var isExtensible = Object.isExtensible;
var canDefineProperty = function() {
  try {
    Object.defineProperty({}, "@", {});
    return true;
  } catch (e) {
    return false;
  }
}();
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1:
        return node.uniqueID;
      case 9:
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? (
    // @ts-expect-error weird the "obj" parameter as `valueOf` should not have a parameter
    obj.valueOf(obj)
  ) : obj;
}
function nextHash() {
  var nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
var usingWeakMap = typeof WeakMap === "function";
var weakMap;
if (usingWeakMap) {
  weakMap = /* @__PURE__ */ new WeakMap();
}
var symbolMap = /* @__PURE__ */ Object.create(null);
var _objHashUID = 0;
var UID_HASH_KEY = "__immutablehash__";
if (typeof Symbol === "function") {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};
var ToKeyedSequence = function(KeyedSeq2) {
  function ToKeyedSequence2(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }
  if (KeyedSeq2) ToKeyedSequence2.__proto__ = KeyedSeq2;
  ToKeyedSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ToKeyedSequence2.prototype.constructor = ToKeyedSequence2;
  ToKeyedSequence2.prototype.get = function get11(key2, notSetValue) {
    return this._iter.get(key2, notSetValue);
  };
  ToKeyedSequence2.prototype.has = function has6(key2) {
    return this._iter.has(key2);
  };
  ToKeyedSequence2.prototype.valueSeq = function valueSeq2() {
    return this._iter.valueSeq();
  };
  ToKeyedSequence2.prototype.reverse = function reverse3() {
    var this$1$1 = this;
    var reversedSequence = reverseFactory(this, true);
    if (!this._useKeys) {
      reversedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().reverse();
      };
    }
    return reversedSequence;
  };
  ToKeyedSequence2.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    var mappedSequence = mapFactory(this, mapper, context2);
    if (!this._useKeys) {
      mappedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().map(mapper, context2);
      };
    }
    return mappedSequence;
  };
  ToKeyedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v3, k) {
      return fn(v3, k, this$1$1);
    }, reverse3);
  };
  ToKeyedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    return this._iter.__iterator(type, reverse3);
  };
  return ToKeyedSequence2;
}(KeyedSeq);
ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
var ToIndexedSequence = function(IndexedSeq2) {
  function ToIndexedSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  if (IndexedSeq2) ToIndexedSequence2.__proto__ = IndexedSeq2;
  ToIndexedSequence2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ToIndexedSequence2.prototype.constructor = ToIndexedSequence2;
  ToIndexedSequence2.prototype.includes = function includes3(value) {
    return this._iter.includes(value);
  };
  ToIndexedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    var i = 0;
    reverse3 && ensureSize(this);
    return this._iter.__iterate(
      function(v3) {
        return fn(v3, reverse3 ? this$1$1.size - ++i : i++, this$1$1);
      },
      reverse3
    );
  };
  ToIndexedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    var this$1$1 = this;
    var iterator2 = this._iter.__iterator(ITERATE_VALUES, reverse3);
    var i = 0;
    reverse3 && ensureSize(this);
    return new Iterator2(function() {
      var step = iterator2.next();
      return step.done ? step : iteratorValue(
        type,
        reverse3 ? this$1$1.size - ++i : i++,
        step.value,
        step
      );
    });
  };
  return ToIndexedSequence2;
}(IndexedSeq);
var ToSetSequence = function(SetSeq2) {
  function ToSetSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  if (SetSeq2) ToSetSequence2.__proto__ = SetSeq2;
  ToSetSequence2.prototype = Object.create(SetSeq2 && SetSeq2.prototype);
  ToSetSequence2.prototype.constructor = ToSetSequence2;
  ToSetSequence2.prototype.has = function has6(key2) {
    return this._iter.includes(key2);
  };
  ToSetSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v3) {
      return fn(v3, v3, this$1$1);
    }, reverse3);
  };
  ToSetSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    var iterator2 = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator2(function() {
      var step = iterator2.next();
      return step.done ? step : iteratorValue(type, step.value, step.value, step);
    });
  };
  return ToSetSequence2;
}(SetSeq);
var FromEntriesSequence = function(KeyedSeq2) {
  function FromEntriesSequence2(entries3) {
    this._iter = entries3;
    this.size = entries3.size;
  }
  if (KeyedSeq2) FromEntriesSequence2.__proto__ = KeyedSeq2;
  FromEntriesSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  FromEntriesSequence2.prototype.constructor = FromEntriesSequence2;
  FromEntriesSequence2.prototype.entrySeq = function entrySeq2() {
    return this._iter.toSeq();
  };
  FromEntriesSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(entry) {
      if (entry) {
        validateEntry(entry);
        var indexedCollection = isCollection(entry);
        return fn(
          indexedCollection ? entry.get(1) : entry[1],
          indexedCollection ? entry.get(0) : entry[0],
          this$1$1
        );
      }
    }, reverse3);
  };
  FromEntriesSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    var iterator2 = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator2(function() {
      while (true) {
        var step = iterator2.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return iteratorValue(
            type,
            indexedCollection ? entry.get(0) : entry[0],
            indexedCollection ? entry.get(1) : entry[1],
            step
          );
        }
      }
    });
  };
  return FromEntriesSequence2;
}(KeyedSeq);
ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function() {
    return collection;
  };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this);
    reversedSequence.flip = function() {
      return collection.reverse();
    };
    return reversedSequence;
  };
  flipSequence.has = function(key2) {
    return collection.includes(key2);
  };
  flipSequence.includes = function(key2) {
    return collection.has(key2);
  };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(function(v3, k) {
      return fn(k, v3, this$1$1) !== false;
    }, reverse3);
  };
  flipSequence.__iteratorUncached = function(type, reverse3) {
    if (type === ITERATE_ENTRIES) {
      var iterator2 = collection.__iterator(type, reverse3);
      return new Iterator2(function() {
        var step = iterator2.next();
        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }
        return step;
      });
    }
    return collection.__iterator(
      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
      reverse3
    );
  };
  return flipSequence;
}
function mapFactory(collection, mapper, context2) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function(key2) {
    return collection.has(key2);
  };
  mappedSequence.get = function(key2, notSetValue) {
    var v3 = collection.get(key2, NOT_SET);
    return v3 === NOT_SET ? notSetValue : mapper.call(context2, v3, key2, collection);
  };
  mappedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(
      function(v3, k, c5) {
        return fn(mapper.call(context2, v3, k, c5), k, this$1$1) !== false;
      },
      reverse3
    );
  };
  mappedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator2 = collection.__iterator(ITERATE_ENTRIES, reverse3);
    return new Iterator2(function() {
      var step = iterator2.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key2 = entry[0];
      return iteratorValue(
        type,
        key2,
        mapper.call(context2, entry[1], key2, collection),
        step
      );
    });
  };
  return mappedSequence;
}
function reverseFactory(collection, useKeys) {
  var this$1$1 = this;
  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function() {
    return collection;
  };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function() {
        return collection.flip();
      };
      return flipSequence;
    };
  }
  reversedSequence.get = function(key2, notSetValue) {
    return collection.get(useKeys ? key2 : -1 - key2, notSetValue);
  };
  reversedSequence.has = function(key2) {
    return collection.has(useKeys ? key2 : -1 - key2);
  };
  reversedSequence.includes = function(value) {
    return collection.includes(value);
  };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn, reverse3) {
    var this$1$12 = this;
    var i = 0;
    reverse3 && ensureSize(collection);
    return collection.__iterate(
      function(v3, k) {
        return fn(v3, useKeys ? k : reverse3 ? this$1$12.size - ++i : i++, this$1$12);
      },
      !reverse3
    );
  };
  reversedSequence.__iterator = function(type, reverse3) {
    var i = 0;
    reverse3 && ensureSize(collection);
    var iterator2 = collection.__iterator(ITERATE_ENTRIES, !reverse3);
    return new Iterator2(function() {
      var step = iterator2.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(
        type,
        useKeys ? entry[0] : reverse3 ? this$1$1.size - ++i : i++,
        entry[1],
        step
      );
    });
  };
  return reversedSequence;
}
function filterFactory(collection, predicate, context2, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function(key2) {
      var v3 = collection.get(key2, NOT_SET);
      return v3 !== NOT_SET && !!predicate.call(context2, v3, key2, collection);
    };
    filterSequence.get = function(key2, notSetValue) {
      var v3 = collection.get(key2, NOT_SET);
      return v3 !== NOT_SET && predicate.call(context2, v3, key2, collection) ? v3 : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(function(v3, k, c5) {
      if (predicate.call(context2, v3, k, c5)) {
        iterations++;
        return fn(v3, useKeys ? k : iterations - 1, this$1$1);
      }
    }, reverse3);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse3) {
    var iterator2 = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterations = 0;
    return new Iterator2(function() {
      while (true) {
        var step = iterator2.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key2 = entry[0];
        var value = entry[1];
        if (predicate.call(context2, value, key2, collection)) {
          return iteratorValue(type, useKeys ? key2 : iterations++, value, step);
        }
      }
    });
  };
  return filterSequence;
}
function countByFactory(collection, grouper, context2) {
  var groups = Map2().asMutable();
  collection.__iterate(function(v3, k) {
    groups.update(grouper.call(context2, v3, k, collection), 0, function(a5) {
      return a5 + 1;
    });
  });
  return groups.asImmutable();
}
function groupByFactory(collection, grouper, context2) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map2()).asMutable();
  collection.__iterate(function(v3, k) {
    groups.update(
      grouper.call(context2, v3, k, collection),
      function(a5) {
        return a5 = a5 || [], a5.push(isKeyedIter ? [k, v3] : v3), a5;
      }
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  }).asImmutable();
}
function partitionFactory(collection, predicate, context2) {
  var isKeyedIter = isKeyed(collection);
  var groups = [[], []];
  collection.__iterate(function(v3, k) {
    groups[predicate.call(context2, v3, k, collection) ? 1 : 0].push(
      isKeyedIter ? [k, v3] : v3
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  });
}
function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;
  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }
  if (typeof originalSize === "undefined" && (begin < 0 || end < 0)) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  }
  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize);
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }
  var sliceSeq = makeSequence(collection);
  sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || void 0;
  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
    };
  }
  sliceSeq.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (sliceSize === 0) {
      return 0;
    }
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v3, k) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return fn(v3, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
      }
    });
    return iterations;
  };
  sliceSeq.__iteratorUncached = function(type, reverse3) {
    if (sliceSize !== 0 && reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    if (sliceSize === 0) {
      return new Iterator2(iteratorDone);
    }
    var iterator2 = collection.__iterator(type, reverse3);
    var skipped = 0;
    var iterations = 0;
    return new Iterator2(function() {
      while (skipped++ < resolvedBegin) {
        iterator2.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator2.next();
      if (useKeys || type === ITERATE_VALUES || step.done) {
        return step;
      }
      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, void 0, step);
      }
      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };
  return sliceSeq;
}
function takeWhileFactory(collection, predicate, context2) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    collection.__iterate(
      function(v3, k, c5) {
        return predicate.call(context2, v3, k, c5) && ++iterations && fn(v3, k, this$1$1);
      }
    );
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator2 = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterating = true;
    return new Iterator2(function() {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator2.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v3 = entry[1];
      if (!predicate.call(context2, v3, k, this$1$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v3, step);
    });
  };
  return takeSequence;
}
function skipWhileFactory(collection, predicate, context2, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v3, k, c5) {
      if (!(isSkipping && (isSkipping = predicate.call(context2, v3, k, c5)))) {
        iterations++;
        return fn(v3, useKeys ? k : iterations - 1, this$1$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator2 = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var skipping = true;
    var iterations = 0;
    return new Iterator2(function() {
      var step;
      var k;
      var v3;
      do {
        step = iterator2.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }
          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, void 0, step);
          }
          return iteratorValue(type, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k = entry[0];
        v3 = entry[1];
        skipping && (skipping = predicate.call(context2, v3, k, this$1$1));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v3, step);
    });
  };
  return skipSequence;
}
var ConcatSeq = function(Seq2) {
  function ConcatSeq2(iterables) {
    this._wrappedIterables = iterables.flatMap(function(iterable) {
      if (iterable._wrappedIterables) {
        return iterable._wrappedIterables;
      }
      return [iterable];
    });
    this.size = this._wrappedIterables.reduce(function(sum, iterable) {
      if (sum !== void 0) {
        var size = iterable.size;
        if (size !== void 0) {
          return sum + size;
        }
      }
    }, 0);
    this[IS_KEYED_SYMBOL] = this._wrappedIterables[0][IS_KEYED_SYMBOL];
    this[IS_INDEXED_SYMBOL] = this._wrappedIterables[0][IS_INDEXED_SYMBOL];
    this[IS_ORDERED_SYMBOL] = this._wrappedIterables[0][IS_ORDERED_SYMBOL];
  }
  if (Seq2) ConcatSeq2.__proto__ = Seq2;
  ConcatSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  ConcatSeq2.prototype.constructor = ConcatSeq2;
  ConcatSeq2.prototype.__iterateUncached = function __iterateUncached(fn, reverse3) {
    if (this._wrappedIterables.length === 0) {
      return;
    }
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterableIndex = 0;
    var useKeys = isKeyed(this);
    var iteratorType = useKeys ? ITERATE_ENTRIES : ITERATE_VALUES;
    var currentIterator = this._wrappedIterables[iterableIndex].__iterator(
      iteratorType,
      reverse3
    );
    var keepGoing = true;
    var index = 0;
    while (keepGoing) {
      var next = currentIterator.next();
      while (next.done) {
        iterableIndex++;
        if (iterableIndex === this._wrappedIterables.length) {
          return index;
        }
        currentIterator = this._wrappedIterables[iterableIndex].__iterator(
          iteratorType,
          reverse3
        );
        next = currentIterator.next();
      }
      var fnResult = useKeys ? fn(next.value[1], next.value[0], this) : fn(next.value, index, this);
      keepGoing = fnResult !== false;
      index++;
    }
    return index;
  };
  ConcatSeq2.prototype.__iteratorUncached = function __iteratorUncached(type, reverse3) {
    var this$1$1 = this;
    if (this._wrappedIterables.length === 0) {
      return new Iterator2(iteratorDone);
    }
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterableIndex = 0;
    var currentIterator = this._wrappedIterables[iterableIndex].__iterator(
      type,
      reverse3
    );
    return new Iterator2(function() {
      var next = currentIterator.next();
      while (next.done) {
        iterableIndex++;
        if (iterableIndex === this$1$1._wrappedIterables.length) {
          return next;
        }
        currentIterator = this$1$1._wrappedIterables[iterableIndex].__iterator(
          type,
          reverse3
        );
        next = currentIterator.next();
      }
      return next;
    });
  };
  return ConcatSeq2;
}(Seq);
function concatFactory(collection, values2) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection].concat(values2).map(function(v3) {
    if (!isCollection(v3)) {
      v3 = isKeyedCollection ? keyedSeqFromValue(v3) : indexedSeqFromValue(Array.isArray(v3) ? v3 : [v3]);
    } else if (isKeyedCollection) {
      v3 = KeyedCollection(v3);
    }
    return v3;
  }).filter(function(v3) {
    return v3.size !== 0;
  });
  if (iters.length === 0) {
    return collection;
  }
  if (iters.length === 1) {
    var singleton = iters[0];
    if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
      return singleton;
    }
  }
  return new ConcatSeq(iters);
}
function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(function(v3, k) {
        if ((!depth || currentDepth < depth) && isCollection(v3)) {
          flatDeep(v3, currentDepth + 1);
        } else {
          iterations++;
          if (fn(v3, useKeys ? k : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }
        return !stopped;
      }, reverse3);
    }
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator2 = collection.__iterator(type, reverse3);
    var stack = [];
    var iterations = 0;
    return new Iterator2(function() {
      while (iterator2) {
        var step = iterator2.next();
        if (step.done !== false) {
          iterator2 = stack.pop();
          continue;
        }
        var v3 = step.value;
        if (type === ITERATE_ENTRIES) {
          v3 = v3[1];
        }
        if ((!depth || stack.length < depth) && isCollection(v3)) {
          stack.push(iterator2);
          iterator2 = v3.__iterator(type, reverse3);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v3, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}
function flatMapFactory(collection, mapper, context2) {
  var coerce = collectionClass(collection);
  return collection.toSeq().map(function(v3, k) {
    return coerce(mapper.call(context2, v3, k, collection));
  }).flatten(true);
}
function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(
      function(v3) {
        return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v3, iterations++, this$1$1) !== false;
      },
      reverse3
    );
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator2 = collection.__iterator(ITERATE_VALUES, reverse3);
    var iterations = 0;
    var step;
    return new Iterator2(function() {
      if (!step || iterations % 2) {
        step = iterator2.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}
function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index = 0;
  var entries3 = collection.toSeq().map(function(v3, k) {
    return [k, v3, index++, mapper ? mapper(v3, k, collection) : v3];
  }).valueSeq().toArray();
  entries3.sort(function(a5, b5) {
    return comparator(a5[3], b5[3]) || a5[2] - b5[2];
  }).forEach(
    isKeyedCollection ? function(v3, i) {
      entries3[i].length = 2;
    } : function(v3, i) {
      entries3[i] = v3[1];
    }
  );
  return isKeyedCollection ? KeyedSeq(entries3) : isIndexed(collection) ? IndexedSeq(entries3) : SetSeq(entries3);
}
function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection.toSeq().map(function(v3, k) {
      return [v3, mapper(v3, k, collection)];
    }).reduce(function(a5, b5) {
      return maxCompare(comparator, a5[1], b5[1]) ? b5 : a5;
    });
    return entry && entry[0];
  }
  return collection.reduce(function(a5, b5) {
    return maxCompare(comparator, a5, b5) ? b5 : a5;
  });
}
function maxCompare(comparator, a5, b5) {
  var comp = comparator(b5, a5);
  return comp === 0 && b5 !== a5 && (b5 === void 0 || b5 === null || b5 !== b5) || comp > 0;
}
function zipWithFactory(keyIter, zipper, iters, zipAll3) {
  var zipSequence = makeSequence(keyIter);
  var sizes = new ArraySeq(iters).map(function(i) {
    return i.size;
  });
  zipSequence.size = zipAll3 ? sizes.max() : sizes.min();
  zipSequence.__iterate = function(fn, reverse3) {
    var iterator2 = this.__iterator(ITERATE_VALUES, reverse3);
    var step;
    var iterations = 0;
    while (!(step = iterator2.next()).done) {
      if (fn(step.value, iterations++, this) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type, reverse3) {
    var iterators = iters.map(
      function(i) {
        return i = Collection(i), getIterator(reverse3 ? i.reverse() : i);
      }
    );
    var iterations = 0;
    var isDone = false;
    return new Iterator2(function() {
      var steps;
      if (!isDone) {
        steps = iterators.map(function(i) {
          return i.next();
        });
        isDone = zipAll3 ? steps.every(function(s) {
          return s.done;
        }) : steps.some(function(s) {
          return s.done;
        });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(
        type,
        iterations++,
        zipper.apply(
          null,
          steps.map(function(s) {
            return s.value;
          })
        )
      );
    });
  };
  return zipSequence;
}
function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}
function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError("Expected [K, V] tuple: " + entry);
  }
}
function collectionClass(collection) {
  return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
}
function makeSequence(collection) {
  return Object.create(
    (isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype
  );
}
function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}
function defaultComparator(a5, b5) {
  if (a5 === void 0 && b5 === void 0) {
    return 0;
  }
  if (a5 === void 0) {
    return 1;
  }
  if (b5 === void 0) {
    return -1;
  }
  return a5 > b5 ? 1 : a5 < b5 ? -1 : 0;
}
function isValueObject(maybeValue) {
  return Boolean(maybeValue && // @ts-expect-error: maybeValue is typed as `{}`
  typeof maybeValue.equals === "function" && // @ts-expect-error: maybeValue is typed as `{}`
  typeof maybeValue.hashCode === "function");
}
function is(valueA, valueB) {
  if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
}
function update$1(collection, key2, notSetValue, updater) {
  return updateIn(
    // @ts-expect-error Index signature for type string is missing in type V[]
    collection,
    [key2],
    notSetValue,
    updater
  );
}
function merge$1() {
  var iters = [], len = arguments.length;
  while (len--) iters[len] = arguments[len];
  return mergeIntoKeyedWith(this, iters);
}
function mergeWith$1(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  if (typeof merger !== "function") {
    throw new TypeError("Invalid merger function: " + merger);
  }
  return mergeIntoKeyedWith(this, iters, merger);
}
function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);
    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }
  if (iters.length === 0) {
    return collection;
  }
  if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
    return isRecord(collection) ? collection : collection.constructor(iters[0]);
  }
  return collection.withMutations(function(collection2) {
    var mergeIntoCollection = merger ? function(value, key2) {
      update$1(
        collection2,
        key2,
        NOT_SET,
        function(oldVal) {
          return oldVal === NOT_SET ? value : merger(oldVal, value, key2);
        }
      );
    } : function(value, key2) {
      collection2.set(key2, value);
    };
    for (var ii2 = 0; ii2 < iters.length; ii2++) {
      iters[ii2].forEach(mergeIntoCollection);
    }
  });
}
var toString2 = Object.prototype.toString;
function isPlainObject(value) {
  if (!value || typeof value !== "object" || toString2.call(value) !== "[object Object]") {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  var parentProto = proto;
  var nextProto = Object.getPrototypeOf(proto);
  while (nextProto !== null) {
    parentProto = nextProto;
    nextProto = Object.getPrototypeOf(parentProto);
  }
  return parentProto === proto;
}
function isDataStructure(value) {
  return typeof value === "object" && (isImmutable(value) || Array.isArray(value) || isPlainObject(value));
}
function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }
  return newArr;
}
function shallowCopy(from2) {
  if (Array.isArray(from2)) {
    return arrCopy(from2);
  }
  var to = {};
  for (var key2 in from2) {
    if (hasOwnProperty.call(from2, key2)) {
      to[key2] = from2[key2];
    }
  }
  return to;
}
function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}
function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot merge into non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
  }
  var isArray4 = Array.isArray(collection);
  var merged = collection;
  var Collection3 = isArray4 ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray4 ? function(value) {
    if (merged === collection) {
      merged = shallowCopy(merged);
    }
    merged.push(value);
  } : function(value, key2) {
    var hasVal = hasOwnProperty.call(merged, key2);
    var nextVal = hasVal && merger ? merger(merged[key2], value, key2) : value;
    if (!hasVal || nextVal !== merged[key2]) {
      if (merged === collection) {
        merged = shallowCopy(merged);
      }
      merged[key2] = nextVal;
    }
  };
  for (var i = 0; i < sources.length; i++) {
    Collection3(sources[i]).forEach(mergeItem);
  }
  return merged;
}
function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key2) {
    return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key2) : newValue;
  }
  return deepMerger;
}
function areMergeable(oldDataStructure, newDataStructure) {
  var oldSeq = Seq(oldDataStructure);
  var newSeq = Seq(newDataStructure);
  return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
}
function mergeDeep() {
  var iters = [], len = arguments.length;
  while (len--) iters[len] = arguments[len];
  return mergeDeepWithSources(this, iters);
}
function mergeDeepWith(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return mergeDeepWithSources(this, iters, merger);
}
function mergeDeepIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return updateIn(
    this,
    keyPath,
    emptyMap(),
    function(m) {
      return mergeDeepWithSources(m, iters);
    }
  );
}
function mergeIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0) iters[len] = arguments[len + 1];
  return updateIn(this, keyPath, emptyMap(), function(m) {
    return mergeWithSources(m, iters);
  });
}
function setIn$1(collection, keyPath, value) {
  return updateIn(collection, keyPath, NOT_SET, function() {
    return value;
  });
}
function setIn(keyPath, v3) {
  return setIn$1(this, keyPath, v3);
}
function update(key2, notSetValue, updater) {
  return arguments.length === 1 ? key2(this) : update$1(this, key2, notSetValue, updater);
}
function updateIn$1(keyPath, notSetValue, updater) {
  return updateIn(this, keyPath, notSetValue, updater);
}
function wasAltered() {
  return this.__altered;
}
function withMutations(fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}
var IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
function isMap(maybeMap) {
  return Boolean(maybeMap && // @ts-expect-error: maybeMap is typed as `{}`, need to change in 6.0 to `maybeMap && typeof maybeMap === 'object' && IS_MAP_SYMBOL in maybeMap`
  maybeMap[IS_MAP_SYMBOL]);
}
function invariant(condition, error) {
  if (!condition) {
    throw new Error(error);
  }
}
function assertNotInfinite(size) {
  invariant(size !== Infinity, "Cannot perform this action with an infinite size.");
}
var Map2 = function(KeyedCollection2) {
  function Map3(value) {
    return value === void 0 || value === null ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map3) {
      var iter = KeyedCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v3, k) {
        return map3.set(k, v3);
      });
    });
  }
  if (KeyedCollection2) Map3.__proto__ = KeyedCollection2;
  Map3.prototype = Object.create(KeyedCollection2 && KeyedCollection2.prototype);
  Map3.prototype.constructor = Map3;
  Map3.prototype.toString = function toString5() {
    return this.__toString("Map {", "}");
  };
  Map3.prototype.get = function get11(k, notSetValue) {
    return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
  };
  Map3.prototype.set = function set4(k, v3) {
    return updateMap(this, k, v3);
  };
  Map3.prototype.remove = function remove3(k) {
    return updateMap(this, k, NOT_SET);
  };
  Map3.prototype.deleteAll = function deleteAll(keys2) {
    var collection = Collection(keys2);
    if (collection.size === 0) {
      return this;
    }
    return this.withMutations(function(map3) {
      collection.forEach(function(key2) {
        return map3.remove(key2);
      });
    });
  };
  Map3.prototype.clear = function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyMap();
  };
  Map3.prototype.sort = function sort2(comparator) {
    return OrderedMap(sortFactory(this, comparator));
  };
  Map3.prototype.sortBy = function sortBy2(mapper, comparator) {
    return OrderedMap(sortFactory(this, comparator, mapper));
  };
  Map3.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    return this.withMutations(function(map4) {
      map4.forEach(function(value, key2) {
        map4.set(key2, mapper.call(context2, value, key2, this$1$1));
      });
    });
  };
  Map3.prototype.__iterator = function __iterator2(type, reverse3) {
    return new MapIterator(this, type, reverse3);
  };
  Map3.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    this._root && this._root.iterate(function(entry) {
      iterations++;
      return fn(entry[1], entry[0], this$1$1);
    }, reverse3);
    return iterations;
  };
  Map3.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  };
  return Map3;
}(KeyedCollection);
Map2.isMap = isMap;
var MapPrototype = Map2.prototype;
MapPrototype[IS_MAP_SYMBOL] = true;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype.removeAll = MapPrototype.deleteAll;
MapPrototype.setIn = setIn;
MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
MapPrototype.update = update;
MapPrototype.updateIn = updateIn$1;
MapPrototype.merge = MapPrototype.concat = merge$1;
MapPrototype.mergeWith = mergeWith$1;
MapPrototype.mergeDeep = mergeDeep;
MapPrototype.mergeDeepWith = mergeDeepWith;
MapPrototype.mergeIn = mergeIn;
MapPrototype.mergeDeepIn = mergeDeepIn;
MapPrototype.withMutations = withMutations;
MapPrototype.wasAltered = wasAltered;
MapPrototype.asImmutable = asImmutable;
MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
MapPrototype["@@transducer/step"] = function(result, arr) {
  return result.set(arr[0], arr[1]);
};
MapPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var ArrayMapNode = function ArrayMapNode2(ownerID, entries3) {
  this.ownerID = ownerID;
  this.entries = entries3;
};
ArrayMapNode.prototype.get = function get(shift, keyHash, key2, notSetValue) {
  var entries3 = this.entries;
  for (var ii = 0, len = entries3.length; ii < len; ii++) {
    if (is(key2, entries3[ii][0])) {
      return entries3[ii][1];
    }
  }
  return notSetValue;
};
ArrayMapNode.prototype.update = function update2(ownerID, shift, keyHash, key2, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var entries3 = this.entries;
  var idx = 0;
  var len = entries3.length;
  for (; idx < len; idx++) {
    if (is(key2, entries3[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries3[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && entries3.length === 1) {
    return;
  }
  if (!exists && !removed && entries3.length >= MAX_ARRAY_MAP_SIZE) {
    return createNodes(ownerID, entries3, key2, value);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries3 : arrCopy(entries3);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key2, value];
    }
  } else {
    newEntries.push([key2, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new ArrayMapNode(ownerID, newEntries);
};
var BitmapIndexedNode = function BitmapIndexedNode2(ownerID, bitmap, nodes) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes;
};
BitmapIndexedNode.prototype.get = function get2(shift, keyHash, key2, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key2);
  }
  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
  var bitmap = this.bitmap;
  return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(
    shift + SHIFT,
    keyHash,
    key2,
    notSetValue
  );
};
BitmapIndexedNode.prototype.update = function update3(ownerID, shift, keyHash, key2, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key2);
  }
  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var bit = 1 << keyHashFrag;
  var bitmap = this.bitmap;
  var exists = (bitmap & bit) !== 0;
  if (!exists && value === NOT_SET) {
    return this;
  }
  var idx = popCount(bitmap & bit - 1);
  var nodes = this.nodes;
  var node = exists ? nodes[idx] : void 0;
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key2,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }
  if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
    return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
  }
  if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
    return nodes[idx ^ 1];
  }
  if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
    return newNode;
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
  var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
  if (isEditable) {
    this.bitmap = newBitmap;
    this.nodes = newNodes;
    return this;
  }
  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
};
var HashArrayMapNode = function HashArrayMapNode2(ownerID, count3, nodes) {
  this.ownerID = ownerID;
  this.count = count3;
  this.nodes = nodes;
};
HashArrayMapNode.prototype.get = function get3(shift, keyHash, key2, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key2);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var node = this.nodes[idx];
  return node ? node.get(shift + SHIFT, keyHash, key2, notSetValue) : notSetValue;
};
HashArrayMapNode.prototype.update = function update4(ownerID, shift, keyHash, key2, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key2);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var removed = value === NOT_SET;
  var nodes = this.nodes;
  var node = nodes[idx];
  if (removed && !node) {
    return this;
  }
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key2,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }
  var newCount = this.count;
  if (!node) {
    newCount++;
  } else if (!newNode) {
    newCount--;
    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
      return packNodes(ownerID, nodes, newCount, idx);
    }
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newNodes = setAt(nodes, idx, newNode, isEditable);
  if (isEditable) {
    this.count = newCount;
    this.nodes = newNodes;
    return this;
  }
  return new HashArrayMapNode(ownerID, newCount, newNodes);
};
var HashCollisionNode = function HashCollisionNode2(ownerID, keyHash, entries3) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entries = entries3;
};
HashCollisionNode.prototype.get = function get4(shift, keyHash, key2, notSetValue) {
  var entries3 = this.entries;
  for (var ii = 0, len = entries3.length; ii < len; ii++) {
    if (is(key2, entries3[ii][0])) {
      return entries3[ii][1];
    }
  }
  return notSetValue;
};
HashCollisionNode.prototype.update = function update5(ownerID, shift, keyHash, key2, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key2);
  }
  var removed = value === NOT_SET;
  if (keyHash !== this.keyHash) {
    if (removed) {
      return this;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, keyHash, [key2, value]);
  }
  var entries3 = this.entries;
  var idx = 0;
  var len = entries3.length;
  for (; idx < len; idx++) {
    if (is(key2, entries3[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries3[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && len === 2) {
    return new ValueNode(ownerID, this.keyHash, entries3[idx ^ 1]);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries3 : arrCopy(entries3);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key2, value];
    }
  } else {
    newEntries.push([key2, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new HashCollisionNode(ownerID, this.keyHash, newEntries);
};
var ValueNode = function ValueNode2(ownerID, keyHash, entry) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entry = entry;
};
ValueNode.prototype.get = function get5(shift, keyHash, key2, notSetValue) {
  return is(key2, this.entry[0]) ? this.entry[1] : notSetValue;
};
ValueNode.prototype.update = function update6(ownerID, shift, keyHash, key2, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var keyMatch = is(key2, this.entry[0]);
  if (keyMatch ? value === this.entry[1] : removed) {
    return this;
  }
  SetRef(didAlter);
  if (removed) {
    SetRef(didChangeSize);
    return;
  }
  if (keyMatch) {
    if (ownerID && ownerID === this.ownerID) {
      this.entry[1] = value;
      return this;
    }
    return new ValueNode(ownerID, this.keyHash, [key2, value]);
  }
  SetRef(didChangeSize);
  return mergeIntoNode(this, ownerID, shift, hash(key2), [key2, value]);
};
ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse3) {
  var entries3 = this.entries;
  for (var ii = 0, maxIndex = entries3.length - 1; ii <= maxIndex; ii++) {
    if (fn(entries3[reverse3 ? maxIndex - ii : ii]) === false) {
      return false;
    }
  }
};
BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse3) {
  var nodes = this.nodes;
  for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
    var node = nodes[reverse3 ? maxIndex - ii : ii];
    if (node && node.iterate(fn, reverse3) === false) {
      return false;
    }
  }
};
ValueNode.prototype.iterate = function(fn, reverse3) {
  return fn(this.entry);
};
var MapIterator = function(Iterator4) {
  function MapIterator2(map3, type, reverse3) {
    this._type = type;
    this._reverse = reverse3;
    this._stack = map3._root && mapIteratorFrame(map3._root);
  }
  if (Iterator4) MapIterator2.__proto__ = Iterator4;
  MapIterator2.prototype = Object.create(Iterator4 && Iterator4.prototype);
  MapIterator2.prototype.constructor = MapIterator2;
  MapIterator2.prototype.next = function next() {
    var type = this._type;
    var stack = this._stack;
    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex = void 0;
      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;
        if (index <= maxIndex) {
          return mapIteratorValue(
            type,
            node.entries[this._reverse ? maxIndex - index : index]
          );
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index : index];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack = this._stack = mapIteratorFrame(subNode, stack);
          }
          continue;
        }
      }
      stack = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  };
  return MapIterator2;
}(Iterator2);
function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
function makeMap(size, root, ownerID, hash3) {
  var map3 = Object.create(MapPrototype);
  map3.size = size;
  map3._root = root;
  map3.__ownerID = ownerID;
  map3.__hash = hash3;
  map3.__altered = false;
  return map3;
}
var EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map3, k, v3) {
  var newRoot;
  var newSize;
  if (!map3._root) {
    if (v3 === NOT_SET) {
      return map3;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map3.__ownerID, [[k, v3]]);
  } else {
    var didChangeSize = MakeRef();
    var didAlter = MakeRef();
    newRoot = updateNode(
      map3._root,
      map3.__ownerID,
      0,
      void 0,
      k,
      v3,
      didChangeSize,
      didAlter
    );
    if (!didAlter.value) {
      return map3;
    }
    newSize = map3.size + (didChangeSize.value ? v3 === NOT_SET ? -1 : 1 : 0);
  }
  if (map3.__ownerID) {
    map3.size = newSize;
    map3._root = newRoot;
    map3.__hash = void 0;
    map3.__altered = true;
    return map3;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key2, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key2, value]);
  }
  return node.update(
    ownerID,
    shift,
    keyHash,
    key2,
    value,
    didChangeSize,
    didAlter
  );
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }
  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var newNode;
  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries3, key2, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash(key2), [key2, value]);
  for (var ii = 0; ii < entries3.length; ii++) {
    var entry = entries3[ii];
    node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
  }
  return node;
}
function packNodes(ownerID, nodes, count3, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count3);
  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count3 = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count3++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count3 + 1, expandedNodes);
}
function popCount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function setAt(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}
var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== "string") {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError("Invalid keyPath: expected Ordered Collection or Array: " + keyPath);
}
function quoteString(value) {
  try {
    return typeof value === "string" ? JSON.stringify(value) : String(value);
  } catch (_ignoreError) {
    return JSON.stringify(value);
  }
}
function has(collection, key2) {
  return isImmutable(collection) ? (
    // @ts-expect-error key might be a number or symbol, which is not handled be Record key type
    collection.has(key2)
  ) : (
    // @ts-expect-error key might be anything else than PropertyKey, and will return false in that case but runtime is OK
    isDataStructure(collection) && hasOwnProperty.call(collection, key2)
  );
}
function get6(collection, key2, notSetValue) {
  return isImmutable(collection) ? collection.get(key2, notSetValue) : !has(collection, key2) ? notSetValue : (
    // @ts-expect-error weird "get" here,
    typeof collection.get === "function" ? (
      // @ts-expect-error weird "get" here,
      collection.get(key2)
    ) : (
      // @ts-expect-error key is unknown here,
      collection[key2]
    )
  );
}
function remove(collection, key2) {
  if (!isDataStructure(collection)) {
    throw new TypeError("Cannot update non-data-structure value: " + collection);
  }
  if (isImmutable(collection)) {
    if (!collection.remove) {
      throw new TypeError("Cannot update immutable value without .remove() method: " + collection);
    }
    return collection.remove(key2);
  }
  if (!hasOwnProperty.call(collection, key2)) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key2, 1);
  } else {
    delete collectionCopy[key2];
  }
  return collectionCopy;
}
function set(collection, key2, value) {
  if (!isDataStructure(collection)) {
    throw new TypeError("Cannot update non-data-structure value: " + collection);
  }
  if (isImmutable(collection)) {
    if (!collection.set) {
      throw new TypeError("Cannot update immutable value without .set() method: " + collection);
    }
    return collection.set(key2, value);
  }
  if (hasOwnProperty.call(collection, key2) && value === collection[key2]) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  collectionCopy[key2] = value;
  return collectionCopy;
}
function updateIn(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = void 0;
  }
  var updatedValue = updateInDeeply(
    isImmutable(collection),
    // @ts-expect-error type issues with Record and mixed types
    collection,
    coerceKeyPath(keyPath),
    0,
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}
function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
  var wasNotSet = existing === NOT_SET;
  if (i === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError("Cannot update within non-data-structure value in path [" + Array.from(keyPath).slice(0, i).map(quoteString) + "]: " + existing);
  }
  var key2 = keyPath[i];
  var nextExisting = wasNotSet ? NOT_SET : get6(existing, key2, NOT_SET);
  var nextUpdated = updateInDeeply(
    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),
    // @ts-expect-error mixed type
    nextExisting,
    keyPath,
    i + 1,
    notSetValue,
    updater
  );
  return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key2) : set(wasNotSet ? inImmutable ? emptyMap() : {} : existing, key2, nextUpdated);
}
function removeIn(collection, keyPath) {
  return updateIn(collection, keyPath, function() {
    return NOT_SET;
  });
}
function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}
var IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
function isList(maybeList) {
  return Boolean(maybeList && // @ts-expect-error: maybeList is typed as `{}`, need to change in 6.0 to `maybeList && typeof maybeList === 'object' && IS_LIST_SYMBOL in maybeList`
  maybeList[IS_LIST_SYMBOL]);
}
var List = function(IndexedCollection2) {
  function List2(value) {
    var empty2 = emptyList();
    if (value === void 0 || value === null) {
      return empty2;
    }
    if (isList(value)) {
      return value;
    }
    var iter = IndexedCollection2(value);
    var size = iter.size;
    if (size === 0) {
      return empty2;
    }
    assertNotInfinite(size);
    if (size > 0 && size < SIZE) {
      return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
    }
    return empty2.withMutations(function(list2) {
      list2.setSize(size);
      iter.forEach(function(v3, i) {
        return list2.set(i, v3);
      });
    });
  }
  if (IndexedCollection2) List2.__proto__ = IndexedCollection2;
  List2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  List2.prototype.constructor = List2;
  List2.of = function of2() {
    return this(arguments);
  };
  List2.prototype.toString = function toString5() {
    return this.__toString("List [", "]");
  };
  List2.prototype.get = function get11(index, notSetValue) {
    index = wrapIndex(this, index);
    if (index >= 0 && index < this.size) {
      index += this._origin;
      var node = listNodeFor(this, index);
      return node && node.array[index & MASK];
    }
    return notSetValue;
  };
  List2.prototype.set = function set4(index, value) {
    return updateList(this, index, value);
  };
  List2.prototype.remove = function remove3(index) {
    return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
  };
  List2.prototype.insert = function insert(index, value) {
    return this.splice(index, 0, value);
  };
  List2.prototype.clear = function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = this._origin = this._capacity = 0;
      this._level = SHIFT;
      this._root = this._tail = this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyList();
  };
  List2.prototype.push = function push() {
    var values2 = arguments;
    var oldSize = this.size;
    return this.withMutations(function(list2) {
      setListBounds(list2, 0, oldSize + values2.length);
      for (var ii = 0; ii < values2.length; ii++) {
        list2.set(oldSize + ii, values2[ii]);
      }
    });
  };
  List2.prototype.pop = function pop() {
    return setListBounds(this, 0, -1);
  };
  List2.prototype.unshift = function unshift() {
    var values2 = arguments;
    return this.withMutations(function(list2) {
      setListBounds(list2, -values2.length);
      for (var ii = 0; ii < values2.length; ii++) {
        list2.set(ii, values2[ii]);
      }
    });
  };
  List2.prototype.shift = function shift() {
    return setListBounds(this, 1);
  };
  List2.prototype.shuffle = function shuffle(random) {
    if (random === void 0) random = Math.random;
    return this.withMutations(function(mutable) {
      var current3 = mutable.size;
      var destination;
      var tmp;
      while (current3) {
        destination = Math.floor(random() * current3--);
        tmp = mutable.get(destination);
        mutable.set(destination, mutable.get(current3));
        mutable.set(current3, tmp);
      }
    });
  };
  List2.prototype.concat = function concat4() {
    var arguments$1 = arguments;
    var seqs = [];
    for (var i = 0; i < arguments.length; i++) {
      var argument = arguments$1[i];
      var seq = IndexedCollection2(
        typeof argument !== "string" && hasIterator(argument) ? argument : [argument]
      );
      if (seq.size !== 0) {
        seqs.push(seq);
      }
    }
    if (seqs.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
      return this.constructor(seqs[0]);
    }
    return this.withMutations(function(list2) {
      seqs.forEach(function(seq2) {
        return seq2.forEach(function(value) {
          return list2.push(value);
        });
      });
    });
  };
  List2.prototype.setSize = function setSize(size) {
    return setListBounds(this, 0, size);
  };
  List2.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    return this.withMutations(function(list2) {
      for (var i = 0; i < this$1$1.size; i++) {
        list2.set(i, mapper.call(context2, list2.get(i), i, this$1$1));
      }
    });
  };
  List2.prototype.slice = function slice3(begin, end) {
    var size = this.size;
    if (wholeSlice(begin, end, size)) {
      return this;
    }
    return setListBounds(
      this,
      resolveBegin(begin, size),
      resolveEnd(end, size)
    );
  };
  List2.prototype.__iterator = function __iterator2(type, reverse3) {
    var index = reverse3 ? this.size : 0;
    var values2 = iterateList(this, reverse3);
    return new Iterator2(function() {
      var value = values2();
      return value === DONE ? iteratorDone() : iteratorValue(type, reverse3 ? --index : index++, value);
    });
  };
  List2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var index = reverse3 ? this.size : 0;
    var values2 = iterateList(this, reverse3);
    var value;
    while ((value = values2()) !== DONE) {
      if (fn(value, reverse3 ? --index : index++, this) === false) {
        break;
      }
    }
    return index;
  };
  List2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyList();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeList(
      this._origin,
      this._capacity,
      this._level,
      this._root,
      this._tail,
      ownerID,
      this.__hash
    );
  };
  return List2;
}(IndexedCollection);
List.isList = isList;
var ListPrototype = List.prototype;
ListPrototype[IS_LIST_SYMBOL] = true;
ListPrototype[DELETE] = ListPrototype.remove;
ListPrototype.merge = ListPrototype.concat;
ListPrototype.setIn = setIn;
ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
ListPrototype.update = update;
ListPrototype.updateIn = updateIn$1;
ListPrototype.mergeIn = mergeIn;
ListPrototype.mergeDeepIn = mergeDeepIn;
ListPrototype.withMutations = withMutations;
ListPrototype.wasAltered = wasAltered;
ListPrototype.asImmutable = asImmutable;
ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
ListPrototype["@@transducer/step"] = function(result, arr) {
  return result.push(arr);
};
ListPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var VNode = function VNode2(array, ownerID) {
  this.array = array;
  this.ownerID = ownerID;
};
VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
  if ((index & (1 << level + SHIFT) - 1) === 0 || this.array.length === 0) {
    return this;
  }
  var originIndex = index >>> level & MASK;
  if (originIndex >= this.array.length) {
    return new VNode([], ownerID);
  }
  var removingFirst = originIndex === 0;
  var newChild;
  if (level > 0) {
    var oldChild = this.array[originIndex];
    newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
    if (newChild === oldChild && removingFirst) {
      return this;
    }
  }
  if (removingFirst && !newChild) {
    return this;
  }
  var editable = editableVNode(this, ownerID);
  if (!removingFirst) {
    for (var ii = 0; ii < originIndex; ii++) {
      editable.array[ii] = void 0;
    }
  }
  if (newChild) {
    editable.array[originIndex] = newChild;
  }
  return editable;
};
VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
  if (index === (level ? 1 << level + SHIFT : SIZE) || this.array.length === 0) {
    return this;
  }
  var sizeIndex = index - 1 >>> level & MASK;
  if (sizeIndex >= this.array.length) {
    return this;
  }
  var newChild;
  if (level > 0) {
    var oldChild = this.array[sizeIndex];
    newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
    if (newChild === oldChild && sizeIndex === this.array.length - 1) {
      return this;
    }
  }
  var editable = editableVNode(this, ownerID);
  editable.array.splice(sizeIndex + 1);
  if (newChild) {
    editable.array[sizeIndex] = newChild;
  }
  return editable;
};
var DONE = {};
function iterateList(list2, reverse3) {
  var left = list2._origin;
  var right = list2._capacity;
  var tailPos = getTailOffset(right);
  var tail = list2._tail;
  return iterateNodeOrLeaf(list2._root, list2._level, 0);
  function iterateNodeOrLeaf(node, level, offset) {
    return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
  }
  function iterateLeaf(node, offset) {
    var array = offset === tailPos ? tail && tail.array : node && node.array;
    var from2 = offset > left ? 0 : left - offset;
    var to = right - offset;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      if (from2 === to) {
        return DONE;
      }
      var idx = reverse3 ? --to : from2++;
      return array && array[idx];
    };
  }
  function iterateNode(node, level, offset) {
    var values2;
    var array = node && node.array;
    var from2 = offset > left ? 0 : left - offset >> level;
    var to = (right - offset >> level) + 1;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      while (true) {
        if (values2) {
          var value = values2();
          if (value !== DONE) {
            return value;
          }
          values2 = null;
        }
        if (from2 === to) {
          return DONE;
        }
        var idx = reverse3 ? --to : from2++;
        values2 = iterateNodeOrLeaf(
          array && array[idx],
          level - SHIFT,
          offset + (idx << level)
        );
      }
    };
  }
}
function makeList(origin, capacity, level, root, tail, ownerID, hash3) {
  var list2 = Object.create(ListPrototype);
  list2.size = capacity - origin;
  list2._origin = origin;
  list2._capacity = capacity;
  list2._level = level;
  list2._root = root;
  list2._tail = tail;
  list2.__ownerID = ownerID;
  list2.__hash = hash3;
  list2.__altered = false;
  return list2;
}
function emptyList() {
  return makeList(0, 0, SHIFT);
}
function updateList(list2, index, value) {
  index = wrapIndex(list2, index);
  if (index !== index) {
    return list2;
  }
  if (index >= list2.size || index < 0) {
    return list2.withMutations(function(list3) {
      index < 0 ? setListBounds(list3, index).set(0, value) : setListBounds(list3, 0, index + 1).set(index, value);
    });
  }
  index += list2._origin;
  var newTail = list2._tail;
  var newRoot = list2._root;
  var didAlter = MakeRef();
  if (index >= getTailOffset(list2._capacity)) {
    newTail = updateVNode(newTail, list2.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(
      newRoot,
      list2.__ownerID,
      list2._level,
      index,
      value,
      didAlter
    );
  }
  if (!didAlter.value) {
    return list2;
  }
  if (list2.__ownerID) {
    list2._root = newRoot;
    list2._tail = newTail;
    list2.__hash = void 0;
    list2.__altered = true;
    return list2;
  }
  return makeList(list2._origin, list2._capacity, list2._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index, value, didAlter) {
  var idx = index >>> level & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value === void 0) {
    return node;
  }
  var newNode;
  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index,
      value,
      didAlter
    );
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }
  if (nodeHas && node.array[idx] === value) {
    return node;
  }
  if (didAlter) {
    SetRef(didAlter);
  }
  newNode = editableVNode(node, ownerID);
  if (value === void 0 && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }
  return newNode;
}
function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}
function listNodeFor(list2, rawIndex) {
  if (rawIndex >= getTailOffset(list2._capacity)) {
    return list2._tail;
  }
  if (rawIndex < 1 << list2._level + SHIFT) {
    var node = list2._root;
    var level = list2._level;
    while (node && level > 0) {
      node = node.array[rawIndex >>> level & MASK];
      level -= SHIFT;
    }
    return node;
  }
}
function setListBounds(list2, begin, end) {
  if (begin !== void 0) {
    begin |= 0;
  }
  if (end !== void 0) {
    end |= 0;
  }
  var owner = list2.__ownerID || new OwnerID();
  var oldOrigin = list2._origin;
  var oldCapacity = list2._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list2;
  }
  if (newOrigin >= newCapacity) {
    return list2.clear();
  }
  var newLevel = list2._level;
  var newRoot = list2._root;
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [void 0, newRoot] : [],
      owner
    );
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }
  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);
  while (newTailOffset >= 1 << newLevel + SHIFT) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [newRoot] : [],
      owner
    );
    newLevel += SHIFT;
  }
  var oldTail = list2._tail;
  var newTail = newTailOffset < oldTailOffset ? listNodeFor(list2, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = oldTailOffset >>> level & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
  }
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;
    while (newRoot) {
      var beginIndex = newOrigin >>> newLevel & MASK;
      if (beginIndex !== newTailOffset >>> newLevel & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(
        owner,
        newLevel,
        newTailOffset - offsetShift
      );
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }
  if (list2.__ownerID) {
    list2.size = newCapacity - newOrigin;
    list2._origin = newOrigin;
    list2._capacity = newCapacity;
    list2._level = newLevel;
    list2._root = newRoot;
    list2._tail = newTail;
    list2.__hash = void 0;
    list2.__altered = true;
    return list2;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
function getTailOffset(size) {
  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
}
function isOrderedMap(maybeOrderedMap) {
  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
var OrderedMap = function(Map3) {
  function OrderedMap2(value) {
    return value === void 0 || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map3) {
      var iter = KeyedCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v3, k) {
        return map3.set(k, v3);
      });
    });
  }
  if (Map3) OrderedMap2.__proto__ = Map3;
  OrderedMap2.prototype = Object.create(Map3 && Map3.prototype);
  OrderedMap2.prototype.constructor = OrderedMap2;
  OrderedMap2.of = function of2() {
    return this(arguments);
  };
  OrderedMap2.prototype.toString = function toString5() {
    return this.__toString("OrderedMap {", "}");
  };
  OrderedMap2.prototype.get = function get11(k, notSetValue) {
    var index = this._map.get(k);
    return index !== void 0 ? this._list.get(index)[1] : notSetValue;
  };
  OrderedMap2.prototype.clear = function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._map.clear();
      this._list.clear();
      this.__altered = true;
      return this;
    }
    return emptyOrderedMap();
  };
  OrderedMap2.prototype.set = function set4(k, v3) {
    return updateOrderedMap(this, k, v3);
  };
  OrderedMap2.prototype.remove = function remove3(k) {
    return updateOrderedMap(this, k, NOT_SET);
  };
  OrderedMap2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._list.__iterate(
      function(entry) {
        return entry && fn(entry[1], entry[0], this$1$1);
      },
      reverse3
    );
  };
  OrderedMap2.prototype.__iterator = function __iterator2(type, reverse3) {
    return this._list.fromEntrySeq().__iterator(type, reverse3);
  };
  OrderedMap2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    var newList = this._list.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return emptyOrderedMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      this._map = newMap;
      this._list = newList;
      return this;
    }
    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  };
  return OrderedMap2;
}(Map2);
OrderedMap.isOrderedMap = isOrderedMap;
OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
function makeOrderedMap(map3, list2, ownerID, hash3) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map3 ? map3.size : 0;
  omap._map = map3;
  omap._list = list2;
  omap.__ownerID = ownerID;
  omap.__hash = hash3;
  omap.__altered = false;
  return omap;
}
var EMPTY_ORDERED_MAP;
function emptyOrderedMap() {
  return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}
function updateOrderedMap(omap, k, v3) {
  var map3 = omap._map;
  var list2 = omap._list;
  var i = map3.get(k);
  var has6 = i !== void 0;
  var newMap;
  var newList;
  if (v3 === NOT_SET) {
    if (!has6) {
      return omap;
    }
    if (list2.size >= SIZE && list2.size >= map3.size * 2) {
      newList = list2.filter(function(entry, idx) {
        return entry !== void 0 && i !== idx;
      });
      newMap = newList.toKeyedSeq().map(function(entry) {
        return entry[0];
      }).flip().toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map3.remove(k);
      newList = i === list2.size - 1 ? list2.pop() : list2.set(i, void 0);
    }
  } else if (has6) {
    if (v3 === list2.get(i)[1]) {
      return omap;
    }
    newMap = map3;
    newList = list2.set(i, [k, v3]);
  } else {
    newMap = map3.set(k, list2.size);
    newList = list2.set(list2.size, [k, v3]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = void 0;
    omap.__altered = true;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}
var IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
function isStack(maybeStack) {
  return Boolean(maybeStack && // @ts-expect-error: maybeStack is typed as `{}`, need to change in 6.0 to `maybeStack && typeof maybeStack === 'object' && MAYBE_STACK_SYMBOL in maybeStack`
  maybeStack[IS_STACK_SYMBOL]);
}
var Stack = function(IndexedCollection2) {
  function Stack2(value) {
    return value === void 0 || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
  }
  if (IndexedCollection2) Stack2.__proto__ = IndexedCollection2;
  Stack2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  Stack2.prototype.constructor = Stack2;
  Stack2.of = function of2() {
    return this(arguments);
  };
  Stack2.prototype.toString = function toString5() {
    return this.__toString("Stack [", "]");
  };
  Stack2.prototype.get = function get11(index, notSetValue) {
    var head = this._head;
    index = wrapIndex(this, index);
    while (head && index--) {
      head = head.next;
    }
    return head ? head.value : notSetValue;
  };
  Stack2.prototype.peek = function peek2() {
    return this._head && this._head.value;
  };
  Stack2.prototype.push = function push() {
    var arguments$1 = arguments;
    if (arguments.length === 0) {
      return this;
    }
    var newSize = this.size + arguments.length;
    var head = this._head;
    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments$1[ii],
        next: head
      };
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.pushAll = function pushAll(iter) {
    iter = IndexedCollection2(iter);
    if (iter.size === 0) {
      return this;
    }
    if (this.size === 0 && isStack(iter)) {
      return iter;
    }
    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;
    iter.__iterate(
      function(value) {
        newSize++;
        head = {
          value,
          next: head
        };
      },
      /* reverse */
      true
    );
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.pop = function pop() {
    return this.slice(1);
  };
  Stack2.prototype.clear = function clear2() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._head = void 0;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyStack();
  };
  Stack2.prototype.slice = function slice3(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end, this.size);
    if (resolvedEnd !== this.size) {
      return IndexedCollection2.prototype.slice.call(this, begin, end);
    }
    var newSize = this.size - resolvedBegin;
    var head = this._head;
    while (resolvedBegin--) {
      head = head.next;
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyStack();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeStack(this.size, this._head, ownerID, this.__hash);
  };
  Stack2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterate(
        function(v3, k) {
          return fn(v3, k, this$1$1);
        },
        reverse3
      );
    }
    var iterations = 0;
    var node = this._head;
    while (node) {
      if (fn(node.value, iterations++, this) === false) {
        break;
      }
      node = node.next;
    }
    return iterations;
  };
  Stack2.prototype.__iterator = function __iterator2(type, reverse3) {
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterator(type, reverse3);
    }
    var iterations = 0;
    var node = this._head;
    return new Iterator2(function() {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }
      return iteratorDone();
    });
  };
  return Stack2;
}(IndexedCollection);
Stack.isStack = isStack;
var StackPrototype = Stack.prototype;
StackPrototype[IS_STACK_SYMBOL] = true;
StackPrototype.shift = StackPrototype.pop;
StackPrototype.unshift = StackPrototype.push;
StackPrototype.unshiftAll = StackPrototype.pushAll;
StackPrototype.withMutations = withMutations;
StackPrototype.wasAltered = wasAltered;
StackPrototype.asImmutable = asImmutable;
StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
StackPrototype["@@transducer/step"] = function(result, arr) {
  return result.unshift(arr);
};
StackPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
function makeStack(size, head, ownerID, hash3) {
  var map3 = Object.create(StackPrototype);
  map3.size = size;
  map3._head = head;
  map3.__ownerID = ownerID;
  map3.__hash = hash3;
  map3.__altered = false;
  return map3;
}
var EMPTY_STACK;
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
function reduce(collection, reducer, reduction, context2, useFirst, reverse3) {
  assertNotInfinite(collection.size);
  collection.__iterate(function(v3, k, c5) {
    if (useFirst) {
      useFirst = false;
      reduction = v3;
    } else {
      reduction = reducer.call(context2, reduction, v3, k, c5);
    }
  }, reverse3);
  return reduction;
}
function keyMapper(v3, k) {
  return k;
}
function entryMapper(v3, k) {
  return [k, v3];
}
function not(predicate) {
  return function() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    return !predicate.apply(this, args);
  };
}
function neg(predicate) {
  return function() {
    var args = [], len = arguments.length;
    while (len--) args[len] = arguments[len];
    return -predicate.apply(this, args);
  };
}
function defaultNegComparator(a5, b5) {
  return a5 < b5 ? 1 : a5 > b5 ? -1 : 0;
}
function deepEqual2(a5, b5) {
  if (a5 === b5) {
    return true;
  }
  if (!isCollection(b5) || // @ts-expect-error size should exists on Collection
  a5.size !== void 0 && b5.size !== void 0 && a5.size !== b5.size || // @ts-expect-error __hash exists on Collection
  a5.__hash !== void 0 && // @ts-expect-error __hash exists on Collection
  b5.__hash !== void 0 && // @ts-expect-error __hash exists on Collection
  a5.__hash !== b5.__hash || isKeyed(a5) !== isKeyed(b5) || isIndexed(a5) !== isIndexed(b5) || // @ts-expect-error Range extends Collection, which implements [Symbol.iterator], so it is valid
  isOrdered(a5) !== isOrdered(b5)) {
    return false;
  }
  if (a5.size === 0 && b5.size === 0) {
    return true;
  }
  var notAssociative = !isAssociative(a5);
  if (isOrdered(a5)) {
    var entries3 = a5.entries();
    return b5.every(function(v3, k) {
      var entry = entries3.next().value;
      return entry && is(entry[1], v3) && (notAssociative || is(entry[0], k));
    }) && entries3.next().done;
  }
  var flipped = false;
  if (a5.size === void 0) {
    if (b5.size === void 0) {
      if (typeof a5.cacheResult === "function") {
        a5.cacheResult();
      }
    } else {
      flipped = true;
      var _ = a5;
      a5 = b5;
      b5 = _;
    }
  }
  var allEqual = true;
  var bSize = (
    // @ts-expect-error b is Range | Repeat | Collection<unknown, unknown> as it may have been flipped, and __iterate is valid
    b5.__iterate(function(v3, k) {
      if (notAssociative ? (
        // @ts-expect-error has exists on Collection
        !a5.has(v3)
      ) : flipped ? (
        // @ts-expect-error type of `get` does not "catch" the version with `notSetValue`
        !is(v3, a5.get(k, NOT_SET))
      ) : (
        // @ts-expect-error type of `get` does not "catch" the version with `notSetValue`
        !is(a5.get(k, NOT_SET), v3)
      )) {
        allEqual = false;
        return false;
      }
    })
  );
  return allEqual && // @ts-expect-error size should exists on Collection
  a5.size === bSize;
}
var Range = function(IndexedSeq2) {
  function Range2(start, end, step) {
    if (step === void 0) step = 1;
    if (!(this instanceof Range2)) {
      return new Range2(start, end, step);
    }
    invariant(step !== 0, "Cannot step a Range by 0");
    invariant(
      start !== void 0,
      "You must define a start value when using Range"
    );
    invariant(
      end !== void 0,
      "You must define an end value when using Range"
    );
    step = Math.abs(step);
    if (end < start) {
      step = -step;
    }
    this._start = start;
    this._end = end;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }
      EMPTY_RANGE = this;
    }
  }
  if (IndexedSeq2) Range2.__proto__ = IndexedSeq2;
  Range2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  Range2.prototype.constructor = Range2;
  Range2.prototype.toString = function toString5() {
    return this.size === 0 ? "Range []" : "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
  };
  Range2.prototype.get = function get11(index, notSetValue) {
    return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
  };
  Range2.prototype.includes = function includes3(searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
  };
  Range2.prototype.slice = function slice3(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    begin = resolveBegin(begin, this.size);
    end = resolveEnd(end, this.size);
    if (end <= begin) {
      return new Range2(0, 0);
    }
    return new Range2(
      this.get(begin, this._end),
      this.get(end, this._end),
      this._step
    );
  };
  Range2.prototype.indexOf = function indexOf2(searchValue) {
    var offsetValue = searchValue - this._start;
    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;
      if (index >= 0 && index < this.size) {
        return index;
      }
    }
    return -1;
  };
  Range2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
    return this.indexOf(searchValue);
  };
  Range2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var size = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size - 1) * step : this._start;
    var i = 0;
    while (i !== size) {
      if (fn(value, reverse3 ? size - ++i : i++, this) === false) {
        break;
      }
      value += reverse3 ? -step : step;
    }
    return i;
  };
  Range2.prototype.__iterator = function __iterator2(type, reverse3) {
    var size = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size - 1) * step : this._start;
    var i = 0;
    return new Iterator2(function() {
      if (i === size) {
        return iteratorDone();
      }
      var v3 = value;
      value += reverse3 ? -step : step;
      return iteratorValue(type, reverse3 ? size - ++i : i++, v3);
    });
  };
  Range2.prototype.equals = function equals3(other) {
    return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual2(this, other);
  };
  return Range2;
}(IndexedSeq);
var EMPTY_RANGE;
var IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
function isSet(maybeSet) {
  return Boolean(maybeSet && // @ts-expect-error: maybeSet is typed as `{}`,  need to change in 6.0 to `maybeSeq && typeof maybeSet === 'object' && MAYBE_SET_SYMBOL in maybeSet`
  maybeSet[IS_SET_SYMBOL]);
}
var Set2 = function(SetCollection2) {
  function Set3(value) {
    return value === void 0 || value === null ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set4) {
      var iter = SetCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v3) {
        return set4.add(v3);
      });
    });
  }
  if (SetCollection2) Set3.__proto__ = SetCollection2;
  Set3.prototype = Object.create(SetCollection2 && SetCollection2.prototype);
  Set3.prototype.constructor = Set3;
  Set3.of = function of2() {
    return this(arguments);
  };
  Set3.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };
  Set3.intersect = function intersect(sets) {
    sets = Collection(sets).toArray();
    return sets.length ? SetPrototype.intersect.apply(Set3(sets.pop()), sets) : emptySet();
  };
  Set3.union = function union(sets) {
    sets = Collection(sets).toArray();
    return sets.length ? SetPrototype.union.apply(Set3(sets.pop()), sets) : emptySet();
  };
  Set3.prototype.toString = function toString5() {
    return this.__toString("Set {", "}");
  };
  Set3.prototype.has = function has6(value) {
    return this._map.has(value);
  };
  Set3.prototype.add = function add(value) {
    return updateSet(this, this._map.set(value, value));
  };
  Set3.prototype.remove = function remove3(value) {
    return updateSet(this, this._map.remove(value));
  };
  Set3.prototype.clear = function clear2() {
    return updateSet(this, this._map.clear());
  };
  Set3.prototype.map = function map3(mapper, context2) {
    var this$1$1 = this;
    var didChanges = false;
    var newMap = updateSet(
      this,
      this._map.mapEntries(function(ref) {
        var v3 = ref[1];
        var mapped = mapper.call(context2, v3, v3, this$1$1);
        if (mapped !== v3) {
          didChanges = true;
        }
        return [mapped, mapped];
      }, context2)
    );
    return didChanges ? newMap : this;
  };
  Set3.prototype.union = function union() {
    var iters = [], len = arguments.length;
    while (len--) iters[len] = arguments[len];
    iters = iters.filter(function(x) {
      return x.size !== 0;
    });
    if (iters.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }
    return this.withMutations(function(set4) {
      for (var ii = 0; ii < iters.length; ii++) {
        if (typeof iters[ii] === "string") {
          set4.add(iters[ii]);
        } else {
          SetCollection2(iters[ii]).forEach(function(value) {
            return set4.add(value);
          });
        }
      }
    });
  };
  Set3.prototype.intersect = function intersect() {
    var iters = [], len = arguments.length;
    while (len--) iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (!iters.every(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set4) {
      toRemove.forEach(function(value) {
        set4.remove(value);
      });
    });
  };
  Set3.prototype.subtract = function subtract() {
    var iters = [], len = arguments.length;
    while (len--) iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (iters.some(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set4) {
      toRemove.forEach(function(value) {
        set4.remove(value);
      });
    });
  };
  Set3.prototype.sort = function sort2(comparator) {
    return OrderedSet2(sortFactory(this, comparator));
  };
  Set3.prototype.sortBy = function sortBy2(mapper, comparator) {
    return OrderedSet2(sortFactory(this, comparator, mapper));
  };
  Set3.prototype.wasAltered = function wasAltered3() {
    return this._map.wasAltered();
  };
  Set3.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._map.__iterate(function(k) {
      return fn(k, k, this$1$1);
    }, reverse3);
  };
  Set3.prototype.__iterator = function __iterator2(type, reverse3) {
    return this._map.__iterator(type, reverse3);
  };
  Set3.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return this.__empty();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return this.__make(newMap, ownerID);
  };
  return Set3;
}(SetCollection);
Set2.isSet = isSet;
var SetPrototype = Set2.prototype;
SetPrototype[IS_SET_SYMBOL] = true;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
SetPrototype.withMutations = withMutations;
SetPrototype.asImmutable = asImmutable;
SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
SetPrototype["@@transducer/step"] = function(result, arr) {
  return result.add(arr);
};
SetPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
SetPrototype.__empty = emptySet;
SetPrototype.__make = makeSet;
function updateSet(set4, newMap) {
  if (set4.__ownerID) {
    set4.size = newMap.size;
    set4._map = newMap;
    return set4;
  }
  return newMap === set4._map ? set4 : newMap.size === 0 ? set4.__empty() : set4.__make(newMap);
}
function makeSet(map3, ownerID) {
  var set4 = Object.create(SetPrototype);
  set4.size = map3 ? map3.size : 0;
  set4._map = map3;
  set4.__ownerID = ownerID;
  return set4;
}
var EMPTY_SET;
function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
function getIn$1(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i = 0;
  while (i !== keyPath.length) {
    collection = get6(collection, keyPath[i++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}
function getIn(searchKeyPath, notSetValue) {
  return getIn$1(this, searchKeyPath, notSetValue);
}
function hasIn$1(collection, keyPath) {
  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
}
function hasIn(searchKeyPath) {
  return hasIn$1(this, searchKeyPath);
}
function toObject() {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v3, k) {
    object[k] = v3;
  });
  return object;
}
function toJS(value) {
  if (!value || typeof value !== "object") {
    return value;
  }
  if (!isCollection(value)) {
    if (!isDataStructure(value)) {
      return value;
    }
    value = Seq(value);
  }
  if (isKeyed(value)) {
    var result$1 = {};
    value.__iterate(function(v3, k) {
      result$1[k] = toJS(v3);
    });
    return result$1;
  }
  var result = [];
  value.__iterate(function(v3) {
    result.push(toJS(v3));
  });
  return result;
}
function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h = ordered ? 1 : 0;
  collection.__iterate(keyed ? ordered ? function(v3, k) {
    h = 31 * h + hashMerge(hash(v3), hash(k)) | 0;
  } : function(v3, k) {
    h = h + hashMerge(hash(v3), hash(k)) | 0;
  } : ordered ? function(v3) {
    h = 31 * h + hash(v3) | 0;
  } : function(v3) {
    h = h + hash(v3) | 0;
  });
  return murmurHashOfSize(collection.size, h);
}
function murmurHashOfSize(size, h) {
  h = imul(h, 3432918353);
  h = imul(h << 15 | h >>> -15, 461845907);
  h = imul(h << 13 | h >>> -13, 5);
  h = (h + 3864292196 | 0) ^ size;
  h = imul(h ^ h >>> 16, 2246822507);
  h = imul(h ^ h >>> 13, 3266489909);
  h = smi(h ^ h >>> 16);
  return h;
}
function hashMerge(a5, b5) {
  return a5 ^ b5 + 2654435769 + (a5 << 6) + (a5 >> 2) | 0;
}
function mixin(ctor, methods) {
  var keyCopier = function(key2) {
    ctor.prototype[key2] = methods[key2];
  };
  Object.keys(methods).forEach(keyCopier);
  Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  return ctor;
}
Collection.Iterator = Iterator2;
mixin(Collection, {
  // ### Conversion to other types
  toArray: function toArray() {
    assertNotInfinite(this.size);
    var array = new Array(this.size || 0);
    var useTuples = isKeyed(this);
    var i = 0;
    this.__iterate(function(v3, k) {
      array[i++] = useTuples ? [k, v3] : v3;
    });
    return array;
  },
  toIndexedSeq: function toIndexedSeq() {
    return new ToIndexedSequence(this);
  },
  toJS: function toJS$1() {
    return toJS(this);
  },
  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, true);
  },
  toMap: function toMap() {
    return Map2(this.toKeyedSeq());
  },
  toObject,
  toOrderedMap: function toOrderedMap() {
    return OrderedMap(this.toKeyedSeq());
  },
  toOrderedSet: function toOrderedSet() {
    return OrderedSet2(isKeyed(this) ? this.valueSeq() : this);
  },
  toSet: function toSet() {
    return Set2(isKeyed(this) ? this.valueSeq() : this);
  },
  toSetSeq: function toSetSeq() {
    return new ToSetSequence(this);
  },
  toSeq: function toSeq() {
    return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
  },
  toStack: function toStack() {
    return Stack(isKeyed(this) ? this.valueSeq() : this);
  },
  toList: function toList() {
    return List(isKeyed(this) ? this.valueSeq() : this);
  },
  // ### Common JavaScript methods and properties
  toString: function toString3() {
    return "[Collection]";
  },
  __toString: function __toString(head, tail) {
    if (this.size === 0) {
      return head + tail;
    }
    return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
  },
  // ### ES6 Collection methods (ES6 Array and Map)
  concat: function concat() {
    var values2 = [], len = arguments.length;
    while (len--) values2[len] = arguments[len];
    return reify(this, concatFactory(this, values2));
  },
  includes: function includes(searchValue) {
    return this.some(function(value) {
      return is(value, searchValue);
    });
  },
  entries: function entries() {
    return this.__iterator(ITERATE_ENTRIES);
  },
  every: function every(predicate, context2) {
    assertNotInfinite(this.size);
    var returnValue = true;
    this.__iterate(function(v3, k, c5) {
      if (!predicate.call(context2, v3, k, c5)) {
        returnValue = false;
        return false;
      }
    });
    return returnValue;
  },
  filter: function filter(predicate, context2) {
    return reify(this, filterFactory(this, predicate, context2, true));
  },
  partition: function partition(predicate, context2) {
    return partitionFactory(this, predicate, context2);
  },
  find: function find(predicate, context2, notSetValue) {
    var entry = this.findEntry(predicate, context2);
    return entry ? entry[1] : notSetValue;
  },
  forEach: function forEach(sideEffect, context2) {
    assertNotInfinite(this.size);
    return this.__iterate(context2 ? sideEffect.bind(context2) : sideEffect);
  },
  join: function join(separator) {
    assertNotInfinite(this.size);
    separator = separator !== void 0 ? "" + separator : ",";
    var joined = "";
    var isFirst = true;
    this.__iterate(function(v3) {
      isFirst ? isFirst = false : joined += separator;
      joined += v3 !== null && v3 !== void 0 ? v3.toString() : "";
    });
    return joined;
  },
  keys: function keys() {
    return this.__iterator(ITERATE_KEYS);
  },
  map: function map(mapper, context2) {
    return reify(this, mapFactory(this, mapper, context2));
  },
  reduce: function reduce$1(reducer, initialReduction, context2) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context2,
      arguments.length < 2,
      false
    );
  },
  reduceRight: function reduceRight(reducer, initialReduction, context2) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context2,
      arguments.length < 2,
      true
    );
  },
  reverse: function reverse() {
    return reify(this, reverseFactory(this, true));
  },
  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, true));
  },
  some: function some(predicate, context2) {
    assertNotInfinite(this.size);
    var returnValue = false;
    this.__iterate(function(v3, k, c5) {
      if (predicate.call(context2, v3, k, c5)) {
        returnValue = true;
        return false;
      }
    });
    return returnValue;
  },
  sort: function sort(comparator) {
    return reify(this, sortFactory(this, comparator));
  },
  values: function values() {
    return this.__iterator(ITERATE_VALUES);
  },
  // ### More sequential methods
  butLast: function butLast() {
    return this.slice(0, -1);
  },
  isEmpty: function isEmpty() {
    return this.size !== void 0 ? this.size === 0 : !this.some(function() {
      return true;
    });
  },
  count: function count(predicate, context2) {
    return ensureSize(
      predicate ? this.toSeq().filter(predicate, context2) : this
    );
  },
  countBy: function countBy(grouper, context2) {
    return countByFactory(this, grouper, context2);
  },
  equals: function equals(other) {
    return deepEqual2(this, other);
  },
  entrySeq: function entrySeq() {
    var collection = this;
    if (collection._cache) {
      return new ArraySeq(collection._cache);
    }
    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
    entriesSequence.fromEntrySeq = function() {
      return collection.toSeq();
    };
    return entriesSequence;
  },
  filterNot: function filterNot(predicate, context2) {
    return this.filter(not(predicate), context2);
  },
  findEntry: function findEntry(predicate, context2, notSetValue) {
    var found = notSetValue;
    this.__iterate(function(v3, k, c5) {
      if (predicate.call(context2, v3, k, c5)) {
        found = [k, v3];
        return false;
      }
    });
    return found;
  },
  findKey: function findKey(predicate, context2) {
    var entry = this.findEntry(predicate, context2);
    return entry && entry[0];
  },
  findLast: function findLast(predicate, context2, notSetValue) {
    return this.toKeyedSeq().reverse().find(predicate, context2, notSetValue);
  },
  findLastEntry: function findLastEntry(predicate, context2, notSetValue) {
    return this.toKeyedSeq().reverse().findEntry(predicate, context2, notSetValue);
  },
  findLastKey: function findLastKey(predicate, context2) {
    return this.toKeyedSeq().reverse().findKey(predicate, context2);
  },
  first: function first(notSetValue) {
    return this.find(returnTrue, null, notSetValue);
  },
  flatMap: function flatMap(mapper, context2) {
    return reify(this, flatMapFactory(this, mapper, context2));
  },
  flatten: function flatten(depth) {
    return reify(this, flattenFactory(this, depth, true));
  },
  fromEntrySeq: function fromEntrySeq() {
    return new FromEntriesSequence(this);
  },
  get: function get7(searchKey, notSetValue) {
    return this.find(function(_, key2) {
      return is(key2, searchKey);
    }, void 0, notSetValue);
  },
  getIn,
  groupBy: function groupBy(grouper, context2) {
    return groupByFactory(this, grouper, context2);
  },
  has: function has2(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  },
  hasIn,
  isSubset: function isSubset(iter) {
    iter = typeof iter.includes === "function" ? iter : Collection(iter);
    return this.every(function(value) {
      return iter.includes(value);
    });
  },
  isSuperset: function isSuperset(iter) {
    iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
    return iter.isSubset(this);
  },
  keyOf: function keyOf(searchValue) {
    return this.findKey(function(value) {
      return is(value, searchValue);
    });
  },
  keySeq: function keySeq() {
    return this.toSeq().map(keyMapper).toIndexedSeq();
  },
  last: function last(notSetValue) {
    return this.toSeq().reverse().first(notSetValue);
  },
  lastKeyOf: function lastKeyOf(searchValue) {
    return this.toKeyedSeq().reverse().keyOf(searchValue);
  },
  max: function max(comparator) {
    return maxFactory(this, comparator);
  },
  maxBy: function maxBy(mapper, comparator) {
    return maxFactory(this, comparator, mapper);
  },
  min: function min(comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator
    );
  },
  minBy: function minBy(mapper, comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator,
      mapper
    );
  },
  rest: function rest() {
    return this.slice(1);
  },
  skip: function skip(amount) {
    return amount === 0 ? this : this.slice(Math.max(0, amount));
  },
  skipLast: function skipLast(amount) {
    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
  },
  skipWhile: function skipWhile(predicate, context2) {
    return reify(this, skipWhileFactory(this, predicate, context2, true));
  },
  skipUntil: function skipUntil(predicate, context2) {
    return this.skipWhile(not(predicate), context2);
  },
  sortBy: function sortBy(mapper, comparator) {
    return reify(this, sortFactory(this, comparator, mapper));
  },
  take: function take(amount) {
    return this.slice(0, Math.max(0, amount));
  },
  takeLast: function takeLast(amount) {
    return this.slice(-Math.max(0, amount));
  },
  takeWhile: function takeWhile(predicate, context2) {
    return reify(this, takeWhileFactory(this, predicate, context2));
  },
  takeUntil: function takeUntil(predicate, context2) {
    return this.takeWhile(not(predicate), context2);
  },
  update: function update7(fn) {
    return fn(this);
  },
  valueSeq: function valueSeq() {
    return this.toIndexedSeq();
  },
  // ### Hashable Object
  hashCode: function hashCode() {
    return this.__hash || (this.__hash = hashCollection(this));
  }
  // ### Internal
  // abstract __iterate(fn, reverse)
  // abstract __iterator(type, reverse)
});
var CollectionPrototype = Collection.prototype;
CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
CollectionPrototype.toJSON = CollectionPrototype.toArray;
CollectionPrototype.__toStringMapper = quoteString;
CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
  return this.toString();
};
CollectionPrototype.chain = CollectionPrototype.flatMap;
CollectionPrototype.contains = CollectionPrototype.includes;
mixin(KeyedCollection, {
  // ### More sequential methods
  flip: function flip() {
    return reify(this, flipFactory(this));
  },
  mapEntries: function mapEntries(mapper, context2) {
    var this$1$1 = this;
    var iterations = 0;
    return reify(
      this,
      this.toSeq().map(function(v3, k) {
        return mapper.call(context2, [k, v3], iterations++, this$1$1);
      }).fromEntrySeq()
    );
  },
  mapKeys: function mapKeys(mapper, context2) {
    var this$1$1 = this;
    return reify(
      this,
      this.toSeq().flip().map(function(k, v3) {
        return mapper.call(context2, k, v3, this$1$1);
      }).flip()
    );
  }
});
var KeyedCollectionPrototype = KeyedCollection.prototype;
KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
KeyedCollectionPrototype.toJSON = toObject;
KeyedCollectionPrototype.__toStringMapper = function(v3, k) {
  return quoteString(k) + ": " + quoteString(v3);
};
mixin(IndexedCollection, {
  // ### Conversion to other types
  toKeyedSeq: function toKeyedSeq2() {
    return new ToKeyedSequence(this, false);
  },
  // ### ES6 Collection methods (ES6 Array and Map)
  filter: function filter2(predicate, context2) {
    return reify(this, filterFactory(this, predicate, context2, false));
  },
  findIndex: function findIndex(predicate, context2) {
    var entry = this.findEntry(predicate, context2);
    return entry ? entry[0] : -1;
  },
  indexOf: function indexOf(searchValue) {
    var key2 = this.keyOf(searchValue);
    return key2 === void 0 ? -1 : key2;
  },
  lastIndexOf: function lastIndexOf(searchValue) {
    var key2 = this.lastKeyOf(searchValue);
    return key2 === void 0 ? -1 : key2;
  },
  reverse: function reverse2() {
    return reify(this, reverseFactory(this, false));
  },
  slice: function slice2(begin, end) {
    return reify(this, sliceFactory(this, begin, end, false));
  },
  splice: function splice(index, removeNum) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum || 0, 0);
    if (numArgs === 0 || numArgs === 2 && !removeNum) {
      return this;
    }
    index = resolveBegin(index, index < 0 ? this.count() : this.size);
    var spliced = this.slice(0, index);
    return reify(
      this,
      numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
    );
  },
  // ### More collection methods
  findLastIndex: function findLastIndex(predicate, context2) {
    var entry = this.findLastEntry(predicate, context2);
    return entry ? entry[0] : -1;
  },
  first: function first2(notSetValue) {
    return this.get(0, notSetValue);
  },
  flatten: function flatten2(depth) {
    return reify(this, flattenFactory(this, depth, false));
  },
  get: function get8(index, notSetValue) {
    index = wrapIndex(this, index);
    return index < 0 || this.size === Infinity || this.size !== void 0 && index > this.size ? notSetValue : this.find(function(_, key2) {
      return key2 === index;
    }, void 0, notSetValue);
  },
  has: function has3(index) {
    index = wrapIndex(this, index);
    return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
  },
  interpose: function interpose(separator) {
    return reify(this, interposeFactory(this, separator));
  },
  interleave: function interleave() {
    var collections = [this].concat(arrCopy(arguments));
    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
    var interleaved = zipped.flatten(true);
    if (zipped.size) {
      interleaved.size = zipped.size * collections.length;
    }
    return reify(this, interleaved);
  },
  keySeq: function keySeq2() {
    return Range(0, this.size);
  },
  last: function last2(notSetValue) {
    return this.get(-1, notSetValue);
  },
  skipWhile: function skipWhile2(predicate, context2) {
    return reify(this, skipWhileFactory(this, predicate, context2, false));
  },
  zip: function zip() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections));
  },
  zipAll: function zipAll() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections, true));
  },
  zipWith: function zipWith(zipper) {
    var collections = arrCopy(arguments);
    collections[0] = this;
    return reify(this, zipWithFactory(this, zipper, collections));
  }
});
var IndexedCollectionPrototype = IndexedCollection.prototype;
IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
mixin(SetCollection, {
  // ### ES6 Collection methods (ES6 Array and Map)
  get: function get9(value, notSetValue) {
    return this.has(value) ? value : notSetValue;
  },
  includes: function includes2(value) {
    return this.has(value);
  },
  // ### More sequential methods
  keySeq: function keySeq3() {
    return this.valueSeq();
  }
});
var SetCollectionPrototype = SetCollection.prototype;
SetCollectionPrototype.has = CollectionPrototype.includes;
SetCollectionPrototype.contains = SetCollectionPrototype.includes;
SetCollectionPrototype.keys = SetCollectionPrototype.values;
mixin(KeyedSeq, KeyedCollectionPrototype);
mixin(IndexedSeq, IndexedCollectionPrototype);
mixin(SetSeq, SetCollectionPrototype);
function defaultZipper() {
  return arrCopy(arguments);
}
function isOrderedSet(maybeOrderedSet) {
  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
var OrderedSet2 = function(Set3) {
  function OrderedSet3(value) {
    return value === void 0 || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set4) {
      var iter = SetCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v3) {
        return set4.add(v3);
      });
    });
  }
  if (Set3) OrderedSet3.__proto__ = Set3;
  OrderedSet3.prototype = Object.create(Set3 && Set3.prototype);
  OrderedSet3.prototype.constructor = OrderedSet3;
  OrderedSet3.of = function of2() {
    return this(arguments);
  };
  OrderedSet3.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };
  OrderedSet3.prototype.toString = function toString5() {
    return this.__toString("OrderedSet {", "}");
  };
  return OrderedSet3;
}(Set2);
OrderedSet2.isOrderedSet = isOrderedSet;
var OrderedSetPrototype = OrderedSet2.prototype;
OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
OrderedSetPrototype.__empty = emptyOrderedSet;
OrderedSetPrototype.__make = makeOrderedSet;
function makeOrderedSet(map3, ownerID) {
  var set4 = Object.create(OrderedSetPrototype);
  set4.size = map3 ? map3.size : 0;
  set4._map = map3;
  set4.__ownerID = ownerID;
  return set4;
}
var EMPTY_ORDERED_SET;
function emptyOrderedSet() {
  return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}
function throwOnInvalidDefaultValues(defaultValues) {
  if (isRecord(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead."
    );
  }
  if (isImmutable(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead."
    );
  }
  if (defaultValues === null || typeof defaultValues !== "object") {
    throw new Error(
      "Can not call `Record` with a non-object as default values. Use a plain javascript object instead."
    );
  }
}
var Record = function Record2(defaultValues, name) {
  var hasInitialized;
  throwOnInvalidDefaultValues(defaultValues);
  var RecordType = function Record3(values2) {
    var this$1$1 = this;
    if (values2 instanceof RecordType) {
      return values2;
    }
    if (!(this instanceof RecordType)) {
      return new RecordType(values2);
    }
    if (!hasInitialized) {
      hasInitialized = true;
      var keys2 = Object.keys(defaultValues);
      var indices2 = RecordTypePrototype._indices = {};
      RecordTypePrototype._name = name;
      RecordTypePrototype._keys = keys2;
      RecordTypePrototype._defaultValues = defaultValues;
      for (var i = 0; i < keys2.length; i++) {
        var propName = keys2[i];
        indices2[propName] = i;
        if (RecordTypePrototype[propName]) {
          typeof console === "object" && console.warn && console.warn(
            "Cannot define " + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.'
          );
        } else {
          setProp(RecordTypePrototype, propName);
        }
      }
    }
    this.__ownerID = void 0;
    this._values = List().withMutations(function(l) {
      l.setSize(this$1$1._keys.length);
      KeyedCollection(values2).forEach(function(v3, k) {
        l.set(this$1$1._indices[k], v3 === this$1$1._defaultValues[k] ? void 0 : v3);
      });
    });
    return this;
  };
  var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  RecordTypePrototype.constructor = RecordType;
  if (name) {
    RecordType.displayName = name;
  }
  return RecordType;
};
Record.prototype.toString = function toString4() {
  var str3 = recordName(this) + " { ";
  var keys2 = this._keys;
  var k;
  for (var i = 0, l = keys2.length; i !== l; i++) {
    k = keys2[i];
    str3 += (i ? ", " : "") + k + ": " + quoteString(this.get(k));
  }
  return str3 + " }";
};
Record.prototype.equals = function equals2(other) {
  return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
};
Record.prototype.hashCode = function hashCode2() {
  return recordSeq(this).hashCode();
};
Record.prototype.has = function has4(k) {
  return this._indices.hasOwnProperty(k);
};
Record.prototype.get = function get10(k, notSetValue) {
  if (!this.has(k)) {
    return notSetValue;
  }
  var index = this._indices[k];
  var value = this._values.get(index);
  return value === void 0 ? this._defaultValues[k] : value;
};
Record.prototype.set = function set2(k, v3) {
  if (this.has(k)) {
    var newValues = this._values.set(
      this._indices[k],
      v3 === this._defaultValues[k] ? void 0 : v3
    );
    if (newValues !== this._values && !this.__ownerID) {
      return makeRecord(this, newValues);
    }
  }
  return this;
};
Record.prototype.remove = function remove2(k) {
  return this.set(k);
};
Record.prototype.clear = function clear() {
  var newValues = this._values.clear().setSize(this._keys.length);
  return this.__ownerID ? this : makeRecord(this, newValues);
};
Record.prototype.wasAltered = function wasAltered2() {
  return this._values.wasAltered();
};
Record.prototype.toSeq = function toSeq2() {
  return recordSeq(this);
};
Record.prototype.toJS = function toJS$12() {
  return toJS(this);
};
Record.prototype.entries = function entries2() {
  return this.__iterator(ITERATE_ENTRIES);
};
Record.prototype.__iterator = function __iterator(type, reverse3) {
  return recordSeq(this).__iterator(type, reverse3);
};
Record.prototype.__iterate = function __iterate(fn, reverse3) {
  return recordSeq(this).__iterate(fn, reverse3);
};
Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  var newValues = this._values.__ensureOwner(ownerID);
  if (!ownerID) {
    this.__ownerID = ownerID;
    this._values = newValues;
    return this;
  }
  return makeRecord(this, newValues, ownerID);
};
Record.isRecord = isRecord;
Record.getDescriptiveName = recordName;
var RecordPrototype = Record.prototype;
RecordPrototype[IS_RECORD_SYMBOL] = true;
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
RecordPrototype.getIn = getIn;
RecordPrototype.hasIn = CollectionPrototype.hasIn;
RecordPrototype.merge = merge$1;
RecordPrototype.mergeWith = mergeWith$1;
RecordPrototype.mergeIn = mergeIn;
RecordPrototype.mergeDeep = mergeDeep;
RecordPrototype.mergeDeepWith = mergeDeepWith;
RecordPrototype.mergeDeepIn = mergeDeepIn;
RecordPrototype.setIn = setIn;
RecordPrototype.update = update;
RecordPrototype.updateIn = updateIn$1;
RecordPrototype.withMutations = withMutations;
RecordPrototype.asMutable = asMutable;
RecordPrototype.asImmutable = asImmutable;
RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
RecordPrototype.inspect = RecordPrototype.toSource = function() {
  return this.toString();
};
function makeRecord(likeRecord, values2, ownerID) {
  var record2 = Object.create(Object.getPrototypeOf(likeRecord));
  record2._values = values2;
  record2.__ownerID = ownerID;
  return record2;
}
function recordName(record2) {
  return record2.constructor.displayName || record2.constructor.name || "Record";
}
function recordSeq(record2) {
  return keyedSeqFromValue(record2._keys.map(function(k) {
    return [k, record2.get(k)];
  }));
}
function setProp(prototype, name) {
  try {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value) {
        invariant(this.__ownerID, "Cannot set on an immutable record.");
        this.set(name, value);
      }
    });
  } catch (error) {
  }
}
var Repeat = function(IndexedSeq2) {
  function Repeat2(value, times) {
    if (!(this instanceof Repeat2)) {
      return new Repeat2(value, times);
    }
    this._value = value;
    this.size = times === void 0 ? Infinity : Math.max(0, times);
    if (this.size === 0) {
      if (EMPTY_REPEAT) {
        return EMPTY_REPEAT;
      }
      EMPTY_REPEAT = this;
    }
  }
  if (IndexedSeq2) Repeat2.__proto__ = IndexedSeq2;
  Repeat2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  Repeat2.prototype.constructor = Repeat2;
  Repeat2.prototype.toString = function toString5() {
    if (this.size === 0) {
      return "Repeat []";
    }
    return "Repeat [ " + this._value + " " + this.size + " times ]";
  };
  Repeat2.prototype.get = function get11(index, notSetValue) {
    return this.has(index) ? this._value : notSetValue;
  };
  Repeat2.prototype.includes = function includes3(searchValue) {
    return is(this._value, searchValue);
  };
  Repeat2.prototype.slice = function slice3(begin, end) {
    var size = this.size;
    return wholeSlice(begin, end, size) ? this : new Repeat2(
      this._value,
      resolveEnd(end, size) - resolveBegin(begin, size)
    );
  };
  Repeat2.prototype.reverse = function reverse3() {
    return this;
  };
  Repeat2.prototype.indexOf = function indexOf2(searchValue) {
    if (is(this._value, searchValue)) {
      return 0;
    }
    return -1;
  };
  Repeat2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
    if (is(this._value, searchValue)) {
      return this.size;
    }
    return -1;
  };
  Repeat2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var size = this.size;
    var i = 0;
    while (i !== size) {
      if (fn(this._value, reverse3 ? size - ++i : i++, this) === false) {
        break;
      }
    }
    return i;
  };
  Repeat2.prototype.__iterator = function __iterator2(type, reverse3) {
    var this$1$1 = this;
    var size = this.size;
    var i = 0;
    return new Iterator2(
      function() {
        return i === size ? iteratorDone() : iteratorValue(type, reverse3 ? size - ++i : i++, this$1$1._value);
      }
    );
  };
  Repeat2.prototype.equals = function equals3(other) {
    return other instanceof Repeat2 ? is(this._value, other._value) : deepEqual2(this, other);
  };
  return Repeat2;
}(IndexedSeq);
var EMPTY_REPEAT;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-state/action.js
var StateAction;
(function(StateAction2) {
  function create(definition) {
    const action = {
      create(params) {
        return { action, params };
      },
      id: UUID.create22(),
      definition,
      createDefaultParams(a5, globalCtx) {
        return definition.params ? ParamDefinition.getDefaultValues(definition.params(a5, globalCtx)) : {};
      }
    };
    return action;
  }
  StateAction2.create = create;
  function fromTransformer(transformer) {
    const def = transformer.definition;
    return create({
      from: def.from,
      display: def.display,
      params: def.params,
      isApplicable: transformer.definition.isApplicable ? (a5, t2, ctx) => transformer.definition.isApplicable(a5, ctx) : void 0,
      run({ cell, state, params }) {
        const tree = state.build().to(cell.transform.ref).apply(transformer, params);
        return state.updateTree(tree);
      }
    });
  }
  StateAction2.fromTransformer = fromTransformer;
  let Builder;
  (function(Builder2) {
    function root(info) {
      return (def) => create({
        from: info.from instanceof Array ? info.from : !!info.from ? [info.from] : [],
        display: typeof info.display === "string" ? { name: info.display } : !!info.display ? info.display : { name: "Unnamed State Action" },
        params: typeof info.params === "object" ? () => info.params : !!info.params ? info.params : void 0,
        isApplicable: info.isApplicable,
        ...typeof def === "function" ? { run: def } : def
      });
    }
    Builder2.build = (info) => root(info);
  })(Builder = StateAction2.Builder || (StateAction2.Builder = {}));
  StateAction2.build = Builder.build;
})(StateAction || (StateAction = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-state/transformer.js
var Transformer;
(function(Transformer2) {
  function getParamDefinition(t2, a5, globalCtx) {
    return t2.definition.params ? t2.definition.params(a5, globalCtx) : {};
  }
  Transformer2.getParamDefinition = getParamDefinition;
  function is3(obj) {
    return !!obj && typeof obj.toAction === "function" && typeof obj.apply === "function";
  }
  Transformer2.is = is3;
  let UpdateResult;
  (function(UpdateResult2) {
    UpdateResult2[UpdateResult2["Unchanged"] = 0] = "Unchanged";
    UpdateResult2[UpdateResult2["Updated"] = 1] = "Updated";
    UpdateResult2[UpdateResult2["Recreate"] = 2] = "Recreate";
    UpdateResult2[UpdateResult2["Null"] = 3] = "Null";
  })(UpdateResult = Transformer2.UpdateResult || (Transformer2.UpdateResult = {}));
  const registry = /* @__PURE__ */ new Map();
  const fromTypeIndex = /* @__PURE__ */ new Map();
  function _index(tr) {
    for (const t2 of tr.definition.from) {
      if (fromTypeIndex.has(t2.type)) {
        fromTypeIndex.get(t2.type).push(tr);
      } else {
        fromTypeIndex.set(t2.type, [tr]);
      }
    }
  }
  function getAll() {
    return Array.from(registry.values());
  }
  Transformer2.getAll = getAll;
  function get11(id) {
    const t2 = registry.get(id);
    if (!t2) {
      throw new Error(`A transformer with signature '${id}' is not registered.`);
    }
    return t2;
  }
  Transformer2.get = get11;
  function fromType(type) {
    return fromTypeIndex.get(type) || [];
  }
  Transformer2.fromType = fromType;
  function create(namespace, definition) {
    const { name } = definition;
    const id = `${namespace}.${name}`;
    if (registry.has(id)) {
      console.warn(`A transform with id '${name}' is already registered. Please pick a unique identifier for your transforms and/or register them only once. This is to ensure that transforms can be serialized and replayed.`);
    }
    const t2 = {
      apply(parent, params, props) {
        return Transform.create(parent, t2, params, props);
      },
      toAction() {
        return StateAction.fromTransformer(t2);
      },
      namespace,
      id,
      definition,
      createDefaultParams(a5, globalCtx) {
        return definition.params ? ParamDefinition.getDefaultValues(definition.params(a5, globalCtx)) : {};
      }
    };
    registry.set(id, t2);
    _index(t2);
    return t2;
  }
  Transformer2.create = create;
  function factory(namespace) {
    return (definition) => create(namespace, definition);
  }
  Transformer2.factory = factory;
  function builderFactory(namespace) {
    return Builder.build(namespace);
  }
  Transformer2.builderFactory = builderFactory;
  let Builder;
  (function(Builder2) {
    function root(namespace, info) {
      return (def) => create(namespace, {
        name: info.name,
        from: info.from instanceof Array ? info.from : [info.from],
        to: info.to instanceof Array ? info.to : [info.to],
        display: typeof info.display === "string" ? { name: info.display } : !!info.display ? info.display : { name: capitalize(info.name.replace(/[-]/g, " ")) },
        params: typeof info.params === "object" ? () => info.params : !!info.params ? info.params : void 0,
        isDecorator: info.isDecorator,
        ...def
      });
    }
    function build2(namespace) {
      return (info) => root(namespace, info);
    }
    Builder2.build = build2;
  })(Builder = Transformer2.Builder || (Transformer2.Builder = {}));
  function build(namespace) {
    return Builder.build(namespace);
  }
  Transformer2.build = build;
  Transformer2.ROOT = create("build-in", {
    name: "root",
    from: [],
    to: [],
    display: { name: "Root", description: "For internal use." },
    apply() {
      throw new Error("should never be applied");
    },
    update() {
      return UpdateResult.Unchanged;
    }
  });
})(Transformer || (Transformer = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-state/transform.js
var Transform;
(function(Transform2) {
  Transform2.RootRef = "-=root=-";
  function isStateChange(a5, b5) {
    if (!b5)
      return false;
    if (typeof b5.isCollapsed !== "undefined" && a5.isCollapsed !== b5.isCollapsed)
      return true;
    if (typeof b5.isHidden !== "undefined" && a5.isHidden !== b5.isHidden)
      return true;
    if (typeof b5.isGhost !== "undefined" && a5.isGhost !== b5.isGhost)
      return true;
    if (typeof b5.isLocked !== "undefined" && a5.isLocked !== b5.isLocked)
      return true;
    return false;
  }
  Transform2.isStateChange = isStateChange;
  function assignState(a5, b5) {
    if (!b5)
      return false;
    let changed = false;
    for (const k of Object.keys(b5)) {
      const s = b5[k], t2 = a5[k];
      if (!!s === !!t2)
        continue;
      changed = true;
      a5[k] = s;
    }
    return changed;
  }
  Transform2.assignState = assignState;
  function syncState(a5, b5) {
    if (!b5)
      return false;
    let changed = false;
    for (const k of Object.keys(b5)) {
      const s = b5[k], t2 = a5[k];
      if (!!s === !!t2)
        continue;
      changed = true;
      if (s !== void 0) {
        a5[k] = s;
      } else {
        delete a5[k];
      }
    }
    for (const k of Object.keys(a5)) {
      const s = b5[k], t2 = a5[k];
      if (!!s === !!t2)
        continue;
      changed = true;
      if (s !== void 0) {
        a5[k] = s;
      } else {
        delete a5[k];
      }
    }
    return changed;
  }
  Transform2.syncState = syncState;
  function create(parent, transformer, params, options) {
    const ref = options && options.ref ? options.ref : UUID.create22();
    let tags = void 0;
    if (options && options.tags) {
      tags = typeof options.tags === "string" ? [options.tags] : options.tags;
      if (tags.length === 0)
        tags = void 0;
      else
        tags.sort();
    }
    return {
      parent,
      transformer,
      state: (options === null || options === void 0 ? void 0 : options.state) || {},
      tags,
      ref,
      dependsOn: options && options.dependsOn,
      params,
      version: UUID.create22()
    };
  }
  Transform2.create = create;
  function withParams(t2, params) {
    return { ...t2, params, version: UUID.create22() };
  }
  Transform2.withParams = withParams;
  function withState(t2, state) {
    if (!state)
      return t2;
    return { ...t2, state: { ...t2.state, ...state } };
  }
  Transform2.withState = withState;
  function withTags(t2, newTags) {
    let tags = void 0;
    if (newTags) {
      tags = typeof newTags === "string" ? [newTags] : newTags;
      if (tags.length === 0)
        tags = void 0;
      else
        tags.sort();
    }
    return { ...t2, tags, version: UUID.create22() };
  }
  Transform2.withTags = withTags;
  function withDependsOn(t2, newDependsOn) {
    let dependsOn = void 0;
    if (newDependsOn) {
      dependsOn = typeof newDependsOn === "string" ? [newDependsOn] : newDependsOn;
      if (dependsOn.length === 0)
        dependsOn = void 0;
      else
        dependsOn.sort();
    }
    return { ...t2, dependsOn, version: UUID.create22() };
  }
  Transform2.withDependsOn = withDependsOn;
  function withParent(t2, parent) {
    return { ...t2, parent, version: UUID.create22() };
  }
  Transform2.withParent = withParent;
  function createRoot(state) {
    return create(Transform2.RootRef, Transformer.ROOT, {}, { ref: Transform2.RootRef, state });
  }
  Transform2.createRoot = createRoot;
  function hasTag(t2, tag) {
    if (!t2.tags)
      return false;
    return t2.tags.indexOf(tag) >= 0;
  }
  Transform2.hasTag = hasTag;
  function hasTags(t2, tags) {
    if (!t2.tags)
      return typeof tags !== "string" && tags.length === 0;
    if (typeof tags === "string")
      return hasTag(t2, tags);
    for (const tag of tags) {
      if (t2.tags.indexOf(tag) < 0)
        return false;
    }
    return true;
  }
  Transform2.hasTags = hasTags;
  function _id(x) {
    return x;
  }
  function toJSON(t2) {
    const pToJson = t2.transformer.definition.customSerialization ? t2.transformer.definition.customSerialization.toJSON : _id;
    let state = void 0;
    for (const k of Object.keys(t2.state)) {
      const s = t2.state[k];
      if (!s)
        continue;
      if (!state)
        state = {};
      state[k] = true;
    }
    return {
      parent: t2.parent,
      transformer: t2.transformer.id,
      params: t2.params ? pToJson(t2.params) : void 0,
      state,
      tags: t2.tags,
      ref: t2.ref,
      dependsOn: t2.dependsOn,
      version: t2.version
    };
  }
  Transform2.toJSON = toJSON;
  function fromJSON(t2) {
    const transformer = Transformer.get(t2.transformer);
    const pFromJson = transformer.definition.customSerialization ? transformer.definition.customSerialization.fromJSON : _id;
    return {
      parent: t2.parent,
      transformer,
      params: t2.params ? pFromJson(t2.params) : void 0,
      state: t2.state || {},
      tags: t2.tags,
      ref: t2.ref,
      dependsOn: t2.dependsOn,
      version: t2.version
    };
  }
  Transform2.fromJSON = fromJSON;
})(Transform || (Transform = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-state/tree/transient.js
var TransientTree = class {
  get childMutations() {
    if (this._childMutations)
      return this._childMutations;
    this._childMutations = /* @__PURE__ */ new Map();
    return this._childMutations;
  }
  get dependencyMutations() {
    if (this._dependencyMutations)
      return this._dependencyMutations;
    this._dependencyMutations = /* @__PURE__ */ new Map();
    return this._dependencyMutations;
  }
  changeNodes() {
    if (this.changedNodes)
      return;
    this.changedNodes = true;
    this.transforms = this.transforms.asMutable();
  }
  changeChildren() {
    if (this.changedChildren)
      return;
    this.changedChildren = true;
    this.children = this.children.asMutable();
  }
  changeDependencies() {
    if (this.changedDependencies)
      return;
    this.changedDependencies = true;
    this.dependencies = this.dependencies.asMutable();
  }
  get root() {
    return this.transforms.get(Transform.RootRef);
  }
  asTransient() {
    return this.asImmutable().asTransient();
  }
  addChild(parent, child) {
    this.changeChildren();
    if (this.childMutations.has(parent)) {
      this.childMutations.get(parent).add(child);
    } else {
      const set4 = this.children.get(parent).asMutable();
      set4.add(child);
      this.children.set(parent, set4);
      this.childMutations.set(parent, set4);
    }
  }
  removeChild(parent, child) {
    this.changeChildren();
    if (this.childMutations.has(parent)) {
      this.childMutations.get(parent).remove(child);
    } else {
      const set4 = this.children.get(parent).asMutable();
      set4.remove(child);
      this.children.set(parent, set4);
      this.childMutations.set(parent, set4);
    }
  }
  clearRoot() {
    const parent = Transform.RootRef;
    if (this.children.get(parent).size === 0)
      return;
    this.changeChildren();
    const set4 = OrderedSet2();
    this.children.set(parent, set4);
    this.childMutations.set(parent, set4);
  }
  mutateDependency(parent, child, action) {
    let set4 = this.dependencyMutations.get(parent);
    if (!set4) {
      const src = this.dependencies.get(parent);
      if (!src && action === "remove")
        return;
      this.changeDependencies();
      set4 = src ? src.asMutable() : OrderedSet2().asMutable();
      this.dependencyMutations.set(parent, set4);
      this.dependencies.set(parent, set4);
    }
    if (action === "add") {
      set4.add(child);
    } else {
      set4.remove(child);
    }
  }
  changeParent(ref, newParent) {
    ensurePresent(this.transforms, ref);
    const old = this.transforms.get(ref);
    this.removeChild(old.parent, ref);
    this.addChild(newParent, ref);
    this.changeNodes();
    this.transforms.set(ref, Transform.withParent(old, newParent));
  }
  add(transform) {
    const ref = transform.ref;
    if (this.transforms.has(transform.ref)) {
      const node = this.transforms.get(transform.ref);
      if (node.parent !== transform.parent)
        alreadyPresent(transform.ref);
    }
    const children = this.children.get(transform.parent);
    if (!children)
      parentNotPresent(transform.parent);
    if (!children.has(transform.ref)) {
      this.addChild(transform.parent, transform.ref);
    }
    if (!this.children.has(transform.ref)) {
      if (!this.changedChildren) {
        this.changedChildren = true;
        this.children = this.children.asMutable();
      }
      this.children.set(transform.ref, OrderedSet2());
    }
    this.changeNodes();
    this.transforms.set(ref, transform);
    if (transform.dependsOn) {
      for (const d3 of transform.dependsOn) {
        this.mutateDependency(d3, ref, "add");
      }
    }
    return this;
  }
  /** Calls Transform.definition.params.areEqual if available, otherwise uses shallowEqual to check if the params changed */
  setParams(ref, params) {
    ensurePresent(this.transforms, ref);
    const transform = this.transforms.get(ref);
    if (shallowEqual2(transform.params, params)) {
      return false;
    }
    if (!this.changedNodes) {
      this.changedNodes = true;
      this.transforms = this.transforms.asMutable();
    }
    this.transforms.set(transform.ref, Transform.withParams(transform, params));
    return true;
  }
  /** Calls Transform.definition.params.areEqual if available, otherwise uses shallowEqual to check if the params changed */
  setTags(ref, tags) {
    ensurePresent(this.transforms, ref);
    const transform = this.transforms.get(ref);
    const withTags = Transform.withTags(transform, tags);
    if (arrayEqual(transform.tags, withTags.tags)) {
      return false;
    }
    if (!this.changedNodes) {
      this.changedNodes = true;
      this.transforms = this.transforms.asMutable();
    }
    this.transforms.set(transform.ref, withTags);
    return true;
  }
  setDependsOn(ref, dependsOn) {
    ensurePresent(this.transforms, ref);
    const transform = this.transforms.get(ref);
    const withDependsOn = Transform.withDependsOn(transform, dependsOn);
    if (arrayEqual(transform.dependsOn, withDependsOn.dependsOn)) {
      return false;
    }
    if (!this.changedNodes) {
      this.changedNodes = true;
      this.transforms = this.transforms.asMutable();
    }
    this.transforms.set(transform.ref, withDependsOn);
    return true;
  }
  assignState(ref, state) {
    ensurePresent(this.transforms, ref);
    const old = this.transforms.get(ref);
    if (this._stateUpdates && this._stateUpdates.has(ref)) {
      Transform.assignState(old.state, state);
      return old;
    } else {
      if (!this._stateUpdates)
        this._stateUpdates = /* @__PURE__ */ new Set();
      this._stateUpdates.add(old.ref);
      this.changeNodes();
      const updated = Transform.withState(old, state);
      this.transforms.set(ref, updated);
      return updated;
    }
  }
  remove(ref) {
    const node = this.transforms.get(ref);
    if (!node)
      return [];
    const st = StateTree.subtreePostOrder(this, node);
    if (ref === Transform.RootRef) {
      st.pop();
      if (st.length === 0)
        return st;
      this.clearRoot();
    } else {
      if (st.length === 0)
        return st;
      this.removeChild(node.parent, node.ref);
    }
    this.changeNodes();
    this.changeChildren();
    for (const n of st) {
      this.transforms.delete(n.ref);
      this.children.delete(n.ref);
      if (this._childMutations)
        this._childMutations.delete(n.ref);
    }
    const depRemoves = [];
    for (const n of st) {
      if (n.dependsOn) {
        for (const d3 of n.dependsOn) {
          if (!this.transforms.has(d3))
            continue;
          this.mutateDependency(d3, n.ref, "remove");
        }
      }
      if (this.dependencies.has(n.ref)) {
        const deps = this.dependencies.get(n.ref).toArray();
        this.changeDependencies();
        this.dependencies.delete(n.ref);
        if (this._dependencyMutations)
          this._dependencyMutations.delete(n.ref);
        for (const dep of deps) {
          if (!this.transforms.has(dep))
            continue;
          for (const del of this.remove(dep))
            depRemoves[depRemoves.length] = del;
        }
      }
    }
    for (const dep of depRemoves)
      st[st.length] = dep;
    return st;
  }
  asImmutable() {
    if (!this.changedNodes && !this.changedChildren && !this._childMutations)
      return this.tree;
    if (this._childMutations)
      this._childMutations.forEach(fixChildMutations, this.children);
    if (this._dependencyMutations)
      this._dependencyMutations.forEach(fixDependencyMutations, this.dependencies);
    return StateTree.create(this.changedNodes ? this.transforms.asImmutable() : this.transforms, this.changedChildren ? this.children.asImmutable() : this.children, this.changedDependencies ? this.dependencies.asImmutable() : this.dependencies);
  }
  constructor(tree) {
    this.tree = tree;
    this.transforms = this.tree.transforms;
    this.children = this.tree.children;
    this.dependencies = this.tree.dependencies;
    this.changedNodes = false;
    this.changedChildren = false;
    this.changedDependencies = false;
    this._childMutations = void 0;
    this._dependencyMutations = void 0;
    this._stateUpdates = void 0;
  }
};
function fixChildMutations(m, k) {
  this.set(k, m.asImmutable());
}
function fixDependencyMutations(m, k) {
  if (m.size === 0)
    this.delete(k);
  else
    this.set(k, m.asImmutable());
}
function alreadyPresent(ref) {
  throw new Error(`Transform '${ref}' is already present in the tree.`);
}
function parentNotPresent(ref) {
  throw new Error(`Parent '${ref}' must be present in the tree.`);
}
function ensurePresent(nodes, ref) {
  if (!nodes.has(ref)) {
    throw new Error(`Node '${ref}' is not present in the tree.`);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-state/tree/immutable.js
var StateTree;
(function(StateTree2) {
  class Impl {
    get root() {
      return this.transforms.get(Transform.RootRef);
    }
    asTransient() {
      return new TransientTree(this);
    }
    constructor(transforms, children, dependencies) {
      this.transforms = transforms;
      this.children = children;
      this.dependencies = dependencies;
    }
  }
  function createEmpty(customRoot) {
    const root = customRoot || Transform.createRoot();
    return create(Map2([[root.ref, root]]), Map2([[root.ref, OrderedSet2()]]), Map2());
  }
  StateTree2.createEmpty = createEmpty;
  function create(nodes, children, dependencies) {
    return new Impl(nodes, children, dependencies);
  }
  StateTree2.create = create;
  function _postOrderFunc(c5) {
    _doPostOrder(this, this.tree.transforms.get(c5));
  }
  function _doPostOrder(ctx, root) {
    const children = ctx.tree.children.get(root.ref);
    if (children && children.size) {
      children.forEach(_postOrderFunc, ctx);
    }
    ctx.f(root, ctx.tree, ctx.state);
  }
  function doPostOrder(tree, root, state, f) {
    const ctx = { tree, state, f };
    _doPostOrder(ctx, root);
    return ctx.state;
  }
  StateTree2.doPostOrder = doPostOrder;
  function _preOrderFunc(c5) {
    _doPreOrder(this, this.tree.transforms.get(c5));
  }
  function _doPreOrder(ctx, root) {
    const ret = ctx.f(root, ctx.tree, ctx.state);
    if (typeof ret === "boolean" && !ret)
      return;
    const children = ctx.tree.children.get(root.ref);
    if (children && children.size) {
      children.forEach(_preOrderFunc, ctx);
    }
  }
  function doPreOrder(tree, root, state, f) {
    const ctx = { tree, state, f };
    _doPreOrder(ctx, root);
    return ctx.state;
  }
  StateTree2.doPreOrder = doPreOrder;
  function _subtree(n, _, subtree) {
    subtree.push(n);
  }
  function subtreePostOrder(tree, root) {
    return doPostOrder(tree, root, [], _subtree);
  }
  StateTree2.subtreePostOrder = subtreePostOrder;
  function _visitNodeToJson(node, tree, ctx) {
    ctx.push(Transform.toJSON(node));
  }
  function toJSON(tree) {
    const transforms = [];
    doPreOrder(tree, tree.root, transforms, _visitNodeToJson);
    return { transforms };
  }
  StateTree2.toJSON = toJSON;
  function fromJSON(data) {
    const nodes = Map2().asMutable();
    const children = Map2().asMutable();
    const dependencies = Map2().asMutable();
    for (const t2 of data.transforms) {
      const transform = Transform.fromJSON(t2);
      nodes.set(transform.ref, transform);
      if (!children.has(transform.ref)) {
        children.set(transform.ref, OrderedSet2().asMutable());
      }
      if (transform.ref !== transform.parent)
        children.get(transform.parent).add(transform.ref);
    }
    const dependent = /* @__PURE__ */ new Set();
    for (const t2 of data.transforms) {
      const ref = t2.ref;
      children.set(ref, children.get(ref).asImmutable());
      if (!t2.dependsOn)
        continue;
      for (const d3 of t2.dependsOn) {
        dependent.add(d3);
        if (!dependencies.has(d3)) {
          dependencies.set(d3, OrderedSet2([ref]).asMutable());
        } else {
          dependencies.get(d3).add(ref);
        }
      }
    }
    dependent.forEach((d3) => {
      dependencies.set(d3, dependencies.get(d3).asImmutable());
    });
    return create(nodes.asImmutable(), children.asImmutable(), dependencies.asImmutable());
  }
  StateTree2.fromJSON = fromJSON;
  function dump(tree) {
    console.log({
      tr: tree.transforms.keySeq().toArray(),
      tr1: tree.transforms.valueSeq().toArray().map((t2) => t2.ref),
      ch: tree.children.keySeq().toArray()
    });
  }
  StateTree2.dump = dump;
  function _subtreeHasRef(tree, root, ref) {
    if (root === ref)
      return true;
    const children = tree.children.get(root);
    const it = children.values();
    while (true) {
      const next = it.next();
      if (next.done)
        return false;
      if (_subtreeHasRef(tree, next.value, ref))
        return true;
    }
  }
  function subtreeHasRef(tree, root, ref) {
    if (!tree.transforms.has(root) || !tree.transforms.has(ref))
      return false;
    return _subtreeHasRef(tree, root, ref);
  }
  StateTree2.subtreeHasRef = subtreeHasRef;
  function getDecoratorRoot(tree, ref) {
    const children = tree.children.get(ref);
    if (children.size !== 1)
      return ref;
    const child = tree.transforms.get(children.first());
    if (child === null || child === void 0 ? void 0 : child.transformer.definition.isDecorator)
      return getDecoratorRoot(tree, child.ref);
    return ref;
  }
  StateTree2.getDecoratorRoot = getDecoratorRoot;
})(StateTree || (StateTree = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-state/state/selection.js
var StateSelection;
(function(StateSelection2) {
  function select(s, state) {
    return compile2(s)(state);
  }
  StateSelection2.select = select;
  function compile2(s) {
    const selector = s ? s : Generators.root;
    let query;
    if (isBuilder(selector))
      query = selector.compile();
    else if (isObj(selector))
      query = Generators.byValue(selector).compile();
    else if (isQuery(selector))
      query = selector;
    else
      query = Generators.byRef(selector).compile();
    return query;
  }
  StateSelection2.compile = compile2;
  function isObj(arg) {
    return arg.transform !== void 0 && arg.status !== void 0;
  }
  function isBuilder(arg) {
    return arg.compile !== void 0;
  }
  function isQuery(arg) {
    return typeof arg === "function";
  }
  const BuilderPrototype = {
    select(state) {
      return select(this, state || this.state);
    }
  };
  function registerModifier(name, f) {
    BuilderPrototype[name] = function(...args) {
      return f.call(void 0, this, ...args);
    };
  }
  function build(compile3) {
    return Object.create(BuilderPrototype, { compile: { writable: false, configurable: false, value: compile3 } });
  }
  let Generators;
  (function(Generators2) {
    Generators2.root = build(() => (state) => [state.cells.get(state.tree.root.ref)]);
    function byRef(...refs) {
      return build(() => (state) => {
        const ret = [];
        for (const ref of refs) {
          const n = state.cells.get(ref);
          if (!n)
            continue;
          ret.push(n);
        }
        return ret;
      });
    }
    Generators2.byRef = byRef;
    function byValue(...objects) {
      return build(() => (state) => objects);
    }
    Generators2.byValue = byValue;
    function rootsOfType(type, root2 = Transform.RootRef) {
      return build(() => (state) => {
        const ctx = { roots: [], cells: state.cells, type: type.type };
        StateTree.doPreOrder(state.tree, state.tree.transforms.get(root2), ctx, _findRootsOfType);
        return ctx.roots;
      });
    }
    Generators2.rootsOfType = rootsOfType;
    function ofType2(type, root2 = Transform.RootRef) {
      return build(() => (state) => {
        const ctx = { ret: [], cells: state.cells, type: type.type };
        StateTree.doPreOrder(state.tree, state.tree.transforms.get(root2), ctx, _findOfType);
        return ctx.ret;
      });
    }
    Generators2.ofType = ofType2;
    function ofTransformer(t2, root2 = Transform.RootRef) {
      return build(() => (state) => {
        const ctx = { ret: [], cells: state.cells, t: t2 };
        StateTree.doPreOrder(state.tree, state.tree.transforms.get(root2), ctx, _findOfTransformer);
        return ctx.ret;
      });
    }
    Generators2.ofTransformer = ofTransformer;
    function ofTransformerWithError(t2, root2 = Transform.RootRef) {
      return build(() => (state) => {
        const ctx = { ret: [], cells: state.cells, t: t2 };
        StateTree.doPreOrder(state.tree, state.tree.transforms.get(root2), ctx, _findOfTransformerWithError);
        return ctx.ret;
      });
    }
    Generators2.ofTransformerWithError = ofTransformerWithError;
    function _findRootsOfType(n, _, s) {
      const cell = s.cells.get(n.ref);
      if (cell && cell.obj && cell.obj.type === s.type) {
        s.roots.push(cell);
        return false;
      }
      return true;
    }
    function _findOfType(n, _, s) {
      const cell = s.cells.get(n.ref);
      if (cell && cell.obj && cell.obj.type === s.type) {
        s.ret.push(cell);
      }
      return true;
    }
    function _findOfTransformer(n, _, s) {
      const cell = s.cells.get(n.ref);
      if (cell && cell.obj && cell.transform.transformer === s.t) {
        s.ret.push(cell);
      }
      return true;
    }
    function _findOfTransformerWithError(n, _, s) {
      const cell = s.cells.get(n.ref);
      if (cell && cell.status === "error" && cell.transform.transformer === s.t) {
        s.ret.push(cell);
      }
      return true;
    }
  })(Generators = StateSelection2.Generators || (StateSelection2.Generators = {}));
  registerModifier("flatMap", flatMap3);
  function flatMap3(b5, f) {
    const q = compile2(b5);
    return build(() => (state) => {
      const ret = [];
      for (const n of q(state)) {
        for (const m of f(n, state)) {
          ret.push(m);
        }
      }
      return ret;
    });
  }
  StateSelection2.flatMap = flatMap3;
  registerModifier("mapObject", mapObject);
  function mapObject(b5, f) {
    const q = compile2(b5);
    return build(() => (state) => {
      const ret = [];
      for (const n of q(state)) {
        const x = f(n, state);
        if (x)
          ret.push(x);
      }
      return ret;
    });
  }
  StateSelection2.mapObject = mapObject;
  registerModifier("unique", unique);
  function unique(b5) {
    const q = compile2(b5);
    return build(() => (state) => {
      const set4 = /* @__PURE__ */ new Set();
      const ret = [];
      for (const n of q(state)) {
        if (!n)
          continue;
        if (!set4.has(n.transform.ref)) {
          set4.add(n.transform.ref);
          ret.push(n);
        }
      }
      return ret;
    });
  }
  StateSelection2.unique = unique;
  registerModifier("first", first4);
  function first4(b5) {
    const q = compile2(b5);
    return build(() => (state) => {
      const r = q(state);
      return r.length ? [r[0]] : [];
    });
  }
  StateSelection2.first = first4;
  registerModifier("filter", filter4);
  function filter4(b5, p) {
    return flatMap3(b5, (n) => p(n) ? [n] : []);
  }
  StateSelection2.filter = filter4;
  registerModifier("withStatus", withStatus);
  function withStatus(b5, s) {
    return filter4(b5, (n) => n.status === s);
  }
  StateSelection2.withStatus = withStatus;
  registerModifier("withTag", withTag);
  function withTag(b5, tag) {
    return filter4(b5, (n) => !!n.transform.tags && n.transform.tags.indexOf(tag) >= 0);
  }
  StateSelection2.withTag = withTag;
  registerModifier("subtree", subtree);
  function subtree(b5) {
    return flatMap3(b5, (n, s) => {
      const nodes = [];
      StateTree.doPreOrder(s.tree, s.tree.transforms.get(n.transform.ref), nodes, (x, _, ctx) => {
        ctx.push(x.ref);
      });
      return nodes.map((x) => s.cells.get(x));
    });
  }
  StateSelection2.subtree = subtree;
  registerModifier("children", children);
  function children(b5) {
    return flatMap3(b5, (n, s) => {
      const nodes = [];
      s.tree.children.get(n.transform.ref).forEach((c5) => nodes.push(s.cells.get(c5)));
      return nodes;
    });
  }
  StateSelection2.children = children;
  registerModifier("ofType", ofType);
  function ofType(b5, t2) {
    return filter4(b5, (n) => n.obj ? n.obj.type === t2.type : false);
  }
  StateSelection2.ofType = ofType;
  registerModifier("ancestor", ancestor);
  function ancestor(b5, test) {
    return unique(mapObject(b5, (n, s) => findAncestor(s.tree, s.cells, n.transform.ref, test)));
  }
  StateSelection2.ancestor = ancestor;
  registerModifier("ancestorOfType", ancestorOfType);
  function ancestorOfType(b5, types2) {
    return unique(mapObject(b5, (n, s) => findAncestorOfType(s.tree, s.cells, n.transform.ref, types2)));
  }
  StateSelection2.ancestorOfType = ancestorOfType;
  registerModifier("ancestorWithTransformer", ancestorWithTransformer);
  function ancestorWithTransformer(b5, transfomers) {
    return unique(mapObject(b5, (n, s) => findAncestorWithTransformer(s.tree, s.cells, n.transform.ref, transfomers)));
  }
  StateSelection2.ancestorWithTransformer = ancestorWithTransformer;
  registerModifier("withTransformer", withTransformer);
  function withTransformer(b5, t2) {
    return filter4(b5, (o) => o.transform.transformer === t2);
  }
  StateSelection2.withTransformer = withTransformer;
  registerModifier("root", root);
  function root(b5, test) {
    return unique(mapObject(b5, (n, s) => findRoot(s.tree, s.cells, n.transform.ref, test)));
  }
  StateSelection2.root = root;
  registerModifier("rootOfType", rootOfType);
  function rootOfType(b5, types2) {
    return unique(mapObject(b5, (n, s) => findRootOfType(s.tree, s.cells, n.transform.ref, types2)));
  }
  StateSelection2.rootOfType = rootOfType;
  registerModifier("parent", parent);
  function parent(b5) {
    return unique(mapObject(b5, (n, s) => s.cells.get(s.tree.transforms.get(n.transform.ref).parent)));
  }
  StateSelection2.parent = parent;
  function _findAncestor(tree, cells, root2, test, findClosest) {
    let current3 = tree.transforms.get(root2);
    let ret = void 0;
    while (true) {
      current3 = tree.transforms.get(current3.parent);
      const cell = cells.get(current3.ref);
      if (cell.obj && test(cell)) {
        ret = cell;
        if (findClosest)
          return ret;
      }
      if (current3.ref === Transform.RootRef) {
        return ret;
      }
    }
  }
  function findAncestor(tree, cells, root2, test) {
    return _findAncestor(tree, cells, root2, test, true);
  }
  StateSelection2.findAncestor = findAncestor;
  function findRoot(tree, cells, root2, test) {
    return _findAncestor(tree, cells, root2, test, false);
  }
  StateSelection2.findRoot = findRoot;
  function findAncestorWithTransformer(tree, cells, root2, transfomers) {
    return findAncestor(tree, cells, root2, Array.isArray(transfomers) ? (cell) => transfomers.indexOf(cell.transform.transformer) >= 0 : (cell) => cell.transform.transformer === transfomers);
  }
  StateSelection2.findAncestorWithTransformer = findAncestorWithTransformer;
  function findAncestorOfType(tree, cells, root2, types2) {
    return findAncestor(tree, cells, root2, _testTypes(types2));
  }
  StateSelection2.findAncestorOfType = findAncestorOfType;
  function findRootOfType(tree, cells, root2, types2) {
    return findRoot(tree, cells, root2, _testTypes(types2));
  }
  StateSelection2.findRootOfType = findRootOfType;
  function _testTypes(types2) {
    return Array.isArray(types2) ? (cell) => {
      for (const t2 of types2) {
        if (t2.type === cell.obj.type)
          return true;
      }
    } : (cell) => cell.obj.type === types2.type;
  }
  function findUniqueTagsInSubtree(tree, root2, tags) {
    return StateTree.doPreOrder(tree, tree.transforms.get(root2), { refs: {}, tags }, _findUniqueTagsInSubtree).refs;
  }
  StateSelection2.findUniqueTagsInSubtree = findUniqueTagsInSubtree;
  function _findUniqueTagsInSubtree(n, _, s) {
    if (n.tags) {
      for (const t2 of n.tags) {
        if (!s.tags.has(t2))
          continue;
        s.refs[t2] = n.ref;
        break;
      }
    }
    return true;
  }
  function findTagInSubtree(tree, root2, tag) {
    return StateTree.doPreOrder(tree, tree.transforms.get(root2), { ref: void 0, tag }, _findTagInSubtree).ref;
  }
  StateSelection2.findTagInSubtree = findTagInSubtree;
  function _findTagInSubtree(n, _, s) {
    if (n.tags && n.tags.indexOf(s.tag) >= 0) {
      s.ref = n.ref;
      return false;
    }
    return true;
  }
  function findWithAllTags(tree, root2, tags) {
    return StateTree.doPreOrder(tree, tree.transforms.get(root2), { refs: [], tags }, _findWithAllTags).refs;
  }
  StateSelection2.findWithAllTags = findWithAllTags;
  function _findWithAllTags(n, _, s) {
    if (n.tags) {
      const len = s.tags.size;
      let found = 0;
      for (const t2 of n.tags) {
        if (!s.tags.has(t2))
          continue;
        found++;
        if (found === len) {
          s.refs.push(n);
          break;
        }
      }
    } else if (s.tags.size === 0) {
      s.refs.push(n);
    }
  }
  function tryFindDecorator(state, root2, transformer) {
    const t2 = state.transforms.get(root2);
    if (t2.transformer === transformer)
      return state.cells.get(root2);
    const children2 = state.tree.children.get(root2);
    if (children2.size !== 1)
      return;
    const first5 = children2.first();
    if (first5 && state.transforms.get(first5).transformer.definition.isDecorator)
      return tryFindDecorator(state, first5, transformer);
  }
  StateSelection2.tryFindDecorator = tryFindDecorator;
})(StateSelection || (StateSelection = {}));

// ../node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d3, b5) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b6) {
    d4.__proto__ = b6;
  } || function(d4, b6) {
    for (var p in b6) if (Object.prototype.hasOwnProperty.call(b6, p)) d4[p] = b6[p];
  };
  return extendStatics(d3, b5);
};
function __extends(d3, b5) {
  if (typeof b5 !== "function" && b5 !== null)
    throw new TypeError("Class extends value " + String(b5) + " is not a constructor or null");
  extendStatics(d3, b5);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v3) {
      return step([n, v3]);
    };
  }
  function step(op2) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op2[0] && (_ = 0)), _) try {
      if (f = 1, y && (t2 = op2[0] & 2 ? y["return"] : op2[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op2[1])).done) return t2;
      if (y = 0, t2) op2 = [op2[0] & 2, t2.value];
      switch (op2[0]) {
        case 0:
        case 1:
          t2 = op2;
          break;
        case 4:
          _.label++;
          return { value: op2[1], done: false };
        case 5:
          _.label++;
          y = op2[1];
          op2 = [0];
          continue;
        case 7:
          op2 = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op2[0] === 3 && (!t2 || op2[1] > t2[0] && op2[1] < t2[3])) {
            _.label = op2[1];
            break;
          }
          if (op2[0] === 6 && _.label < t2[1]) {
            _.label = t2[1];
            t2 = op2;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2];
            _.ops.push(op2);
            break;
          }
          if (t2[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op2 = body.call(thisArg, _);
    } catch (e) {
      op2 = [6, e];
      y = 0;
    } finally {
      f = t2 = 0;
    }
    if (op2[0] & 5) throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v3) {
  return this instanceof __await ? (this.v = v3, this) : new __await(v3);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v3) {
      return Promise.resolve(v3).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v3) {
        return new Promise(function(a5, b5) {
          q.push([n, v3, a5, b5]) > 1 || resume(n, v3);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v3) {
    try {
      step(g[n](v3));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v3) {
    if (f(v3), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v3) {
      return new Promise(function(resolve, reject) {
        v3 = o[n](v3), settle(resolve, reject, v3.done, v3.value);
      });
    };
  }
  function settle(resolve, reject, d3, v3) {
    Promise.resolve(v3).then(function(v4) {
      resolve({ value: v4, done: d3 });
    }, reject);
  }
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors2) {
    _super(this);
    this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors2;
  };
});

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors2;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors2 = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors2 = errors2 !== null && errors2 !== void 0 ? errors2 : [];
              if (err instanceof UnsubscriptionError) {
                errors2 = __spreadArray(__spreadArray([], __read(errors2)), __read(err.errors));
              } else {
                errors2.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors2) {
        throw new UnsubscriptionError(errors2);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop2() {
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb2) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb2();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb2();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop2,
  error: defaultErrorHandler,
  complete: noop2
};

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now2 = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now2 : timestamp2,
            elapsed: now2 - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now2 = _timestampProvider.now();
      var last5 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now2; i += 2) {
        last5 = i;
      }
      last5 && _buffer.splice(0, last5 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb2) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb2();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate2 = Immediate.setImmediate;
var clearImmediate2 = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate2)(handle);
  },
  delegate: void 0
};

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler2 = function() {
  function Scheduler3(schedulerActionCtor, now2) {
    if (now2 === void 0) {
      now2 = Scheduler3.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now2;
  }
  Scheduler3.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler3.now = dateTimestampProvider.now;
  return Scheduler3;
}();

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    var _this = _super.call(this, SchedulerAction, now2) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler2);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId;
    if (action) {
      flushId = action.id;
    } else {
      flushId = this._scheduled;
      this._scheduled = void 0;
    }
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a5, b5) {
    if (a5.delay === b5.delay) {
      if (a5.index === b5.index) {
        return 0;
      } else if (a5.index > b5.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a5.delay > b5.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/args.js
function last3(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last3(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last3(args) === "number" ? args.pop() : defaultValue;
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike2 = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike2(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike2(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/map.js
function map2(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var objectProto = Object.prototype;

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a5, i) {
      return map2(function(b5, ii) {
        return resultSelector(a5, b5, i, ii);
      })(innerFrom(project(a5, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop2);

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter3(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now2 = scheduler.now();
      if (now2 < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now2);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/take.js
function take2(count3) {
  return count3 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count3) {
        subscriber.next(value);
        if (count3 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first4 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first4 || !comparator(previousKey, currentKey)) {
        first4 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a5, b5) {
  return a5 === b5;
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/skip.js
function skip2(count3) {
  return filter3(function(_, index) {
    return count3 <= index;
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/throttle.js
function throttle(durationSelector, config2) {
  return operate(function(source, subscriber) {
    var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
    var hasValue = false;
    var sendValue = null;
    var throttled = null;
    var isComplete = false;
    var endThrottling = function() {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    };
    var cleanupThrottling = function() {
      throttled = null;
      isComplete && subscriber.complete();
    };
    var startThrottle = function(value) {
      return throttled = innerFrom(durationSelector(value)).subscribe(createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    };
    var send = function() {
      if (hasValue) {
        hasValue = false;
        var value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, function() {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}

// ../node_modules/.pnpm/rxjs@7.8.2/node_modules/rxjs/dist/esm5/internal/operators/throttleTime.js
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  var duration$ = timer(duration, scheduler);
  return throttle(function() {
    return duration$;
  }, config2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/rx-event-helper.js
var RxEventHelper;
(function(RxEventHelper2) {
  function create() {
    const helper = new _RxEventHelper();
    const ret = () => helper.create();
    ret.dispose = () => helper.dispose();
    ret.behavior = (v3) => helper.behavior(v3);
    return ret;
  }
  RxEventHelper2.create = create;
})(RxEventHelper || (RxEventHelper = {}));
var _RxEventHelper = class {
  constructor() {
    this._eventList = [];
    this._disposed = false;
  }
  create() {
    const s = new Subject();
    this._eventList.push(s);
    return s;
  }
  behavior(v3) {
    const s = new BehaviorSubject(v3);
    this._eventList.push(s);
    return s;
  }
  dispose() {
    if (this._disposed)
      return;
    for (const e of this._eventList)
      e.complete();
    this._disposed = true;
  }
};

// ../node_modules/.pnpm/immer@10.2.0/node_modules/immer/dist/immer.mjs
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
var errors = true ? [
  // All error codes, starting by 0:
  function(plugin) {
    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
  },
  function(thing) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
  },
  "This object has been frozen and should not be mutated",
  function(data) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(thing) {
    return `'current' expects a draft, got: ${thing}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(thing) {
    return `'original' expects a draft, got: ${thing}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function die(error, ...args) {
  if (true) {
    const e = errors[error];
    const msg = typeof e === "function" ? e.apply(null, args) : e;
    throw new Error(`[Immer] ${msg}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
  return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
  var _a;
  if (!value)
    return false;
  return isPlainObject2(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_a = value.constructor) == null ? void 0 : _a[DRAFTABLE]) || isMap2(value) || isSet2(value);
}
var objectCtorString = Object.prototype.constructor.toString();
var cachedCtorStrings = /* @__PURE__ */ new WeakMap();
function isPlainObject2(value) {
  if (!value || typeof value !== "object")
    return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null || proto === Object.prototype)
    return true;
  const Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  if (Ctor === Object)
    return true;
  if (typeof Ctor !== "function")
    return false;
  let ctorString = cachedCtorStrings.get(Ctor);
  if (ctorString === void 0) {
    ctorString = Function.toString.call(Ctor);
    cachedCtorStrings.set(Ctor, ctorString);
  }
  return ctorString === objectCtorString;
}
function each(obj, iter, strict = true) {
  if (getArchtype(obj) === 0) {
    const keys2 = strict ? Reflect.ownKeys(obj) : Object.keys(obj);
    keys2.forEach((key2) => {
      iter(key2, obj[key2], obj);
    });
  } else {
    obj.forEach((entry, index) => iter(index, entry, obj));
  }
}
function getArchtype(thing) {
  const state = thing[DRAFT_STATE];
  return state ? state.type_ : Array.isArray(thing) ? 1 : isMap2(thing) ? 2 : isSet2(thing) ? 3 : 0;
}
function has5(thing, prop) {
  return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set3(thing, propOrOldValue, value) {
  const t2 = getArchtype(thing);
  if (t2 === 2)
    thing.set(propOrOldValue, value);
  else if (t2 === 3) {
    thing.add(value);
  } else
    thing[propOrOldValue] = value;
}
function is2(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function isMap2(target) {
  return target instanceof Map;
}
function isSet2(target) {
  return target instanceof Set;
}
function latest(state) {
  return state.copy_ || state.base_;
}
function shallowCopy2(base, strict) {
  if (isMap2(base)) {
    return new Map(base);
  }
  if (isSet2(base)) {
    return new Set(base);
  }
  if (Array.isArray(base))
    return Array.prototype.slice.call(base);
  const isPlain = isPlainObject2(base);
  if (strict === true || strict === "class_only" && !isPlain) {
    const descriptors = Object.getOwnPropertyDescriptors(base);
    delete descriptors[DRAFT_STATE];
    let keys2 = Reflect.ownKeys(descriptors);
    for (let i = 0; i < keys2.length; i++) {
      const key2 = keys2[i];
      const desc = descriptors[key2];
      if (desc.writable === false) {
        desc.writable = true;
        desc.configurable = true;
      }
      if (desc.get || desc.set)
        descriptors[key2] = {
          configurable: true,
          writable: true,
          // could live with !!desc.set as well here...
          enumerable: desc.enumerable,
          value: base[key2]
        };
    }
    return Object.create(getPrototypeOf(base), descriptors);
  } else {
    const proto = getPrototypeOf(base);
    if (proto !== null && isPlain) {
      return { ...base };
    }
    const obj = Object.create(proto);
    return Object.assign(obj, base);
  }
}
function freeze(obj, deep = false) {
  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))
    return obj;
  if (getArchtype(obj) > 1) {
    Object.defineProperties(obj, {
      set: dontMutateMethodOverride,
      add: dontMutateMethodOverride,
      clear: dontMutateMethodOverride,
      delete: dontMutateMethodOverride
    });
  }
  Object.freeze(obj);
  if (deep)
    Object.values(obj).forEach((value) => freeze(value, true));
  return obj;
}
function dontMutateFrozenCollections() {
  die(2);
}
var dontMutateMethodOverride = {
  value: dontMutateFrozenCollections
};
function isFrozen(obj) {
  if (obj === null || typeof obj !== "object")
    return true;
  return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
  const plugin = plugins[pluginKey];
  if (!plugin) {
    die(0, pluginKey);
  }
  return plugin;
}
var currentScope;
function getCurrentScope() {
  return currentScope;
}
function createScope(parent_, immer_) {
  return {
    drafts_: [],
    parent_,
    immer_,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: true,
    unfinalizedDrafts_: 0
  };
}
function usePatchesInScope(scope, patchListener) {
  if (patchListener) {
    getPlugin("Patches");
    scope.patches_ = [];
    scope.inversePatches_ = [];
    scope.patchListener_ = patchListener;
  }
}
function revokeScope(scope) {
  leaveScope(scope);
  scope.drafts_.forEach(revokeDraft);
  scope.drafts_ = null;
}
function leaveScope(scope) {
  if (scope === currentScope) {
    currentScope = scope.parent_;
  }
}
function enterScope(immer2) {
  return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
  const state = draft[DRAFT_STATE];
  if (state.type_ === 0 || state.type_ === 1)
    state.revoke_();
  else
    state.revoked_ = true;
}
function processResult(result, scope) {
  scope.unfinalizedDrafts_ = scope.drafts_.length;
  const baseDraft = scope.drafts_[0];
  const isReplaced = result !== void 0 && result !== baseDraft;
  if (isReplaced) {
    if (baseDraft[DRAFT_STATE].modified_) {
      revokeScope(scope);
      die(4);
    }
    if (isDraftable(result)) {
      result = finalize2(scope, result);
      if (!scope.parent_)
        maybeFreeze(scope, result);
    }
    if (scope.patches_) {
      getPlugin("Patches").generateReplacementPatches_(
        baseDraft[DRAFT_STATE].base_,
        result,
        scope.patches_,
        scope.inversePatches_
      );
    }
  } else {
    result = finalize2(scope, baseDraft, []);
  }
  revokeScope(scope);
  if (scope.patches_) {
    scope.patchListener_(scope.patches_, scope.inversePatches_);
  }
  return result !== NOTHING ? result : void 0;
}
function finalize2(rootScope, value, path) {
  if (isFrozen(value))
    return value;
  const useStrictIteration = rootScope.immer_.shouldUseStrictIteration();
  const state = value[DRAFT_STATE];
  if (!state) {
    each(
      value,
      (key2, childValue) => finalizeProperty(rootScope, state, value, key2, childValue, path),
      useStrictIteration
    );
    return value;
  }
  if (state.scope_ !== rootScope)
    return value;
  if (!state.modified_) {
    maybeFreeze(rootScope, state.base_, true);
    return state.base_;
  }
  if (!state.finalized_) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
    const result = state.copy_;
    let resultEach = result;
    let isSet22 = false;
    if (state.type_ === 3) {
      resultEach = new Set(result);
      result.clear();
      isSet22 = true;
    }
    each(
      resultEach,
      (key2, childValue) => finalizeProperty(
        rootScope,
        state,
        result,
        key2,
        childValue,
        path,
        isSet22
      ),
      useStrictIteration
    );
    maybeFreeze(rootScope, result, false);
    if (path && rootScope.patches_) {
      getPlugin("Patches").generatePatches_(
        state,
        path,
        rootScope.patches_,
        rootScope.inversePatches_
      );
    }
  }
  return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
  if (childValue == null) {
    return;
  }
  if (typeof childValue !== "object" && !targetIsSet) {
    return;
  }
  const childIsFrozen = isFrozen(childValue);
  if (childIsFrozen && !targetIsSet) {
    return;
  }
  if (childValue === targetObject)
    die(5);
  if (isDraft(childValue)) {
    const path = rootPath && parentState && parentState.type_ !== 3 && // Set objects are atomic since they have no keys.
    !has5(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
    const res = finalize2(rootScope, childValue, path);
    set3(targetObject, prop, res);
    if (isDraft(res)) {
      rootScope.canAutoFreeze_ = false;
    } else
      return;
  } else if (targetIsSet) {
    targetObject.add(childValue);
  }
  if (isDraftable(childValue) && !childIsFrozen) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
      return;
    }
    if (parentState && parentState.base_ && parentState.base_[prop] === childValue && childIsFrozen) {
      return;
    }
    finalize2(rootScope, childValue);
    if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap2(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop)))
      maybeFreeze(rootScope, childValue);
  }
}
function maybeFreeze(scope, value, deep = false) {
  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
    freeze(value, deep);
  }
}
function createProxyProxy(base, parent) {
  const isArray4 = Array.isArray(base);
  const state = {
    type_: isArray4 ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: parent ? parent.scope_ : getCurrentScope(),
    // True for both shallow and deep changes.
    modified_: false,
    // Used during finalization.
    finalized_: false,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: parent,
    // The base state.
    base_: base,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: false
  };
  let target = state;
  let traps = objectTraps;
  if (isArray4) {
    target = [state];
    traps = arrayTraps;
  }
  const { revoke, proxy } = Proxy.revocable(target, traps);
  state.draft_ = proxy;
  state.revoke_ = revoke;
  return proxy;
}
var objectTraps = {
  get(state, prop) {
    if (prop === DRAFT_STATE)
      return state;
    const source = latest(state);
    if (!has5(source, prop)) {
      return readPropFromProto(state, source, prop);
    }
    const value = source[prop];
    if (state.finalized_ || !isDraftable(value)) {
      return value;
    }
    if (value === peek(state.base_, prop)) {
      prepareCopy(state);
      return state.copy_[prop] = createProxy(value, state);
    }
    return value;
  },
  has(state, prop) {
    return prop in latest(state);
  },
  ownKeys(state) {
    return Reflect.ownKeys(latest(state));
  },
  set(state, prop, value) {
    const desc = getDescriptorFromProto(latest(state), prop);
    if (desc == null ? void 0 : desc.set) {
      desc.set.call(state.draft_, value);
      return true;
    }
    if (!state.modified_) {
      const current22 = peek(latest(state), prop);
      const currentState = current22 == null ? void 0 : current22[DRAFT_STATE];
      if (currentState && currentState.base_ === value) {
        state.copy_[prop] = value;
        state.assigned_[prop] = false;
        return true;
      }
      if (is2(value, current22) && (value !== void 0 || has5(state.base_, prop)))
        return true;
      prepareCopy(state);
      markChanged(state);
    }
    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
    (value !== void 0 || prop in state.copy_) || // special case: NaN
    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))
      return true;
    state.copy_[prop] = value;
    state.assigned_[prop] = true;
    return true;
  },
  deleteProperty(state, prop) {
    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
      state.assigned_[prop] = false;
      prepareCopy(state);
      markChanged(state);
    } else {
      delete state.assigned_[prop];
    }
    if (state.copy_) {
      delete state.copy_[prop];
    }
    return true;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(state, prop) {
    const owner = latest(state);
    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
    if (!desc)
      return desc;
    return {
      writable: true,
      configurable: state.type_ !== 1 || prop !== "length",
      enumerable: desc.enumerable,
      value: owner[prop]
    };
  },
  defineProperty() {
    die(11);
  },
  getPrototypeOf(state) {
    return getPrototypeOf(state.base_);
  },
  setPrototypeOf() {
    die(12);
  }
};
var arrayTraps = {};
each(objectTraps, (key2, fn) => {
  arrayTraps[key2] = function() {
    arguments[0] = arguments[0][0];
    return fn.apply(this, arguments);
  };
});
arrayTraps.deleteProperty = function(state, prop) {
  if (isNaN(parseInt(prop)))
    die(13);
  return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
  if (prop !== "length" && isNaN(parseInt(prop)))
    die(14);
  return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
  const state = draft[DRAFT_STATE];
  const source = state ? latest(state) : draft;
  return source[prop];
}
function readPropFromProto(state, source, prop) {
  var _a;
  const desc = getDescriptorFromProto(source, prop);
  return desc ? `value` in desc ? desc.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (_a = desc.get) == null ? void 0 : _a.call(state.draft_)
  ) : void 0;
}
function getDescriptorFromProto(source, prop) {
  if (!(prop in source))
    return void 0;
  let proto = getPrototypeOf(source);
  while (proto) {
    const desc = Object.getOwnPropertyDescriptor(proto, prop);
    if (desc)
      return desc;
    proto = getPrototypeOf(proto);
  }
  return void 0;
}
function markChanged(state) {
  if (!state.modified_) {
    state.modified_ = true;
    if (state.parent_) {
      markChanged(state.parent_);
    }
  }
}
function prepareCopy(state) {
  if (!state.copy_) {
    state.copy_ = shallowCopy2(
      state.base_,
      state.scope_.immer_.useStrictShallowCopy_
    );
  }
}
var Immer2 = class {
  constructor(config2) {
    this.autoFreeze_ = true;
    this.useStrictShallowCopy_ = false;
    this.useStrictIteration_ = true;
    this.produce = (base, recipe, patchListener) => {
      if (typeof base === "function" && typeof recipe !== "function") {
        const defaultBase = recipe;
        recipe = base;
        const self = this;
        return function curriedProduce(base2 = defaultBase, ...args) {
          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));
        };
      }
      if (typeof recipe !== "function")
        die(6);
      if (patchListener !== void 0 && typeof patchListener !== "function")
        die(7);
      let result;
      if (isDraftable(base)) {
        const scope = enterScope(this);
        const proxy = createProxy(base, void 0);
        let hasError = true;
        try {
          result = recipe(proxy);
          hasError = false;
        } finally {
          if (hasError)
            revokeScope(scope);
          else
            leaveScope(scope);
        }
        usePatchesInScope(scope, patchListener);
        return processResult(result, scope);
      } else if (!base || typeof base !== "object") {
        result = recipe(base);
        if (result === void 0)
          result = base;
        if (result === NOTHING)
          result = void 0;
        if (this.autoFreeze_)
          freeze(result, true);
        if (patchListener) {
          const p = [];
          const ip = [];
          getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
          patchListener(p, ip);
        }
        return result;
      } else
        die(1, base);
    };
    this.produceWithPatches = (base, recipe) => {
      if (typeof base === "function") {
        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
      }
      let patches, inversePatches;
      const result = this.produce(base, recipe, (p, ip) => {
        patches = p;
        inversePatches = ip;
      });
      return [result, patches, inversePatches];
    };
    if (typeof (config2 == null ? void 0 : config2.autoFreeze) === "boolean")
      this.setAutoFreeze(config2.autoFreeze);
    if (typeof (config2 == null ? void 0 : config2.useStrictShallowCopy) === "boolean")
      this.setUseStrictShallowCopy(config2.useStrictShallowCopy);
    if (typeof (config2 == null ? void 0 : config2.useStrictIteration) === "boolean")
      this.setUseStrictIteration(config2.useStrictIteration);
  }
  createDraft(base) {
    if (!isDraftable(base))
      die(8);
    if (isDraft(base))
      base = current(base);
    const scope = enterScope(this);
    const proxy = createProxy(base, void 0);
    proxy[DRAFT_STATE].isManual_ = true;
    leaveScope(scope);
    return proxy;
  }
  finishDraft(draft, patchListener) {
    const state = draft && draft[DRAFT_STATE];
    if (!state || !state.isManual_)
      die(9);
    const { scope_: scope } = state;
    usePatchesInScope(scope, patchListener);
    return processResult(void 0, scope);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(value) {
    this.autoFreeze_ = value;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(value) {
    this.useStrictShallowCopy_ = value;
  }
  /**
   * Pass false to use faster iteration that skips non-enumerable properties
   * but still handles symbols for compatibility.
   *
   * By default, strict iteration is enabled (includes all own properties).
   */
  setUseStrictIteration(value) {
    this.useStrictIteration_ = value;
  }
  shouldUseStrictIteration() {
    return this.useStrictIteration_;
  }
  applyPatches(base, patches) {
    let i;
    for (i = patches.length - 1; i >= 0; i--) {
      const patch = patches[i];
      if (patch.path.length === 0 && patch.op === "replace") {
        base = patch.value;
        break;
      }
    }
    if (i > -1) {
      patches = patches.slice(i + 1);
    }
    const applyPatchesImpl = getPlugin("Patches").applyPatches_;
    if (isDraft(base)) {
      return applyPatchesImpl(base, patches);
    }
    return this.produce(
      base,
      (draft) => applyPatchesImpl(draft, patches)
    );
  }
};
function createProxy(value, parent) {
  const draft = isMap2(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet2(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
  const scope = parent ? parent.scope_ : getCurrentScope();
  scope.drafts_.push(draft);
  return draft;
}
function current(value) {
  if (!isDraft(value))
    die(10, value);
  return currentImpl(value);
}
function currentImpl(value) {
  if (!isDraftable(value) || isFrozen(value))
    return value;
  const state = value[DRAFT_STATE];
  let copy;
  let strict = true;
  if (state) {
    if (!state.modified_)
      return state.base_;
    state.finalized_ = true;
    copy = shallowCopy2(value, state.scope_.immer_.useStrictShallowCopy_);
    strict = state.scope_.immer_.shouldUseStrictIteration();
  } else {
    copy = shallowCopy2(value, true);
  }
  each(
    copy,
    (key2, childValue) => {
      set3(copy, key2, currentImpl(childValue));
    },
    strict
  );
  if (state) {
    state.finalized_ = false;
  }
  return copy;
}
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = immer.produceWithPatches.bind(
  immer
);
var setAutoFreeze = immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(
  immer
);
var setUseStrictIteration = immer.setUseStrictIteration.bind(
  immer
);
var applyPatches = immer.applyPatches.bind(immer);
var createDraft = immer.createDraft.bind(immer);
var finishDraft = immer.finishDraft.bind(immer);

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-state/state/builder.js
var StateBuilder;
(function(StateBuilder2) {
  function buildTree(state) {
    if (!state.state || state.state.tree === state.editInfo.sourceTree) {
      return state.tree.asImmutable();
    }
    const tree = state.state.tree.asTransient();
    for (const a5 of state.actions) {
      switch (a5.kind) {
        case "add":
          tree.add(a5.transform);
          break;
        case "update":
          tree.setParams(a5.ref, a5.params);
          break;
        case "delete":
          tree.remove(a5.ref);
          break;
        case "insert": {
          const children = tree.children.get(a5.ref).toArray();
          tree.add(a5.transform);
          for (const c5 of children) {
            tree.changeParent(c5, a5.transform.ref);
          }
          break;
        }
      }
    }
    state.editInfo.sourceTree = state.tree;
    return tree.asImmutable();
  }
  function is3(obj) {
    return !!obj && typeof obj.getTree === "function";
  }
  StateBuilder2.is = is3;
  function isTo(obj) {
    return !!obj && typeof obj.getTree === "function" && typeof obj.ref === "string";
  }
  StateBuilder2.isTo = isTo;
  class Root {
    get editInfo() {
      return this.state.editInfo;
    }
    get currentTree() {
      return this.state.tree;
    }
    to(refOrCellOrSelector) {
      const ref = typeof refOrCellOrSelector === "string" ? refOrCellOrSelector : StateObjectCell.is(refOrCellOrSelector) ? refOrCellOrSelector.transform.ref : refOrCellOrSelector.ref;
      return new To(this.state, ref, this);
    }
    toRoot() {
      return new To(this.state, this.state.tree.root.ref, this);
    }
    delete(obj) {
      const ref = StateObjectRef.resolveRef(obj);
      if (!ref || !this.state.tree.transforms.has(ref))
        return this;
      this.editInfo.count++;
      this.state.tree.remove(ref);
      this.state.actions.push({ kind: "delete", ref });
      return this;
    }
    getTree() {
      return buildTree(this.state);
    }
    commit(options) {
      if (!this.state.state)
        throw new Error("Cannot commit template tree");
      return this.state.state.runTask(this.state.state.updateTree(this, options));
    }
    constructor(tree, state) {
      this.state = { state, tree: tree.asTransient(), actions: [], editInfo: { applied: false, sourceTree: tree, count: 0, lastUpdate: void 0 } };
    }
  }
  StateBuilder2.Root = Root;
  class To {
    get editInfo() {
      return this.state.editInfo;
    }
    get selector() {
      return new StateObjectSelector(this.ref, this.state.state);
    }
    getApplyRoot() {
      return StateTree.getDecoratorRoot(this.state.tree, this.ref);
    }
    /**
     * Apply the transformed to the parent node
     * If no params are specified (params <- undefined), default params are lazily resolved.
     */
    apply(tr, params, options) {
      if (tr.definition.isDecorator) {
        return this.insert(tr, params, options);
      }
      const applyRoot = this.getApplyRoot();
      const t2 = tr.apply(applyRoot, params, options);
      this.state.tree.add(t2);
      this.editInfo.count++;
      this.editInfo.lastUpdate = t2.ref;
      this.state.actions.push({ kind: "add", transform: t2 });
      return new To(this.state, t2.ref, this.root);
    }
    /**
     * If the ref is present, the transform is applied.
     * Otherwise a transform with the specifed ref is created.
     */
    applyOrUpdate(ref, tr, params, options) {
      if (this.state.tree.transforms.has(ref)) {
        const to = this.to(ref);
        if (params)
          to.update(params);
        return to;
      } else {
        return this.apply(tr, params, { ...options, ref });
      }
    }
    /**
     * Apply the transformed to the parent node
     * If no params are specified (params <- undefined), default params are lazily resolved.
     * The transformer cannot be a decorator to be able to use this.
     */
    applyOrUpdateTagged(tags, tr, params, options) {
      if (tr.definition.isDecorator) {
        throw new Error(`Can't use applyOrUpdateTagged on decorator transformers.`);
      }
      const applyRoot = this.getApplyRoot();
      const children = this.state.tree.children.get(applyRoot).values();
      while (true) {
        const child = children.next();
        if (child.done)
          break;
        const tr2 = this.state.tree.transforms.get(child.value);
        if (tr2 && Transform.hasTags(tr2, tags)) {
          const to = this.to(child.value);
          to.updateTagged(params, stringArrayUnion(tr2.tags, tags, options && options.tags));
          return to;
        }
      }
      const t2 = tr.apply(applyRoot, params, { ...options, tags: stringArrayUnion(tags, options && options.tags) });
      this.state.tree.add(t2);
      this.editInfo.count++;
      this.editInfo.lastUpdate = t2.ref;
      this.state.actions.push({ kind: "add", transform: t2 });
      return new To(this.state, t2.ref, this.root);
    }
    /**
     * A helper to greate a group-like state object and keep the current type.
     */
    group(tr, params, options) {
      return this.apply(tr, params, options);
    }
    /**
     * Inserts a new transform that does not change the object type and move the original children to it.
     */
    insert(tr, params, options) {
      const children = this.state.tree.children.get(this.ref).toArray();
      const t2 = tr.apply(this.ref, params, options);
      this.state.tree.add(t2);
      for (const c5 of children) {
        this.state.tree.changeParent(c5, t2.ref);
      }
      this.editInfo.count++;
      this.editInfo.lastUpdate = t2.ref;
      this.state.actions.push({ kind: "insert", ref: this.ref, transform: t2 });
      return new To(this.state, t2.ref, this.root);
    }
    updateTagged(params, tags) {
      if (this.state.tree.setParams(this.ref, params) || this.state.tree.setTags(this.ref, tags)) {
        this.editInfo.count++;
        this.editInfo.lastUpdate = this.ref;
        this.state.actions.push({ kind: "update", ref: this.ref, params });
      }
    }
    update(paramsOrTransformer, provider) {
      let params;
      if (provider) {
        const old = this.state.tree.transforms.get(this.ref);
        params = produce(old.params, provider);
      } else {
        params = typeof paramsOrTransformer === "function" ? produce(this.state.tree.transforms.get(this.ref).params, paramsOrTransformer) : paramsOrTransformer;
      }
      if (this.state.tree.setParams(this.ref, params)) {
        this.editInfo.count++;
        this.editInfo.lastUpdate = this.ref;
        this.state.actions.push({ kind: "update", ref: this.ref, params });
      }
      return this.root;
    }
    updateState(state) {
      const transform = this.state.tree.transforms.get(this.ref);
      if (Transform.isStateChange(transform.state, state)) {
        this.state.tree.assignState(this.ref, state);
        this.editInfo.count++;
        this.editInfo.lastUpdate = this.ref;
        if (!this.state.actions.find((a5) => a5.kind === "update" && a5.ref === this.ref)) {
          this.state.actions.push({ kind: "update", ref: this.ref, params: transform.params });
        }
      }
    }
    /** Add tags to the current node */
    tag(tags) {
      const transform = this.state.tree.transforms.get(this.ref);
      this.updateTagged(transform.params, stringArrayUnion(transform.tags, tags));
      return this;
    }
    /** Add dependsOn to the current node */
    dependsOn(dependsOn) {
      const transform = this.state.tree.transforms.get(this.ref);
      if (this.state.tree.setDependsOn(this.ref, stringArrayUnion(transform.dependsOn, dependsOn))) {
        this.editInfo.count++;
        this.editInfo.lastUpdate = this.ref;
        this.state.actions.push({ kind: "update", ref: this.ref, params: transform.params });
      }
    }
    to(ref) {
      return this.root.to(ref);
    }
    toRoot() {
      return this.root.toRoot();
    }
    delete(ref) {
      return this.root.delete(ref);
    }
    getTree() {
      return buildTree(this.state);
    }
    /** Returns selector to this node. */
    commit(options) {
      if (!this.state.state)
        throw new Error("Cannot commit template tree");
      return this.state.state.runTask(this.state.state.updateTree(this, options));
    }
    constructor(state, ref, root) {
      this.state = state;
      this.root = root;
      this.ref = ref;
      if (!this.state.tree.transforms.has(ref)) {
        throw new Error(`Could not find node '${ref}'.`);
      }
    }
  }
  StateBuilder2.To = To;
})(StateBuilder || (StateBuilder = {}));
function stringArrayUnion(...arrays) {
  let set4 = void 0;
  const ret = [];
  for (const xs of arrays) {
    if (!xs)
      continue;
    if (!set4)
      set4 = /* @__PURE__ */ new Set();
    if (typeof xs === "string") {
      if (set4.has(xs))
        continue;
      set4.add(xs);
      ret.push(xs);
    } else {
      for (const x of xs) {
        if (set4.has(x))
          continue;
        set4.add(x);
        ret.push(x);
      }
    }
  }
  return ret;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-state/action/manager.js
var StateActionManager = class {
  constructor() {
    this.ev = RxEventHelper.create();
    this.actions = /* @__PURE__ */ new Map();
    this.fromTypeIndex = /* @__PURE__ */ new Map();
    this.events = {
      added: this.ev(),
      removed: this.ev()
    };
  }
  add(actionOrTransformer) {
    const action = Transformer.is(actionOrTransformer) ? actionOrTransformer.toAction() : actionOrTransformer;
    if (this.actions.has(action.id))
      return this;
    this.actions.set(action.id, action);
    for (const t2 of action.definition.from) {
      if (this.fromTypeIndex.has(t2.type)) {
        this.fromTypeIndex.get(t2.type).push(action);
      } else {
        this.fromTypeIndex.set(t2.type, [action]);
      }
    }
    this.events.added.next(void 0);
    return this;
  }
  remove(actionOrTransformer) {
    const id = Transformer.is(actionOrTransformer) ? actionOrTransformer.toAction().id : UUID.is(actionOrTransformer) ? actionOrTransformer : actionOrTransformer.id;
    const action = this.actions.get(id);
    if (!action)
      return this;
    this.actions.delete(id);
    for (const t2 of action.definition.from) {
      const xs = this.fromTypeIndex.get(t2.type);
      if (!xs)
        continue;
      arraySetRemove(xs, action);
      if (xs.length === 0)
        this.fromTypeIndex.delete(t2.type);
    }
    this.events.removed.next(void 0);
    return this;
  }
  fromCell(cell, ctx) {
    const obj = cell.obj;
    if (!obj)
      return [];
    const actions = this.fromTypeIndex.get(obj.type);
    if (!actions)
      return [];
    let hasTest = false;
    for (const a5 of actions) {
      if (a5.definition.isApplicable) {
        hasTest = true;
        break;
      }
    }
    if (!hasTest)
      return actions;
    const ret = [];
    for (const a5 of actions) {
      if (a5.definition.isApplicable) {
        if (a5.definition.isApplicable(obj, cell.transform, ctx)) {
          ret.push(a5);
        }
      } else {
        ret.push(a5);
      }
    }
    return ret;
  }
  dispose() {
    this.ev.dispose();
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/log-entry.js
var LogEntry;
(function(LogEntry2) {
  function message(msg) {
    return { type: "message", timestamp: /* @__PURE__ */ new Date(), message: msg };
  }
  LogEntry2.message = message;
  function error(msg) {
    return { type: "error", timestamp: /* @__PURE__ */ new Date(), message: msg };
  }
  LogEntry2.error = error;
  function warning(msg) {
    return { type: "warning", timestamp: /* @__PURE__ */ new Date(), message: msg };
  }
  LogEntry2.warning = warning;
  function info(msg) {
    return { type: "info", timestamp: /* @__PURE__ */ new Date(), message: msg };
  }
  LogEntry2.info = info;
})(LogEntry || (LogEntry = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-state/tree/spine.js
var StateTreeSpine;
(function(StateTreeSpine2) {
  class Impl {
    get current() {
      return this._current;
    }
    set current(cell) {
      this._current = cell;
    }
    getAncestorOfType(t2) {
      if (!this._current)
        return void 0;
      let cell = this._current;
      while (true) {
        cell = this.cells.get(cell.transform.parent);
        if (!cell.obj)
          return void 0;
        if (cell.obj.type === t2.type)
          return cell.obj;
        if (cell.transform.ref === Transform.RootRef)
          return void 0;
      }
    }
    getRootOfType(t2) {
      if (!this._current)
        return void 0;
      let cell = this._current;
      let ret = void 0;
      while (true) {
        if (!cell.obj)
          return void 0;
        if (cell.obj.type === t2.type) {
          ret = cell;
        }
        if (cell.transform.ref === Transform.RootRef)
          return ret ? ret.obj : void 0;
        cell = this.cells.get(cell.transform.parent);
      }
    }
    constructor(cells) {
      this.cells = cells;
      this._current = void 0;
    }
  }
  StateTreeSpine2.Impl = Impl;
  function getDecoratorChain(state, currentRef) {
    const cells = state.cells;
    let current3 = cells.get(currentRef);
    const ret = [current3];
    while (current3 === null || current3 === void 0 ? void 0 : current3.transform.transformer.definition.isDecorator) {
      current3 = cells.get(current3.transform.parent);
      ret.push(current3);
    }
    return ret;
  }
  StateTreeSpine2.getDecoratorChain = getDecoratorChain;
  function getRootOfType(state, t2, ref) {
    let ret = void 0;
    let cell = state.cells.get(ref);
    if (!cell)
      return void 0;
    while (true) {
      if (!cell.obj)
        return void 0;
      if (cell.obj.type === t2.type) {
        ret = cell;
      }
      if (cell.transform.ref === Transform.RootRef)
        return ret ? ret.obj : void 0;
      cell = state.cells.get(cell.transform.parent);
    }
  }
  StateTreeSpine2.getRootOfType = getRootOfType;
})(StateTreeSpine || (StateTreeSpine = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/async-queue.js
var AsyncQueue = class {
  constructor() {
    this.queue = [];
    this.signal = new Subject();
  }
  get length() {
    return this.queue.length;
  }
  enqueue(v3) {
    this.queue.push(v3);
    if (this.queue.length === 1)
      return true;
    return this.waitFor(v3);
  }
  handled(v3) {
    arrayRemoveInPlace(this.queue, v3);
    if (this.queue.length > 0) {
      this.signal.next({ v: this.queue[0], stillPresent: true });
    }
  }
  remove(v3) {
    const rem = arrayRemoveInPlace(this.queue, v3);
    if (rem)
      this.signal.next({ v: v3, stillPresent: false });
    return rem;
  }
  waitFor(t2) {
    return new Promise((res) => {
      const sub = this.signal.subscribe(({ v: v3, stillPresent: removed }) => {
        if (v3 === t2) {
          sub.unsubscribe();
          res(removed);
        }
      });
    });
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-state/state.js
var State = class {
  get tree() {
    return this._tree;
  }
  get transforms() {
    return this._tree.transforms;
  }
  get current() {
    return this.behaviors.currentObject.value.ref;
  }
  get root() {
    return this.cells.get(this._tree.root.ref);
  }
  build() {
    return new StateBuilder.Root(this.tree, this);
  }
  addHistory(tree, label2) {
    if (this.historyCapacity === 0)
      return;
    this.history.unshift([tree, label2 || "Update"]);
    if (this.history.length > this.historyCapacity)
      this.history.pop();
    this.events.historyUpdated.next({ state: this });
  }
  clearHistory() {
    if (this.history.length === 0)
      return;
    this.history = [];
    this.events.historyUpdated.next({ state: this });
  }
  get latestUndoLabel() {
    return this.history.length > 0 ? this.history[0][1] : void 0;
  }
  get canUndo() {
    return this.history.length > 0;
  }
  undo() {
    return Task.create("Undo", async (ctx) => {
      const e = this.history.shift();
      if (!e)
        return;
      this.events.historyUpdated.next({ state: this });
      this.undoingHistory = true;
      try {
        await this.updateTree(e[0], { canUndo: false }).runInContext(ctx);
      } finally {
        this.undoingHistory = false;
      }
    });
  }
  getSnapshot() {
    return { tree: StateTree.toJSON(this._tree) };
  }
  setSnapshot(snapshot) {
    const tree = StateTree.fromJSON(snapshot.tree);
    return this.updateTree(tree);
  }
  setCurrent(ref) {
    this.behaviors.currentObject.next({ state: this, ref });
  }
  updateCellState(ref, stateOrProvider) {
    const cell = this.cells.get(ref);
    if (!cell)
      return;
    const update10 = typeof stateOrProvider === "function" ? stateOrProvider(cell.state) : stateOrProvider;
    if (Transform.assignState(cell.state, update10)) {
      cell.transform = this._tree.assignState(cell.transform.ref, update10);
      this.events.cell.stateUpdated.next({ state: this, ref, cell });
    }
  }
  dispose() {
    this.ev.dispose();
    this.actions.dispose();
  }
  /**
   * Select Cells using the provided selector.
   * @example state.query(StateSelection.Generators.byRef('test').ancestorOfType(type))
   * @example state.query('test')
   */
  select(selector) {
    return StateSelection.select(selector, this);
  }
  /**
   * Select Cells by building a query generated on the fly.
   * @example state.select(q => q.byRef('test').subtree())
   */
  selectQ(selector) {
    if (typeof selector === "string")
      return StateSelection.select(selector, this);
    return StateSelection.select(selector(StateSelection.Generators), this);
  }
  /**
   * Creates a Task that applies the specified StateAction (i.e. must use run* on the result)
   * If no ref is specified, apply to root.
   */
  applyAction(action, params, ref = Transform.RootRef) {
    return Task.create("Apply Action", (ctx) => {
      const cell = this.cells.get(ref);
      if (!cell)
        throw new Error(`'${ref}' does not exist.`);
      if (cell.status !== "ok")
        throw new Error(`Action cannot be applied to a cell with status '${cell.status}'`);
      return runTask(action.definition.run({ ref, cell, a: cell.obj, params, state: this }, this.globalContext), ctx);
    });
  }
  /** Apply series of updates to the state. If any of them fail, revert to the original state. */
  transaction(edits, options) {
    return Task.create("State Transaction", async (ctx) => {
      const isNested = this.inTransaction;
      const snapshot = this._tree.asImmutable();
      let restored = false;
      try {
        if (!isNested)
          this.behaviors.isUpdating.next(true);
        this.inTransaction = true;
        this.inTransactionError = false;
        await edits(ctx);
        if (this.inTransactionError) {
          restored = true;
          await this.updateTree(snapshot).runInContext(ctx);
        }
      } catch (e) {
        if (!restored) {
          restored = true;
          await this.updateTree(snapshot).runInContext(ctx);
          this.events.log.next(LogEntry.error("Error during state transaction, reverting"));
        }
        if (isNested) {
          this.inTransactionError = true;
          throw e;
        }
        if (options === null || options === void 0 ? void 0 : options.rethrowErrors) {
          throw e;
        } else {
          console.error(e);
        }
      } finally {
        if (!isNested) {
          this.inTransaction = false;
          this.events.changed.next({ state: this, inTransaction: false });
          this.behaviors.isUpdating.next(false);
          if (!restored) {
            if (options === null || options === void 0 ? void 0 : options.canUndo)
              this.addHistory(snapshot, typeof options.canUndo === "string" ? options.canUndo : void 0);
            else
              this.clearHistory();
          }
        }
      }
    });
  }
  /**
   * Determines whether the state is currently "inside" updateTree function.
   * This is different from "isUpdating" which wraps entire transactions.
   */
  get inUpdate() {
    return this._inUpdate;
  }
  updateTree(tree, options) {
    const params = { tree, options };
    return Task.create("Update Tree", async (taskCtx) => {
      const removed = await this.updateQueue.enqueue(params);
      if (!removed)
        return;
      this._inUpdate = true;
      const snapshot = (options === null || options === void 0 ? void 0 : options.canUndo) ? this._tree.asImmutable() : void 0;
      let reverted = false;
      if (!this.inTransaction)
        this.behaviors.isUpdating.next(true);
      try {
        if (StateBuilder.is(tree)) {
          if (tree.editInfo.applied)
            throw new Error("This builder has already been applied. Create a new builder for further state updates");
          tree.editInfo.applied = true;
        }
        this.reverted = false;
        const ret = options && (options.revertIfAborted || options.revertOnError) ? await this._revertibleTreeUpdate(taskCtx, params, options) : await this._updateTree(taskCtx, params);
        reverted = this.reverted;
        if (ret.ctx.hadError)
          this.inTransactionError = true;
        if (!ret.cell)
          return;
        return new StateObjectSelector(ret.cell.transform.ref, this);
      } finally {
        this._inUpdate = false;
        this.updateQueue.handled(params);
        if (!this.inTransaction) {
          this.behaviors.isUpdating.next(false);
          if (!(options === null || options === void 0 ? void 0 : options.canUndo)) {
            if (!this.undoingHistory)
              this.clearHistory();
          } else if (!reverted) {
            this.addHistory(snapshot, typeof options.canUndo === "string" ? options.canUndo : void 0);
          }
        }
      }
    }, () => {
      this.updateQueue.remove(params);
    });
  }
  async _revertibleTreeUpdate(taskCtx, params, options) {
    const old = this.tree;
    const ret = await this._updateTree(taskCtx, params);
    const revert = (ret.ctx.hadError || ret.ctx.wasAborted) && options.revertOnError || ret.ctx.wasAborted && options.revertIfAborted;
    if (revert) {
      this.reverted = true;
      return await this._updateTree(taskCtx, { tree: old, options: params.options });
    }
    return ret;
  }
  async _updateTree(taskCtx, params) {
    let updated = false;
    const ctx = this.updateTreeAndCreateCtx(params.tree, taskCtx, params.options);
    try {
      updated = await update8(ctx);
      if (StateBuilder.isTo(params.tree)) {
        const cell = this.select(params.tree.ref)[0];
        return { ctx, cell };
      }
      return { ctx };
    } finally {
      this.spine.current = void 0;
      if (updated)
        this.events.changed.next({ state: this, inTransaction: this.inTransaction });
    }
  }
  updateTreeAndCreateCtx(tree, taskCtx, options) {
    const _tree = (StateBuilder.is(tree) ? tree.getTree() : tree).asTransient();
    const oldTree = this._tree;
    this._tree = _tree;
    const cells = this.cells;
    const ctx = {
      parent: this,
      editInfo: StateBuilder.is(tree) ? tree.editInfo : void 0,
      errorFree: this.errorFree,
      taskCtx,
      oldTree,
      tree: _tree,
      cells: this.cells,
      spine: this.spine,
      results: [],
      options: { ...StateUpdateDefaultOptions, ...options },
      changed: false,
      hadError: false,
      wasAborted: false,
      newCurrent: void 0,
      getCellData: (ref) => {
        var _a;
        return (_a = cells.get(ref).obj) === null || _a === void 0 ? void 0 : _a.data;
      }
    };
    this.errorFree = true;
    return ctx;
  }
  constructor(rootObject, params) {
    this.errorFree = true;
    this.ev = RxEventHelper.create();
    this.globalContext = void 0;
    this.events = {
      cell: {
        stateUpdated: this.ev(),
        created: this.ev(),
        removed: this.ev()
      },
      object: {
        updated: this.ev(),
        created: this.ev(),
        removed: this.ev()
      },
      log: this.ev(),
      changed: this.ev(),
      historyUpdated: this.ev()
    };
    this.behaviors = {
      currentObject: this.ev.behavior({ state: this, ref: Transform.RootRef }),
      isUpdating: this.ev.behavior(false)
    };
    this.actions = new StateActionManager();
    this.cells = /* @__PURE__ */ new Map();
    this.spine = new StateTreeSpine.Impl(this.cells);
    this.tryGetCellData = (ref) => {
      var _a, _b;
      const ret = (_b = (_a = this.cells.get(ref)) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;
      if (ret === void 0)
        throw new Error(`Cell '${ref}' data undefined.`);
      return ret;
    };
    this.historyCapacity = 5;
    this.history = [];
    this.undoingHistory = false;
    this.inTransaction = false;
    this.inTransactionError = false;
    this._inUpdate = false;
    this.reverted = false;
    this.updateQueue = new AsyncQueue();
    this._tree = StateTree.createEmpty(Transform.createRoot(params && params.rootState)).asTransient();
    const tree = this._tree;
    const root = tree.root;
    this.runTask = params.runTask;
    if ((params === null || params === void 0 ? void 0 : params.historyCapacity) !== void 0)
      this.historyCapacity = params.historyCapacity;
    this.cells.set(root.ref, {
      parent: this,
      transform: root,
      sourceRef: void 0,
      obj: rootObject,
      status: "ok",
      state: { ...root.state },
      errorText: void 0,
      params: {
        definition: {},
        values: {}
      },
      paramsNormalizedVersion: root.version,
      dependencies: { dependentBy: [], dependsOn: [] },
      cache: {}
    });
    this.globalContext = params && params.globalContext;
  }
};
(function(State10) {
  function create(rootObject, params) {
    return new State10(rootObject, params);
  }
  State10.create = create;
  let ObjectEvent;
  (function(ObjectEvent2) {
    function isCell(e, cell) {
      return !!cell && e.ref === cell.transform.ref && e.state === cell.parent;
    }
    ObjectEvent2.isCell = isCell;
  })(ObjectEvent = State10.ObjectEvent || (State10.ObjectEvent = {}));
})(State || (State = {}));
var StateUpdateDefaultOptions = {
  doNotLogTiming: false,
  doNotUpdateCurrent: true,
  revertIfAborted: false,
  revertOnError: false,
  canUndo: false
};
async function update8(ctx) {
  const fastTrack = !!(ctx.editInfo && ctx.editInfo.count === 1 && ctx.editInfo.lastUpdate && ctx.editInfo.sourceTree === ctx.oldTree);
  let deletes, deletedObjects = [], roots;
  if (fastTrack) {
    deletes = [];
    roots = [ctx.editInfo.lastUpdate];
  } else {
    deletes = findDeletes(ctx);
    const current3 = ctx.parent.current;
    let hasCurrent = false;
    for (const d3 of deletes) {
      if (d3 === current3) {
        hasCurrent = true;
        break;
      }
    }
    if (hasCurrent) {
      const newCurrent2 = findNewCurrent(ctx.oldTree, current3, deletes, ctx.cells);
      ctx.parent.setCurrent(newCurrent2);
    }
    for (let i = deletes.length - 1; i >= 0; i--) {
      const cell = ctx.cells.get(deletes[i]);
      if (cell) {
        dispose(cell.transform, cell.obj, cell === null || cell === void 0 ? void 0 : cell.transform.params, cell.cache, ctx.parent.globalContext);
      }
    }
    for (const d3 of deletes) {
      const cell = ctx.cells.get(d3);
      if (cell) {
        cell.parent = void 0;
        unlinkCell(cell);
      }
      const obj = cell && cell.obj;
      ctx.cells.delete(d3);
      deletedObjects.push(obj);
    }
    roots = findUpdateRoots(ctx.cells, ctx.tree);
  }
  const init = initCells(ctx, roots);
  for (const cell of init.added) {
    ctx.parent.events.cell.created.next({ state: ctx.parent, ref: cell.transform.ref, cell });
  }
  for (let i = 0; i < deletes.length; i++) {
    const d3 = deletes[i];
    const parent = ctx.oldTree.transforms.get(d3).parent;
    ctx.parent.events.object.removed.next({ state: ctx.parent, ref: d3, obj: deletedObjects[i] });
    ctx.parent.events.cell.removed.next({ state: ctx.parent, ref: d3, parent });
  }
  if (deletedObjects.length)
    deletedObjects = [];
  if (init.dependent) {
    for (const cell of init.dependent) {
      roots.push(cell.transform.ref);
    }
  }
  initCellStatus(ctx, roots);
  for (const root of roots) {
    await updateSubtree(ctx, root);
  }
  if (!ctx.editInfo) {
    syncNewStates(ctx);
  }
  let newCurrent = ctx.newCurrent;
  for (const update10 of ctx.results) {
    if (update10.action === "created") {
      ctx.parent.events.object.created.next({ state: ctx.parent, ref: update10.ref, obj: update10.obj });
      if (!ctx.newCurrent) {
        const transform = ctx.tree.transforms.get(update10.ref);
        if (!transform.state.isGhost && update10.obj !== StateObject.Null)
          newCurrent = update10.ref;
      }
    } else if (update10.action === "updated") {
      ctx.parent.events.object.updated.next({ state: ctx.parent, ref: update10.ref, action: "in-place", obj: update10.obj, oldData: update10.oldData });
    } else if (update10.action === "replaced") {
      ctx.parent.events.object.updated.next({ state: ctx.parent, ref: update10.ref, action: "recreate", obj: update10.obj, oldObj: update10.oldObj });
    }
  }
  if (newCurrent) {
    if (!ctx.options.doNotUpdateCurrent)
      ctx.parent.setCurrent(newCurrent);
  } else {
    const current3 = ctx.parent.current;
    const currentCell = ctx.cells.get(current3);
    if (currentCell && (currentCell.obj === StateObject.Null || currentCell.status === "error" && currentCell.errorText === ParentNullErrorText)) {
      newCurrent = findNewCurrent(ctx.oldTree, current3, [], ctx.cells);
      ctx.parent.setCurrent(newCurrent);
    }
  }
  return deletes.length > 0 || roots.length > 0 || ctx.changed;
}
function findUpdateRoots(cells, tree) {
  const findState = { roots: [], cells };
  StateTree.doPreOrder(tree, tree.root, findState, findUpdateRootsVisitor);
  return findState.roots;
}
function findUpdateRootsVisitor(n, _, s) {
  const cell = s.cells.get(n.ref);
  if (!cell || cell.transform.version !== n.version) {
    s.roots.push(n.ref);
    return false;
  }
  if (cell.status === "error")
    return false;
  if (cell && cell.obj === StateObject.Null)
    return false;
  return true;
}
function checkDeleteVisitor(n, _, ctx) {
  if (!ctx.newTree.transforms.has(n.ref) && ctx.cells.has(n.ref))
    ctx.deletes.push(n.ref);
}
function findDeletes(ctx) {
  const deleteCtx = { newTree: ctx.tree, cells: ctx.cells, deletes: [] };
  StateTree.doPostOrder(ctx.oldTree, ctx.oldTree.root, deleteCtx, checkDeleteVisitor);
  return deleteCtx.deletes;
}
function syncNewStatesVisitor(n, tree, ctx) {
  const cell = ctx.cells.get(n.ref);
  if (!cell || !Transform.syncState(cell.state, n.state))
    return;
  ctx.parent.events.cell.stateUpdated.next({ state: ctx.parent, ref: n.ref, cell });
}
function syncNewStates(ctx) {
  StateTree.doPreOrder(ctx.tree, ctx.tree.root, ctx, syncNewStatesVisitor);
}
function setCellStatus(ctx, ref, status, errorText) {
  const cell = ctx.cells.get(ref);
  const changed = cell.status !== status;
  cell.status = status;
  cell.errorText = errorText;
  if (changed)
    ctx.parent.events.cell.stateUpdated.next({ state: ctx.parent, ref, cell });
}
function initCellStatusVisitor(t2, _, ctx) {
  ctx.cells.get(t2.ref).transform = t2;
  setCellStatus(ctx, t2.ref, "pending");
}
function initCellStatus(ctx, roots) {
  for (const root of roots) {
    StateTree.doPreOrder(ctx.tree, ctx.tree.transforms.get(root), ctx, initCellStatusVisitor);
  }
}
function unlinkCell(cell) {
  for (const other of cell.dependencies.dependsOn) {
    arraySetRemove(other.dependencies.dependentBy, cell);
  }
}
function addCellsVisitor(transform, _, { ctx, added, visited }) {
  visited.add(transform.ref);
  if (ctx.cells.has(transform.ref)) {
    return;
  }
  const cell = {
    parent: ctx.parent,
    transform,
    sourceRef: void 0,
    status: "pending",
    state: { ...transform.state },
    errorText: void 0,
    params: void 0,
    paramsNormalizedVersion: "",
    dependencies: { dependentBy: [], dependsOn: [] },
    cache: void 0
  };
  ctx.cells.set(transform.ref, cell);
  added.push(cell);
}
function linkCells(target, ctx) {
  if (!target.transform.dependsOn)
    return;
  for (const ref of target.transform.dependsOn) {
    const t2 = ctx.tree.transforms.get(ref);
    if (!t2) {
      throw new Error(`Cannot depend on a non-existent transform.`);
    }
    const cell = ctx.cells.get(ref);
    arraySetAdd(target.dependencies.dependsOn, cell);
    arraySetAdd(cell.dependencies.dependentBy, target);
  }
}
function initCells(ctx, roots) {
  const initCtx = { ctx, visited: /* @__PURE__ */ new Set(), added: [] };
  for (const root of roots) {
    StateTree.doPreOrder(ctx.tree, ctx.tree.transforms.get(root), initCtx, addCellsVisitor);
  }
  for (const cell of initCtx.added) {
    linkCells(cell, ctx);
  }
  let dependent;
  initCtx.visited.forEach((ref) => {
    const cell = ctx.cells.get(ref);
    for (const by of cell.dependencies.dependentBy) {
      if (initCtx.visited.has(by.transform.ref))
        continue;
      if (!dependent)
        dependent = UniqueArray.create();
      UniqueArray.add(dependent, by.transform.ref, by);
    }
  });
  return { added: initCtx.added, dependent: dependent ? dependent.array : void 0 };
}
function findNewCurrent(tree, start, deletes, cells) {
  const deleteSet = new Set(deletes);
  return _findNewCurrent(tree, start, deleteSet, cells);
}
function _findNewCurrent(tree, ref, deletes, cells) {
  if (ref === Transform.RootRef)
    return ref;
  const node = tree.transforms.get(ref);
  const siblings = tree.children.get(node.parent).values();
  let prevCandidate = void 0, seenRef = false;
  while (true) {
    const s = siblings.next();
    if (s.done)
      break;
    if (deletes.has(s.value))
      continue;
    const cell = cells.get(s.value);
    if (!cell || cell.status === "error" || cell.obj === StateObject.Null) {
      continue;
    }
    const t2 = tree.transforms.get(s.value);
    if (t2.state.isGhost)
      continue;
    if (s.value === ref) {
      seenRef = true;
      if (!deletes.has(ref))
        prevCandidate = ref;
      continue;
    }
    if (seenRef)
      return t2.ref;
    prevCandidate = t2.ref;
  }
  if (prevCandidate)
    return prevCandidate;
  return _findNewCurrent(tree, node.parent, deletes, cells);
}
function doError(ctx, ref, errorObject, silent) {
  if (!silent) {
    ctx.hadError = true;
    ctx.parent.errorFree = false;
  }
  const cell = ctx.cells.get(ref);
  if (errorObject) {
    ctx.wasAborted = ctx.wasAborted || Task.isAbort(errorObject);
    const message = "" + errorObject;
    setCellStatus(ctx, ref, "error", message);
    if (!silent)
      ctx.parent.events.log.next({ type: "error", timestamp: /* @__PURE__ */ new Date(), message });
  } else {
    cell.params = void 0;
  }
  if (cell.obj) {
    const obj = cell.obj;
    cell.obj = void 0;
    cell.cache = void 0;
    ctx.parent.events.object.removed.next({ state: ctx.parent, ref, obj });
  }
  const children = ctx.tree.children.get(ref).values();
  while (true) {
    const next = children.next();
    if (next.done)
      return;
    doError(ctx, next.value, void 0, silent);
  }
}
var ParentNullErrorText = "Parent is null";
async function updateSubtree(ctx, root) {
  setCellStatus(ctx, root, "processing");
  let isNull = false;
  try {
    const start = now();
    const update10 = await updateNode2(ctx, root);
    const time = now() - start;
    if (update10.action !== "none")
      ctx.changed = true;
    setCellStatus(ctx, root, "ok");
    ctx.results.push(update10);
    if (update10.action === "created") {
      isNull = update10.obj === StateObject.Null;
      if (!isNull && !ctx.options.doNotLogTiming)
        ctx.parent.events.log.next(LogEntry.info(`Created ${update10.obj.label} in ${formatTimespan(time)}.`));
    } else if (update10.action === "updated") {
      isNull = update10.obj === StateObject.Null;
      if (!isNull && !ctx.options.doNotLogTiming)
        ctx.parent.events.log.next(LogEntry.info(`Updated ${update10.obj.label} in ${formatTimespan(time)}.`));
    } else if (update10.action === "replaced") {
      isNull = update10.obj === StateObject.Null;
      if (!isNull && !ctx.options.doNotLogTiming)
        ctx.parent.events.log.next(LogEntry.info(`Updated ${update10.obj.label} in ${formatTimespan(time)}.`));
    }
  } catch (e) {
    ctx.changed = true;
    if (!ctx.hadError)
      ctx.newCurrent = root;
    doError(ctx, root, e, false);
    console.error(e);
    return;
  }
  const children = ctx.tree.children.get(root).values();
  while (true) {
    const next = children.next();
    if (next.done)
      return;
    if (isNull)
      doError(ctx, next.value, void 0, true);
    else
      await updateSubtree(ctx, next.value);
  }
}
function resolveParams(ctx, transform, src, cell) {
  const prms = transform.transformer.definition.params;
  const definition = prms ? prms(src, ctx.parent.globalContext) : {};
  if (cell.paramsNormalizedVersion !== transform.version) {
    transform.params = ParamDefinition.normalizeParams(definition, transform.params, "all");
    cell.paramsNormalizedVersion = transform.version;
  } else {
    const defaultValues = ParamDefinition.getDefaultValues(definition);
    transform.params = transform.params ? assignIfUndefined(transform.params, defaultValues) : defaultValues;
  }
  ParamDefinition.resolveRefs(definition, transform.params, ctx.getCellData);
  return { definition, values: transform.params };
}
async function updateNode2(ctx, currentRef) {
  var _a;
  const { oldTree, tree } = ctx;
  const current3 = ctx.cells.get(currentRef);
  const transform = current3.transform;
  if (current3.transform.ref === Transform.RootRef) {
    return { action: "none" };
  }
  const treeParent = ctx.cells.get(current3.transform.parent);
  const isParentNull = (treeParent === null || treeParent === void 0 ? void 0 : treeParent.obj) === StateObject.Null;
  if (isParentNull) {
    current3.sourceRef = treeParent.transform.ref;
    if (oldTree.transforms.has(currentRef) && current3.params) {
      const oldParams = current3.params.values;
      const oldCache = current3.cache;
      dispose(transform, current3.obj, oldParams, oldCache, ctx.parent.globalContext);
      current3.params = void 0;
      current3.obj = StateObject.Null;
      return { ref: currentRef, action: "updated", obj: current3.obj };
    } else {
      current3.params = void 0;
      return { ref: currentRef, action: "created", obj: StateObject.Null };
    }
  }
  const parentCell = transform.transformer.definition.from.length === 0 ? treeParent : StateSelection.findAncestorOfType(tree, ctx.cells, currentRef, transform.transformer.definition.from);
  if (!parentCell) {
    throw new Error(`No suitable parent found for '${currentRef}'`);
  }
  ctx.spine.current = current3;
  const parent = parentCell.obj;
  current3.sourceRef = parentCell.transform.ref;
  const params = resolveParams(ctx, transform, parent, current3);
  if (!oldTree.transforms.has(currentRef) || !current3.params) {
    current3.params = params;
    const obj = await createObject2(ctx, current3, transform.transformer, parent, params.values);
    updateTag(obj, transform);
    current3.obj = obj;
    return { ref: currentRef, action: "created", obj };
  } else {
    const oldParams = current3.params.values;
    const oldCache = current3.cache;
    const oldData = (_a = current3.obj) === null || _a === void 0 ? void 0 : _a.data;
    const newParams = params.values;
    current3.params = params;
    const updateKind = !!current3.obj && current3.obj !== StateObject.Null ? await updateObject(ctx, current3, transform.transformer, parent, current3.obj, oldParams, newParams) : Transformer.UpdateResult.Recreate;
    switch (updateKind) {
      case Transformer.UpdateResult.Recreate: {
        const oldObj = current3.obj;
        dispose(transform, oldObj, oldParams, oldCache, ctx.parent.globalContext);
        const newObj = await createObject2(ctx, current3, transform.transformer, parent, newParams);
        updateTag(newObj, transform);
        current3.obj = newObj;
        return { ref: currentRef, action: "replaced", oldObj, obj: newObj };
      }
      case Transformer.UpdateResult.Updated:
        updateTag(current3.obj, transform);
        return { ref: currentRef, action: "updated", oldData, obj: current3.obj };
      case Transformer.UpdateResult.Null: {
        dispose(transform, current3.obj, oldParams, oldCache, ctx.parent.globalContext);
        current3.obj = StateObject.Null;
        return { ref: currentRef, action: "updated", obj: current3.obj };
      }
      default:
        return { action: "none" };
    }
  }
}
function dispose(transform, b5, params, cache, globalContext) {
  var _a, _b;
  (_b = (_a = transform.transformer.definition).dispose) === null || _b === void 0 ? void 0 : _b.call(_a, {
    b: b5 !== StateObject.Null ? b5 : void 0,
    params,
    cache
  }, globalContext);
}
function updateTag(obj, transform) {
  if (!obj || obj === StateObject.Null)
    return;
  obj.tags = transform.tags;
}
function runTask(t2, ctx) {
  if (typeof t2.runInContext === "function")
    return t2.runInContext(ctx);
  return t2;
}
function resolveDependencies(cell) {
  if (cell.dependencies.dependsOn.length === 0)
    return void 0;
  const deps = /* @__PURE__ */ Object.create(null);
  for (const dep of cell.dependencies.dependsOn) {
    if (!dep.obj) {
      throw new Error("Unresolved dependency.");
    }
    deps[dep.transform.ref] = dep.obj;
  }
  return deps;
}
function createObject2(ctx, cell, transformer, a5, params) {
  if (!cell.cache)
    cell.cache = /* @__PURE__ */ Object.create(null);
  return runTask(transformer.definition.apply({ a: a5, params, cache: cell.cache, spine: ctx.spine, dependencies: resolveDependencies(cell) }, ctx.parent.globalContext), ctx.taskCtx);
}
async function updateObject(ctx, cell, transformer, a5, b5, oldParams, newParams) {
  if (!transformer.definition.update) {
    return Transformer.UpdateResult.Recreate;
  }
  if (!cell.cache)
    cell.cache = /* @__PURE__ */ Object.create(null);
  return runTask(transformer.definition.update({ a: a5, oldParams, b: b5, newParams, cache: cell.cache, spine: ctx.spine, dependencies: resolveDependencies(cell) }, ctx.parent.globalContext), ctx.taskCtx);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/objects.js
var PluginStateObject;
(function(PluginStateObject2) {
  PluginStateObject2.Create = StateObject.factory();
  function isRepresentation3D(o) {
    return !!o && o.type.typeClass === "Representation3D";
  }
  PluginStateObject2.isRepresentation3D = isRepresentation3D;
  function isBehavior(o) {
    return !!o && o.type.typeClass === "Behavior";
  }
  PluginStateObject2.isBehavior = isBehavior;
  function CreateRepresentation3D(type) {
    return PluginStateObject2.Create({ ...type, typeClass: "Representation3D" });
  }
  PluginStateObject2.CreateRepresentation3D = CreateRepresentation3D;
  function CreateBehavior(type) {
    return PluginStateObject2.Create({ ...type, typeClass: "Behavior" });
  }
  PluginStateObject2.CreateBehavior = CreateBehavior;
  class Root extends PluginStateObject2.Create({ name: "Root", typeClass: "Root" }) {
  }
  PluginStateObject2.Root = Root;
  class Group extends PluginStateObject2.Create({ name: "Group", typeClass: "Group" }) {
  }
  PluginStateObject2.Group = Group;
  let Data;
  (function(Data2) {
    class String2 extends PluginStateObject2.Create({ name: "String Data", typeClass: "Data" }) {
    }
    Data2.String = String2;
    class Binary extends PluginStateObject2.Create({ name: "Binary Data", typeClass: "Data" }) {
    }
    Data2.Binary = Binary;
    class Blob2 extends PluginStateObject2.Create({ name: "Data Blob", typeClass: "Data" }) {
    }
    Data2.Blob = Blob2;
  })(Data = PluginStateObject2.Data || (PluginStateObject2.Data = {}));
  let Format;
  (function(Format2) {
    class Json extends PluginStateObject2.Create({ name: "JSON Data", typeClass: "Data" }) {
    }
    Format2.Json = Json;
    class Cif extends PluginStateObject2.Create({ name: "CIF File", typeClass: "Data" }) {
    }
    Format2.Cif = Cif;
    class Cube extends PluginStateObject2.Create({ name: "Cube File", typeClass: "Data" }) {
    }
    Format2.Cube = Cube;
    class Psf extends PluginStateObject2.Create({ name: "PSF File", typeClass: "Data" }) {
    }
    Format2.Psf = Psf;
    class Prmtop extends PluginStateObject2.Create({ name: "PRMTOP File", typeClass: "Data" }) {
    }
    Format2.Prmtop = Prmtop;
    class Top extends PluginStateObject2.Create({ name: "TOP File", typeClass: "Data" }) {
    }
    Format2.Top = Top;
    class Ply extends PluginStateObject2.Create({ name: "PLY File", typeClass: "Data" }) {
    }
    Format2.Ply = Ply;
    class Ccp4 extends PluginStateObject2.Create({ name: "CCP4/MRC/MAP File", typeClass: "Data" }) {
    }
    Format2.Ccp4 = Ccp4;
    class Dsn6 extends PluginStateObject2.Create({ name: "DSN6/BRIX File", typeClass: "Data" }) {
    }
    Format2.Dsn6 = Dsn6;
    class Dx extends PluginStateObject2.Create({ name: "DX File", typeClass: "Data" }) {
    }
    Format2.Dx = Dx;
    class Blob2 extends PluginStateObject2.Create({ name: "Format Blob", typeClass: "Data" }) {
    }
    Format2.Blob = Blob2;
  })(Format = PluginStateObject2.Format || (PluginStateObject2.Format = {}));
  let Molecule;
  (function(Molecule2) {
    class Coordinates2 extends PluginStateObject2.Create({ name: "Coordinates", typeClass: "Object" }) {
    }
    Molecule2.Coordinates = Coordinates2;
    class Topology2 extends PluginStateObject2.Create({ name: "Topology", typeClass: "Object" }) {
    }
    Molecule2.Topology = Topology2;
    class Model2 extends PluginStateObject2.Create({ name: "Model", typeClass: "Object" }) {
    }
    Molecule2.Model = Model2;
    class Trajectory extends PluginStateObject2.Create({ name: "Trajectory", typeClass: "Object" }) {
    }
    Molecule2.Trajectory = Trajectory;
    class Structure2 extends PluginStateObject2.Create({ name: "Structure", typeClass: "Object" }) {
    }
    Molecule2.Structure = Structure2;
    (function(Structure3) {
      class Representation3D extends CreateRepresentation3D({ name: "Structure 3D" }) {
      }
      Structure3.Representation3D = Representation3D;
      class Representation3DState extends PluginStateObject2.Create({ name: "Structure 3D State", typeClass: "Object" }) {
      }
      Structure3.Representation3DState = Representation3DState;
      class Selections extends PluginStateObject2.Create({ name: "Selections", typeClass: "Object" }) {
      }
      Structure3.Selections = Selections;
    })(Structure2 = Molecule2.Structure || (Molecule2.Structure = {}));
  })(Molecule = PluginStateObject2.Molecule || (PluginStateObject2.Molecule = {}));
  let Volume2;
  (function(Volume3) {
    class Data2 extends PluginStateObject2.Create({ name: "Volume", typeClass: "Object" }) {
    }
    Volume3.Data = Data2;
    class Lazy extends PluginStateObject2.Create({ name: "Lazy Volume", typeClass: "Object" }) {
    }
    Volume3.Lazy = Lazy;
    class Representation3D extends CreateRepresentation3D({ name: "Volume 3D" }) {
    }
    Volume3.Representation3D = Representation3D;
  })(Volume2 = PluginStateObject2.Volume || (PluginStateObject2.Volume = {}));
  let Shape2;
  (function(Shape3) {
    class Provider extends PluginStateObject2.Create({ name: "Shape Provider", typeClass: "Object" }) {
    }
    Shape3.Provider = Provider;
    class Representation3D extends CreateRepresentation3D({ name: "Shape 3D" }) {
    }
    Shape3.Representation3D = Representation3D;
  })(Shape2 = PluginStateObject2.Shape || (PluginStateObject2.Shape = {}));
})(PluginStateObject || (PluginStateObject = {}));
var PluginStateTransform;
(function(PluginStateTransform2) {
  PluginStateTransform2.CreateBuiltIn = Transformer.factory("ms-plugin");
  PluginStateTransform2.BuiltIn = Transformer.builderFactory("ms-plugin");
})(PluginStateTransform || (PluginStateTransform = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms/data.js
var data_exports = {};
__export(data_exports, {
  DeflateData: () => DeflateData,
  Download: () => Download,
  DownloadBlob: () => DownloadBlob,
  ImportJson: () => ImportJson,
  ImportString: () => ImportString,
  LazyVolume: () => LazyVolume,
  ParseBlob: () => ParseBlob,
  ParseCcp4: () => ParseCcp4,
  ParseCif: () => ParseCif,
  ParseCube: () => ParseCube,
  ParseDsn6: () => ParseDsn6,
  ParseDx: () => ParseDx,
  ParseJson: () => ParseJson,
  ParsePly: () => ParsePly,
  ParsePrmtop: () => ParsePrmtop,
  ParsePsf: () => ParsePsf,
  ParseTop: () => ParseTop,
  RawData: () => RawData,
  ReadFile: () => ReadFile
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/simple-buffer.js
var SimpleBuffer;
(function(SimpleBuffer2) {
  function fromUint8Array(array) {
    const dv = new DataView(array.buffer);
    return Object.assign(array.subarray(0), {
      readInt8: (offset) => dv.getInt8(offset),
      readUInt8: (offset) => dv.getUint8(offset),
      writeInt8: (value, offset) => dv.setInt8(offset, value),
      writeUInt8: (value, offset) => dv.setUint8(offset, value),
      readInt16LE: (offset) => dv.getInt16(offset, true),
      readInt32LE: (offset) => dv.getInt32(offset, true),
      readUInt16LE: (offset) => dv.getUint16(offset, true),
      readUInt32LE: (offset) => dv.getUint32(offset, true),
      readFloatLE: (offset) => dv.getFloat32(offset, true),
      readDoubleLE: (offset) => dv.getFloat64(offset, true),
      writeInt16LE: (value, offset) => dv.setInt16(offset, value, true),
      writeInt32LE: (value, offset) => dv.setInt32(offset, value, true),
      writeUInt16LE: (value, offset) => dv.setUint16(offset, value, true),
      writeUInt32LE: (value, offset) => dv.setUint32(offset, value, true),
      writeFloatLE: (value, offset) => dv.setFloat32(offset, value, true),
      writeDoubleLE: (value, offset) => dv.setFloat64(offset, value, true),
      readInt16BE: (offset) => dv.getInt16(offset, false),
      readInt32BE: (offset) => dv.getInt32(offset, false),
      readUInt16BE: (offset) => dv.getUint16(offset, false),
      readUInt32BE: (offset) => dv.getUint32(offset, false),
      readFloatBE: (offset) => dv.getFloat32(offset, false),
      readDoubleBE: (offset) => dv.getFloat64(offset, false),
      writeInt16BE: (value, offset) => dv.setInt16(offset, value, false),
      writeInt32BE: (value, offset) => dv.setInt32(offset, value, false),
      writeUInt16BE: (value, offset) => dv.setUint16(offset, value, false),
      writeUInt32BE: (value, offset) => dv.setUint32(offset, value, false),
      writeFloatBE: (value, offset) => dv.setFloat32(offset, value, false),
      writeDoubleBE: (value, offset) => dv.setFloat64(offset, value, false),
      copy: (targetBuffer, targetStart, sourceStart, sourceEnd) => {
        targetStart = defaults(targetStart, 0);
        sourceStart = defaults(sourceStart, 0);
        sourceEnd = defaults(sourceEnd, array.length);
        targetBuffer.set(array.subarray(sourceStart, sourceEnd), targetStart);
        return sourceEnd - sourceStart;
      }
    });
  }
  SimpleBuffer2.fromUint8Array = fromUint8Array;
  function fromArrayBuffer(arrayBuffer) {
    return fromUint8Array(new Uint8Array(arrayBuffer));
  }
  SimpleBuffer2.fromArrayBuffer = fromArrayBuffer;
  function fromBuffer(buffer2) {
    return buffer2;
  }
  SimpleBuffer2.fromBuffer = fromBuffer;
  SimpleBuffer2.IsNativeEndianLittle = new Uint16Array(new Uint8Array([18, 52]).buffer)[0] === 13330;
  function flipByteOrder(source, target, byteCount, elementByteSize, offset) {
    for (let i = 0, n = byteCount; i < n; i += elementByteSize) {
      for (let j = 0; j < elementByteSize; j++) {
        target[offset + i + elementByteSize - j - 1] = source[offset + i + j];
      }
    }
  }
  SimpleBuffer2.flipByteOrder = flipByteOrder;
  function flipByteOrderInPlace2(buffer2, byteOffset = 0, length) {
    const intView = new Int16Array(buffer2, byteOffset, length);
    for (let i = 0, n = intView.length; i < n; ++i) {
      const val = intView[i];
      intView[i] = (val & 255) << 8 | val >> 8 & 255;
    }
  }
  SimpleBuffer2.flipByteOrderInPlace2 = flipByteOrderInPlace2;
  function ensureLittleEndian(source, target, byteCount, elementByteSize, offset) {
    if (SimpleBuffer2.IsNativeEndianLittle)
      return;
    if (!byteCount || elementByteSize <= 1)
      return;
    flipByteOrder(source, target, byteCount, elementByteSize, offset);
  }
  SimpleBuffer2.ensureLittleEndian = ensureLittleEndian;
})(SimpleBuffer || (SimpleBuffer = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/file-handle.js
var FileHandle;
(function(FileHandle2) {
  function fromBuffer(buffer2, name) {
    return {
      name,
      readBuffer: (position, sizeOrBuffer, size, byteOffset) => {
        let bytesRead;
        let outBuffer;
        if (typeof sizeOrBuffer === "number") {
          size = defaults(size, sizeOrBuffer);
          const start = position;
          const end = Math.min(buffer2.length, start + size);
          bytesRead = end - start;
          outBuffer = SimpleBuffer.fromUint8Array(new Uint8Array(buffer2.buffer, start, end - start));
        } else {
          size = defaults(size, sizeOrBuffer.length);
          const start = position;
          const end = Math.min(buffer2.length, start + size);
          sizeOrBuffer.set(buffer2.subarray(start, end), byteOffset);
          bytesRead = end - start;
          outBuffer = sizeOrBuffer;
        }
        if (size !== bytesRead) {
          console.warn(`byteCount ${size} and bytesRead ${bytesRead} differ`);
        }
        return Promise.resolve({ bytesRead, buffer: outBuffer });
      },
      writeBuffer: (position, buffer3, length) => {
        length = defaults(length, buffer3.length);
        console.error(".writeBuffer not implemented for FileHandle.fromBuffer");
        return Promise.resolve(0);
      },
      writeBufferSync: (position, buffer3, length) => {
        length = defaults(length, buffer3.length);
        console.error(".writeSync not implemented for FileHandle.fromBuffer");
        return 0;
      },
      close: noop
    };
  }
  FileHandle2.fromBuffer = fromBuffer;
})(FileHandle || (FileHandle = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/typed-array.js
var TypedArrayValueType;
(function(TypedArrayValueType2) {
  TypedArrayValueType2.Float32 = "float32";
  TypedArrayValueType2.Int8 = "int8";
  TypedArrayValueType2.Int16 = "int16";
  TypedArrayValueType2.Uint16 = "uint16";
})(TypedArrayValueType || (TypedArrayValueType = {}));
function getElementByteSize(type) {
  if (type === TypedArrayValueType.Float32)
    return 4;
  if (type === TypedArrayValueType.Int16)
    return 2;
  if (type === TypedArrayValueType.Uint16)
    return 2;
  return 1;
}
function makeTypedArray(type, buffer2, byteOffset = 0, length) {
  if (type === TypedArrayValueType.Float32)
    return new Float32Array(buffer2, byteOffset, length);
  if (type === TypedArrayValueType.Int16)
    return new Int16Array(buffer2, byteOffset, length);
  if (type === TypedArrayValueType.Uint16)
    return new Uint16Array(buffer2, byteOffset, length);
  return new Int8Array(buffer2, byteOffset, length);
}
function createTypedArrayBufferContext(size, type) {
  const elementByteSize = getElementByteSize(type);
  const arrayBuffer = new ArrayBuffer(elementByteSize * size);
  const readBuffer = SimpleBuffer.fromArrayBuffer(arrayBuffer);
  const valuesBuffer = SimpleBuffer.IsNativeEndianLittle ? arrayBuffer : new ArrayBuffer(elementByteSize * size);
  return {
    type,
    elementByteSize,
    readBuffer,
    valuesBuffer: new Uint8Array(valuesBuffer),
    values: makeTypedArray(type, valuesBuffer)
  };
}
async function readTypedArray(ctx, file, position, byteCount, valueByteOffset, littleEndian) {
  await file.readBuffer(position, ctx.readBuffer, byteCount, valueByteOffset);
  if (ctx.elementByteSize > 1 && (littleEndian !== void 0 && littleEndian !== SimpleBuffer.IsNativeEndianLittle || !SimpleBuffer.IsNativeEndianLittle)) {
    SimpleBuffer.flipByteOrder(ctx.readBuffer, ctx.valuesBuffer, byteCount, ctx.elementByteSize, valueByteOffset);
  }
  return ctx.values;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/ccp4/parser.js
async function readCcp4Header(file) {
  const headerSize = 1024;
  const { buffer: buffer2 } = await file.readBuffer(0, headerSize);
  const MAP = String.fromCharCode(buffer2.readUInt8(52 * 4), buffer2.readUInt8(52 * 4 + 1), buffer2.readUInt8(52 * 4 + 2), buffer2.readUInt8(52 * 4 + 3));
  if (MAP !== "MAP ") {
    throw new Error('ccp4 format error, missing "MAP " string');
  }
  const MACHST = [buffer2.readUInt8(53 * 4), buffer2.readUInt8(53 * 4 + 1)];
  let littleEndian = false;
  if (MACHST[0] === 68 && MACHST[1] === 65) {
    littleEndian = true;
  } else if (MACHST[0] === 17 && MACHST[1] === 17) {
    littleEndian = false;
  } else {
    const modeLE = buffer2.readInt32LE(3 * 4);
    if (modeLE <= 16)
      littleEndian = true;
  }
  const readInt = littleEndian ? (o) => buffer2.readInt32LE(o * 4) : (o) => buffer2.readInt32BE(o * 4);
  const readFloat = littleEndian ? (o) => buffer2.readFloatLE(o * 4) : (o) => buffer2.readFloatBE(o * 4);
  const header2 = {
    NC: readInt(0),
    NR: readInt(1),
    NS: readInt(2),
    MODE: readInt(3),
    NCSTART: readInt(4),
    NRSTART: readInt(5),
    NSSTART: readInt(6),
    NX: readInt(7),
    NY: readInt(8),
    NZ: readInt(9),
    xLength: readFloat(10),
    yLength: readFloat(11),
    zLength: readFloat(12),
    alpha: readFloat(13),
    beta: readFloat(14),
    gamma: readFloat(15),
    MAPC: readInt(16),
    MAPR: readInt(17),
    MAPS: readInt(18),
    AMIN: readFloat(19),
    AMAX: readFloat(20),
    AMEAN: readFloat(21),
    ISPG: readInt(22),
    NSYMBT: readInt(23),
    LSKFLG: readInt(24),
    SKWMAT: [],
    // TODO bytes 26-34
    SKWTRN: [],
    // TODO bytes 35-37
    userFlag1: readInt(39),
    userFlag2: readInt(40),
    // bytes 50-52 origin in X,Y,Z used for transforms
    originX: readFloat(49),
    originY: readFloat(50),
    originZ: readFloat(51),
    MAP,
    // bytes 53 MAP
    MACHST,
    // bytes 54 MACHST
    ARMS: readFloat(54)
    // TODO bytes 56 NLABL
    // TODO bytes 57-256 LABEL
  };
  return { header: header2, littleEndian };
}
async function readCcp4Slices(header2, buffer2, file, byteOffset, length, littleEndian) {
  if (isMapmode2to0(header2)) {
    const valueByteOffset = 3 * length;
    await file.readBuffer(byteOffset, buffer2.readBuffer, length, valueByteOffset);
    const int8 = new Int8Array(buffer2.valuesBuffer.buffer, valueByteOffset);
    const b1 = (header2.AMAX - header2.AMIN) / 255;
    const b0 = 0.5 * (header2.AMIN + header2.AMAX + b1);
    for (let j = 0, jl = length; j < jl; ++j) {
      buffer2.values[j] = b1 * int8[j] + b0;
    }
  } else {
    await readTypedArray(buffer2, file, byteOffset, length, 0, littleEndian);
  }
}
function getCcp4DataType(mode) {
  switch (mode) {
    case 0:
      return TypedArrayValueType.Int8;
    case 1:
      return TypedArrayValueType.Int16;
    case 2:
      return TypedArrayValueType.Float32;
    case 3:
      throw new Error("mode 3 unsupported, complex 16-bit integers");
    case 4:
      throw new Error("mode 4 unsupported, complex 32-bit reals");
    case 6:
      TypedArrayValueType.Uint16;
    case 16:
      throw new Error("mode 16 unsupported, unsigned char * 3 (for rgb data, non-standard)");
  }
  throw new Error(`unknown mode '${mode}'`);
}
function isMapmode2to0(header2) {
  return header2.userFlag1 === -128 && header2.userFlag2 === 127;
}
function getCcp4ValueType(header2) {
  return isMapmode2to0(header2) ? TypedArrayValueType.Float32 : getCcp4DataType(header2.MODE);
}
function getCcp4DataOffset(header2) {
  return 256 * 4 + header2.NSYMBT;
}
async function parseInternal(file, size, ctx) {
  await ctx.update({ message: "Parsing CCP4/MRC/MAP file..." });
  const { header: header2, littleEndian } = await readCcp4Header(file);
  const offset = getCcp4DataOffset(header2);
  const dataType = getCcp4DataType(header2.MODE);
  const valueType = getCcp4ValueType(header2);
  const count3 = header2.NC * header2.NR * header2.NS;
  const elementByteSize = getElementByteSize(dataType);
  const byteCount = count3 * elementByteSize;
  const buffer2 = createTypedArrayBufferContext(count3, valueType);
  readCcp4Slices(header2, buffer2, file, offset, byteCount, littleEndian);
  const result = { header: header2, values: buffer2.values, name: file.name };
  return result;
}
function parseFile(file, size) {
  return Task.create("Parse CCP4/MRC/MAP", async (ctx) => {
    try {
      return ReaderResult.success(await parseInternal(file, size, ctx));
    } catch (e) {
      return ReaderResult.error(e);
    }
  });
}
function parse(buffer2, name) {
  return parseFile(FileHandle.fromBuffer(SimpleBuffer.fromUint8Array(buffer2), name), buffer2.length);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/dsn6/parser.js
var dsn6HeaderSize = 512;
function parseBrixHeader(str3) {
  return {
    xStart: parseInt(str3.substr(10, 5)),
    yStart: parseInt(str3.substr(15, 5)),
    zStart: parseInt(str3.substr(20, 5)),
    xExtent: parseInt(str3.substr(32, 5)),
    yExtent: parseInt(str3.substr(38, 5)),
    zExtent: parseInt(str3.substr(42, 5)),
    xRate: parseInt(str3.substr(52, 5)),
    yRate: parseInt(str3.substr(58, 5)),
    zRate: parseInt(str3.substr(62, 5)),
    xlen: parseFloat(str3.substr(73, 10)),
    ylen: parseFloat(str3.substr(83, 10)),
    zlen: parseFloat(str3.substr(93, 10)),
    alpha: parseFloat(str3.substr(103, 10)),
    beta: parseFloat(str3.substr(113, 10)),
    gamma: parseFloat(str3.substr(123, 10)),
    divisor: parseFloat(str3.substr(138, 12)),
    summand: parseInt(str3.substr(155, 8)),
    sigma: parseFloat(str3.substr(170, 12))
  };
}
function parseDsn6Header(buffer2, littleEndian) {
  const readInt = littleEndian ? (o) => buffer2.readInt16LE(o * 2) : (o) => buffer2.readInt16BE(o * 2);
  const factor = 1 / readInt(17);
  return {
    xStart: readInt(0),
    yStart: readInt(1),
    zStart: readInt(2),
    xExtent: readInt(3),
    yExtent: readInt(4),
    zExtent: readInt(5),
    xRate: readInt(6),
    yRate: readInt(7),
    zRate: readInt(8),
    xlen: readInt(9) * factor,
    ylen: readInt(10) * factor,
    zlen: readInt(11) * factor,
    alpha: readInt(12) * factor,
    beta: readInt(13) * factor,
    gamma: readInt(14) * factor,
    divisor: readInt(15) / 100,
    summand: readInt(16),
    sigma: void 0
  };
}
function getBlocks(header2) {
  const { xExtent, yExtent, zExtent } = header2;
  const xBlocks = Math.ceil(xExtent / 8);
  const yBlocks = Math.ceil(yExtent / 8);
  const zBlocks = Math.ceil(zExtent / 8);
  return { xBlocks, yBlocks, zBlocks };
}
async function readDsn6Header(file) {
  const { buffer: buffer2 } = await file.readBuffer(0, dsn6HeaderSize);
  const brixStr = String.fromCharCode.apply(null, buffer2);
  const isBrix = brixStr.startsWith(":-)");
  const littleEndian = isBrix || buffer2.readInt16LE(18 * 2) === 100;
  const header2 = isBrix ? parseBrixHeader(brixStr) : parseDsn6Header(buffer2, littleEndian);
  return { header: header2, littleEndian };
}
async function parseDsn6Values(header2, source, target, littleEndian) {
  if (!littleEndian) {
    SimpleBuffer.flipByteOrderInPlace2(source.buffer);
  }
  const { divisor, summand, xExtent, yExtent, zExtent } = header2;
  const { xBlocks, yBlocks, zBlocks } = getBlocks(header2);
  let offset = 0;
  for (let zz = 0; zz < zBlocks; ++zz) {
    for (let yy = 0; yy < yBlocks; ++yy) {
      for (let xx = 0; xx < xBlocks; ++xx) {
        for (let k = 0; k < 8; ++k) {
          const z = 8 * zz + k;
          for (let j = 0; j < 8; ++j) {
            const y = 8 * yy + j;
            for (let i = 0; i < 8; ++i) {
              const x = 8 * xx + i;
              if (x < xExtent && y < yExtent && z < zExtent) {
                const idx = (x * yExtent + y) * zExtent + z;
                target[idx] = (source[offset] - summand) / divisor;
                ++offset;
              } else {
                offset += 8 - i;
                break;
              }
            }
          }
        }
      }
    }
  }
}
function getDsn6Counts(header2) {
  const { xExtent, yExtent, zExtent } = header2;
  const { xBlocks, yBlocks, zBlocks } = getBlocks(header2);
  const valueCount = xExtent * yExtent * zExtent;
  const count3 = xBlocks * 8 * yBlocks * 8 * zBlocks * 8;
  const elementByteSize = 1;
  const byteCount = count3 * elementByteSize;
  return { count: count3, byteCount, valueCount };
}
async function parseInternal2(file, size, ctx) {
  await ctx.update({ message: "Parsing DSN6/BRIX file..." });
  const { header: header2, littleEndian } = await readDsn6Header(file);
  const { buffer: buffer2 } = await file.readBuffer(dsn6HeaderSize, size - dsn6HeaderSize);
  const { valueCount } = getDsn6Counts(header2);
  const values2 = new Float32Array(valueCount);
  await parseDsn6Values(header2, buffer2, values2, littleEndian);
  const result = { header: header2, values: values2, name: file.name };
  return result;
}
function parseFile2(file, size) {
  return Task.create("Parse DSN6/BRIX", async (ctx) => {
    try {
      return ReaderResult.success(await parseInternal2(file, size, ctx));
    } catch (e) {
      return ReaderResult.error(e);
    }
  });
}
function parse2(buffer2, name) {
  return parseFile2(FileHandle.fromBuffer(SimpleBuffer.fromUint8Array(buffer2), name), buffer2.length);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/ply/schema.js
var PlyTypeByteLength = {
  "char": 1,
  "uchar": 1,
  "short": 2,
  "ushort": 2,
  "int": 4,
  "uint": 4,
  "float": 4,
  "double": 8,
  "int8": 1,
  "uint8": 1,
  "int16": 2,
  "uint16": 2,
  "int32": 4,
  "uint32": 4,
  "float32": 4,
  "float64": 8
};
var PlyTypes = new Set(Object.keys(PlyTypeByteLength));
function PlyType(str3) {
  if (!PlyTypes.has(str3))
    throw new Error(`unknown ply type '${str3}'`);
  return str3;
}
function PlyFile(elements, elementNames, comments) {
  const elementMap = /* @__PURE__ */ new Map();
  for (let i = 0, il = elementNames.length; i < il; ++i) {
    elementMap.set(elementNames[i], elements[i]);
  }
  return {
    comments,
    elementNames,
    getElement: (name) => {
      return elementMap.get(name);
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/ply/parser.js
function State2(data, runtimeCtx) {
  const tokenizer = Tokenizer(data);
  return {
    data,
    tokenizer,
    runtimeCtx,
    comments: [],
    elementSpecs: [],
    elements: []
  };
}
function markHeader(tokenizer) {
  const endHeaderIndex = tokenizer.data.indexOf("end_header", tokenizer.position);
  if (endHeaderIndex === -1)
    throw new Error(`no 'end_header' record found`);
  tokenizer.tokenStart = tokenizer.position;
  tokenizer.tokenEnd = endHeaderIndex;
  tokenizer.position = endHeaderIndex;
  Tokenizer.eatLine(tokenizer);
}
function parseHeader(state) {
  const { tokenizer, comments, elementSpecs } = state;
  markHeader(tokenizer);
  const headerLines = Tokenizer.getTokenString(tokenizer).split(/\r?\n/);
  if (headerLines[0] !== "ply")
    throw new Error(`data not starting with 'ply'`);
  if (headerLines[1] !== "format ascii 1.0")
    throw new Error(`format not 'ascii 1.0'`);
  let currentName;
  let currentCount;
  let currentProperties;
  function addCurrentElementSchema() {
    if (currentName !== void 0 && currentCount !== void 0 && currentProperties !== void 0) {
      let isList2 = false;
      for (let i = 0, il = currentProperties.length; i < il; ++i) {
        const p = currentProperties[i];
        if (p.kind === "list") {
          isList2 = true;
          break;
        }
      }
      if (isList2 && currentProperties.length !== 1) {
      }
      if (isList2) {
        elementSpecs.push({
          kind: "list",
          name: currentName,
          count: currentCount,
          property: currentProperties[0]
        });
      } else {
        elementSpecs.push({
          kind: "table",
          name: currentName,
          count: currentCount,
          properties: currentProperties
        });
      }
    }
  }
  for (let i = 2, il = headerLines.length; i < il; ++i) {
    const l = headerLines[i];
    const ls = l.split(" ");
    if (l.startsWith("comment")) {
      comments.push(l.substr(8));
    } else if (l.startsWith("element")) {
      addCurrentElementSchema();
      currentProperties = [];
      currentName = ls[1];
      currentCount = parseInt(ls[2]);
    } else if (l.startsWith("property")) {
      if (currentProperties === void 0)
        throw new Error(`properties outside of element`);
      if (ls[1] === "list") {
        currentProperties.push({
          kind: "list",
          countType: PlyType(ls[2]),
          dataType: PlyType(ls[3]),
          name: ls[4]
        });
      } else {
        currentProperties.push({
          kind: "column",
          type: PlyType(ls[1]),
          name: ls[2]
        });
      }
    } else if (l.startsWith("end_header")) {
      addCurrentElementSchema();
    } else {
      console.warn("unknown header line");
    }
  }
}
function parseElements(state) {
  const { elementSpecs } = state;
  for (let i = 0, il = elementSpecs.length; i < il; ++i) {
    const spec = elementSpecs[i];
    if (spec.kind === "table")
      parseTableElement(state, spec);
    else if (spec.kind === "list")
      parseListElement(state, spec);
  }
}
function getColumnSchema(type) {
  switch (type) {
    case "char":
    case "uchar":
    case "int8":
    case "uint8":
    case "short":
    case "ushort":
    case "int16":
    case "uint16":
    case "int":
    case "uint":
    case "int32":
    case "uint32":
      return Column.Schema.int;
    case "float":
    case "double":
    case "float32":
    case "float64":
      return Column.Schema.float;
  }
}
function parseTableElement(state, spec) {
  const { elements, tokenizer } = state;
  const { count: count3, properties: properties4 } = spec;
  const propertyCount = properties4.length;
  const propertyNames = [];
  const propertyTypes = [];
  const propertyTokens = [];
  const propertyColumns = /* @__PURE__ */ new Map();
  for (let i = 0, il = propertyCount; i < il; ++i) {
    const tokens = TokenBuilder.create(tokenizer.data, count3 * 2);
    propertyTokens.push(tokens);
  }
  for (let i = 0, il = count3; i < il; ++i) {
    for (let j = 0, jl = propertyCount; j < jl; ++j) {
      Tokenizer.skipWhitespace(tokenizer);
      Tokenizer.markStart(tokenizer);
      Tokenizer.eatValue(tokenizer);
      TokenBuilder.addUnchecked(propertyTokens[j], tokenizer.tokenStart, tokenizer.tokenEnd);
    }
  }
  for (let i = 0, il = propertyCount; i < il; ++i) {
    const { type, name } = properties4[i];
    const column = TokenColumn(propertyTokens[i], getColumnSchema(type));
    propertyNames.push(name);
    propertyTypes.push(type);
    propertyColumns.set(name, column);
  }
  elements.push({
    kind: "table",
    rowCount: count3,
    propertyNames,
    propertyTypes,
    getProperty: (name) => propertyColumns.get(name)
  });
}
function parseListElement(state, spec) {
  const { elements, tokenizer } = state;
  const { count: count3, property } = spec;
  const tokens = TokenBuilder.create(tokenizer.data, count3 * 2 * 3);
  const offsets = new Uint32Array(count3 + 1);
  let entryCount = 0;
  for (let i = 0, il = count3; i < il; ++i) {
    Tokenizer.skipWhitespace(tokenizer);
    Tokenizer.markStart(tokenizer);
    while (Tokenizer.skipWhitespace(tokenizer) !== 10) {
      ++entryCount;
      Tokenizer.markStart(tokenizer);
      Tokenizer.eatValue(tokenizer);
      TokenBuilder.addToken(tokens, tokenizer);
    }
    offsets[i + 1] = entryCount;
  }
  const listValue = {
    entries: [],
    count: 0
  };
  const column = TokenColumn(tokens, getColumnSchema(property.dataType));
  elements.push({
    kind: "list",
    rowCount: count3,
    name: property.name,
    type: property.dataType,
    value: (row) => {
      const offset = offsets[row] + 1;
      const count4 = column.value(offset - 1);
      for (let i = offset, il = offset + count4; i < il; ++i) {
        listValue.entries[i - offset] = column.value(i);
      }
      listValue.count = count4;
      return listValue;
    }
  });
}
async function parseInternal3(data, ctx) {
  const state = State2(data, ctx);
  ctx.update({ message: "Parsing...", current: 0, max: data.length });
  parseHeader(state);
  parseElements(state);
  const { elements, elementSpecs, comments } = state;
  const elementNames = elementSpecs.map((s) => s.name);
  const result = PlyFile(elements, elementNames, comments);
  return ReaderResult.success(result);
}
function parsePly(data) {
  return Task.create("Parse PLY", async (ctx) => {
    return await parseInternal3(data, ctx);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/psf/parser.js
var { readLine, skipWhitespace, eatValue, eatLine, markStart } = Tokenizer;
var reWhitespace = /\s+/;
var reTitle = /(^\*|REMARK)*/;
function State3(tokenizer, runtimeCtx) {
  return {
    tokenizer,
    runtimeCtx
  };
}
async function handleAtoms(state, count3) {
  const { tokenizer } = state;
  const atomId2 = TokenBuilder.create(tokenizer.data, count3 * 2);
  const segmentName = TokenBuilder.create(tokenizer.data, count3 * 2);
  const residueId = TokenBuilder.create(tokenizer.data, count3 * 2);
  const residueName = TokenBuilder.create(tokenizer.data, count3 * 2);
  const atomName = TokenBuilder.create(tokenizer.data, count3 * 2);
  const atomType = TokenBuilder.create(tokenizer.data, count3 * 2);
  const charge = TokenBuilder.create(tokenizer.data, count3 * 2);
  const mass = TokenBuilder.create(tokenizer.data, count3 * 2);
  const { position } = tokenizer;
  const line = readLine(tokenizer).trim();
  tokenizer.position = position;
  const isLammpsFull = line.split(reWhitespace).length === 7;
  const n = isLammpsFull ? 6 : 8;
  const { length } = tokenizer;
  let linesAlreadyRead = 0;
  await chunkedSubtask(state.runtimeCtx, 1e5, void 0, (chunkSize) => {
    const linesToRead = Math.min(count3 - linesAlreadyRead, chunkSize);
    for (let i = 0; i < linesToRead; ++i) {
      for (let j = 0; j < n; ++j) {
        skipWhitespace(tokenizer);
        markStart(tokenizer);
        eatValue(tokenizer);
        if (isLammpsFull) {
          switch (j) {
            case 0:
              TokenBuilder.addUnchecked(atomId2, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 1:
              TokenBuilder.addUnchecked(residueId, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 2:
              TokenBuilder.addUnchecked(atomName, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 3:
              TokenBuilder.addUnchecked(atomType, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 4:
              TokenBuilder.addUnchecked(charge, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 5:
              TokenBuilder.addUnchecked(mass, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
          }
        } else {
          switch (j) {
            case 0:
              TokenBuilder.addUnchecked(atomId2, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 1:
              TokenBuilder.addUnchecked(segmentName, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 2:
              TokenBuilder.addUnchecked(residueId, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 3:
              TokenBuilder.addUnchecked(residueName, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 4:
              TokenBuilder.addUnchecked(atomName, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 5:
              TokenBuilder.addUnchecked(atomType, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 6:
              TokenBuilder.addUnchecked(charge, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
            case 7:
              TokenBuilder.addUnchecked(mass, tokenizer.tokenStart, tokenizer.tokenEnd);
              break;
          }
        }
      }
      eatLine(tokenizer);
      markStart(tokenizer);
    }
    linesAlreadyRead += linesToRead;
    return linesToRead;
  }, (ctx) => ctx.update({ message: "Parsing...", current: tokenizer.position, max: length }));
  return {
    count: count3,
    atomId: TokenColumnProvider(atomId2)(Column.Schema.int),
    segmentName: isLammpsFull ? TokenColumnProvider(residueId)(Column.Schema.str) : TokenColumnProvider(segmentName)(Column.Schema.str),
    residueId: TokenColumnProvider(residueId)(Column.Schema.int),
    residueName: isLammpsFull ? TokenColumnProvider(residueId)(Column.Schema.str) : TokenColumnProvider(residueName)(Column.Schema.str),
    atomName: TokenColumnProvider(atomName)(Column.Schema.str),
    atomType: TokenColumnProvider(atomType)(Column.Schema.str),
    charge: TokenColumnProvider(charge)(Column.Schema.float),
    mass: TokenColumnProvider(mass)(Column.Schema.float)
  };
}
async function handleBonds(state, count3) {
  const { tokenizer } = state;
  const atomIdA = TokenBuilder.create(tokenizer.data, count3 * 2);
  const atomIdB = TokenBuilder.create(tokenizer.data, count3 * 2);
  const { length } = tokenizer;
  let bondsAlreadyRead = 0;
  await chunkedSubtask(state.runtimeCtx, 10, void 0, (chunkSize) => {
    const bondsToRead = Math.min(count3 - bondsAlreadyRead, chunkSize);
    for (let i = 0; i < bondsToRead; ++i) {
      for (let j = 0; j < 2; ++j) {
        skipWhitespace(tokenizer);
        markStart(tokenizer);
        eatValue(tokenizer);
        switch (j) {
          case 0:
            TokenBuilder.addUnchecked(atomIdA, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
          case 1:
            TokenBuilder.addUnchecked(atomIdB, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
        }
      }
    }
    bondsAlreadyRead += bondsToRead;
    return bondsToRead;
  }, (ctx) => ctx.update({ message: "Parsing...", current: tokenizer.position, max: length }));
  return {
    count: count3,
    atomIdA: TokenColumnProvider(atomIdA)(Column.Schema.int),
    atomIdB: TokenColumnProvider(atomIdB)(Column.Schema.int)
  };
}
function parseTitle(state, count3) {
  const title = [];
  for (let i = 0; i < count3; ++i) {
    const line = readLine(state.tokenizer);
    title.push(line.replace(reTitle, "").trim());
  }
  return title;
}
async function parseInternal4(data, ctx) {
  const tokenizer = Tokenizer(data);
  const state = State3(tokenizer, ctx);
  let title = void 0;
  let atoms = void 0;
  let bonds = void 0;
  const id = readLine(state.tokenizer).trim();
  while (tokenizer.tokenEnd < tokenizer.length) {
    const line = readLine(state.tokenizer).trim();
    if (line.includes("!NTITLE")) {
      const numTitle = parseInt(line.split(reWhitespace)[0]);
      title = parseTitle(state, numTitle);
    } else if (line.includes("!NATOM")) {
      const numAtoms = parseInt(line.split(reWhitespace)[0]);
      atoms = await handleAtoms(state, numAtoms);
    } else if (line.includes("!NBOND")) {
      const numBonds = parseInt(line.split(reWhitespace)[0]);
      bonds = await handleBonds(state, numBonds);
      break;
    } else if (line.includes("!NTHETA")) {
    } else if (line.includes("!NPHI")) {
    } else if (line.includes("!NIMPHI")) {
    } else if (line.includes("!NDON")) {
    } else if (line.includes("!NACC")) {
    } else if (line.includes("!NNB")) {
    } else if (line.includes("!NGRP NST2")) {
    } else if (line.includes("!MOLNT")) {
    } else if (line.includes("!NUMLP NUMLPH")) {
    } else if (line.includes("!NCRTERM")) {
    }
  }
  if (title === void 0) {
    title = [];
  }
  if (atoms === void 0) {
    return ReaderResult.error("no atoms data");
  }
  if (bonds === void 0) {
    return ReaderResult.error("no bonds data");
  }
  const result = {
    id,
    title,
    atoms,
    bonds
  };
  return ReaderResult.success(result);
}
function parsePsf(data) {
  return Task.create("Parse PSF", async (ctx) => {
    return await parseInternal4(data, ctx);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/cube/parser.js
var bohrToAngstromFactor = 0.529177210859;
function readHeader(tokenizer) {
  const headerLines = Tokenizer.readLines(tokenizer, 6);
  const h = (k, l) => {
    const field = +headerLines[k].trim().split(/\s+/g)[l];
    return Number.isNaN(field) ? 0 : field;
  };
  const basis = (i) => {
    const n = h(i + 2, 0);
    const s = bohrToAngstromFactor;
    return [Math.abs(n), Vec3.create(h(i + 2, 1) * s, h(i + 2, 2) * s, h(i + 2, 3) * s), n];
  };
  const comment1 = headerLines[0].trim();
  const comment2 = headerLines[1].trim();
  const [atomCount, origin, rawAtomCount] = basis(0);
  const [NVX, basisX] = basis(1);
  const [NVY, basisY] = basis(2);
  const [NVZ, basisZ] = basis(3);
  const atoms = readAtoms(tokenizer, atomCount, bohrToAngstromFactor);
  const dataSetIds = [];
  if (rawAtomCount >= 0) {
    let nVal = h(2, 4);
    if (nVal === 0)
      nVal = 1;
    for (let i = 0; i < nVal; i++)
      dataSetIds.push(i);
  } else {
    const counts = Tokenizer.readLine(tokenizer).trim().split(/\s+/g);
    for (let i = 0, _i = +counts[0]; i < _i; i++)
      dataSetIds.push(+counts[i + 1]);
  }
  const header2 = { orbitals: rawAtomCount < 0, comment1, comment2, atomCount, origin, dim: Vec3.create(NVX, NVY, NVZ), basisX, basisY, basisZ, dataSetIds };
  return { header: header2, atoms };
}
function readAtoms(tokenizer, count3, scaleFactor) {
  const number = new Int32Array(count3);
  const value = new Float64Array(count3);
  const x = new Float32Array(count3);
  const y = new Float32Array(count3);
  const z = new Float32Array(count3);
  for (let i = 0; i < count3; i++) {
    const fields = Tokenizer.readLine(tokenizer).trim().split(/\s+/g);
    number[i] = +fields[0];
    value[i] = +fields[1];
    x[i] = +fields[2] * scaleFactor;
    y[i] = +fields[3] * scaleFactor;
    z[i] = +fields[4] * scaleFactor;
  }
  return {
    count: count3,
    number: Column.ofArray({ array: number, schema: Column.Schema.int }),
    nuclearCharge: Column.ofArray({ array: value, schema: Column.Schema.float }),
    x: Column.ofArray({ array: x, schema: Column.Schema.float }),
    y: Column.ofArray({ array: y, schema: Column.Schema.float }),
    z: Column.ofArray({ array: z, schema: Column.Schema.float })
  };
}
function readValues(ctx, tokenizer, header2) {
  const N = header2.dim[0] * header2.dim[1] * header2.dim[2] * header2.dataSetIds.length;
  const chunkSize = 100 * 100 * 100;
  const data = new Float64Array(N);
  let offset = 0;
  return chunkedSubtask(ctx, chunkSize, data, (count3, data2) => {
    const max3 = Math.min(N, offset + count3);
    for (let i = offset; i < max3; i++) {
      Tokenizer.skipWhitespace(tokenizer);
      tokenizer.tokenStart = tokenizer.position;
      Tokenizer.eatValue(tokenizer);
      data2[i] = parseFloat2(tokenizer.data, tokenizer.tokenStart, tokenizer.tokenEnd);
    }
    offset = max3;
    return max3 === N ? 0 : chunkSize;
  }, (ctx2, _, i) => ctx2.update({ current: Math.min(i, N), max: N }));
}
function parseCube(data, name) {
  return Task.create("Parse Cube", async (taskCtx) => {
    await taskCtx.update("Reading header...");
    const tokenizer = Tokenizer(data);
    const { header: header2, atoms } = readHeader(tokenizer);
    const values2 = await readValues(taskCtx, tokenizer, header2);
    return ReaderResult.success({ header: header2, atoms, values: values2, name });
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/dx/parser.js
function readHeader2(tokenizer) {
  const header2 = { h: Vec3() };
  let headerByteCount = 0;
  let deltaLineCount = 0;
  const reWhitespace5 = /\s+/g;
  while (true) {
    const line = Tokenizer.readLine(tokenizer);
    let ls;
    if (line.startsWith("object 1")) {
      ls = line.split(reWhitespace5);
      header2.dim = Vec3.create(parseInt(ls[5]), parseInt(ls[6]), parseInt(ls[7]));
    } else if (line.startsWith("origin")) {
      ls = line.split(reWhitespace5);
      header2.min = Vec3.create(parseFloat(ls[1]), parseFloat(ls[2]), parseFloat(ls[3]));
    } else if (line.startsWith("delta")) {
      ls = line.split(reWhitespace5);
      if (deltaLineCount === 0) {
        header2.h[0] = parseFloat(ls[1]);
      } else if (deltaLineCount === 1) {
        header2.h[1] = parseFloat(ls[2]);
      } else if (deltaLineCount === 2) {
        header2.h[2] = parseFloat(ls[3]);
      }
      deltaLineCount += 1;
    } else if (line.startsWith("object 3")) {
      headerByteCount += line.length + 1;
      break;
    }
    headerByteCount += line.length + 1;
  }
  return { header: header2, headerByteCount };
}
function readValuesText(ctx, tokenizer, header2) {
  const N = header2.dim[0] * header2.dim[1] * header2.dim[2];
  const chunkSize = 100 * 100 * 100;
  const data = new Float64Array(N);
  let offset = 0;
  return chunkedSubtask(ctx, chunkSize, data, (count3, data2) => {
    const max3 = Math.min(N, offset + count3);
    for (let i = offset; i < max3; i++) {
      Tokenizer.skipWhitespace(tokenizer);
      tokenizer.tokenStart = tokenizer.position;
      Tokenizer.eatValue(tokenizer);
      data2[i] = parseFloat2(tokenizer.data, tokenizer.tokenStart, tokenizer.tokenEnd);
    }
    offset = max3;
    return max3 === N ? 0 : chunkSize;
  }, (ctx2, _, i) => ctx2.update({ current: Math.min(i, N), max: N }));
}
async function parseText(taskCtx, data, name) {
  await taskCtx.update("Reading header...");
  const tokenizer = Tokenizer(data);
  const { header: header2 } = readHeader2(tokenizer);
  await taskCtx.update("Reading values...");
  const values2 = await readValuesText(taskCtx, tokenizer, header2);
  return ReaderResult.success({ header: header2, values: values2, name });
}
async function parseBinary(taskCtx, data, name) {
  await taskCtx.update("Reading header...");
  const headerString = utf8Read(data, 0, 1e3);
  const tokenizer = Tokenizer(headerString);
  const { header: header2, headerByteCount } = readHeader2(tokenizer);
  await taskCtx.update("Reading values...");
  const size = header2.dim[0] * header2.dim[1] * header2.dim[2];
  const dv = new DataView(data.buffer, data.byteOffset + headerByteCount);
  const values2 = new Float64Array(size);
  for (let i = 0; i < size; i++) {
    values2[i] = dv.getFloat64(i * 8, true);
  }
  return ReaderResult.success({ header: header2, values: values2, name });
}
function parseDx(data, name) {
  return Task.create("Parse DX", (taskCtx) => {
    if (StringLike.is(data))
      return parseText(taskCtx, data, name);
    return parseBinary(taskCtx, data, name);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/prmtop/parser.js
var Pointers = {
  "NATOM": "",
  "NTYPES": "",
  "NBONH": "",
  "MBONA": "",
  "NTHETH": "",
  "MTHETA": "",
  "NPHIH": "",
  "MPHIA": "",
  "NHPARM": "",
  "NPARM": "",
  "NNB": "",
  "NRES": "",
  "NBONA": "",
  "NTHETA": "",
  "NPHIA": "",
  "NUMBND": "",
  "NUMANG": "",
  "NPTRA": "",
  "NATYP": "",
  "NPHB": "",
  "IFPERT": "",
  "NBPER": "",
  "NGPER": "",
  "NDPER": "",
  "MBPER": "",
  "MGPER": "",
  "MDPER": "",
  "IFBOX": "",
  "NMXRS": "",
  "IFCAP": "",
  "NUMEXTRA": "",
  "NCOPY": ""
};
var PointersNames = Object.keys(Pointers);
var { readLine: readLine2, markLine, trim } = Tokenizer;
function State4(tokenizer, runtimeCtx) {
  return {
    tokenizer,
    runtimeCtx
  };
}
function handleTitle(state) {
  const { tokenizer } = state;
  const title = [];
  while (tokenizer.tokenEnd < tokenizer.length) {
    if (tokenizer.data.charAt(tokenizer.position) === "%")
      break;
    const line = readLine2(tokenizer).trim();
    if (line)
      title.push(line);
  }
  return title;
}
function handlePointers(state) {
  const { tokenizer } = state;
  const pointers = /* @__PURE__ */ Object.create(null);
  PointersNames.forEach((name) => {
    pointers[name] = 0;
  });
  let curIdx = 0;
  while (tokenizer.tokenEnd < tokenizer.length) {
    if (tokenizer.data.charAt(tokenizer.position) === "%")
      break;
    const line = readLine2(tokenizer);
    const n = Math.min(curIdx + 10, 32);
    for (let i = 0; curIdx < n; ++i, ++curIdx) {
      pointers[PointersNames[curIdx]] = parseInt(line.substring(i * 8, i * 8 + 8).trim());
    }
  }
  return pointers;
}
function handleTokens(state, count3, countPerLine, itemSize) {
  const { tokenizer } = state;
  const tokens = TokenBuilder.create(tokenizer.data, count3 * 2);
  let curIdx = 0;
  while (tokenizer.tokenEnd < tokenizer.length) {
    if (tokenizer.data.charAt(tokenizer.position) === "%")
      break;
    tokenizer.tokenStart = tokenizer.position;
    const n = Math.min(curIdx + countPerLine, count3);
    for (let i = 0; curIdx < n; ++i, ++curIdx) {
      const p = tokenizer.position;
      trim(tokenizer, tokenizer.position, tokenizer.position + itemSize);
      TokenBuilder.addUnchecked(tokens, tokenizer.tokenStart, tokenizer.tokenEnd);
      tokenizer.position = p + itemSize;
    }
    markLine(tokenizer);
  }
  return tokens;
}
async function parseInternal5(data, ctx) {
  const t2 = Tokenizer(data);
  const state = State4(t2, ctx);
  const result = /* @__PURE__ */ Object.create(null);
  let prevPosition = 0;
  while (t2.tokenEnd < t2.length) {
    if (t2.position - prevPosition > 1e5 && ctx.shouldUpdate) {
      prevPosition = t2.position;
      await ctx.update({ current: t2.position, max: t2.length });
    }
    const line = readLine2(state.tokenizer).trim();
    if (line.startsWith("%VERSION")) {
      result.version = line.substring(8).trim();
    } else if (line.startsWith("%FLAG")) {
      const flag = line.substring(5).trim();
      let formatLine = readLine2(state.tokenizer).trim();
      while (formatLine.startsWith("%COMMENT")) {
        formatLine = readLine2(state.tokenizer).trim();
      }
      if (!formatLine.startsWith("%FORMAT"))
        throw new Error(`expected %FORMAT got "${formatLine}"`);
      if (flag === "TITLE" || flag === "CTITLE") {
        result.title = handleTitle(state);
      } else if (flag === "POINTERS") {
        result.pointers = handlePointers(state);
      } else if (flag === "ATOM_NAME") {
        const tokens = handleTokens(state, result.pointers["NATOM"], 20, 4);
        result.atomName = TokenColumnProvider(tokens)(Column.Schema.str);
      } else if (flag === "CHARGE") {
        const tokens = handleTokens(state, result.pointers["NATOM"], 5, 16);
        result.charge = TokenColumnProvider(tokens)(Column.Schema.float);
      } else if (flag === "MASS") {
        const tokens = handleTokens(state, result.pointers["NATOM"], 5, 16);
        result.mass = TokenColumnProvider(tokens)(Column.Schema.float);
      } else if (flag === "RESIDUE_LABEL") {
        const tokens = handleTokens(state, result.pointers["NRES"], 20, 4);
        result.residueLabel = TokenColumnProvider(tokens)(Column.Schema.str);
      } else if (flag === "RESIDUE_POINTER") {
        const tokens = handleTokens(state, result.pointers["NRES"], 10, 8);
        result.residuePointer = TokenColumnProvider(tokens)(Column.Schema.int);
      } else if (flag === "BONDS_INC_HYDROGEN") {
        const tokens = handleTokens(state, result.pointers["NBONH"] * 3, 10, 8);
        result.bondsIncHydrogen = TokenColumnProvider(tokens)(Column.Schema.int);
      } else if (flag === "BONDS_WITHOUT_HYDROGEN") {
        const tokens = handleTokens(state, result.pointers["NBONA"] * 3, 10, 8);
        result.bondsWithoutHydrogen = TokenColumnProvider(tokens)(Column.Schema.int);
      } else if (flag === "RADII") {
        const tokens = handleTokens(state, result.pointers["NATOM"], 5, 16);
        result.radii = TokenColumnProvider(tokens)(Column.Schema.float);
      } else {
        while (t2.tokenEnd < t2.length) {
          if (t2.data.charAt(t2.position) === "%")
            break;
          markLine(t2);
        }
      }
    }
  }
  return ReaderResult.success(result);
}
function parsePrmtop(data) {
  return Task.create("Parse PRMTOP", async (ctx) => {
    return await parseInternal5(data, ctx);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/top/parser.js
var AtomsSchema = {
  nr: Column.Schema.Int(),
  type: Column.Schema.Str(),
  resnr: Column.Schema.Int(),
  residu: Column.Schema.Str(),
  atom: Column.Schema.Str(),
  cgnr: Column.Schema.Int(),
  charge: Column.Schema.Float(),
  mass: Column.Schema.Float()
};
var BondsSchema = {
  ai: Column.Schema.Int(),
  aj: Column.Schema.Int()
};
var MoleculesSchema = {
  compound: Column.Schema.Str(),
  molCount: Column.Schema.Int()
};
var { readLine: readLine3, markLine: markLine2, skipWhitespace: skipWhitespace2, markStart: markStart2, eatValue: eatValue2, eatLine: eatLine2 } = Tokenizer;
function State5(tokenizer, runtimeCtx) {
  return {
    tokenizer,
    runtimeCtx
  };
}
var reField = /\[ (.+) \]/;
var reWhitespace2 = /\s+/;
function handleMoleculetype(state) {
  const { tokenizer } = state;
  let molName = void 0;
  while (tokenizer.tokenEnd < tokenizer.length) {
    skipWhitespace2(tokenizer);
    const c5 = tokenizer.data.charAt(tokenizer.position);
    if (c5 === "[")
      break;
    if (c5 === ";" || c5 === "*") {
      markLine2(tokenizer);
      continue;
    }
    if (molName !== void 0)
      throw new Error("more than one molName");
    const line = readLine3(tokenizer);
    molName = line.split(reWhitespace2)[0];
  }
  if (molName === void 0)
    throw new Error("missing molName");
  return molName;
}
function handleAtoms2(state) {
  const { tokenizer } = state;
  const nr = TokenBuilder.create(tokenizer.data, 64);
  const type = TokenBuilder.create(tokenizer.data, 64);
  const resnr = TokenBuilder.create(tokenizer.data, 64);
  const residu = TokenBuilder.create(tokenizer.data, 64);
  const atom = TokenBuilder.create(tokenizer.data, 64);
  const cgnr = TokenBuilder.create(tokenizer.data, 64);
  const charge = TokenBuilder.create(tokenizer.data, 64);
  const mass = TokenBuilder.create(tokenizer.data, 64);
  while (tokenizer.tokenEnd < tokenizer.length) {
    skipWhitespace2(tokenizer);
    const c5 = tokenizer.data.charAt(tokenizer.position);
    if (c5 === "[")
      break;
    if (c5 === ";" || c5 === "*") {
      markLine2(tokenizer);
      continue;
    }
    for (let j = 0; j < 8; ++j) {
      skipWhitespace2(tokenizer);
      markStart2(tokenizer);
      eatValue2(tokenizer);
      switch (j) {
        case 0:
          TokenBuilder.add(nr, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
        case 1:
          TokenBuilder.add(type, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
        case 2:
          TokenBuilder.add(resnr, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
        case 3:
          TokenBuilder.add(residu, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
        case 4:
          TokenBuilder.add(atom, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
        case 5:
          TokenBuilder.add(cgnr, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
        case 6:
          TokenBuilder.add(charge, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
        case 7:
          TokenBuilder.add(mass, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
      }
    }
    markLine2(tokenizer);
  }
  return Table.ofColumns(AtomsSchema, {
    nr: TokenColumnProvider(nr)(Column.Schema.int),
    type: TokenColumnProvider(type)(Column.Schema.str),
    resnr: TokenColumnProvider(resnr)(Column.Schema.int),
    residu: TokenColumnProvider(residu)(Column.Schema.str),
    atom: TokenColumnProvider(atom)(Column.Schema.str),
    cgnr: TokenColumnProvider(cgnr)(Column.Schema.int),
    charge: TokenColumnProvider(charge)(Column.Schema.float),
    mass: TokenColumnProvider(mass)(Column.Schema.float)
  });
}
function handleBonds2(state) {
  const { tokenizer } = state;
  const ai = TokenBuilder.create(tokenizer.data, 64);
  const aj = TokenBuilder.create(tokenizer.data, 64);
  while (tokenizer.tokenEnd < tokenizer.length) {
    skipWhitespace2(tokenizer);
    const c5 = tokenizer.data.charAt(tokenizer.position);
    if (c5 === "[")
      break;
    if (c5 === ";" || c5 === "*") {
      markLine2(tokenizer);
      continue;
    }
    for (let j = 0; j < 2; ++j) {
      skipWhitespace2(tokenizer);
      markStart2(tokenizer);
      eatValue2(tokenizer);
      switch (j) {
        case 0:
          TokenBuilder.add(ai, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
        case 1:
          TokenBuilder.add(aj, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
      }
    }
    markLine2(tokenizer);
  }
  return Table.ofColumns(BondsSchema, {
    ai: TokenColumnProvider(ai)(Column.Schema.int),
    aj: TokenColumnProvider(aj)(Column.Schema.int)
  });
}
function handleSystem(state) {
  const { tokenizer } = state;
  let system = void 0;
  while (tokenizer.tokenEnd < tokenizer.length) {
    skipWhitespace2(tokenizer);
    const c5 = tokenizer.data.charAt(tokenizer.position);
    if (c5 === "[")
      break;
    if (c5 === ";" || c5 === "*") {
      markLine2(tokenizer);
      continue;
    }
    if (system !== void 0)
      throw new Error("more than one system");
    system = readLine3(tokenizer).trim();
  }
  if (system === void 0)
    throw new Error("missing system");
  return system;
}
function handleMolecules(state) {
  const { tokenizer } = state;
  const compound = TokenBuilder.create(tokenizer.data, 64);
  const molCount = TokenBuilder.create(tokenizer.data, 64);
  while (tokenizer.tokenEnd < tokenizer.length) {
    skipWhitespace2(tokenizer);
    if (tokenizer.position >= tokenizer.length)
      break;
    const c5 = tokenizer.data.charAt(tokenizer.position);
    if (c5 === "[")
      break;
    if (c5 === ";" || c5 === "*") {
      markLine2(tokenizer);
      continue;
    }
    for (let j = 0; j < 2; ++j) {
      skipWhitespace2(tokenizer);
      markStart2(tokenizer);
      eatValue2(tokenizer);
      switch (j) {
        case 0:
          TokenBuilder.add(compound, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
        case 1:
          TokenBuilder.add(molCount, tokenizer.tokenStart, tokenizer.tokenEnd);
          break;
      }
    }
    eatLine2(tokenizer);
    markStart2(tokenizer);
  }
  return Table.ofColumns(MoleculesSchema, {
    compound: TokenColumnProvider(compound)(Column.Schema.str),
    molCount: TokenColumnProvider(molCount)(Column.Schema.int)
  });
}
async function parseInternal6(data, ctx) {
  const t2 = Tokenizer(data);
  const state = State5(t2, ctx);
  const result = /* @__PURE__ */ Object.create(null);
  let prevPosition = 0;
  result.compounds = {};
  let currentCompound = {};
  let currentMolName = "";
  function addMol() {
    if (currentMolName && currentCompound.atoms) {
      result.compounds[currentMolName] = currentCompound;
      currentCompound = {};
      currentMolName = "";
    }
  }
  while (t2.tokenEnd < t2.length) {
    if (t2.position - prevPosition > 1e5 && ctx.shouldUpdate) {
      prevPosition = t2.position;
      await ctx.update({ current: t2.position, max: t2.length });
    }
    const line = readLine3(state.tokenizer).trim();
    if (!line || line[0] === "*" || line[0] === ";") {
      continue;
    }
    if (line.startsWith("#include")) {
      throw new Error("#include statements not allowed");
    }
    if (line.startsWith("[")) {
      const fieldMatch = line.match(reField);
      if (fieldMatch === null)
        throw new Error("expected field name");
      const fieldName = fieldMatch[1];
      if (fieldName === "moleculetype") {
        addMol();
        currentMolName = handleMoleculetype(state);
      } else if (fieldName === "atoms") {
        currentCompound.atoms = handleAtoms2(state);
      } else if (fieldName === "bonds") {
        currentCompound.bonds = handleBonds2(state);
      } else if (fieldName === "system") {
        result.system = handleSystem(state);
      } else if (fieldName === "molecules") {
        addMol();
        result.molecules = handleMolecules(state);
      } else {
        while (t2.tokenEnd < t2.length) {
          if (t2.data.charAt(t2.position) === "[")
            break;
          markLine2(t2);
        }
      }
    }
  }
  return ReaderResult.success(result);
}
function parseTop(data) {
  return Task.create("Parse TOP", async (ctx) => {
    return await parseInternal6(data, ctx);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms/data.js
var Download = PluginStateTransform.BuiltIn({
  name: "download",
  display: { name: "Download", description: "Download string or binary data from the specified URL" },
  from: [PluginStateObject.Root],
  to: [PluginStateObject.Data.String, PluginStateObject.Data.Binary],
  params: {
    url: ParamDefinition.Url("https://www.ebi.ac.uk/pdbe/static/entry/1cbs_updated.cif", { description: "Resource URL. Must be the same domain or support CORS." }),
    label: ParamDefinition.Optional(ParamDefinition.Text("")),
    isBinary: ParamDefinition.Optional(ParamDefinition.Boolean(false, { description: "If true, download data as binary (string otherwise)" }))
  }
})({
  apply({ params: p, cache }, plugin) {
    return Task.create("Download", async (ctx) => {
      const url = Asset.getUrlAsset(plugin.managers.asset, p.url);
      const asset = await plugin.managers.asset.resolve(url, p.isBinary ? "binary" : "string").runInContext(ctx);
      cache.asset = asset;
      return p.isBinary ? new PluginStateObject.Data.Binary(asset.data, { label: p.label ? p.label : url.url }) : new PluginStateObject.Data.String(asset.data, { label: p.label ? p.label : url.url });
    });
  },
  dispose({ cache }) {
    var _a;
    (_a = cache === null || cache === void 0 ? void 0 : cache.asset) === null || _a === void 0 ? void 0 : _a.dispose();
  },
  update({ oldParams, newParams, b: b5 }) {
    if (oldParams.url !== newParams.url || oldParams.isBinary !== newParams.isBinary)
      return Transformer.UpdateResult.Recreate;
    if (oldParams.label !== newParams.label) {
      b5.label = newParams.label || (typeof newParams.url === "string" ? newParams.url : newParams.url.url);
      return Transformer.UpdateResult.Updated;
    }
    return Transformer.UpdateResult.Unchanged;
  }
});
var DownloadBlob = PluginStateTransform.BuiltIn({
  name: "download-blob",
  display: { name: "Download Blob", description: "Download multiple string or binary data from the specified URLs." },
  from: PluginStateObject.Root,
  to: PluginStateObject.Data.Blob,
  params: {
    sources: ParamDefinition.ObjectList({
      id: ParamDefinition.Text("", { label: "Unique ID" }),
      url: ParamDefinition.Url("https://www.ebi.ac.uk/pdbe/static/entry/1cbs_updated.cif", { description: "Resource URL. Must be the same domain or support CORS." }),
      isBinary: ParamDefinition.Optional(ParamDefinition.Boolean(false, { description: "If true, download data as binary (string otherwise)" })),
      canFail: ParamDefinition.Optional(ParamDefinition.Boolean(false, { description: "Indicate whether the download can fail and not be included in the blob as a result." }))
    }, (e) => `${e.id}: ${e.url}`),
    maxConcurrency: ParamDefinition.Optional(ParamDefinition.Numeric(4, { min: 1, max: 12, step: 1 }, { description: "The maximum number of concurrent downloads." }))
  }
})({
  apply({ params, cache }, plugin) {
    return Task.create("Download Blob", async (ctx) => {
      const entries3 = [];
      const data = await ajaxGetMany(ctx, plugin.managers.asset, params.sources, params.maxConcurrency || 4);
      const assets = [];
      for (let i = 0; i < data.length; i++) {
        const r = data[i], src = params.sources[i];
        if (r.kind === "error")
          plugin.log.warn(`Download ${r.id} (${src.url}) failed: ${r.error}`);
        else {
          assets.push(r.result);
          entries3.push(src.isBinary ? { id: r.id, kind: "binary", data: r.result.data } : { id: r.id, kind: "string", data: r.result.data });
        }
      }
      cache.assets = assets;
      return new PluginStateObject.Data.Blob(entries3, { label: "Data Blob", description: `${entries3.length} ${entries3.length === 1 ? "entry" : "entries"}` });
    });
  },
  dispose({ cache }, plugin) {
    const assets = cache === null || cache === void 0 ? void 0 : cache.assets;
    if (!assets)
      return;
    for (const a5 of assets) {
      a5.dispose();
    }
  }
  // TODO: ??
  // update({ oldParams, newParams, b }) {
  //     return 0 as any;
  //     // if (oldParams.url !== newParams.url || oldParams.isBinary !== newParams.isBinary) return StateTransformer.UpdateResult.Recreate;
  //     // if (oldParams.label !== newParams.label) {
  //     //     (b.label as string) = newParams.label || newParams.url;
  //     //     return StateTransformer.UpdateResult.Updated;
  //     // }
  //     // return StateTransformer.UpdateResult.Unchanged;
  // }
});
var DeflateData = PluginStateTransform.BuiltIn({
  name: "defalate-data",
  display: { name: "Deflate", description: "Deflate compressed data" },
  params: {
    method: ParamDefinition.Select("gzip", [["gzip", "gzip"]]),
    // later on we might have to add say brotli
    isString: ParamDefinition.Boolean(false),
    stringEncoding: ParamDefinition.Optional(ParamDefinition.Select("utf-8", [["utf-8", "UTF8"]])),
    label: ParamDefinition.Optional(ParamDefinition.Text(""))
  },
  from: [PluginStateObject.Data.Binary],
  to: [PluginStateObject.Data.Binary, PluginStateObject.Data.String]
})({
  apply({ a: a5, params }, plugin) {
    return Task.create("Gzip", async (ctx) => {
      const decompressedData = await ungzip(ctx, a5.data);
      const label2 = params.label ? params.label : a5.label;
      if (params.isString) {
        const textData = utf8ReadLong(decompressedData);
        return new PluginStateObject.Data.String(textData, { label: label2 });
      }
      return new PluginStateObject.Data.Binary(decompressedData, { label: label2 });
    });
  }
});
var RawData = PluginStateTransform.BuiltIn({
  name: "raw-data",
  display: { name: "Raw Data", description: "Raw data supplied by value." },
  from: [PluginStateObject.Root],
  to: [PluginStateObject.Data.String, PluginStateObject.Data.Binary],
  params: {
    data: ParamDefinition.Value("", { isHidden: true }),
    label: ParamDefinition.Optional(ParamDefinition.Text(""))
  }
})({
  apply({ params: p }) {
    return Task.create("Raw Data", async () => {
      if (typeof p.data === "string") {
        return new PluginStateObject.Data.String(p.data, { label: p.label ? p.label : "String" });
      } else if (Array.isArray(p.data)) {
        return new PluginStateObject.Data.Binary(new Uint8Array(p.data), { label: p.label ? p.label : "Binary" });
      } else if (p.data instanceof ArrayBuffer) {
        return new PluginStateObject.Data.Binary(new Uint8Array(p.data), { label: p.label ? p.label : "Binary" });
      } else if (p.data instanceof Uint8Array) {
        return new PluginStateObject.Data.Binary(p.data, { label: p.label ? p.label : "Binary" });
      } else {
        assertUnreachable(p.data);
      }
    });
  },
  update({ oldParams, newParams, b: b5 }) {
    if (oldParams.data !== newParams.data)
      return Transformer.UpdateResult.Recreate;
    if (oldParams.label !== newParams.label) {
      b5.label = newParams.label || b5.label;
      return Transformer.UpdateResult.Updated;
    }
    return Transformer.UpdateResult.Unchanged;
  },
  customSerialization: {
    toJSON(p) {
      if (typeof p.data === "string" || Array.isArray(p.data)) {
        return p;
      } else if (p.data instanceof ArrayBuffer) {
        const v3 = new Uint8Array(p.data);
        const data = new Array(v3.length);
        for (let i = 0, _i = v3.length; i < _i; i++)
          data[i] = v3[i];
        return { data, label: p.label };
      } else if (p.data instanceof Uint8Array) {
        const data = new Array(p.data.length);
        for (let i = 0, _i = p.data.length; i < _i; i++)
          data[i] = p.data[i];
        return { data, label: p.label };
      }
    },
    fromJSON(data) {
      return data;
    }
  }
});
var ReadFile = PluginStateTransform.BuiltIn({
  name: "read-file",
  display: { name: "Read File", description: "Read string or binary data from the specified file" },
  from: PluginStateObject.Root,
  to: [PluginStateObject.Data.String, PluginStateObject.Data.Binary],
  params: {
    file: ParamDefinition.File(),
    label: ParamDefinition.Optional(ParamDefinition.Text("")),
    isBinary: ParamDefinition.Optional(ParamDefinition.Boolean(false, { description: "If true, open file as as binary (string otherwise)" }))
  }
})({
  apply({ params: p, cache }, plugin) {
    return Task.create("Open File", async (ctx) => {
      if (p.file === null) {
        plugin.log.error("No file(s) selected");
        return StateObject.Null;
      }
      const asset = await plugin.managers.asset.resolve(p.file, p.isBinary ? "binary" : "string").runInContext(ctx);
      cache.asset = asset;
      const o = p.isBinary ? new PluginStateObject.Data.Binary(asset.data, { label: p.label ? p.label : p.file.name }) : new PluginStateObject.Data.String(asset.data, { label: p.label ? p.label : p.file.name });
      return o;
    });
  },
  dispose({ cache }) {
    var _a;
    (_a = cache === null || cache === void 0 ? void 0 : cache.asset) === null || _a === void 0 ? void 0 : _a.dispose();
  },
  update({ oldParams, newParams, b: b5 }) {
    var _a;
    if (oldParams.label !== newParams.label) {
      b5.label = newParams.label || ((_a = oldParams.file) === null || _a === void 0 ? void 0 : _a.name) || "";
      return Transformer.UpdateResult.Updated;
    }
    return Transformer.UpdateResult.Unchanged;
  },
  isSerializable: () => ({ isSerializable: false, reason: "Cannot serialize user loaded files." })
});
var ParseBlob = PluginStateTransform.BuiltIn({
  name: "parse-blob",
  display: { name: "Parse Blob", description: "Parse multiple data enties" },
  from: PluginStateObject.Data.Blob,
  to: PluginStateObject.Format.Blob,
  params: {
    formats: ParamDefinition.ObjectList({
      id: ParamDefinition.Text("", { label: "Unique ID" }),
      format: ParamDefinition.Select("cif", [["cif", "cif"]])
    }, (e) => `${e.id}: ${e.format}`)
  }
})({
  apply({ a: a5, params }, plugin) {
    return Task.create("Parse Blob", async (ctx) => {
      const map3 = /* @__PURE__ */ new Map();
      for (const f of params.formats)
        map3.set(f.id, f.format);
      const entries3 = [];
      for (const e of a5.data) {
        if (!map3.has(e.id))
          continue;
        const parsed = await (e.kind === "string" ? CIF.parse(e.data) : CIF.parseBinary(e.data)).runInContext(ctx);
        if (parsed.isError)
          throw new Error(`${e.id}: ${parsed.message}`);
        entries3.push({ id: e.id, kind: "cif", data: parsed.result });
      }
      return new PluginStateObject.Format.Blob(entries3, { label: "Format Blob", description: `${entries3.length} ${entries3.length === 1 ? "entry" : "entries"}` });
    });
  }
  // TODO: ??
  // update({ oldParams, newParams, b }) {
  //     return 0 as any;
  //     // if (oldParams.url !== newParams.url || oldParams.isBinary !== newParams.isBinary) return StateTransformer.UpdateResult.Recreate;
  //     // if (oldParams.label !== newParams.label) {
  //     //     (b.label as string) = newParams.label || newParams.url;
  //     //     return StateTransformer.UpdateResult.Updated;
  //     // }
  //     // return StateTransformer.UpdateResult.Unchanged;
  // }
});
var ParseCif = PluginStateTransform.BuiltIn({
  name: "parse-cif",
  display: { name: "Parse CIF", description: "Parse CIF from String or Binary data" },
  from: [PluginStateObject.Data.String, PluginStateObject.Data.Binary],
  to: PluginStateObject.Format.Cif
})({
  apply({ a: a5 }) {
    return Task.create("Parse CIF", async (ctx) => {
      const parsed = await CIF.parse(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      if (parsed.result.blocks.length === 0)
        return StateObject.Null;
      return new PluginStateObject.Format.Cif(parsed.result);
    });
  }
});
var ParseCube = PluginStateTransform.BuiltIn({
  name: "parse-cube",
  display: { name: "Parse Cube", description: "Parse Cube from String data" },
  from: PluginStateObject.Data.String,
  to: PluginStateObject.Format.Cube
})({
  apply({ a: a5 }) {
    return Task.create("Parse Cube", async (ctx) => {
      const parsed = await parseCube(a5.data, a5.label).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      return new PluginStateObject.Format.Cube(parsed.result);
    });
  }
});
var ParsePsf = PluginStateTransform.BuiltIn({
  name: "parse-psf",
  display: { name: "Parse PSF", description: "Parse PSF from String data" },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Format.Psf
})({
  apply({ a: a5 }) {
    return Task.create("Parse PSF", async (ctx) => {
      const parsed = await parsePsf(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      return new PluginStateObject.Format.Psf(parsed.result);
    });
  }
});
var ParsePrmtop = PluginStateTransform.BuiltIn({
  name: "parse-prmtop",
  display: { name: "Parse PRMTOP", description: "Parse PRMTOP from String data" },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Format.Prmtop
})({
  apply({ a: a5 }) {
    return Task.create("Parse PRMTOP", async (ctx) => {
      const parsed = await parsePrmtop(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      return new PluginStateObject.Format.Prmtop(parsed.result);
    });
  }
});
var ParseTop = PluginStateTransform.BuiltIn({
  name: "parse-top",
  display: { name: "Parse TOP", description: "Parse TOP from String data" },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Format.Top
})({
  apply({ a: a5 }) {
    return Task.create("Parse TOP", async (ctx) => {
      const parsed = await parseTop(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      return new PluginStateObject.Format.Top(parsed.result);
    });
  }
});
var ParsePly = PluginStateTransform.BuiltIn({
  name: "parse-ply",
  display: { name: "Parse PLY", description: "Parse PLY from String data" },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Format.Ply
})({
  apply({ a: a5 }) {
    return Task.create("Parse PLY", async (ctx) => {
      const parsed = await parsePly(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      return new PluginStateObject.Format.Ply(parsed.result, { label: parsed.result.comments[0] || "PLY Data" });
    });
  }
});
var ParseCcp4 = PluginStateTransform.BuiltIn({
  name: "parse-ccp4",
  display: { name: "Parse CCP4/MRC/MAP", description: "Parse CCP4/MRC/MAP from Binary data" },
  from: [PluginStateObject.Data.Binary],
  to: PluginStateObject.Format.Ccp4
})({
  apply({ a: a5 }) {
    return Task.create("Parse CCP4/MRC/MAP", async (ctx) => {
      const parsed = await parse(a5.data, a5.label).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      return new PluginStateObject.Format.Ccp4(parsed.result);
    });
  }
});
var ParseDsn6 = PluginStateTransform.BuiltIn({
  name: "parse-dsn6",
  display: { name: "Parse DSN6/BRIX", description: "Parse CCP4/BRIX from Binary data" },
  from: [PluginStateObject.Data.Binary],
  to: PluginStateObject.Format.Dsn6
})({
  apply({ a: a5 }) {
    return Task.create("Parse DSN6/BRIX", async (ctx) => {
      const parsed = await parse2(a5.data, a5.label).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      return new PluginStateObject.Format.Dsn6(parsed.result);
    });
  }
});
var ParseDx = PluginStateTransform.BuiltIn({
  name: "parse-dx",
  display: { name: "Parse DX", description: "Parse DX from Binary/String data" },
  from: [PluginStateObject.Data.Binary, PluginStateObject.Data.String],
  to: PluginStateObject.Format.Dx
})({
  apply({ a: a5 }) {
    return Task.create("Parse DX", async (ctx) => {
      const parsed = await parseDx(a5.data, a5.label).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      return new PluginStateObject.Format.Dx(parsed.result);
    });
  }
});
var ImportString = PluginStateTransform.BuiltIn({
  name: "import-string",
  display: { name: "Import String", description: "Import given data as a string" },
  from: PluginStateObject.Root,
  to: PluginStateObject.Data.String,
  params: {
    data: ParamDefinition.Value(""),
    label: ParamDefinition.Optional(ParamDefinition.Text(""))
  }
})({
  apply({ params: { data, label: label2 } }) {
    return new PluginStateObject.Data.String(data, { label: label2 || "" });
  },
  update({ oldParams, newParams, b: b5 }) {
    if (oldParams.data !== newParams.data)
      return Transformer.UpdateResult.Recreate;
    if (oldParams.label !== newParams.label) {
      b5.label = newParams.label || "";
      return Transformer.UpdateResult.Updated;
    }
    return Transformer.UpdateResult.Unchanged;
  },
  isSerializable: () => ({ isSerializable: false, reason: "Cannot serialize user imported strings." })
});
var ImportJson = PluginStateTransform.BuiltIn({
  name: "import-json",
  display: { name: "Import JSON", description: "Import given data as a JSON" },
  from: PluginStateObject.Root,
  to: PluginStateObject.Format.Json,
  params: {
    data: ParamDefinition.Value({}),
    label: ParamDefinition.Optional(ParamDefinition.Text(""))
  }
})({
  apply({ params: { data, label: label2 } }) {
    return new PluginStateObject.Format.Json(data, { label: label2 || "" });
  },
  update({ oldParams, newParams, b: b5 }) {
    if (oldParams.data !== newParams.data)
      return Transformer.UpdateResult.Recreate;
    if (oldParams.label !== newParams.label) {
      b5.label = newParams.label || "";
      return Transformer.UpdateResult.Updated;
    }
    return Transformer.UpdateResult.Unchanged;
  },
  isSerializable: () => ({ isSerializable: false, reason: "Cannot serialize user imported JSON." })
});
var ParseJson = PluginStateTransform.BuiltIn({
  name: "parse-json",
  display: { name: "Parse JSON", description: "Parse JSON from String data" },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Format.Json
})({
  apply({ a: a5 }) {
    return Task.create("Parse JSON", async (ctx) => {
      const json = await new Response(StringLike.toString(a5.data)).json();
      return new PluginStateObject.Format.Json(json);
    });
  }
});
var LazyVolume = PluginStateTransform.BuiltIn({
  name: "lazy-volume",
  display: { name: "Lazy Volume", description: "A placeholder for lazy loaded volume representation" },
  from: PluginStateObject.Root,
  to: PluginStateObject.Volume.Lazy,
  params: {
    url: ParamDefinition.Url(""),
    isBinary: ParamDefinition.Boolean(false),
    format: ParamDefinition.Text("ccp4"),
    // TODO: use Select based on available formats
    entryId: ParamDefinition.Value("", { isHidden: true }),
    isovalues: ParamDefinition.ObjectList({
      type: ParamDefinition.Text("relative"),
      // TODO: Select
      value: ParamDefinition.Numeric(0),
      color: ParamDefinition.Color(ColorNames.black),
      alpha: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.01 }),
      volumeIndex: ParamDefinition.Numeric(0)
    }, (e) => `${e.type} ${e.value}`)
  }
})({
  apply({ a: a5, params }) {
    return Task.create("Lazy Volume", async (ctx) => {
      const entryId = Array.isArray(params.entryId) ? params.entryId.join(", ") : params.entryId;
      return new PluginStateObject.Volume.Lazy(params, { label: `${entryId || params.url}`, description: "Lazy Volume" });
    });
  }
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms/model.js
var model_exports = {};
__export(model_exports, {
  CoordinatesFromDcd: () => CoordinatesFromDcd,
  CoordinatesFromLammpstraj: () => CoordinatesFromLammpstraj,
  CoordinatesFromNctraj: () => CoordinatesFromNctraj,
  CoordinatesFromTrr: () => CoordinatesFromTrr,
  CoordinatesFromXtc: () => CoordinatesFromXtc,
  CustomModelProperties: () => CustomModelProperties,
  CustomStructureProperties: () => CustomStructureProperties,
  ModelFromTrajectory: () => ModelFromTrajectory,
  ModelWithCoordinates: () => ModelWithCoordinates,
  MultiStructureSelectionFromBundle: () => MultiStructureSelectionFromBundle,
  MultiStructureSelectionFromExpression: () => MultiStructureSelectionFromExpression,
  ShapeFromPly: () => ShapeFromPly,
  StructureComplexElement: () => StructureComplexElement,
  StructureComplexElementTypes: () => StructureComplexElementTypes,
  StructureComponent: () => StructureComponent,
  StructureFromModel: () => StructureFromModel,
  StructureFromTrajectory: () => StructureFromTrajectory,
  StructureSelectionFromBundle: () => StructureSelectionFromBundle,
  StructureSelectionFromExpression: () => StructureSelectionFromExpression,
  StructureSelectionFromScript: () => StructureSelectionFromScript,
  TopologyFromPrmtop: () => TopologyFromPrmtop,
  TopologyFromPsf: () => TopologyFromPsf,
  TopologyFromTop: () => TopologyFromTop,
  TrajectoryFromBlob: () => TrajectoryFromBlob,
  TrajectoryFromCifCore: () => TrajectoryFromCifCore,
  TrajectoryFromCube: () => TrajectoryFromCube,
  TrajectoryFromGRO: () => TrajectoryFromGRO,
  TrajectoryFromLammpsData: () => TrajectoryFromLammpsData,
  TrajectoryFromLammpsTrajData: () => TrajectoryFromLammpsTrajData,
  TrajectoryFromMOL: () => TrajectoryFromMOL,
  TrajectoryFromMOL2: () => TrajectoryFromMOL2,
  TrajectoryFromMmCif: () => TrajectoryFromMmCif,
  TrajectoryFromModelAndCoordinates: () => TrajectoryFromModelAndCoordinates,
  TrajectoryFromPDB: () => TrajectoryFromPDB,
  TrajectoryFromSDF: () => TrajectoryFromSDF,
  TrajectoryFromXYZ: () => TrajectoryFromXYZ,
  TransformStructureConformation: () => TransformStructureConformation
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/dcd/parser.js
function _parseDcd(data) {
  const dv = new DataView(data.buffer);
  const header2 = /* @__PURE__ */ Object.create(null);
  const frames = [];
  let nextPos = 0;
  const intView = new Int32Array(data.buffer, 0, 23);
  const ef = intView[0] !== dv.getInt32(0);
  if (intView[0] !== 84) {
    const n = data.byteLength;
    for (let i = 0; i < n; i += 4) {
      dv.setFloat32(i, dv.getFloat32(i), true);
    }
  }
  if (intView[0] !== 84) {
    throw new Error("dcd bad format, header block start");
  }
  const formatString = String.fromCharCode(dv.getUint8(4), dv.getUint8(5), dv.getUint8(6), dv.getUint8(7));
  if (formatString !== "CORD") {
    throw new Error("dcd bad format, format string");
  }
  let isCharmm = false;
  let extraBlock = false;
  let fourDims = false;
  if (intView[22] !== 0) {
    isCharmm = true;
    if (intView[12] !== 0)
      extraBlock = true;
    if (intView[13] === 1)
      fourDims = true;
  }
  header2.NSET = intView[2];
  header2.ISTART = intView[3];
  header2.NSAVC = intView[4];
  header2.NAMNF = intView[10];
  if (isCharmm) {
    header2.DELTA = dv.getFloat32(44, ef);
  } else {
    header2.DELTA = dv.getFloat64(44, ef);
  }
  if (intView[22] !== 84) {
    throw new Error("dcd bad format, header block end");
  }
  nextPos = nextPos + 21 * 4 + 8;
  const titleEnd = dv.getInt32(nextPos, ef);
  const titleStart = nextPos + 1;
  if ((titleEnd - 4) % 80 !== 0) {
    throw new Error("dcd bad format, title block start");
  }
  header2.TITLE = uint8ToString(data.subarray(titleStart, titleEnd));
  if (dv.getInt32(titleStart + titleEnd + 4 - 1, ef) !== titleEnd) {
    throw new Error("dcd bad format, title block end");
  }
  nextPos = nextPos + titleEnd + 8;
  if (dv.getInt32(nextPos, ef) !== 4) {
    throw new Error("dcd bad format, natom block start");
  }
  header2.NATOM = dv.getInt32(nextPos + 4, ef);
  if (dv.getInt32(nextPos + 8, ef) !== 4) {
    throw new Error("dcd bad format, natom block end");
  }
  nextPos = nextPos + 4 + 8;
  if (header2.NAMNF > 0) {
    throw new Error("dcd format with fixed atoms unsupported, aborting");
  }
  const natom = header2.NATOM;
  const natom4 = natom * 4;
  for (let i = 0, n = header2.NSET; i < n; ++i) {
    const frame = /* @__PURE__ */ Object.create(null);
    frame.elementCount = natom;
    if (extraBlock) {
      nextPos += 4;
      frame.cell = [
        dv.getFloat64(nextPos, ef),
        dv.getFloat64(nextPos + 1, ef),
        dv.getFloat64(nextPos + 2 * 8, ef),
        dv.getFloat64(nextPos + 3 * 8, ef),
        dv.getFloat64(nextPos + 4 * 8, ef),
        dv.getFloat64(nextPos + 5 * 8, ef)
      ];
      nextPos += 48;
      nextPos += 4;
    }
    for (let j = 0; j < 3; ++j) {
      if (dv.getInt32(nextPos, ef) !== natom4) {
        throw new Error(`dcd bad format, coord block start: ${i}, ${j}`);
      }
      nextPos += 4;
      const c5 = new Float32Array(data.buffer, nextPos, natom);
      if (j === 0)
        frame.x = c5;
      else if (j === 1)
        frame.y = c5;
      else
        frame.z = c5;
      nextPos += natom4;
      if (dv.getInt32(nextPos, ef) !== natom4) {
        throw new Error(`dcd bad format, coord block end: ${i}, ${j}`);
      }
      nextPos += 4;
    }
    if (fourDims) {
      const bytes = dv.getInt32(nextPos, ef);
      nextPos += 4 + bytes + 4;
    }
    frames.push(frame);
  }
  return { header: header2, frames };
}
function parseDcd(data) {
  return Task.create("Parse DCD", async (ctx) => {
    try {
      const dcdFile = _parseDcd(data);
      return ReaderResult.success(dcdFile);
    } catch (e) {
      return ReaderResult.error(e);
    }
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/common/text/column/fixed.js
function FixedColumnProvider(lines) {
  return function(offset, width, type) {
    return FixedColumn(lines, offset, width, type);
  };
}
function FixedColumn(lines, offset, width, schema) {
  const { data, indices: indices2, count: rowCount } = lines;
  const { valueType: type } = schema;
  const value = type === "str" ? (row) => {
    const s = indices2[2 * row] + offset, le = indices2[2 * row + 1];
    if (s >= le)
      return "";
    let e = s + width;
    if (e > le)
      e = le;
    return trimStr(data, s, e);
  } : type === "int" ? (row) => {
    const s = indices2[2 * row] + offset;
    if (s > indices2[2 * row + 1])
      return 0;
    return parseIntSkipLeadingWhitespace(data, s, s + width);
  } : (row) => {
    const s = indices2[2 * row] + offset;
    if (s > indices2[2 * row + 1])
      return 0;
    return parseFloatSkipLeadingWhitespace(data, s, s + width);
  };
  return {
    schema,
    __array: void 0,
    isDefined: true,
    rowCount,
    value,
    valueKind: (row) => Column.ValueKinds.Present,
    toArray: (params) => column_helpers_exports.createAndFillArray(rowCount, value, params),
    areValuesEqual: (rowA, rowB) => value(rowA) === value(rowB)
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/gro/parser.js
function createEmptyHeader() {
  return {
    title: "",
    timeInPs: 0,
    hasVelocities: false,
    precision: { position: 0, velocity: 0 },
    box: [0, 0, 0]
  };
}
function State6(tokenizer, runtimeCtx) {
  return {
    tokenizer,
    header: createEmptyHeader(),
    numberOfAtoms: 0,
    runtimeCtx
  };
}
function handleTitleString(state) {
  const { tokenizer, header: header2 } = state;
  let line = Tokenizer.readLine(tokenizer);
  if (line.trim().length === 0) {
    line = Tokenizer.readLine(tokenizer);
  }
  const timeOffset = line.lastIndexOf("t=");
  if (timeOffset >= 0) {
    header2.timeInPs = parseFloat(line.substring(timeOffset + 2));
    header2.title = line.substring(0, timeOffset).trim();
    if (header2.title && header2.title[header2.title.length - 1] === ",") {
      header2.title = header2.title.substring(0, header2.title.length - 1);
    }
  } else {
    header2.title = line;
  }
}
function handleNumberOfAtoms(state) {
  const { tokenizer } = state;
  Tokenizer.markLine(tokenizer);
  const line = Tokenizer.getTokenString(tokenizer);
  state.numberOfAtoms = parseInt(line);
}
async function handleAtoms3(state) {
  const { tokenizer, numberOfAtoms } = state;
  const lines = await Tokenizer.readLinesAsync(tokenizer, numberOfAtoms, state.runtimeCtx, 1e5);
  const positionSample = tokenizer.data.substring(lines.indices[0], lines.indices[1]).substring(20);
  const precisions = positionSample.match(/\.\d+/g);
  const hasVelocities = precisions.length === 6;
  state.header.hasVelocities = hasVelocities;
  state.header.precision.position = precisions[0].length - 1;
  state.header.precision.velocity = hasVelocities ? precisions[3].length - 1 : 0;
  const pO = 20;
  const pW = state.header.precision.position + 5;
  const vO = pO + 3 * pW;
  const vW = state.header.precision.velocity + 4;
  const col = FixedColumnProvider(lines);
  const undef = Column.Undefined(state.numberOfAtoms, Column.Schema.float);
  const ret = {
    count: state.numberOfAtoms,
    residueNumber: col(0, 5, Column.Schema.int),
    residueName: col(5, 5, Column.Schema.str),
    atomName: col(10, 5, Column.Schema.str),
    atomNumber: col(15, 5, Column.Schema.int),
    x: col(pO, pW, Column.Schema.float),
    y: col(pO + pW, pW, Column.Schema.float),
    z: col(pO + 2 * pW, pW, Column.Schema.float),
    vx: hasVelocities ? col(vO, vW, Column.Schema.float) : undef,
    vy: hasVelocities ? col(vO + vW, vW, Column.Schema.float) : undef,
    vz: hasVelocities ? col(vO + 2 * vW, vW, Column.Schema.float) : undef
  };
  return ret;
}
function handleBoxVectors(state) {
  const { tokenizer } = state;
  const values2 = Tokenizer.readLine(tokenizer).trim().split(/\s+/g);
  state.header.box = [+values2[0], +values2[1], +values2[2]];
}
async function parseInternal7(data, ctx) {
  const tokenizer = Tokenizer(data);
  await ctx.update({ message: "Parsing...", current: 0, max: data.length });
  const structures = [];
  while (tokenizer.position < data.length) {
    const state = State6(tokenizer, ctx);
    handleTitleString(state);
    handleNumberOfAtoms(state);
    const atoms = await handleAtoms3(state);
    handleBoxVectors(state);
    structures.push({ header: state.header, atoms });
  }
  const result = { structures };
  return ReaderResult.success(result);
}
function parseGRO(data) {
  return Task.create("Parse GRO", async (ctx) => {
    return await parseInternal7(data, ctx);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/pdb/parser.js
function parsePDB(data, id, isPdbqt = false) {
  return Task.create("Parse PDB", async (ctx) => ReaderResult.success({
    lines: await Tokenizer.readAllLinesAsync(data, ctx),
    id,
    isPdbqt
  }));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/util.js
function normalizeVec3Array(a5, count3) {
  for (let i = 0, il = count3 * 3; i < il; i += 3) {
    const x = a5[i];
    const y = a5[i + 1];
    const z = a5[i + 2];
    const s = 1 / Math.sqrt(x * x + y * y + z * z);
    a5[i] = x * s;
    a5[i + 1] = y * s;
    a5[i + 2] = z * s;
  }
  return a5;
}
var tmpV3 = Vec3();
function transformPositionArray(t2, array, offset, count3) {
  for (let i = 0, il = count3 * 3; i < il; i += 3) {
    Vec3.fromArray(tmpV3, array, offset + i);
    Vec3.transformMat4(tmpV3, tmpV3, t2);
    Vec3.toArray(tmpV3, array, offset + i);
  }
}
function transformDirectionArray(n, array, offset, count3) {
  for (let i = 0, il = count3 * 3; i < il; i += 3) {
    Vec3.fromArray(tmpV3, array, offset + i);
    Vec3.transformMat3(tmpV3, tmpV3, n);
    Vec3.toArray(tmpV3, array, offset + i);
  }
}
function appplyRadius(vertices2, radius) {
  for (let i = 0, il = vertices2.length; i < il; i += 3) {
    Vec3.fromArray(tmpV3, vertices2, i);
    Vec3.normalize(tmpV3, tmpV3);
    Vec3.scale(tmpV3, tmpV3, radius);
    Vec3.toArray(tmpV3, vertices2, i);
  }
}
var a = Vec3();
var b = Vec3();
var c = Vec3();
var cb = Vec3();
var ab = Vec3();
function computeIndexedVertexNormals(vertices2, indices2, normals, vertexCount, triangleCount) {
  for (let i = 0, il = triangleCount * 3; i < il; i += 3) {
    const ai = indices2[i] * 3;
    const bi = indices2[i + 1] * 3;
    const ci = indices2[i + 2] * 3;
    Vec3.fromArray(a, vertices2, ai);
    Vec3.fromArray(b, vertices2, bi);
    Vec3.fromArray(c, vertices2, ci);
    Vec3.sub(cb, c, b);
    Vec3.sub(ab, a, b);
    Vec3.cross(cb, cb, ab);
    normals[ai] += cb[0];
    normals[ai + 1] += cb[1];
    normals[ai + 2] += cb[2];
    normals[bi] += cb[0];
    normals[bi + 1] += cb[1];
    normals[bi + 2] += cb[2];
    normals[ci] += cb[0];
    normals[ci + 1] += cb[1];
    normals[ci + 2] += cb[2];
  }
  return normalizeVec3Array(normals, vertexCount);
}
function createGroupMapping(groups, dataCount, step = 1) {
  const maxId = arrayMax(groups);
  const offsets = new Int32Array(maxId + 2);
  const bucketFill = new Int32Array(dataCount);
  const bucketSizes = new Int32Array(dataCount);
  for (let i = 0, il = dataCount * step; i < il; i += step)
    ++bucketSizes[groups[i]];
  let offset = 0;
  for (let i = 0; i < dataCount; i++) {
    offsets[i] = offset;
    offset += bucketSizes[i];
  }
  offsets[dataCount] = offset;
  const indices2 = new Int32Array(offset);
  for (let i = 0, il = dataCount * step; i < il; i += step) {
    const g = groups[i];
    const og = offsets[g] + bucketFill[g];
    indices2[og] = i;
    ++bucketFill[g];
  }
  return { indices: indices2, offsets };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable/util.js
var v3fromArray = Vec3.fromArray;
var v3transformMat4Offset = Vec3.transformMat4Offset;
function calculateTextureInfo(n, itemSize) {
  n = Math.max(n, 2);
  const sqN = Math.sqrt(n);
  let width = Math.ceil(sqN);
  width = width + (itemSize - width % itemSize) % itemSize;
  const height = width > 0 ? Math.ceil(n / width) : 0;
  return { width, height, length: width * height * itemSize };
}
function createTextureImage(n, itemSize, arrayCtor, array) {
  const { length, width, height } = calculateTextureInfo(n, itemSize);
  array = array && array.length >= length ? array : new arrayCtor(length);
  return { array, width, height };
}
var v = Vec3();
var boundaryHelperCoarse = new BoundaryHelper("14");
var boundaryHelperFine = new BoundaryHelper("98");
function getHelper(count3) {
  return count3 > 1e5 ? boundaryHelperCoarse : boundaryHelperFine;
}
function calculateInvariantBoundingSphere(position, positionCount, stepFactor) {
  const step = stepFactor * 3;
  const boundaryHelper2 = getHelper(positionCount);
  boundaryHelper2.reset();
  for (let i = 0, _i = positionCount * 3; i < _i; i += step) {
    v3fromArray(v, position, i);
    boundaryHelper2.includePosition(v);
  }
  boundaryHelper2.finishedIncludeStep();
  for (let i = 0, _i = positionCount * 3; i < _i; i += step) {
    v3fromArray(v, position, i);
    boundaryHelper2.radiusPosition(v);
  }
  const sphere = boundaryHelper2.getSphere();
  if (positionCount <= 14) {
    const extrema = [];
    for (let i = 0, _i = positionCount * 3; i < _i; i += step) {
      extrema.push(v3fromArray(Vec3(), position, i));
    }
    Sphere3D.setExtrema(sphere, extrema);
  }
  return sphere;
}
var _mat4 = Mat4();
function calculateTransformBoundingSphere(invariantBoundingSphere, transform, transformCount, transformOffset) {
  if (transformCount === 1) {
    Mat4.fromArray(_mat4, transform, transformOffset);
    const s = Sphere3D.clone(invariantBoundingSphere);
    return Mat4.isIdentity(_mat4) ? s : Sphere3D.transform(s, s, _mat4);
  }
  const boundaryHelper2 = getHelper(transformCount);
  boundaryHelper2.reset();
  const { center, radius, extrema } = invariantBoundingSphere;
  if (extrema && transformCount <= 14) {
    for (let i = 0, _i = transformCount; i < _i; ++i) {
      for (const e of extrema) {
        v3transformMat4Offset(v, e, transform, 0, 0, i * 16 + transformOffset);
        boundaryHelper2.includePosition(v);
      }
    }
    boundaryHelper2.finishedIncludeStep();
    for (let i = 0, _i = transformCount; i < _i; ++i) {
      for (const e of extrema) {
        v3transformMat4Offset(v, e, transform, 0, 0, i * 16 + transformOffset);
        boundaryHelper2.radiusPosition(v);
      }
    }
  } else {
    for (let i = 0, _i = transformCount; i < _i; ++i) {
      v3transformMat4Offset(v, center, transform, 0, 0, i * 16 + transformOffset);
      boundaryHelper2.includePositionRadius(v, radius);
    }
    boundaryHelper2.finishedIncludeStep();
    for (let i = 0, _i = transformCount; i < _i; ++i) {
      v3transformMat4Offset(v, center, transform, 0, 0, i * 16 + transformOffset);
      boundaryHelper2.radiusPositionRadius(v, radius);
    }
  }
  return boundaryHelper2.getSphere();
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/marker-data.js
var MarkerCountLut = new Uint8Array(771 + 1);
MarkerCountLut[1] = 1;
MarkerCountLut[2] = 1;
MarkerCountLut[3] = 1;
MarkerCountLut[256] = 1;
MarkerCountLut[512] = 1;
MarkerCountLut[768] = 1;
MarkerCountLut[257] = 2;
MarkerCountLut[513] = 2;
MarkerCountLut[769] = 2;
MarkerCountLut[258] = 2;
MarkerCountLut[514] = 2;
MarkerCountLut[770] = 2;
MarkerCountLut[259] = 2;
MarkerCountLut[515] = 2;
MarkerCountLut[771] = 2;
function getMarkersAverage(array, count3) {
  if (count3 === 0)
    return 0;
  const view = new Uint32Array(array.buffer, 0, array.buffer.byteLength >> 2);
  const viewEnd = count3 - 4 >> 2;
  const backStart = 4 * viewEnd;
  let sum = 0;
  if (viewEnd < 0) {
    for (let i = 0; i < count3; ++i) {
      sum += array[i] && 1;
    }
  } else {
    for (let i = 0; i < viewEnd; ++i) {
      const v3 = view[i];
      sum += MarkerCountLut[v3 & 65535] + MarkerCountLut[v3 >> 16];
    }
    for (let i = backStart; i < count3; ++i) {
      sum += array[i] && 1;
    }
  }
  return sum / count3;
}
function createMarkers(count3, type, markerData) {
  const markers = createTextureImage(Math.max(1, count3), 1, Uint8Array, markerData && markerData.tMarker.ref.value.array);
  const average = getMarkersAverage(markers.array, count3);
  const status = average === 0 ? 0 : -1;
  if (markerData) {
    ValueCell.updateIfChanged(markerData.uMarker, 0);
    ValueCell.update(markerData.tMarker, markers);
    ValueCell.update(markerData.uMarkerTexDim, Vec2.create(markers.width, markers.height));
    ValueCell.updateIfChanged(markerData.markerAverage, average);
    ValueCell.updateIfChanged(markerData.markerStatus, status);
    ValueCell.updateIfChanged(markerData.dMarkerType, type);
    return markerData;
  } else {
    return {
      uMarker: ValueCell.create(0),
      tMarker: ValueCell.create(markers),
      uMarkerTexDim: ValueCell.create(Vec2.create(markers.width, markers.height)),
      markerAverage: ValueCell.create(average),
      markerStatus: ValueCell.create(status),
      dMarkerType: ValueCell.create(type)
    };
  }
}
var emptyMarkerTexture = { array: new Uint8Array(1), width: 1, height: 1 };

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/location.js
var NullLocation = { kind: "null-location" };
function DataLocation(tag, data, element) {
  return { kind: "data-location", tag, data, element };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/util/location-iterator.js
function LocationIterator(groupCount, instanceCount, stride, getLocation, nonInstanceable = false, isSecondary = () => false, getLocation2) {
  if (groupCount % stride !== 0) {
    throw new Error("incompatible groupCount and stride");
  }
  const value = {
    location: NullLocation,
    location2: NullLocation,
    index: 0,
    groupIndex: 0,
    instanceIndex: 0,
    isSecondary: false
  };
  let hasNext = value.groupIndex < groupCount;
  let isNextNewInstance = false;
  let groupIndex = 0;
  let instanceIndex = 0;
  let voidInstances = false;
  const hasLocation2 = !!getLocation2;
  return {
    get hasNext() {
      return hasNext;
    },
    get isNextNewInstance() {
      return isNextNewInstance;
    },
    groupCount,
    instanceCount,
    count: groupCount * instanceCount,
    stride,
    nonInstanceable,
    hasLocation2,
    move() {
      if (hasNext) {
        value.groupIndex = groupIndex;
        value.instanceIndex = instanceIndex;
        value.index = instanceIndex * groupCount + groupIndex;
        value.location = getLocation(groupIndex, voidInstances ? -1 : instanceIndex);
        if (hasLocation2)
          value.location2 = getLocation2(groupIndex, voidInstances ? -1 : instanceIndex);
        value.isSecondary = isSecondary(groupIndex, voidInstances ? -1 : instanceIndex);
        groupIndex += stride;
        if (groupIndex === groupCount) {
          ++instanceIndex;
          isNextNewInstance = true;
          if (instanceIndex < instanceCount)
            groupIndex = 0;
        } else {
          isNextNewInstance = false;
        }
        hasNext = groupIndex < groupCount;
      }
      return value;
    },
    reset() {
      value.location = NullLocation;
      value.location2 = NullLocation;
      value.index = 0;
      value.groupIndex = 0;
      value.instanceIndex = 0;
      value.isSecondary = false;
      hasNext = value.groupIndex < groupCount;
      isNextNewInstance = false;
      groupIndex = 0;
      instanceIndex = 0;
      voidInstances = false;
    },
    skipInstance() {
      if (hasNext && value.instanceIndex === instanceIndex) {
        ++instanceIndex;
        groupIndex = 0;
        hasNext = instanceIndex < instanceCount;
      }
    },
    voidInstances() {
      voidInstances = true;
    }
  };
}
var EmptyLocationIterator = {
  get hasNext() {
    return false;
  },
  get isNextNewInstance() {
    return false;
  },
  groupCount: 0,
  instanceCount: 0,
  count: 0,
  stride: 0,
  nonInstanceable: false,
  hasLocation2: false,
  move() {
    return {
      location: NullLocation,
      location2: NullLocation,
      index: 0,
      groupIndex: 0,
      instanceIndex: 0,
      isSecondary: false
    };
  },
  reset() {
  },
  skipInstance() {
  },
  voidInstances() {
  }
};
function PositionLocation(position, normal) {
  return {
    kind: "position-location",
    position: position ? Vec3.clone(position) : Vec3(),
    normal: normal ? Vec3.clone(normal) : Vec3()
  };
}
function isPositionLocation(x) {
  return !!x && x.kind === "position-location";
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/framebuffer.js
var getNextFramebufferId = idFactory();
function getFramebufferStatusDescription(gl, status) {
  switch (status) {
    case gl.FRAMEBUFFER_COMPLETE:
      return "complete";
    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      return "incomplete attachment";
    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
      return "incomplete missing attachment";
    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
      return "incomplete dimensions";
    case gl.FRAMEBUFFER_UNSUPPORTED:
      return "unsupported";
  }
  if (isWebGL2(gl)) {
    switch (status) {
      case gl.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:
        return "incomplete multisample";
      case gl.RENDERBUFFER_SAMPLES:
        return "renderbuffer samples";
    }
  }
  return "unknown error";
}
function checkFramebufferStatus(gl) {
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  if (status !== gl.FRAMEBUFFER_COMPLETE) {
    const description = getFramebufferStatusDescription(gl, status);
    throw new Error(`Framebuffer status: ${description}`);
  }
}
function getFramebuffer(gl) {
  const framebuffer = gl.createFramebuffer();
  if (framebuffer === null) {
    throw new Error("Could not create WebGL framebuffer");
  }
  return framebuffer;
}
function createFramebuffer(gl) {
  let _framebuffer = getFramebuffer(gl);
  let destroyed = false;
  return {
    id: getNextFramebufferId(),
    bind: () => gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer),
    reset: () => {
      _framebuffer = getFramebuffer(gl);
    },
    destroy: () => {
      if (destroyed)
        return;
      gl.deleteFramebuffer(_framebuffer);
      destroyed = true;
    }
  };
}
function createNullFramebuffer() {
  return {
    id: getNextFramebufferId(),
    bind: () => {
    },
    reset: () => {
    },
    destroy: () => {
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/extensions.js
function createExtensions(gl) {
  const instancedArrays = getInstancedArrays(gl);
  if (instancedArrays === null) {
    throw new Error('Could not find support for "instanced_arrays"');
  }
  const elementIndexUint = getElementIndexUint(gl);
  if (elementIndexUint === null) {
    throw new Error('Could not find support for "element_index_uint"');
  }
  const standardDerivatives = getStandardDerivatives(gl);
  if (standardDerivatives === null) {
    throw new Error('Could not find support for "standard_derivatives"');
  }
  const textureFloat = getTextureFloat(gl);
  if (isDebugMode && textureFloat === null) {
    console.log('Could not find support for "texture_float"');
  }
  const textureFloatLinear = getTextureFloatLinear(gl);
  if (isDebugMode && textureFloatLinear === null) {
    console.log('Could not find support for "texture_float_linear"');
  }
  const textureHalfFloat = getTextureHalfFloat(gl);
  if (isDebugMode && textureHalfFloat === null) {
    console.log('Could not find support for "texture_half_float"');
  }
  const textureHalfFloatLinear = getTextureHalfFloatLinear(gl);
  if (isDebugMode && textureHalfFloatLinear === null) {
    console.log('Could not find support for "texture_half_float_linear"');
  }
  const depthTexture = getDepthTexture(gl);
  if (isDebugMode && depthTexture === null) {
    console.log('Could not find support for "depth_texture"');
  }
  const blendMinMax = getBlendMinMax(gl);
  if (isDebugMode && blendMinMax === null) {
    console.log('Could not find support for "blend_minmax"');
  }
  const vertexArrayObject = getVertexArrayObject(gl);
  if (isDebugMode && vertexArrayObject === null) {
    console.log('Could not find support for "vertex_array_object"');
  }
  const fragDepth = getFragDepth(gl);
  if (isDebugMode && fragDepth === null) {
    console.log('Could not find support for "frag_depth"');
  }
  const colorBufferFloat = getColorBufferFloat(gl);
  if (isDebugMode && colorBufferFloat === null) {
    console.log('Could not find support for "color_buffer_float"');
  }
  const colorBufferHalfFloat = getColorBufferHalfFloat(gl);
  if (isDebugMode && colorBufferHalfFloat === null) {
    console.log('Could not find support for "color_buffer_half_float"');
  }
  const drawBuffers = getDrawBuffers(gl);
  if (isDebugMode && drawBuffers === null) {
    console.log('Could not find support for "draw_buffers"');
  }
  const drawBuffersIndexed = getDrawBuffersIndexed(gl);
  if (isDebugMode && drawBuffersIndexed === null) {
    console.log('Could not find support for "draw_buffers_indexed"');
  }
  const shaderTextureLod = getShaderTextureLod(gl);
  if (isDebugMode && shaderTextureLod === null) {
    console.log('Could not find support for "shader_texture_lod"');
  }
  const sRGB = getSRGB(gl);
  if (isDebugMode && sRGB === null) {
    console.log('Could not find support for "sRGB"');
  }
  const disjointTimerQuery = getDisjointTimerQuery(gl);
  if (isDebugMode && disjointTimerQuery === null) {
    console.log('Could not find support for "disjoint_timer_query"');
  }
  const multiDraw = getMultiDraw(gl);
  if (isDebugMode && multiDraw === null) {
    console.log('Could not find support for "multi_draw"');
  }
  const drawInstancedBaseVertexBaseInstance = getDrawInstancedBaseVertexBaseInstance(gl);
  if (isDebugMode && drawInstancedBaseVertexBaseInstance === null) {
    console.log('Could not find support for "draw_instanced_base_vertex_base_instance"');
  }
  const multiDrawInstancedBaseVertexBaseInstance = getMultiDrawInstancedBaseVertexBaseInstance(gl);
  if (isDebugMode && multiDrawInstancedBaseVertexBaseInstance === null) {
    console.log('Could not find support for "multi_draw_instanced_base_vertex_base_instance"');
  }
  const parallelShaderCompile = getParallelShaderCompile(gl);
  if (isDebugMode && parallelShaderCompile === null) {
    console.log('Could not find support for "parallel_shader_compile"');
  }
  const fboRenderMipmap = getFboRenderMipmap(gl);
  if (isDebugMode && fboRenderMipmap === null) {
    console.log('Could not find support for "fbo_render_mipmap"');
  }
  const provokingVertex = getProvokingVertex(gl);
  if (isDebugMode && provokingVertex === null) {
    console.log('Could not find support for "provoking_vertex"');
  }
  const clipCullDistance = getClipCullDistance(gl);
  if (isDebugMode && clipCullDistance === null) {
    console.log('Could not find support for "clip_cull_distance"');
  }
  const conservativeDepth = getConservativeDepth(gl);
  if (isDebugMode && conservativeDepth === null) {
    console.log('Could not find support for "conservative_depth"');
  }
  const stencilTexturing = getStencilTexturing(gl);
  if (isDebugMode && stencilTexturing === null) {
    console.log('Could not find support for "stencil_texturing"');
  }
  const clipControl = getClipControl(gl);
  if (isDebugMode && clipControl === null) {
    console.log('Could not find support for "clip_control"');
  }
  const renderSnorm = getRenderSnorm(gl);
  if (isDebugMode && renderSnorm === null) {
    console.log('Could not find support for "render_snorm"');
  }
  const renderSharedExponent = getRenderSharedExponent(gl);
  if (isDebugMode && renderSharedExponent === null) {
    console.log('Could not find support for "render_shared_exponent"');
  }
  const textureNorm16 = getTextureNorm16(gl);
  if (isDebugMode && textureNorm16 === null) {
    console.log('Could not find support for "texture_norm16"');
  }
  const depthClamp = getDepthClamp(gl);
  if (isDebugMode && depthClamp === null) {
    console.log('Could not find support for "depth_clamp"');
  }
  const noNonInstancedActiveAttribs = getNoNonInstancedActiveAttribs(gl);
  return {
    instancedArrays,
    standardDerivatives,
    elementIndexUint,
    textureFloat,
    textureFloatLinear,
    textureHalfFloat,
    textureHalfFloatLinear,
    depthTexture,
    blendMinMax,
    vertexArrayObject,
    fragDepth,
    colorBufferFloat,
    colorBufferHalfFloat,
    drawBuffers,
    drawBuffersIndexed,
    shaderTextureLod,
    sRGB,
    disjointTimerQuery,
    multiDraw,
    drawInstancedBaseVertexBaseInstance,
    multiDrawInstancedBaseVertexBaseInstance,
    parallelShaderCompile,
    fboRenderMipmap,
    provokingVertex,
    clipCullDistance,
    conservativeDepth,
    stencilTexturing,
    clipControl,
    renderSnorm,
    renderSharedExponent,
    textureNorm16,
    depthClamp,
    noNonInstancedActiveAttribs
  };
}
function resetExtensions(gl, extensions) {
  const e = createExtensions(gl);
  objectForEach(extensions, (v3, k) => {
    if (k === "noNonInstancedActiveAttribs") {
      extensions.noNonInstancedActiveAttribs = e.noNonInstancedActiveAttribs;
    } else if (v3 !== null) {
      if (e[k] === null) {
        extensions[k] = null;
      } else {
        Object.assign(v3, e[k]);
      }
    }
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/state.js
function createState(gl, e) {
  let enabledCapabilities = {};
  let currentFrontFace = gl.getParameter(gl.FRONT_FACE);
  let currentCullFace = gl.getParameter(gl.CULL_FACE_MODE);
  let currentDepthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
  let currentClearDepth = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
  let currentDepthFunc = gl.getParameter(gl.DEPTH_FUNC);
  let currentColorMask = gl.getParameter(gl.COLOR_WRITEMASK);
  let currentClearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
  let currentBlendSrcRGB = gl.getParameter(gl.BLEND_SRC_RGB);
  let currentBlendDstRGB = gl.getParameter(gl.BLEND_DST_RGB);
  let currentBlendSrcAlpha = gl.getParameter(gl.BLEND_SRC_ALPHA);
  let currentBlendDstAlpha = gl.getParameter(gl.BLEND_DST_ALPHA);
  let currentBlendColor = gl.getParameter(gl.BLEND_COLOR);
  let currentBlendEqRGB = gl.getParameter(gl.BLEND_EQUATION_RGB);
  let currentBlendEqAlpha = gl.getParameter(gl.BLEND_EQUATION_ALPHA);
  let currentStencilFunc = gl.getParameter(gl.STENCIL_FUNC);
  let currentStencilValueMask = gl.getParameter(gl.STENCIL_VALUE_MASK);
  let currentStencilRef = gl.getParameter(gl.STENCIL_REF);
  let currentStencilBackFunc = gl.getParameter(gl.STENCIL_BACK_FUNC);
  let currentStencilBackValueMask = gl.getParameter(gl.STENCIL_BACK_VALUE_MASK);
  let currentStencilBackRef = gl.getParameter(gl.STENCIL_BACK_REF);
  let currentStencilWriteMask = gl.getParameter(gl.STENCIL_WRITEMASK);
  let currentStencilBackWriteMask = gl.getParameter(gl.STENCIL_BACK_WRITEMASK);
  let currentStencilFail = gl.getParameter(gl.STENCIL_FAIL);
  let currentStencilPassDepthPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);
  let currentStencilPassDepthFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);
  let currentStencilBackFail = gl.getParameter(gl.STENCIL_BACK_FAIL);
  let currentStencilBackPassDepthPass = gl.getParameter(gl.STENCIL_BACK_PASS_DEPTH_PASS);
  let currentStencilBackPassDepthFail = gl.getParameter(gl.STENCIL_BACK_PASS_DEPTH_FAIL);
  let maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const vertexAttribsState = [];
  let currentViewport = gl.getParameter(gl.VIEWPORT);
  let currentScissor = gl.getParameter(gl.SCISSOR_BOX);
  let currentClipOrigin = e.clipControl ? gl.getParameter(e.clipControl.CLIP_ORIGIN) : -1;
  let currentClipDepthMode = e.clipControl ? gl.getParameter(e.clipControl.CLIP_DEPTH_MODE) : -1;
  const clearVertexAttribsState = () => {
    for (let i = 0; i < maxVertexAttribs; ++i) {
      vertexAttribsState[i] = 0;
    }
  };
  clearVertexAttribsState();
  return {
    currentProgramId: -1,
    currentMaterialId: -1,
    currentRenderItemId: -1,
    enable: (cap) => {
      if (enabledCapabilities[cap] !== true) {
        gl.enable(cap);
        enabledCapabilities[cap] = true;
      }
    },
    disable: (cap) => {
      if (enabledCapabilities[cap] !== false) {
        gl.disable(cap);
        enabledCapabilities[cap] = false;
      }
    },
    frontFace: (mode) => {
      if (mode !== currentFrontFace) {
        gl.frontFace(mode);
        currentFrontFace = mode;
      }
    },
    cullFace: (mode) => {
      if (mode !== currentCullFace) {
        gl.cullFace(mode);
        currentCullFace = mode;
      }
    },
    depthMask: (flag) => {
      if (flag !== currentDepthMask) {
        gl.depthMask(flag);
        currentDepthMask = flag;
      }
    },
    clearDepth: (depth) => {
      if (depth !== currentClearDepth) {
        gl.clearDepth(depth);
        currentClearDepth = depth;
      }
    },
    depthFunc: (func) => {
      if (func !== currentDepthFunc) {
        gl.depthFunc(func);
        currentDepthFunc = func;
      }
    },
    colorMask: (red, green, blue, alpha) => {
      if (red !== currentColorMask[0] || green !== currentColorMask[1] || blue !== currentColorMask[2] || alpha !== currentColorMask[3]) {
        gl.colorMask(red, green, blue, alpha);
        currentColorMask[0] = red;
        currentColorMask[1] = green;
        currentColorMask[2] = blue;
        currentColorMask[3] = alpha;
      }
    },
    clearColor: (red, green, blue, alpha) => {
      if (red !== currentClearColor[0] || green !== currentClearColor[1] || blue !== currentClearColor[2] || alpha !== currentClearColor[3]) {
        gl.clearColor(red, green, blue, alpha);
        currentClearColor[0] = red;
        currentClearColor[1] = green;
        currentClearColor[2] = blue;
        currentClearColor[3] = alpha;
      }
    },
    blendFunc: (src, dst) => {
      if (src !== currentBlendSrcRGB || dst !== currentBlendDstRGB || src !== currentBlendSrcAlpha || dst !== currentBlendDstAlpha) {
        gl.blendFunc(src, dst);
        currentBlendSrcRGB = src;
        currentBlendDstRGB = dst;
        currentBlendSrcAlpha = src;
        currentBlendDstAlpha = dst;
      }
    },
    blendFuncSeparate: (srcRGB, dstRGB, srcAlpha, dstAlpha) => {
      if (srcRGB !== currentBlendSrcRGB || dstRGB !== currentBlendDstRGB || srcAlpha !== currentBlendSrcAlpha || dstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
        currentBlendSrcRGB = srcRGB;
        currentBlendDstRGB = dstRGB;
        currentBlendSrcAlpha = srcAlpha;
        currentBlendDstAlpha = dstAlpha;
      }
    },
    blendEquation: (mode) => {
      if (mode !== currentBlendEqRGB || mode !== currentBlendEqAlpha) {
        gl.blendEquation(mode);
        currentBlendEqRGB = mode;
        currentBlendEqAlpha = mode;
      }
    },
    blendEquationSeparate: (modeRGB, modeAlpha) => {
      if (modeRGB !== currentBlendEqRGB || modeAlpha !== currentBlendEqAlpha) {
        gl.blendEquationSeparate(modeRGB, modeAlpha);
        currentBlendEqRGB = modeRGB;
        currentBlendEqAlpha = modeAlpha;
      }
    },
    blendColor: (red, green, blue, alpha) => {
      if (red !== currentBlendColor[0] || green !== currentBlendColor[1] || blue !== currentBlendColor[2] || alpha !== currentBlendColor[3]) {
        gl.blendColor(red, green, blue, alpha);
        currentBlendColor[0] = red;
        currentBlendColor[1] = green;
        currentBlendColor[2] = blue;
        currentBlendColor[3] = alpha;
      }
    },
    stencilFunc: (func, ref, mask) => {
      if (func !== currentStencilFunc || ref !== currentStencilRef || mask !== currentStencilValueMask || func !== currentStencilBackFunc || ref !== currentStencilBackRef || mask !== currentStencilBackValueMask) {
        gl.stencilFunc(func, ref, mask);
        currentStencilFunc = func;
        currentStencilRef = ref;
        currentStencilValueMask = mask;
        currentStencilBackFunc = func;
        currentStencilBackRef = ref;
        currentStencilBackValueMask = mask;
      }
    },
    stencilFuncSeparate: (face, func, ref, mask) => {
      if (face === gl.FRONT) {
        if (func !== currentStencilFunc || ref !== currentStencilRef || mask !== currentStencilValueMask) {
          gl.stencilFuncSeparate(face, func, ref, mask);
          currentStencilFunc = func;
          currentStencilRef = ref;
          currentStencilValueMask = mask;
        }
      } else if (face === gl.BACK) {
        if (func !== currentStencilBackFunc || ref !== currentStencilBackRef || mask !== currentStencilBackValueMask) {
          gl.stencilFuncSeparate(face, func, ref, mask);
          currentStencilBackFunc = func;
          currentStencilBackRef = ref;
          currentStencilBackValueMask = mask;
        }
      } else if (face === gl.FRONT_AND_BACK) {
        if (func !== currentStencilFunc || ref !== currentStencilRef || mask !== currentStencilValueMask || func !== currentStencilBackFunc || ref !== currentStencilBackRef || mask !== currentStencilBackValueMask) {
          gl.stencilFuncSeparate(face, func, ref, mask);
          currentStencilFunc = func;
          currentStencilRef = ref;
          currentStencilValueMask = mask;
          currentStencilBackFunc = func;
          currentStencilBackRef = ref;
          currentStencilBackValueMask = mask;
        }
      }
    },
    stencilMask: (mask) => {
      if (mask !== currentStencilWriteMask || mask !== currentStencilBackWriteMask) {
        gl.stencilMask(mask);
        currentStencilWriteMask = mask;
        currentStencilBackWriteMask = mask;
      }
    },
    stencilMaskSeparate: (face, mask) => {
      if (face === gl.FRONT) {
        if (mask !== currentStencilWriteMask) {
          gl.stencilMaskSeparate(face, mask);
          currentStencilWriteMask = mask;
        }
      } else if (face === gl.BACK) {
        if (mask !== currentStencilBackWriteMask) {
          gl.stencilMaskSeparate(face, mask);
          currentStencilBackWriteMask = mask;
        }
      } else if (face === gl.FRONT_AND_BACK) {
        if (mask !== currentStencilWriteMask || mask !== currentStencilBackWriteMask) {
          gl.stencilMaskSeparate(face, mask);
          currentStencilWriteMask = mask;
          currentStencilBackWriteMask = mask;
        }
      }
    },
    stencilOp: (fail, zfail, zpass) => {
      if (fail !== currentStencilFail || zfail !== currentStencilPassDepthFail || zpass !== currentStencilPassDepthPass || fail !== currentStencilBackFail || zfail !== currentStencilBackPassDepthFail || zpass !== currentStencilBackPassDepthPass) {
        gl.stencilOp(fail, zfail, zpass);
        currentStencilFail = fail;
        currentStencilPassDepthFail = zfail;
        currentStencilPassDepthPass = zpass;
        currentStencilBackFail = fail;
        currentStencilBackPassDepthFail = zfail;
        currentStencilBackPassDepthPass = zpass;
      }
    },
    stencilOpSeparate: (face, fail, zfail, zpass) => {
      if (face === gl.FRONT) {
        if (fail !== currentStencilFail || zfail !== currentStencilPassDepthFail || zpass !== currentStencilPassDepthPass) {
          gl.stencilOpSeparate(face, fail, zfail, zpass);
          currentStencilFail = fail;
          currentStencilPassDepthFail = zfail;
          currentStencilPassDepthPass = zpass;
        }
      } else if (face === gl.BACK) {
        if (fail !== currentStencilBackFail || zfail !== currentStencilBackPassDepthFail || zpass !== currentStencilBackPassDepthPass) {
          gl.stencilOpSeparate(face, fail, zfail, zpass);
          currentStencilBackFail = fail;
          currentStencilBackPassDepthFail = zfail;
          currentStencilBackPassDepthPass = zpass;
        }
      } else if (face === gl.FRONT_AND_BACK) {
        if (fail !== currentStencilFail || zfail !== currentStencilPassDepthFail || zpass !== currentStencilPassDepthPass || fail !== currentStencilBackFail || zfail !== currentStencilBackPassDepthFail || zpass !== currentStencilBackPassDepthPass) {
          gl.stencilOpSeparate(face, fail, zfail, zpass);
          currentStencilFail = fail;
          currentStencilPassDepthFail = zfail;
          currentStencilPassDepthPass = zpass;
          currentStencilBackFail = fail;
          currentStencilBackPassDepthFail = zfail;
          currentStencilBackPassDepthPass = zpass;
        }
      }
    },
    enableVertexAttrib: (index) => {
      gl.enableVertexAttribArray(index);
      vertexAttribsState[index] = 1;
    },
    clearVertexAttribsState,
    disableUnusedVertexAttribs: () => {
      for (let i = 0; i < maxVertexAttribs; ++i) {
        if (vertexAttribsState[i] === 0)
          gl.disableVertexAttribArray(i);
      }
    },
    viewport: (x, y, width, height) => {
      if (x !== currentViewport[0] || y !== currentViewport[1] || width !== currentViewport[2] || height !== currentViewport[3]) {
        gl.viewport(x, y, width, height);
        currentViewport[0] = x;
        currentViewport[1] = y;
        currentViewport[2] = width;
        currentViewport[3] = height;
      }
    },
    scissor: (x, y, width, height) => {
      if (x !== currentScissor[0] || y !== currentScissor[1] || width !== currentScissor[2] || height !== currentScissor[3]) {
        gl.scissor(x, y, width, height);
        currentScissor[0] = x;
        currentScissor[1] = y;
        currentScissor[2] = width;
        currentScissor[3] = height;
      }
    },
    clipControl: e.clipControl ? (origin, depth) => {
      if (origin !== currentClipOrigin || depth !== currentClipDepthMode) {
        e.clipControl.clipControl(origin, depth);
        currentClipOrigin = origin;
        currentClipDepthMode = depth;
      }
    } : void 0,
    reset: () => {
      enabledCapabilities = {};
      currentFrontFace = gl.getParameter(gl.FRONT_FACE);
      currentCullFace = gl.getParameter(gl.CULL_FACE_MODE);
      currentDepthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
      currentClearDepth = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
      currentDepthFunc = gl.getParameter(gl.DEPTH_FUNC);
      currentColorMask = gl.getParameter(gl.COLOR_WRITEMASK);
      currentClearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
      currentBlendSrcRGB = gl.getParameter(gl.BLEND_SRC_RGB);
      currentBlendDstRGB = gl.getParameter(gl.BLEND_DST_RGB);
      currentBlendSrcAlpha = gl.getParameter(gl.BLEND_SRC_ALPHA);
      currentBlendDstAlpha = gl.getParameter(gl.BLEND_DST_ALPHA);
      currentBlendColor = gl.getParameter(gl.BLEND_COLOR);
      currentBlendEqRGB = gl.getParameter(gl.BLEND_EQUATION_RGB);
      currentBlendEqAlpha = gl.getParameter(gl.BLEND_EQUATION_ALPHA);
      currentStencilFunc = gl.getParameter(gl.STENCIL_FUNC);
      currentStencilValueMask = gl.getParameter(gl.STENCIL_VALUE_MASK);
      currentStencilRef = gl.getParameter(gl.STENCIL_REF);
      currentStencilBackFunc = gl.getParameter(gl.STENCIL_BACK_FUNC);
      currentStencilBackValueMask = gl.getParameter(gl.STENCIL_BACK_VALUE_MASK);
      currentStencilBackRef = gl.getParameter(gl.STENCIL_BACK_REF);
      currentStencilWriteMask = gl.getParameter(gl.STENCIL_WRITEMASK);
      currentStencilBackWriteMask = gl.getParameter(gl.STENCIL_BACK_WRITEMASK);
      currentStencilFail = gl.getParameter(gl.STENCIL_FAIL);
      currentStencilPassDepthPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);
      currentStencilPassDepthFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);
      currentStencilBackFail = gl.getParameter(gl.STENCIL_BACK_FAIL);
      currentStencilBackPassDepthPass = gl.getParameter(gl.STENCIL_BACK_PASS_DEPTH_PASS);
      currentStencilBackPassDepthFail = gl.getParameter(gl.STENCIL_BACK_PASS_DEPTH_FAIL);
      maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
      vertexAttribsState.length = 0;
      for (let i = 0; i < maxVertexAttribs; ++i) {
        vertexAttribsState[i] = 0;
      }
      currentViewport = gl.getParameter(gl.VIEWPORT);
      currentScissor = gl.getParameter(gl.SCISSOR_BOX);
      currentClipOrigin = e.clipControl ? gl.getParameter(e.clipControl.CLIP_ORIGIN) : -1;
      currentClipDepthMode = e.clipControl ? gl.getParameter(e.clipControl.CLIP_DEPTH_MODE) : -1;
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/image.js
var PixelData;
(function(PixelData2) {
  function create(array, width, height) {
    return { array, width, height };
  }
  PixelData2.create = create;
  function flipY(pixelData) {
    const { array, width, height } = pixelData;
    const itemSize = array.length / (width * height);
    const widthIS = width * itemSize;
    for (let i = 0, maxI = height / 2; i < maxI; ++i) {
      for (let j = 0, maxJ = widthIS; j < maxJ; ++j) {
        const index1 = i * widthIS + j;
        const index2 = (height - i - 1) * widthIS + j;
        const tmp = array[index1];
        array[index1] = array[index2];
        array[index2] = tmp;
      }
    }
    return pixelData;
  }
  PixelData2.flipY = flipY;
  function divideByAlpha(pixelData) {
    const { array } = pixelData;
    const factor = array instanceof Uint8Array ? 255 : 1;
    for (let i = 0, il = array.length; i < il; i += 4) {
      const a5 = array[i + 3] / factor;
      array[i] /= a5;
      array[i + 1] /= a5;
      array[i + 2] /= a5;
    }
    return pixelData;
  }
  PixelData2.divideByAlpha = divideByAlpha;
})(PixelData || (PixelData = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/apply-fog.glsl.js
var apply_fog = `
float preFogAlpha = gl_FragColor.a;
if (uFog) {
    float viewZ = depthToViewZ(uIsOrtho, fragmentDepth, uNear, uFar);
    float fogFactor = smoothstep(uFogNear, uFogFar, abs(viewZ));
    float fogAlpha = (1.0 - fogFactor) * gl_FragColor.a;
    if (!uTransparentBackground) {
        if (gl_FragColor.a < 1.0) {
            // transparent objects are blended with background color
            gl_FragColor.a = fogAlpha;
        } else {
            // mix opaque objects with background color
            gl_FragColor.rgb = mix(gl_FragColor.rgb, uFogColor, fogFactor);
        }
    } else {
        #if defined(dRenderVariant_colorDpoit) && !defined(dGeometryType_directVolume)
            if (gl_FragColor.a < 1.0) {
                // transparent objects are blended with background color
                gl_FragColor.a = fogAlpha;
            } else {
                // opaque objects need to be pre-multiplied alpha
                gl_FragColor.rgb *= fogAlpha;
                gl_FragColor.a = fogAlpha;
            }
        #else
            // pre-multiplied alpha expected for transparent background
            gl_FragColor.rgb *= fogAlpha;
            gl_FragColor.a = fogAlpha;
        #endif
    }
} else if (uTransparentBackground) {
    #if !defined(dRenderVariant_colorDpoit) && !defined(dGeometryType_directVolume)
        // pre-multiplied alpha expected for transparent background
        gl_FragColor.rgb *= gl_FragColor.a;
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/apply-interior-color.glsl.js
var apply_interior_color = `
if (interior) {
    if (uInteriorColorFlag) {
        gl_FragColor.rgb = uInteriorColor;
    } else {
        gl_FragColor.rgb *= 1.0 - uInteriorDarkening;
    }

    #ifdef dTransparentBackfaces_opaque
        gl_FragColor.a = 1.0;
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/apply-light-color.glsl.js
var apply_light_color = `
#if defined(dIgnoreLight)
    #ifdef bumpEnabled
        if (uBumpFrequency > 0.0 && uBumpAmplitude > 0.0 && bumpiness > 0.0) {
            material.rgb += fbm(vModelPosition * uBumpFrequency) * uBumpAmplitude * bumpiness;
            material.rgb -= 0.5 * uBumpAmplitude * bumpiness;
        }
    #endif

    #if defined(dRenderVariant_color)
        material.rgb += material.rgb * emissive;
    #endif

    gl_FragColor = material;
#else
    #ifdef bumpEnabled
        if (uBumpFrequency > 0.0 && uBumpAmplitude > 0.0 && bumpiness > 0.0) {
            normal = perturbNormal(-vViewPosition, normal, fbm(vModelPosition * uBumpFrequency), (uBumpAmplitude * bumpiness) / uBumpFrequency);
        }
    #endif

    vec4 color = material;

    #if defined(dCelShaded)
        // clamp to avoid artifacts
        metalness = clamp(metalness, 0.0, 0.99);
        roughness = clamp(roughness, 0.05, 1.0);
    #endif

    GeometricContext geometry;
    geometry.position = -vViewPosition;
    geometry.normal = normal;
    geometry.viewDir = normalize(vViewPosition);

    PhysicalMaterial physicalMaterial;
    physicalMaterial.diffuseColor = color.rgb * (1.0 - metalness);
    #ifdef enabledFragDepth
        physicalMaterial.roughness = min(max(roughness, 0.0525), 1.0);
    #else
        vec3 dxy = max(abs(dFdx(normal)), abs(dFdy(normal)));
        float geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);
        physicalMaterial.roughness = min(max(roughness, 0.0525) + geometryRoughness, 1.0);
    #endif
    physicalMaterial.specularColor = mix(vec3(0.04), color.rgb, metalness);
    physicalMaterial.specularF90 = 1.0;

    IncidentLight directLight;

    vec3 outgoingLight = vec3(0.0);

    #if defined(dCelShaded)
        float celDiffuse;
        float celSpecular;
        float celIntensity;

        #pragma unroll_loop_start
        for (int i = 0; i < dLightCount; ++i) {
            directLight.direction = uLightDirection[i];
            directLight.color = uLightColor[i] * PI; // * PI for punctual light

            celDiffuse = RECIPROCAL_PI * max(dot(geometry.normal, directLight.direction), 0.0) * (1.0 - metalness);
            celSpecular = luminance(saturate(dot(geometry.normal, directLight.direction)) * BRDF_GGX(directLight.direction, geometry.viewDir, geometry.normal, physicalMaterial.specularColor, physicalMaterial.specularF90, roughness));

            celIntensity = celDiffuse + celSpecular;
            celIntensity = ceil(celIntensity * uCelSteps) / uCelSteps;

            outgoingLight += color.rgb * directLight.color * celIntensity;
        }
        #pragma unroll_loop_end

        outgoingLight += physicalMaterial.diffuseColor * luminance(uAmbientColor);
    #else
        ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));

        #pragma unroll_loop_start
        for (int i = 0; i < dLightCount; ++i) {
            directLight.direction = uLightDirection[i];
            directLight.color = uLightColor[i] * PI; // * PI for punctual light
            RE_Direct_Physical(directLight, geometry, physicalMaterial, reflectedLight);
        }
        #pragma unroll_loop_end

        vec3 irradiance = uAmbientColor * PI; // * PI for punctual light
        RE_IndirectDiffuse_Physical(irradiance, geometry, physicalMaterial, reflectedLight);

        // indirect specular only metals
        vec3 radiance = uAmbientColor * metalness;
        vec3 iblIrradiance = uAmbientColor * metalness;
        vec3 clearcoatRadiance = vec3(0.0);
        RE_IndirectSpecular_Physical(radiance, iblIrradiance, clearcoatRadiance, geometry, physicalMaterial, reflectedLight);

        outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular;
    #endif
    outgoingLight = clamp(outgoingLight, 0.01, 0.99); // prevents black artifacts on specular highlight with transparent background

    #if defined(dRenderVariant_color)
        outgoingLight += color.rgb * emissive;
    #endif

    gl_FragColor = vec4(outgoingLight, color.a);
#endif

gl_FragColor.rgb *= uExposure;
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/apply-marker-color.glsl.js
var apply_marker_color = `

#if defined(dColorMarker)
    if (marker > 0.0) {
        if ((uMarkerPriority == 1 && marker != 2.0) || (uMarkerPriority != 1 && marker == 1.0)) {
            gl_FragColor.rgb = mix(gl_FragColor.rgb, uHighlightColor, uHighlightStrength);
            gl_FragColor.a = max(gl_FragColor.a, uHighlightStrength * 0.002); // for direct-volume rendering
        } else {
            gl_FragColor.rgb = mix(gl_FragColor.rgb, uSelectColor, uSelectStrength);
            gl_FragColor.a = max(gl_FragColor.a, uSelectStrength * 0.002); // for direct-volume rendering
        }
    } else if (uMarkerAverage > 0.0) {
        gl_FragColor.rgb = mix(gl_FragColor.rgb, uDimColor, uDimStrength);
        gl_FragColor.a = max(gl_FragColor.a, uDimStrength * 0.002); // for direct-volume rendering
    }
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/assign-clipping-varying.glsl.js
var assign_clipping_varying = `
#if dClipObjectCount != 0 && defined(dClipping)
    #if defined(dClippingType_instance)
        vClipping = readFromTexture(tClipping, aInstance, uClippingTexDim).a;
    #elif defined(dMarkerType_groupInstance)
        vClipping = readFromTexture(tClipping, aInstance * float(uGroupCount) + group, uClippingTexDim).a;
    #endif
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/assign-color-varying.glsl.js
var assign_color_varying = `
#if defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
    #if defined(dColorType_attribute)
        vColor.rgb = aColor;
    #elif defined(dColorType_instance)
        vColor.rgb = readFromTexture(tColor, aInstance, uColorTexDim).rgb;
    #elif defined(dColorType_group)
        #if defined(dDualColor)
            vec4 color2;
            if (aColorMode == 2.0) {
                vColor.rgb = readFromTexture(tColor, group, uColorTexDim).rgb;
            } else {
                vColor.rgb = readFromTexture(tColor, group * 2.0, uColorTexDim).rgb;
                color2.rgb = readFromTexture(tColor, group * 2.0 + 1.0, uColorTexDim).rgb;
            }
        #else
            vColor.rgb = readFromTexture(tColor, group, uColorTexDim).rgb;
        #endif
    #elif defined(dColorType_groupInstance)
        #if defined(dDualColor)
            vec4 color2;
            if (aColorMode == 2.0) {
                vColor.rgb = readFromTexture(tColor, aInstance * float(uGroupCount) + group, uColorTexDim).rgb;
            } else {
                vColor.rgb = readFromTexture(tColor, (aInstance * float(uGroupCount) + group) * 2.0, uColorTexDim).rgb;
                color2.rgb = readFromTexture(tColor, (aInstance * float(uGroupCount) + group) * 2.0 + 1.0, uColorTexDim).rgb;
            }
        #else
            vColor.rgb = readFromTexture(tColor, aInstance * float(uGroupCount) + group, uColorTexDim).rgb;
        #endif
    #elif defined(dColorType_vertex)
        vColor.rgb = readFromTexture(tColor, vertexId, uColorTexDim).rgb;
    #elif defined(dColorType_vertexInstance)
        vColor.rgb = readFromTexture(tColor, int(aInstance) * uVertexCount + vertexId, uColorTexDim).rgb;
    #elif defined(dColorType_volume)
        vec3 cgridPos = (uColorGridTransform.w * (position - uColorGridTransform.xyz)) / uColorGridDim;
        vColor.rgb = texture3dFrom2dLinear(tColorGrid, cgridPos, uColorGridDim, uColorTexDim).rgb;
    #elif defined(dColorType_volumeInstance)
        vec3 cgridPos = (uColorGridTransform.w * (vModelPosition - uColorGridTransform.xyz)) / uColorGridDim;
        vColor.rgb = texture3dFrom2dLinear(tColorGrid, cgridPos, uColorGridDim, uColorTexDim).rgb;
    #endif

    #ifdef dUsePalette
        vPaletteV = ((vColor.r * 256.0 * 256.0 * 255.0 + vColor.g * 256.0 * 255.0 + vColor.b * 255.0) - 1.0) / PALETTE_SCALE;
    #endif

    #ifdef dOverpaint
        #if defined(dOverpaintType_instance)
            vOverpaint = readFromTexture(tOverpaint, aInstance, uOverpaintTexDim);
        #elif defined(dOverpaintType_groupInstance)
            vOverpaint = readFromTexture(tOverpaint, aInstance * float(uGroupCount) + group, uOverpaintTexDim);
        #elif defined(dOverpaintType_vertexInstance)
            vOverpaint = readFromTexture(tOverpaint, int(aInstance) * uVertexCount + vertexId, uOverpaintTexDim);
        #elif defined(dOverpaintType_volumeInstance)
            vec3 ogridPos = (uOverpaintGridTransform.w * (vModelPosition - uOverpaintGridTransform.xyz)) / uOverpaintGridDim;
            vOverpaint = texture3dFrom2dLinear(tOverpaintGrid, ogridPos, uOverpaintGridDim, uOverpaintTexDim);
        #endif

        // pre-mix to avoid darkening due to empty overpaint
        #ifdef dColorType_uniform
            vOverpaint.rgb = mix(uColor.rgb, vOverpaint.rgb, vOverpaint.a);
        #else
            vOverpaint.rgb = mix(vColor.rgb, vOverpaint.rgb, vOverpaint.a);
        #endif
        vOverpaint *= uOverpaintStrength;
    #endif

    #ifdef dEmissive
        #if defined(dEmissiveType_instance)
            vEmissive = readFromTexture(tEmissive, aInstance, uEmissiveTexDim).a;
        #elif defined(dEmissiveType_groupInstance)
            vEmissive = readFromTexture(tEmissive, aInstance * float(uGroupCount) + group, uEmissiveTexDim).a;
        #elif defined(dEmissiveType_vertexInstance)
            vEmissive = readFromTexture(tEmissive, int(aInstance) * uVertexCount + vertexId, uEmissiveTexDim).a;
        #elif defined(dEmissiveType_volumeInstance)
            vec3 egridPos = (uEmissiveGridTransform.w * (vModelPosition - uEmissiveGridTransform.xyz)) / uEmissiveGridDim;
            vEmissive = texture3dFrom2dLinear(tEmissiveGrid, egridPos, uEmissiveGridDim, uEmissiveTexDim).a;
        #endif
        vEmissive *= uEmissiveStrength;
    #endif

    #ifdef dSubstance
        #if defined(dSubstanceType_instance)
            vSubstance = readFromTexture(tSubstance, aInstance, uSubstanceTexDim);
        #elif defined(dSubstanceType_groupInstance)
            vSubstance = readFromTexture(tSubstance, aInstance * float(uGroupCount) + group, uSubstanceTexDim);
        #elif defined(dSubstanceType_vertexInstance)
            vSubstance = readFromTexture(tSubstance, int(aInstance) * uVertexCount + vertexId, uSubstanceTexDim);
        #elif defined(dSubstanceType_volumeInstance)
            vec3 sgridPos = (uSubstanceGridTransform.w * (vModelPosition - uSubstanceGridTransform.xyz)) / uSubstanceGridDim;
            vSubstance = texture3dFrom2dLinear(tSubstanceGrid, sgridPos, uSubstanceGridDim, uSubstanceTexDim);
        #endif

        // pre-mix to avoid artifacts due to empty substance
        vSubstance.rgb = mix(vec3(uMetalness, uRoughness, uBumpiness), vSubstance.rgb, vSubstance.a);
        vSubstance *= uSubstanceStrength;
    #endif
#elif defined(dRenderVariant_emissive)
    #ifdef dEmissive
        #if defined(dEmissiveType_instance)
            vEmissive = readFromTexture(tEmissive, aInstance, uEmissiveTexDim).a;
        #elif defined(dEmissiveType_groupInstance)
            vEmissive = readFromTexture(tEmissive, aInstance * float(uGroupCount) + group, uEmissiveTexDim).a;
        #elif defined(dEmissiveType_vertexInstance)
            vEmissive = readFromTexture(tEmissive, int(aInstance) * uVertexCount + vertexId, uEmissiveTexDim).a;
        #elif defined(dEmissiveType_volumeInstance)
            vec3 egridPos = (uEmissiveGridTransform.w * (vModelPosition - uEmissiveGridTransform.xyz)) / uEmissiveGridDim;
            vEmissive = texture3dFrom2dLinear(tEmissiveGrid, egridPos, uEmissiveGridDim, uEmissiveTexDim).a;
        #endif
        vEmissive *= uEmissiveStrength;
    #endif
#elif defined(dRenderVariant_pick)
    #ifdef requiredDrawBuffers
        vObject = vec4(packIntToRGB(float(uObjectId)), 1.0);
        vInstance = vec4(packIntToRGB(aInstance), 1.0);
        vGroup = vec4(packIntToRGB(group), 1.0);
    #else
        if (uPickType == 1) {
            vColor = vec4(packIntToRGB(float(uObjectId)), 1.0);
        } else if (uPickType == 2) {
            vColor = vec4(packIntToRGB(aInstance), 1.0);
        } else {
            vColor = vec4(packIntToRGB(group), 1.0);
        }
    #endif
#endif

#ifdef dTransparency
    #if defined(dTransparencyType_instance)
        vTransparency = readFromTexture(tTransparency, aInstance, uTransparencyTexDim).a;
    #elif defined(dTransparencyType_groupInstance)
        vTransparency = readFromTexture(tTransparency, aInstance * float(uGroupCount) + group, uTransparencyTexDim).a;
    #elif defined(dTransparencyType_vertexInstance)
        vTransparency = readFromTexture(tTransparency, int(aInstance) * uVertexCount + vertexId, uTransparencyTexDim).a;
    #elif defined(dTransparencyType_volumeInstance)
        vec3 tgridPos = (uTransparencyGridTransform.w * (vModelPosition - uTransparencyGridTransform.xyz)) / uTransparencyGridDim;
        vTransparency = texture3dFrom2dLinear(tTransparencyGrid, tgridPos, uTransparencyGridDim, uTransparencyTexDim).a;
    #endif
    vTransparency *= uTransparencyStrength;
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/assign-group.glsl.js
var assign_group = `
#ifdef dGeometryType_textureMesh
    float group = unpackRGBToInt(readFromTexture(tGroup, vertexId, uGeoTexDim).rgb);
#else
    float group = aGroup;
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/assign-marker-varying.glsl.js
var assign_marker_varying = `
#if defined(dNeedsMarker)
    #if defined(dMarkerType_instance)
        vMarker = readFromTexture(tMarker, aInstance, uMarkerTexDim).a;
    #elif defined(dMarkerType_groupInstance)
        vMarker = readFromTexture(tMarker, aInstance * float(uGroupCount) + group, uMarkerTexDim).a;
    #endif
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/assign-material-color.glsl.js
var assign_material_color = `
#if defined(dNeedsMarker)
    float marker = uMarker;
    if (uMarker == -1.0) {
        marker = floor(vMarker * 255.0 + 0.5); // rounding required to work on some cards on win
    }
#endif

#if defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
    #if defined(dUsePalette)
        vec4 material = vec4(texture2D(tPalette, vec2(vPaletteV, 0.5)).rgb, uAlpha);
    #elif defined(dColorType_uniform)
        vec4 material = vec4(uColor, uAlpha);
    #elif defined(dColorType_varying)
        vec4 material = vec4(vColor.rgb, uAlpha);
    #endif

    // mix material with overpaint
    #if defined(dOverpaint)
        material.rgb = mix(material.rgb, vOverpaint.rgb, vOverpaint.a);
    #endif

    float emissive = uEmissive;
    #ifdef dEmissive
        emissive += vEmissive;
    #endif

    float metalness = uMetalness;
    float roughness = uRoughness;
    float bumpiness = uBumpiness;
    #ifdef dSubstance
        float sf = clamp(vSubstance.a, 0.0, 0.99); // clamp to avoid artifacts
        metalness = mix(metalness, vSubstance.r, sf);
        roughness = mix(roughness, vSubstance.g, sf);
        bumpiness = mix(bumpiness, vSubstance.b, sf);
    #endif

    #if defined(dXrayShaded)
        material.a = calcXrayShadedAlpha(material.a, normal);
    #endif
#elif defined(dRenderVariant_depth)
    if (fragmentDepth > getDepth(gl_FragCoord.xy / uDrawingBufferSize)) {
        discard;
    }
    vec4 material;
    if (uRenderMask == MaskOpaque) {
        #if defined(dXrayShaded)
            discard;
        #endif
        #if defined(dTransparency)
            float dta = 1.0 - vTransparency;
            #if __VERSION__ == 100 || defined(dVaryingGroup)
                if (vTransparency < 0.1) dta = 1.0; // hard cutoff to avoid artifacts
            #endif

            if (uAlpha * dta < 1.0) {
                discard;
            }
        #else
            if (uAlpha < 1.0) {
                discard;
            }
        #endif
        material = packDepthToRGBA(fragmentDepth);
    } else if (uRenderMask == MaskTransparent) {
        float alpha = uAlpha;
        #if defined(dTransparency)
            float dta = 1.0 - vTransparency;
            alpha *= dta;
        #endif

        #ifdef dXrayShaded
            alpha = calcXrayShadedAlpha(alpha, normal);
        #else
            if (alpha == 1.0) {
                discard;
            }
        #endif
        material = packDepthWithAlphaToRGBA(fragmentDepth, alpha);
    }
#elif defined(dRenderVariant_marking)
    vec4 material;
    if(uMarkingType == 1) {
        if (marker > 0.0)
            discard;
        #ifdef enabledFragDepth
            material = packDepthToRGBA(gl_FragDepthEXT);
        #else
            material = packDepthToRGBA(gl_FragCoord.z);
        #endif
    } else {
        if (marker == 0.0)
            discard;
        float depthTest = 1.0;
        if (uMarkingDepthTest) {
            depthTest = (fragmentDepth >= getDepthPacked(gl_FragCoord.xy / uDrawingBufferSize)) ? 1.0 : 0.0;
        }
        bool isHighlight = intMod(marker, 2.0) > 0.1;
        float viewZ = depthToViewZ(uIsOrtho, fragmentDepth, uNear, uFar);
        float fogFactor = smoothstep(uFogNear, uFogFar, abs(viewZ));
        if (fogFactor == 1.0)
            discard;
        material = vec4(0.0, depthTest, isHighlight ? 1.0 : 0.0, 1.0 - fogFactor);
    }
#elif defined(dRenderVariant_emissive)
    float emissive = uEmissive;
    #ifdef dEmissive
        emissive += vEmissive;
    #endif
    vec4 material = vec4(emissive);
#endif

// apply per-group transparency
#if defined(dTransparency) && (defined(dRenderVariant_pick) || defined(dRenderVariant_color) || defined(dRenderVariant_emissive) || defined(dRenderVariant_tracing))
    float ta = 1.0 - vTransparency;
    if (vTransparency < 0.09) ta = 1.0; // hard cutoff looks better

    #if defined(dRenderVariant_pick)
        if (ta * uAlpha < uPickingAlphaThreshold)
            discard; // ignore so the element below can be picked
    #elif defined(dRenderVariant_emissive)
        if (ta < 1.0)
            discard; // emissive not supported with transparency
    #elif defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
        material.a *= ta;
    #endif
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/assign-position.glsl.js
var assign_position = `
mat4 model = uModel * aTransform;
mat4 modelView = uView * model;
#ifdef dGeometryType_textureMesh
    vec3 position = readFromTexture(tPosition, vertexId, uGeoTexDim).xyz;
#else
    vec3 position = aPosition;
#endif
vec4 position4 = vec4(position, 1.0);
// for accessing tColorGrid in vert shader and for clipping in frag shader
vModelPosition = (model * position4).xyz;
vec4 mvPosition = modelView * position4;
vViewPosition = mvPosition.xyz;
gl_Position = uProjection * mvPosition;
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/assign-size.glsl.js
var assign_size = `
#if defined(dSizeType_uniform)
    float size = uSize;
#elif defined(dSizeType_attribute)
    float size = aSize;
#elif defined(dSizeType_instance)
    float size = unpackRGBToInt(readFromTexture(tSize, aInstance, uSizeTexDim).rgb);
#elif defined(dSizeType_group)
    float size = unpackRGBToInt(readFromTexture(tSize, group, uSizeTexDim).rgb);
#elif defined(dSizeType_groupInstance)
    float size = unpackRGBToInt(readFromTexture(tSize, aInstance * float(uGroupCount) + group, uSizeTexDim).rgb);
#endif

#if defined(dSizeType_instance) || defined(dSizeType_group) || defined(dSizeType_groupInstance)
    size /= 100.0; // NOTE factor also set in TypeScript
#endif

size *= uSizeFactor;
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/check-picking-alpha.glsl.js
var check_picking_alpha = `
float viewZ = depthToViewZ(uIsOrtho, fragmentDepth, uNear, uFar);
float fogFactor = smoothstep(uFogNear, uFogFar, abs(viewZ));
float fogAlpha = (1.0 - fogFactor) * uAlpha;
float alpha = uAlpha;
#ifdef dXrayShaded
    // add bias to make picking xray shaded elements easier
    alpha = calcXrayShadedAlpha(alpha, normal) + (0.3 * uPickingAlphaThreshold);
#endif
// if not opaque enough ignore so the element below can be picked
if (alpha < uPickingAlphaThreshold || fogAlpha < 0.1) {
    #ifdef dTransparentBackfaces_opaque
        if (!interior) discard;
    #else
        discard;
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/check-transparency.glsl.js
var check_transparency = `
#if defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
    #if defined(dTransparentBackfaces_off)
        if (interior && material.a < 1.0) discard;
    #elif defined(dTransparentBackfaces_opaque)
        if (interior) material.a = 1.0;
    #endif

    #if !defined(dXrayShaded)
        if ((uRenderMask == MaskOpaque && material.a < 1.0) ||
            (uRenderMask == MaskTransparent && material.a == 1.0)
        ) {
            discard;
        }
    #endif
#endif

#if defined(dRenderVariant_depth)
    #if defined(dTransparentBackfaces_off)
        if (interior) discard;
    #endif
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/clip-instance.glsl.js
var clip_instance = `
#if defined(dClipVariant_instance) && dClipObjectCount != 0
    vec3 mCenter = (uModel * aTransform * vec4(uInvariantBoundingSphere.xyz, 1.0)).xyz;
    if (clipTest(mCenter)) {
        // move out of [ -w, +w ] to 'discard' in vert shader
        gl_Position.z = 2.0 * gl_Position.w;
    }
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/clip-pixel.glsl.js
var clip_pixel = `
#if defined(dClipVariant_pixel) && dClipObjectCount != 0
    if (clipTest(vModelPosition))
        discard;
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/color-frag-params.glsl.js
var color_frag_params = `
uniform float uMetalness;
uniform float uRoughness;
uniform float uBumpiness;
#ifdef bumpEnabled
    uniform float uBumpFrequency;
    uniform float uBumpAmplitude;
#endif
uniform float uEmissive;

// Density value to estimate object thickness
uniform float uDensity;

#if defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
    #if defined(dColorType_uniform)
        uniform vec3 uColor;
    #elif defined(dColorType_varying)
        varying vec4 vColor;
    #endif

    #ifdef dUsePalette
        uniform sampler2D tPalette;
        varying float vPaletteV;
    #endif

    #ifdef dOverpaint
        varying vec4 vOverpaint;
    #endif

    #ifdef dEmissive
        varying float vEmissive;
    #endif

    #ifdef dSubstance
        varying vec4 vSubstance;
    #endif
#elif defined(dRenderVariant_emissive)
    #ifdef dEmissive
        varying float vEmissive;
    #endif
#elif defined(dRenderVariant_pick)
    #if __VERSION__ == 100 || !defined(dVaryingGroup)
        #ifdef requiredDrawBuffers
            varying vec4 vObject;
            varying vec4 vInstance;
            varying vec4 vGroup;
        #else
            varying vec4 vColor;
        #endif
    #else
        #ifdef requiredDrawBuffers
            flat in vec4 vObject;
            flat in vec4 vInstance;
            flat in vec4 vGroup;
        #else
            flat in vec4 vColor;
        #endif
    #endif
#endif

#ifdef dTransparency
    varying float vTransparency;
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/color-vert-params.glsl.js
var color_vert_params = `
uniform float uMetalness;
uniform float uRoughness;
uniform float uBumpiness;

#if defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
    #if defined(dColorType_uniform)
        uniform vec3 uColor;
    #elif defined(dColorType_attribute)
        varying vec4 vColor;
        attribute vec3 aColor;
    #elif defined(dColorType_texture)
        varying vec4 vColor;
        uniform vec2 uColorTexDim;
        uniform sampler2D tColor;
    #elif defined(dColorType_grid)
        varying vec4 vColor;
        uniform vec2 uColorTexDim;
        uniform vec3 uColorGridDim;
        uniform vec4 uColorGridTransform;
        uniform sampler2D tColorGrid;
    #elif defined(dColorType_direct)
        varying vec4 vColor;
    #endif

    #ifdef dUsePalette
        varying float vPaletteV;
    #endif

    #ifdef dOverpaint
        #if defined(dOverpaintType_instance) || defined(dOverpaintType_groupInstance) || defined(dOverpaintType_vertexInstance)
            varying vec4 vOverpaint;
            uniform vec2 uOverpaintTexDim;
            uniform sampler2D tOverpaint;
        #elif defined(dOverpaintType_volumeInstance)
            varying vec4 vOverpaint;
            uniform vec2 uOverpaintTexDim;
            uniform vec3 uOverpaintGridDim;
            uniform vec4 uOverpaintGridTransform;
            uniform sampler2D tOverpaintGrid;
        #endif
        uniform float uOverpaintStrength;
    #endif

    #ifdef dEmissive
        #if defined(dEmissiveType_instance) || defined(dEmissiveType_groupInstance) || defined(dEmissiveType_vertexInstance)
            varying float vEmissive;
            uniform vec2 uEmissiveTexDim;
            uniform sampler2D tEmissive;
        #elif defined(dEmissiveType_volumeInstance)
            varying float vEmissive;
            uniform vec2 uEmissiveTexDim;
            uniform vec3 uEmissiveGridDim;
            uniform vec4 uEmissiveGridTransform;
            uniform sampler2D tEmissiveGrid;
        #endif
        uniform float uEmissiveStrength;
    #endif

    #ifdef dSubstance
        #if defined(dSubstanceType_instance) || defined(dSubstanceType_groupInstance) || defined(dSubstanceType_vertexInstance)
            varying vec4 vSubstance;
            uniform vec2 uSubstanceTexDim;
            uniform sampler2D tSubstance;
        #elif defined(dSubstanceType_volumeInstance)
            varying vec4 vSubstance;
            uniform vec2 uSubstanceTexDim;
            uniform vec3 uSubstanceGridDim;
            uniform vec4 uSubstanceGridTransform;
            uniform sampler2D tSubstanceGrid;
        #endif
        uniform float uSubstanceStrength;
    #endif
#elif defined(dRenderVariant_emissive)
    #ifdef dEmissive
        #if defined(dEmissiveType_instance) || defined(dEmissiveType_groupInstance) || defined(dEmissiveType_vertexInstance)
            varying float vEmissive;
            uniform vec2 uEmissiveTexDim;
            uniform sampler2D tEmissive;
        #elif defined(dEmissiveType_volumeInstance)
            varying float vEmissive;
            uniform vec2 uEmissiveTexDim;
            uniform vec3 uEmissiveGridDim;
            uniform vec4 uEmissiveGridTransform;
            uniform sampler2D tEmissiveGrid;
        #endif
        uniform float uEmissiveStrength;
    #endif
#elif defined(dRenderVariant_pick)
    #if __VERSION__ == 100 || !defined(dVaryingGroup)
        #ifdef requiredDrawBuffers
            varying vec4 vObject;
            varying vec4 vInstance;
            varying vec4 vGroup;
        #else
            varying vec4 vColor;
        #endif
    #else
        #ifdef requiredDrawBuffers
            flat out vec4 vObject;
            flat out vec4 vInstance;
            flat out vec4 vGroup;
        #else
            flat out vec4 vColor;
        #endif
    #endif
#endif

#ifdef dTransparency
    #if defined(dTransparencyType_instance) || defined(dTransparencyType_groupInstance) || defined(dTransparencyType_vertexInstance)
        varying float vTransparency;
        uniform vec2 uTransparencyTexDim;
        uniform sampler2D tTransparency;
    #elif defined(dTransparencyType_volumeInstance)
        varying float vTransparency;
        uniform vec2 uTransparencyTexDim;
        uniform vec3 uTransparencyGridDim;
        uniform vec4 uTransparencyGridTransform;
        uniform sampler2D tTransparencyGrid;
    #endif
    uniform float uTransparencyStrength;
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/common-clip.glsl.js
var common_clip = `
vec3 quaternionTransform(const in vec4 q, const in vec3 v) {
    vec3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}

vec4 computePlane(const in vec3 normal, const in vec3 inPoint) {
    return vec4(normalize(normal), -dot(normal, inPoint));
}

float planeSD(const in vec4 plane, const in vec3 center) {
    return -dot(plane.xyz, center - plane.xyz * -plane.w);
}

float sphereSD(const in vec3 position, const in vec4 rotation, const in vec3 size, const in vec3 center) {
    return (
        length(quaternionTransform(vec4(-rotation.x, -rotation.y, -rotation.z, rotation.w), center - position) / size) - 1.0
    ) * min(min(size.x, size.y), size.z);
}

float cubeSD(const in vec3 position, const in vec4 rotation, const in vec3 size, const in vec3 center) {
    vec3 d = abs(quaternionTransform(vec4(-rotation.x, -rotation.y, -rotation.z, rotation.w), center - position)) - size;
    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
}

float cylinderSD(const in vec3 position, const in vec4 rotation, const in vec3 size, const in vec3 center) {
    vec3 t = quaternionTransform(vec4(-rotation.x, -rotation.y, -rotation.z, rotation.w), center - position);

    vec2 d = abs(vec2(length(t.xz), t.y)) - size.xy;
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float infiniteConeSD(const in vec3 position, const in vec4 rotation, const in vec3 size, const in vec3 center) {
    vec3 t = quaternionTransform(vec4(-rotation.x, -rotation.y, -rotation.z, rotation.w), center - position);

    float q = length(t.xy);
    return dot(size.xy, vec2(q, t.z));
}

float getSignedDistance(const in vec3 center, const in int type, const in vec3 position, const in vec4 rotation, const in vec3 scale, const in mat4 transform) {
    vec3 c = (transform * vec4(center, 1.0)).xyz;
    if (type == 1) {
        vec3 normal = quaternionTransform(rotation, vec3(0.0, 1.0, 0.0));
        vec4 plane = computePlane(normal, position);
        return planeSD(plane, c);
    } else if (type == 2) {
        return sphereSD(position, rotation, scale * 0.5, c);
    } else if (type == 3) {
        return cubeSD(position, rotation, scale * 0.5, c);
    } else if (type == 4) {
        return cylinderSD(position, rotation, scale * 0.5, c);
    } else if (type == 5) {
        return infiniteConeSD(position, rotation, scale * 0.5, c);
    } else {
        return 0.1;
    }
}

#if __VERSION__ == 100
    // 8-bit
    int bitwiseAnd(in int a, in int b) {
        int d = 128;
        int result = 0;
        for (int i = 0; i < 8; ++i) {
            if (d <= 0) break;
            if (a >= d && b >= d) result += d;
            if (a >= d) a -= d;
            if (b >= d) b -= d;
            d /= 2;
        }
        return result;
    }

    bool hasBit(const in int mask, const in int bit) {
        return bitwiseAnd(mask, bit) == 0;
    }
#else
    bool hasBit(const in int mask, const in int bit) {
        return (mask & bit) == 0;
    }
#endif

bool clipTest(const in vec3 center) {
    // flag is a bit-flag for clip-objects to ignore (note, object ids start at 1 not 0)
    #if defined(dClipping)
        int flag = int(floor(vClipping * 255.0 + 0.5));
    #else
        int flag = 0;
    #endif

    #pragma unroll_loop_start
    for (int i = 0; i < dClipObjectCount; ++i) {
        if (flag == 0 || hasBit(flag, UNROLLED_LOOP_INDEX + 1)) {
            bool test = getSignedDistance(center, uClipObjectType[i], uClipObjectPosition[i], uClipObjectRotation[i], uClipObjectScale[i], uClipObjectTransform[i]) <= 0.0;
            if ((!uClipObjectInvert[i] && test) || (uClipObjectInvert[i] && !test)) {
                return true;
            }
        }
    }
    #pragma unroll_loop_end
    return false;
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/common-frag-params.glsl.js
var common_frag_params = `
uniform int uObjectId;
uniform int uInstanceCount;
uniform int uGroupCount;

uniform int uPickType;
uniform int uMarkingType;

uniform vec4 uCameraPlane;
uniform vec4 uLod;

#if dClipObjectCount != 0
    uniform int uClipObjectType[dClipObjectCount];
    uniform bool uClipObjectInvert[dClipObjectCount];
    uniform vec3 uClipObjectPosition[dClipObjectCount];
    uniform vec4 uClipObjectRotation[dClipObjectCount];
    uniform vec3 uClipObjectScale[dClipObjectCount];
    uniform mat4 uClipObjectTransform[dClipObjectCount];

    #if defined(dClipping)
        #if __VERSION__ == 100 || defined(dClippingType_instance) || !defined(dVaryingGroup)
            varying float vClipping;
        #else
            flat in float vClipping;
        #endif
    #endif
#endif

#if defined(dColorMarker)
    uniform vec3 uHighlightColor;
    uniform vec3 uSelectColor;
    uniform vec3 uDimColor;
    uniform float uHighlightStrength;
    uniform float uSelectStrength;
    uniform float uDimStrength;
    uniform int uMarkerPriority;
    uniform float uMarkerAverage;
#endif

#if defined(dNeedsMarker)
    uniform float uMarker;
    #if __VERSION__ == 100 || defined(dMarkerType_instance) || !defined(dVaryingGroup)
        varying float vMarker;
    #else
        flat in float vMarker;
    #endif
#endif

#if defined(dRenderVariant_colorDpoit)
    #define MAX_DPOIT_DEPTH 99999.0 // NOTE constant also set in TypeScript
    uniform sampler2D tDpoitDepth;
    uniform sampler2D tDpoitFrontColor;
#endif

varying vec3 vModelPosition;
varying vec3 vViewPosition;

uniform vec2 uViewOffset;

uniform float uNear;
uniform float uFar;
uniform float uIsOrtho;

uniform bool uFog;
uniform float uFogNear;
uniform float uFogFar;
uniform vec3 uFogColor;

uniform float uAlpha;
uniform float uPickingAlphaThreshold;
uniform bool uTransparentBackground;

uniform bool uDoubleSided;
uniform float uInteriorDarkening;
uniform bool uInteriorColorFlag;
uniform vec3 uInteriorColor;
bool interior;

uniform float uXrayEdgeFalloff;
uniform float uCelSteps;
uniform float uExposure;

uniform mat4 uProjection;

uniform int uRenderMask;
uniform bool uMarkingDepthTest;

uniform sampler2D tDepth;
uniform vec2 uDrawingBufferSize;

float getDepthPacked(const in vec2 coords) {
    return unpackRGBAToDepth(texture2D(tDepth, coords));
}

float getDepth(const in vec2 coords) {
    #ifdef depthTextureSupport
        return texture2D(tDepth, coords).r;
    #else
        return unpackRGBAToDepth(texture2D(tDepth, coords));
    #endif
}

float calcDepth(const in vec3 pos) {
    vec2 clipZW = pos.z * uProjection[2].zw + uProjection[3].zw;
    return 0.5 + 0.5 * clipZW.x / clipZW.y;
}

// "Bump Mapping Unparametrized Surfaces on the GPU" Morten S. Mikkelsen
// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf
vec3 perturbNormal(in vec3 position, in vec3 normal, in float height, in float scale) {
    vec3 sigmaS = dFdx(position);
    vec3 sigmaT = dFdy(position);

    vec3 r1 = cross(sigmaT, normal);
    vec3 r2 = cross(normal, sigmaS);
    float det = dot(sigmaS, r1);
    if (det == 0.0) return normal;

    float bs = dFdx(height);
    float bt = dFdy(height);

    vec3 surfGrad = sign(det) * (bs * r1 + bt * r2);
    return normalize(abs(det) * normal - scale * surfGrad);
}

float hash(in float h) {
    return fract(sin(h) * 43758.5453123);
}

float noise(in vec3 x) {
    vec3 p = floor(x);
    vec3 f = fract(x);
    f = f * f * (3.0 - 2.0 * f);

    float n = p.x + p.y * 157.0 + 113.0 * p.z;
    return mix(
        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
            mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),
        mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
            mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);
}

float fbm(in vec3 p) {
    float f = 0.0;
    f += 0.5 * noise(p);
    p *= 2.01;
    f += 0.25 * noise(p);
    p *= 2.02;
    f += 0.125 * noise(p);

    return f;
}

#ifdef dXrayShaded
    float calcXrayShadedAlpha(in float alpha, const in vec3 normal) {
        #if defined(dXrayShaded_on)
            alpha *= 1.0 - pow(abs(dot(normal, vec3(0.0, 0.0, 1.0))), uXrayEdgeFalloff);
        #elif defined(dXrayShaded_inverted)
            alpha *= pow(abs(dot(normal, vec3(0.0, 0.0, 1.0))), uXrayEdgeFalloff);
        #endif
        return clamp(alpha, 0.001, 0.999);
    }
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/common-vert-params.glsl.js
var common_vert_params = `
uniform mat4 uProjection, uModel, uView;
uniform vec3 uCameraPosition;
uniform vec4 uCameraPlane;

uniform int uObjectId;
uniform int uVertexCount;
uniform int uInstanceCount;
uniform int uGroupCount;
uniform vec4 uInvariantBoundingSphere;
uniform vec4 uLod;

uniform bool uDoubleSided;
uniform int uPickType;

#if dClipObjectCount != 0
    uniform int uClipObjectType[dClipObjectCount];
    uniform bool uClipObjectInvert[dClipObjectCount];
    uniform vec3 uClipObjectPosition[dClipObjectCount];
    uniform vec4 uClipObjectRotation[dClipObjectCount];
    uniform vec3 uClipObjectScale[dClipObjectCount];
    uniform mat4 uClipObjectTransform[dClipObjectCount];

    #if defined(dClipping)
        uniform vec2 uClippingTexDim;
        uniform sampler2D tClipping;
        #if __VERSION__ == 100 || defined(dClippingType_instance) || !defined(dVaryingGroup)
            varying float vClipping;
        #else
            flat out float vClipping;
        #endif
    #endif
#endif

#if defined(dNeedsMarker)
    uniform float uMarker;
    uniform vec2 uMarkerTexDim;
    uniform sampler2D tMarker;
    #if __VERSION__ == 100 || defined(dMarkerType_instance) || !defined(dVaryingGroup)
        varying float vMarker;
    #else
        flat out float vMarker;
    #endif
#endif

varying vec3 vModelPosition;
varying vec3 vViewPosition;

#if defined(noNonInstancedActiveAttribs)
    // int() is needed for some Safari versions
    // see https://bugs.webkit.org/show_bug.cgi?id=244152
    #define VertexID int(gl_VertexID)
#else
    attribute float aVertex;
    #define VertexID int(aVertex)
#endif

#if defined(enabledMultiDraw)
    #define DrawID gl_DrawID
#else
    #define DrawID uDrawId
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/common.glsl.js
var common = `
// TODO find a better place for these convenience defines

#if defined(dRenderVariant_colorBlended) || defined(dRenderVariant_colorWboit) || defined(dRenderVariant_colorDpoit)
    #define dRenderVariant_color
#endif

#if defined(dColorType_instance) || defined(dColorType_group) || defined(dColorType_groupInstance) || defined(dColorType_vertex) || defined(dColorType_vertexInstance)
    #define dColorType_texture
#endif

#if defined(dColorType_volume) || defined(dColorType_volumeInstance)
    #define dColorType_grid
#endif

#if defined(dColorType_attribute) || defined(dColorType_texture) || defined(dColorType_grid)
    #define dColorType_varying
#endif

#if ((defined(dRenderVariant_color) || defined(dRenderVariant_tracing)) && defined(dColorMarker)) || defined(dRenderVariant_marking)
    #define dNeedsMarker
#endif

#if defined(dXrayShaded_on) || defined(dXrayShaded_inverted)
    #define dXrayShaded
#endif

#if defined(dRenderVariant_color) || defined(dRenderVariant_tracing) || ((defined(dRenderVariant_depth) || defined(dRenderVariant_pick)) && defined(dXrayShaded))
    #define dNeedsNormal
#endif

#define MaskAll 0
#define MaskOpaque 1
#define MaskTransparent 2

//

#define PI 3.14159265
#define RECIPROCAL_PI 0.31830988618
#define EPSILON 1e-6
#define ONE_MINUS_EPSILON 1.0 - EPSILON
#define TWO_PI 6.2831853
#define HALF_PI 1.570796325

#define PALETTE_SCALE 16777214.0 // (1 << 24) - 2

#define saturate(a) clamp(a, 0.0, 1.0)

#if __VERSION__ == 100
    #define round(x) floor((x) + 0.5)
#endif

float intDiv(const in float a, const in float b) { return float(int(a) / int(b)); }
vec2 ivec2Div(const in vec2 a, const in vec2 b) { return vec2(ivec2(a) / ivec2(b)); }
float intMod(const in float a, const in float b) { return a - b * float(int(a) / int(b)); }
int imod(const in int a, const in int b) { return a - b * (a / b); }

float pow2(const in float x) { return x * x; }

vec3 packIntToRGB(in float value) {
    value = clamp(round(value), 0.0, 16777216.0 - 1.0) + 1.0;
    vec3 c = vec3(0.0);
    c.b = mod(value, 256.0);
    value = floor(value / 256.0);
    c.g = mod(value, 256.0);
    value = floor(value / 256.0);
    c.r = mod(value, 256.0);
    return c / 255.0;
}
float unpackRGBToInt(const in vec3 rgb) {
    return (floor(rgb.r * 255.0 + 0.5) * 256.0 * 256.0 + floor(rgb.g * 255.0 + 0.5) * 256.0 + floor(rgb.b * 255.0 + 0.5)) - 1.0;
}

vec2 packUnitIntervalToRG(const in float v) {
    vec2 enc;
    enc.xy = vec2(fract(v * 256.0), v);
    enc.y -= enc.x * (1.0 / 256.0);
    enc.xy *=  256.0 / 255.0;

    return enc;
}

float unpackRGToUnitInterval(const in vec2 enc) {
    return dot(enc, vec2(255.0 / (256.0 * 256.0), 255.0 / 256.0));
}

vec3 screenSpaceToViewSpace(const in vec3 ssPos, const in mat4 invProjection) {
    vec4 p = vec4(ssPos * 2.0 - 1.0, 1.0);
    p = invProjection * p;
    return p.xyz / p.w;
}

const float PackUpscale = 256.0 / 255.0; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255.0 / 256.0; // 0..1 -> fraction (excluding 1)
const vec3 PackFactors = vec3(256.0 * 256.0 * 256.0, 256.0 * 256.0,  256.0);
const vec4 UnpackFactors = UnpackDownscale / vec4(PackFactors, 1.0);
const float ShiftRight8 = 1.0 / 256.0;

vec4 packDepthToRGBA(const in float v) {
    vec4 r = vec4(fract(v * PackFactors), v);
    r.yzw -= r.xyz * ShiftRight8; // tidy overflow
    return r * PackUpscale;
}
float unpackRGBAToDepth(const in vec4 v) {
    return dot(v, UnpackFactors);
}

vec4 packDepthWithAlphaToRGBA(const in float depth, const in float alpha){
    vec3 r = vec3(fract(depth * PackFactors.yz), depth);
    r.yz -= r.xy * ShiftRight8; // tidy overflow
    return vec4(r * PackUpscale, alpha);
}
vec2 unpackRGBAToDepthWithAlpha(const in vec4 v) {
    return vec2(dot(v.xyz, UnpackFactors.yzw), v.w);
}

vec4 sRGBToLinear(const in vec4 c) {
    return vec4(mix(pow(c.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), c.rgb * 0.0773993808, vec3(lessThanEqual(c.rgb, vec3(0.04045)))), c.a);
}
vec4 linearTosRGB(const in vec4 c) {
    return vec4(mix(pow(c.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), c.rgb * 12.92, vec3(lessThanEqual(c.rgb, vec3(0.0031308)))), c.a);
}

float luminance(vec3 c) {
    // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance
    const vec3 W = vec3(0.2125, 0.7154, 0.0721);
    return dot(c, W);
}

float linearizeDepth(const in float depth, const in float near, const in float far) {
    return (2.0 * near) / (far + near - depth * (far - near));
}

float perspectiveDepthToViewZ(const in float invClipZ, const in float near, const in float far) {
    return (near * far) / ((far - near) * invClipZ - far);
}

float orthographicDepthToViewZ(const in float linearClipZ, const in float near, const in float far) {
    return linearClipZ * (near - far) - near;
}

float depthToViewZ(const in float isOrtho, const in float linearClipZ, const in float near, const in float far) {
    return isOrtho == 1.0 ? orthographicDepthToViewZ(linearClipZ, near, far) : perspectiveDepthToViewZ(linearClipZ, near, far);
}

// see https://github.com/graphitemaster/normals_revisited and https://www.shadertoy.com/view/3s33zj
mat3 adjoint(const in mat4 m) {
    return mat3(
        cross(m[1].xyz, m[2].xyz),
        cross(m[2].xyz, m[0].xyz),
        cross(m[0].xyz, m[1].xyz)
    );
}

#if __VERSION__ == 100
    // transpose

    float transpose(const in float m) {
        return m;
    }

    mat2 transpose2(const in mat2 m) {
        return mat2(
            m[0][0], m[1][0],
            m[0][1], m[1][1]
        );
    }

    mat3 transpose3(const in mat3 m) {
        return mat3(
            m[0][0], m[1][0], m[2][0],
            m[0][1], m[1][1], m[2][1],
            m[0][2], m[1][2], m[2][2]
        );
    }

    mat4 transpose4(const in mat4 m) {
        return mat4(
            m[0][0], m[1][0], m[2][0], m[3][0],
            m[0][1], m[1][1], m[2][1], m[3][1],
            m[0][2], m[1][2], m[2][2], m[3][2],
            m[0][3], m[1][3], m[2][3], m[3][3]
        );
    }

    // inverse

    float inverse(const in float m) {
        return 1.0 / m;
    }

    mat2 inverse2(const in mat2 m) {
        return mat2(m[1][1],-m[0][1],
                -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);
    }

    mat3 inverse3(const in mat3 m) {
        float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
        float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
        float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];

        float b01 = a22 * a11 - a12 * a21;
        float b11 = -a22 * a10 + a12 * a20;
        float b21 = a21 * a10 - a11 * a20;

        float det = a00 * b01 + a01 * b11 + a02 * b21;

        return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),
                    b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),
                    b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;
    }

    mat4 inverse4(const in mat4 m) {
        float
            a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
            a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
            a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
            a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],

            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,

            det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

        return mat4(
            a11 * b11 - a12 * b10 + a13 * b09,
            a02 * b10 - a01 * b11 - a03 * b09,
            a31 * b05 - a32 * b04 + a33 * b03,
            a22 * b04 - a21 * b05 - a23 * b03,
            a12 * b08 - a10 * b11 - a13 * b07,
            a00 * b11 - a02 * b08 + a03 * b07,
            a32 * b02 - a30 * b05 - a33 * b01,
            a20 * b05 - a22 * b02 + a23 * b01,
            a10 * b10 - a11 * b08 + a13 * b06,
            a01 * b08 - a00 * b10 - a03 * b06,
            a30 * b04 - a31 * b02 + a33 * b00,
            a21 * b02 - a20 * b04 - a23 * b00,
            a11 * b07 - a10 * b09 - a12 * b06,
            a00 * b09 - a01 * b07 + a02 * b06,
            a31 * b01 - a30 * b03 - a32 * b00,
            a20 * b03 - a21 * b01 + a22 * b00) / det;
    }

    #define isNaN(x) ((x) != (x))
    #define isInf(x) ((x) == (x) + 1.0)
#else
    #define transpose2(m) transpose(m)
    #define transpose3(m) transpose(m)
    #define transpose4(m) transpose(m)

    #define inverse2(m) inverse(m)
    #define inverse3(m) inverse(m)
    #define inverse4(m) inverse(m)

    #define isNaN isnan
    #define isInf isinf
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/fade-lod.glsl.js
var fade_lod = `
if (uLod.w == 0.0 && (uLod.x != 0.0 || uLod.y != 0.0)) {
    float d = dot(uCameraPlane.xyz, vModelPosition) + uCameraPlane.w;
    float ta = min(
        smoothstep(uLod.x, uLod.x + uLod.z, d),
        1.0 - smoothstep(uLod.y - uLod.z, uLod.y, d)
    );

    #if defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
        float at = 0.0;

        // shift by view-offset during multi-sample rendering to allow for blending
        vec2 coord = gl_FragCoord.xy + uViewOffset * 0.25;

        const mat4 thresholdMatrix = mat4(
            1.0 / 17.0,  9.0 / 17.0,  3.0 / 17.0, 11.0 / 17.0,
            13.0 / 17.0,  5.0 / 17.0, 15.0 / 17.0,  7.0 / 17.0,
            4.0 / 17.0, 12.0 / 17.0,  2.0 / 17.0, 10.0 / 17.0,
            16.0 / 17.0,  8.0 / 17.0, 14.0 / 17.0,  6.0 / 17.0
        );
        int ci = int(intMod(coord.x, 4.0));
        int ri = int(intMod(coord.y, 4.0));
        #if __VERSION__ == 100
            vec4 i = vec4(float(ci * 4 + ri));
            vec4 v = thresholdMatrix[0] * vec4(equal(i, vec4(0.0, 1.0, 2.0, 3.0))) +
                thresholdMatrix[1] * vec4(equal(i, vec4(4.0, 5.0, 6.0, 7.0))) +
                thresholdMatrix[2] * vec4(equal(i, vec4(8.0, 9.0, 10.0, 11.0))) +
                thresholdMatrix[3] * vec4(equal(i, vec4(12.0, 13.0, 14.0, 15.0)));
            at = v.x + v.y + v.z + v.w;
        #else
            at = thresholdMatrix[ci][ri];
        #endif

        if (ta < 0.99 && (ta < 0.01 || ta < at)) {
            discard;
        }
    #else
        if (ta < uPickingAlphaThreshold) {
            discard;
        }
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/float-to-rgba.glsl.js
var float_to_rgba = `
    // floatToRgba adapted from https://github.com/equinor/glsl-float-to-rgba
    // MIT License, Copyright (c) 2020 Equinor

    float shiftRight (float v, float amt) {
    v = floor(v) + 0.5;
    return floor(v / exp2(amt));
    }
    float shiftLeft (float v, float amt) {
        return floor(v * exp2(amt) + 0.5);
    }
    float maskLast (float v, float bits) {
        return mod(v, shiftLeft(1.0, bits));
    }
    float extractBits (float num, float from, float to) {
        from = floor(from + 0.5); to = floor(to + 0.5);
        return maskLast(shiftRight(num, from), to - from);
    }

    vec4 floatToRgba(float texelFloat, bool littleEndian) {
        if (texelFloat == 0.0) return vec4(0.0, 0.0, 0.0, 0.0);
        float sign = texelFloat > 0.0 ? 0.0 : 1.0;
        texelFloat = abs(texelFloat);
        float exponent = floor(log2(texelFloat));
        float biased_exponent = exponent + 127.0;
        float fraction = ((texelFloat / exp2(exponent)) - 1.0) * 8388608.0;
        float t = biased_exponent / 2.0;
        float last_bit_of_biased_exponent = fract(t) * 2.0;
        float remaining_bits_of_biased_exponent = floor(t);
        float byte4 = extractBits(fraction, 0.0, 8.0) / 255.0;
        float byte3 = extractBits(fraction, 8.0, 16.0) / 255.0;
        float byte2 = (last_bit_of_biased_exponent * 128.0 + extractBits(fraction, 16.0, 23.0)) / 255.0;
        float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;
        return (
            littleEndian
                ? vec4(byte4, byte3, byte2, byte1)
                : vec4(byte1, byte2, byte3, byte4)
        );
    }
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/light-frag-params.glsl.js
var light_frag_params = `
#if dLightCount != 0
    uniform vec3 uLightDirection[dLightCount];
    uniform vec3 uLightColor[dLightCount];
#endif
uniform vec3 uAmbientColor;

struct PhysicalMaterial {
    vec3 diffuseColor;
    float roughness;
    vec3 specularColor;
    float specularF90;
};

struct IncidentLight {
    vec3 color;
    vec3 direction;
};

struct ReflectedLight {
    vec3 directDiffuse;
    vec3 directSpecular;
    vec3 indirectDiffuse;
    vec3 indirectSpecular;
};

struct GeometricContext {
    vec3 position;
    vec3 normal;
    vec3 viewDir;
};

vec3 BRDF_Lambert(const in vec3 diffuseColor) {
    return RECIPROCAL_PI * diffuseColor;
}

vec3 F_Schlick(const in vec3 f0, const in float f90, const in float dotVH) {
    // Original approximation by Christophe Schlick '94
    // float fresnel = pow( 1.0 - dotVH, 5.0 );
    // Optimized variant (presented by Epic at SIGGRAPH '13)
    // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
    float fresnel = exp2((-5.55473 * dotVH - 6.98316) * dotVH);
    return f0 * (1.0 - fresnel) + (f90 * fresnel);
}

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float V_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {
    float a2 = pow2(alpha);
    float gv = dotNL * sqrt(a2 + (1.0 - a2) * pow2(dotNV));
    float gl = dotNV * sqrt(a2 + (1.0 - a2) * pow2(dotNL));
    return 0.5 / max(gv + gl, EPSILON);
}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
float D_GGX(const in float alpha, const in float dotNH) {
    float a2 = pow2(alpha);
    float denom = pow2(dotNH) * (a2 - 1.0) + 1.0; // avoid alpha = 0 with dotNH = 1
    return RECIPROCAL_PI * a2 / pow2(denom);
}

// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
vec3 BRDF_GGX(const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness) {
    float alpha = pow2(roughness); // UE4's roughness
    vec3 halfDir = normalize( lightDir + viewDir);
    float dotNL = saturate(dot(normal, lightDir));
    float dotNV = saturate(dot(normal, viewDir));
    float dotNH = saturate(dot(normal, halfDir));
    float dotVH = saturate(dot(viewDir, halfDir));
    vec3 F = F_Schlick(f0, f90, dotVH);
    float V = V_GGX_SmithCorrelated(alpha, dotNL, dotNV);
    float D = D_GGX(alpha, dotNH);
    return F * (V * D);
}

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 DFGApprox(const in vec3 normal, const in vec3 viewDir, const in float roughness) {
    float dotNV = saturate(dot(normal, viewDir));
    const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
    const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);
    vec4 r = roughness * c0 + c1;
    float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;
    vec2 fab = vec2(-1.04, 1.04) * a004 + r.zw;
    return fab;
}

// Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
void computeMultiscattering(const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter) {
    vec2 fab = DFGApprox(normal, viewDir, roughness);
    vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
    float Ess = fab.x + fab.y;
    float Ems = 1.0 - Ess;
    vec3 Favg = specularColor + (1.0 - specularColor) * 0.047619; // 1/21
    vec3 Fms = FssEss * Favg / (1.0 - Ems * Favg);
    singleScatter += FssEss;
    multiScatter += Fms * Ems;
}

void RE_Direct_Physical(const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
    float dotNL = saturate(dot(geometry.normal, directLight.direction));
    vec3 irradiance = dotNL * directLight.color;
    reflectedLight.directSpecular += irradiance * BRDF_GGX(directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness);
    reflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}

void RE_IndirectDiffuse_Physical(const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);
}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
    // Both indirect specular and indirect diffuse light accumulate here
    vec3 singleScattering = vec3(0.0);
    vec3 multiScattering = vec3(0.0);
    vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
    computeMultiscattering(geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering);
    vec3 diffuse = material.diffuseColor * (1.0 - ( singleScattering + multiScattering));
    reflectedLight.indirectSpecular += radiance * singleScattering;
    reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
    reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/matrix-scale.glsl.js
var matrix_scale = `
float matrixScale(in mat4 m){
    vec4 r = m[0];
    return sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/normal-frag-params.glsl.js
var normal_frag_params = `
varying vec3 vNormal;
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/read-from-texture.glsl.js
var read_from_texture = `
vec4 readFromTexture(const in sampler2D tex, const in float i, const in vec2 dim) {
    float x = intMod(i, dim.x);
    float y = floor(intDiv(i, dim.x));
    vec2 uv = (vec2(x, y) + 0.5) / dim;
    return texture2D(tex, uv);
}

vec4 readFromTexture(const in sampler2D tex, const in int i, const in vec2 dim) {
    int x = imod(i, int(dim.x));
    int y = i / int(dim.x);
    vec2 uv = (vec2(x, y) + 0.5) / dim;
    return texture2D(tex, uv);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/rgba-to-float.glsl.js
var rgba_to_float = `
    // rgbaToFloat adapted from https://github.com/ihmeuw/glsl-rgba-to-float
    // BSD 3-Clause License
    //
    // Copyright (c) 2019, Institute for Health Metrics and Evaluation All rights reserved.
    // Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    //  - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    //  - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    //  - Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
    //
    // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
    // INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
    // IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    // OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
    // OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
    // OF THE POSSIBILITY OF SUCH DAMAGE.

    ivec4 floatsToBytes(vec4 inputFloats, bool littleEndian) {
        ivec4 bytes = ivec4(inputFloats * 255.0);
        return (
            littleEndian
                ? bytes.abgr
                : bytes
        );
    }

    // Break the four bytes down into an array of 32 bits.
    void bytesToBits(const in ivec4 bytes, out bool bits[32]) {
        for (int channelIndex = 0; channelIndex < 4; ++channelIndex) {
            float acc = float(bytes[channelIndex]);
            for (int indexInByte = 7; indexInByte >= 0; --indexInByte) {
                float powerOfTwo = exp2(float(indexInByte));
                bool bit = acc >= powerOfTwo;
                bits[channelIndex * 8 + (7 - indexInByte)] = bit;
                acc = mod(acc, powerOfTwo);
            }
        }
    }

    // Compute the exponent of the 32-bit float.
    float getExponent(bool bits[32]) {
        const int startIndex = 1;
        const int bitStringLength = 8;
        const int endBeforeIndex = startIndex + bitStringLength;
        float acc = 0.0;
        int pow2 = bitStringLength - 1;
        for (int bitIndex = startIndex; bitIndex < endBeforeIndex; ++bitIndex) {
            acc += float(bits[bitIndex]) * exp2(float(pow2--));
        }
        return acc;
    }

    // Compute the mantissa of the 32-bit float.
    float getMantissa(bool bits[32], bool subnormal) {
        const int startIndex = 9;
        const int bitStringLength = 23;
        const int endBeforeIndex = startIndex + bitStringLength;
        // Leading/implicit/hidden bit convention:
        // If the number is not subnormal (with exponent 0), we add a leading 1 digit.
        float acc = float(!subnormal) * exp2(float(bitStringLength));
        int pow2 = bitStringLength - 1;
        for (int bitIndex = startIndex; bitIndex < endBeforeIndex; ++bitIndex) {
            acc += float(bits[bitIndex]) * exp2(float(pow2--));
        }
        return acc;
    }

    // Parse the float from its 32 bits.
    float bitsToFloat(bool bits[32]) {
        float signBit = float(bits[0]) * -2.0 + 1.0;
        float exponent = getExponent(bits);
        bool subnormal = abs(exponent - 0.0) < 0.01;
        float mantissa = getMantissa(bits, subnormal);
        float exponentBias = 127.0;
        return signBit * mantissa * exp2(exponent - exponentBias - 23.0);
    }

    float rgbaToFloat(vec4 texelRGBA, bool littleEndian) {
        ivec4 rgbaBytes = floatsToBytes(texelRGBA, littleEndian);
        bool bits[32];
        bytesToBits(rgbaBytes, bits);
        return bitsToFloat(bits);
    }
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/size-vert-params.glsl.js
var size_vert_params = `
#if defined(dSizeType_uniform)
    uniform float uSize;
#elif defined(dSizeType_attribute)
    attribute float aSize;
#elif defined(dSizeType_instance) || defined(dSizeType_group) || defined(dSizeType_groupInstance)
    uniform vec2 uSizeTexDim;
    uniform sampler2D tSize;
#endif

uniform float uSizeFactor;
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/texture3d-from-1d-trilinear.glsl.js
var texture3d_from_1d_trilinear = `
vec4 texture3dFrom1dTrilinear(const in sampler2D tex, const in vec3 pos, const in vec3 gridDim, const in vec2 texDim, const in float offset) {
    float gdYZ = gridDim.z * gridDim.y;
    float gdZ = gridDim.z;
    vec3 p0 = floor(pos * gridDim);
    vec3 p1 = ceil(pos * gridDim);
    vec3 pd = (pos * gridDim - p0) / (p1 - p0);
    vec4 s000 = readFromTexture(tex, offset + p0.z + p0.y * gdZ + p0.x * gdYZ, texDim);
    vec4 s100 = readFromTexture(tex, offset + p0.z + p0.y * gdZ + p1.x * gdYZ, texDim);
    vec4 s001 = readFromTexture(tex, offset + p1.z + p0.y * gdZ + p0.x * gdYZ, texDim);
    vec4 s101 = readFromTexture(tex, offset + p1.z + p0.y * gdZ + p1.x * gdYZ, texDim);
    vec4 s010 = readFromTexture(tex, offset + p0.z + p1.y * gdZ + p0.x * gdYZ, texDim);
    vec4 s110 = readFromTexture(tex, offset + p0.z + p1.y * gdZ + p1.x * gdYZ, texDim);
    vec4 s011 = readFromTexture(tex, offset + p1.z + p1.y * gdZ + p0.x * gdYZ, texDim);
    vec4 s111 = readFromTexture(tex, offset + p1.z + p1.y * gdZ + p1.x * gdYZ, texDim);
    vec4 s00 = mix(s000, s100, pd.x);
    vec4 s01 = mix(s001, s101, pd.x);
    vec4 s10 = mix(s010, s110, pd.x);
    vec4 s11 = mix(s011, s111, pd.x);
    vec4 s0 = mix(s00, s10, pd.y);
    vec4 s1 = mix(s01, s11, pd.y);
    return mix(s0, s1, pd.z);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/texture3d-from-2d-linear.glsl.js
var texture3d_from_2d_linear = `
vec4 texture3dFrom2dLinear(sampler2D tex, vec3 pos, vec3 gridDim, vec2 texDim) {
    float zSlice0 = floor(pos.z * gridDim.z);
    float column0 = intMod(zSlice0 * gridDim.x, texDim.x) / gridDim.x;
    float row0 = floor(intDiv(zSlice0 * gridDim.x, texDim.x));
    vec2 coord0 = (vec2(column0 * gridDim.x, row0 * gridDim.y) + (pos.xy * gridDim.xy)) / texDim;
    vec4 color0 = texture2D(tex, coord0);

    float zSlice1 = zSlice0 + 1.0;
    float column1 = intMod(zSlice1 * gridDim.x, texDim.x) / gridDim.x;
    float row1 = floor(intDiv(zSlice1 * gridDim.x, texDim.x));
    vec2 coord1 = (vec2(column1 * gridDim.x, row1 * gridDim.y) + (pos.xy * gridDim.xy)) / texDim;
    vec4 color1 = texture2D(tex, coord1);

    float delta0 = abs((pos.z * gridDim.z) - zSlice0);
    return mix(color0, color1, delta0);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/texture3d-from-2d-nearest.glsl.js
var texture3d_from_2d_nearest = `
vec4 texture3dFrom2dNearest(sampler2D tex, vec3 pos, vec3 gridDim, vec2 texDim) {
    float zSlice = floor(pos.z * gridDim.z + 0.5); // round to nearest z-slice
    float column = intMod(zSlice * gridDim.x, texDim.x) / gridDim.x;
    float row = floor(intDiv(zSlice * gridDim.x, texDim.x));
    vec2 coord = (vec2(column * gridDim.x, row * gridDim.y) + (pos.xy * gridDim.xy)) / texDim;
    return texture2D(tex, coord);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/wboit-write.glsl.js
var wboit_write = `
#if defined(dRenderVariant_colorWboit)
    if (uRenderMask == MaskOpaque) {
        if (preFogAlpha < 1.0) {
            discard;
        }
    } else if (uRenderMask == MaskTransparent) {
        if (preFogAlpha != 1.0 && fragmentDepth < getDepth(gl_FragCoord.xy / uDrawingBufferSize)) {
            #ifdef dTransparentBackfaces_off
                if (interior) discard;
            #endif
            float alpha = gl_FragColor.a;
            float wboitWeight = alpha * clamp(pow(1.0 - fragmentDepth, 2.0), 0.01, 1.0);
            gl_FragColor = vec4(gl_FragColor.rgb * alpha * wboitWeight, alpha);
            // extra alpha is to handle pre-multiplied alpha
            #ifndef dGeometryType_directVolume
                gl_FragData[1] = vec4((uTransparentBackground ? alpha : 1.0) * alpha * wboitWeight);
            #else
                gl_FragData[1] = vec4(alpha * alpha * wboitWeight);
            #endif
        } else {
            discard;
        }
    }
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/chunks/dpoit-write.glsl.js
var dpoit_write = `
#if defined(dRenderVariant_colorDpoit)
    if (uRenderMask == MaskOpaque) {
        if (preFogAlpha < 1.0) {
            discard;
        }
    } else if (uRenderMask == MaskTransparent) {
        vec2 coords = gl_FragCoord.xy / uDrawingBufferSize;
        if (preFogAlpha != 1.0 && fragmentDepth < getDepth(coords)) {
            #ifdef dTransparentBackfaces_off
                if (interior) discard;
            #endif

            // adapted from https://github.com/tsherif/webgl2examples
            // The MIT License, Copyright 2017 Tarek Sherif, Shuai Shao

            vec2 lastDepth = texture2D(tDpoitDepth, coords).rg;
            vec4 lastFrontColor = texture2D(tDpoitFrontColor, coords);

            vec4 fragColor = gl_FragColor;

            // depth value always increases
            // so we can use MAX blend equation
            gl_FragData[2].rg = vec2(-MAX_DPOIT_DEPTH);

            // front color always increases
            // so we can use MAX blend equation
            gl_FragColor = lastFrontColor;

            // back color is separately blend afterwards each pass
            gl_FragData[1] = vec4(0.0);

            float nearestDepth = -lastDepth.x;
            float furthestDepth = lastDepth.y;
            float alphaMultiplier = 1.0 - lastFrontColor.a;

            if (fragmentDepth < nearestDepth || fragmentDepth > furthestDepth) {
                // Skip this depth since it's been peeled.
                return;
            }

            if (fragmentDepth > nearestDepth && fragmentDepth < furthestDepth) {
                // This needs to be peeled.
                // The ones remaining after MAX blended for
                // all need-to-peel will be peeled next pass.
                gl_FragData[2].rg = vec2(-fragmentDepth, fragmentDepth);
                return;
            }

            // write to back and front color buffer
            if (fragmentDepth == nearestDepth) {
                gl_FragColor.rgb += fragColor.rgb * fragColor.a * alphaMultiplier;
                gl_FragColor.a = 1.0 - alphaMultiplier * (1.0 - fragColor.a);
            } else {
                gl_FragData[1] += fragColor;
            }

        } else {
            discard;
        }
    }
#endif
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/points.vert.js
var points_vert = `
precision highp float;
precision highp int;

#include common
#include read_from_texture
#include common_vert_params
#include color_vert_params
#include size_vert_params
#include common_clip

uniform float uPixelRatio;
uniform vec4 uViewport;

attribute vec3 aPosition;
attribute mat4 aTransform;
attribute float aInstance;
attribute float aGroup;

void main(){
    int vertexId = VertexID;

    #include assign_group
    #include assign_color_varying
    #include assign_marker_varying
    #include assign_clipping_varying
    #include assign_position
    #include assign_size

    #ifdef dPointSizeAttenuation
        gl_PointSize = size * uPixelRatio * ((uViewport.w / 2.0) / -mvPosition.z) * 5.0;
    #else
        gl_PointSize = size * uPixelRatio;
    #endif
    gl_PointSize = max(1.0, gl_PointSize);

    gl_Position = uProjection * mvPosition;

    #include clip_instance
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/points.frag.js
var points_frag = `
precision highp float;
precision highp int;

#include common
#include common_frag_params
#include color_frag_params
#include common_clip

const vec2 center = vec2(0.5);
const float radius = 0.5;

void main(){
    #include fade_lod
    #include clip_pixel

    float fragmentDepth = gl_FragCoord.z;
    #include assign_material_color

    #if defined(dPointStyle_circle)
        float dist = distance(gl_PointCoord, center);
        if (dist > radius) discard;
    #elif defined(dPointStyle_fuzzy)
        float dist = distance(gl_PointCoord, center);
        float fuzzyAlpha = 1.0 - smoothstep(0.0, radius, dist);
        if (fuzzyAlpha < 0.0001) discard;
    #endif

    #if defined(dPointStyle_fuzzy) && (defined(dRenderVariant_color) || defined(dRenderVariant_tracing))
        material.a *= fuzzyAlpha;
    #endif

    #include check_transparency

    #if defined(dRenderVariant_pick)
        #include check_picking_alpha
        #ifdef requiredDrawBuffers
            gl_FragColor = vObject;
            gl_FragData[1] = vInstance;
            gl_FragData[2] = vGroup;
            gl_FragData[3] = packDepthToRGBA(fragmentDepth);
        #else
            gl_FragColor = vColor;
        #endif
    #elif defined(dRenderVariant_depth)
        gl_FragColor = material;
    #elif defined(dRenderVariant_marking)
        gl_FragColor = material;
    #elif defined(dRenderVariant_emissive)
        gl_FragColor = material;
    #elif defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
        gl_FragColor = material;
        #include apply_marker_color

        #if defined(dRenderVariant_color)
            #include apply_fog
            #include wboit_write
            #include dpoit_write
        #elif defined(dRenderVariant_tracing)
            gl_FragData[1] = vec4(normalize(vViewPosition), emissive);
            gl_FragData[2] = vec4(material.rgb, uDensity);
        #endif
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/spheres.vert.js
var spheres_vert = `
precision highp float;
precision highp int;

#include common
#include read_from_texture
#include common_vert_params
#include color_vert_params
#include size_vert_params
#include common_clip

uniform mat4 uModelView;
uniform mat4 uInvProjection;
uniform float uIsOrtho;

uniform vec2 uTexDim;
uniform sampler2D tPositionGroup;

attribute mat4 aTransform;
attribute float aInstance;

varying float vRadius;
varying vec3 vPoint;
varying vec3 vPointViewPosition;

#include matrix_scale

/**
 * Bounding rectangle of a clipped, perspective-projected 3D Sphere.
 * Michael Mara, Morgan McGuire. 2013
 *
 * Specialization by Arseny Kapoulkine, MIT License Copyright (c) 2018
 * https://github.com/zeux/niagara
 */
void sphereProjection(const in vec3 p, const in float r, const in vec2 mapping) {
    vec3 pr = p * r;
    float pzr2 = p.z * p.z - r * r;

    float vx = sqrt(p.x * p.x + pzr2);
    float minx = ((vx * p.x - pr.z) / (vx * p.z + pr.x)) * uProjection[0][0];
    float maxx = ((vx * p.x + pr.z) / (vx * p.z - pr.x)) * uProjection[0][0];

    float vy = sqrt(p.y * p.y + pzr2);
    float miny = ((vy * p.y - pr.z) / (vy * p.z + pr.y)) * uProjection[1][1];
    float maxy = ((vy * p.y + pr.z) / (vy * p.z - pr.y)) * uProjection[1][1];

    gl_Position.xy = vec2(maxx + minx, maxy + miny) * -0.5;
    gl_Position.xy -= mapping * vec2(maxx - minx, maxy - miny) * 0.5;
    gl_Position.xy *= gl_Position.w;
}

void main(void){
    vec2 mapping = vec2(1.0, 1.0); // vertices 2 and 5
    #if __VERSION__ == 100
        int m = imod(VertexID, 6);
    #else
        int m = VertexID % 6;
    #endif
    if (m == 0) {
        mapping = vec2(-1.0, 1.0);
    } else if (m == 1 || m == 3) {
        mapping = vec2(-1.0, -1.0);
    } else if (m == 4) {
        mapping = vec2(1.0, -1.0);
    }

    int vertexId = VertexID / 6;

    vec4 positionGroup = readFromTexture(tPositionGroup, vertexId, uTexDim);
    vec3 position = positionGroup.rgb;
    float group = positionGroup.a;

    #include assign_color_varying
    #include assign_marker_varying
    #include assign_clipping_varying
    #include assign_size

    vRadius = size * matrixScale(uModelView);

    vec4 position4 = vec4(position, 1.0);
    vModelPosition = (uModel * aTransform * position4).xyz; // for clipping in frag shader

    float d;
    if (uLod.w != 0.0 && (uLod.x != 0.0 || uLod.y != 0.0)) {
        d = dot(uCameraPlane.xyz, vModelPosition) + uCameraPlane.w;
        float f = min(
            smoothstep(uLod.x, uLod.x + uLod.z, d),
            1.0 - smoothstep(uLod.y - uLod.z, uLod.y, d)
        ) * uLod.w;
        vRadius *= f;
    }

    vec4 mvPosition = uModelView * aTransform * position4;

    #ifdef dApproximate
        vec4 mvCorner = vec4(mvPosition.xyz, 1.0);
        mvCorner.xy += mapping * vRadius;
        gl_Position = uProjection * mvCorner;
    #else
        if (uIsOrtho == 1.0) {
            vec4 mvCorner = vec4(mvPosition.xyz, 1.0);
            mvCorner.xy += mapping * vRadius;
            gl_Position = uProjection * mvCorner;
        } else {
            gl_Position = uProjection * vec4(mvPosition.xyz, 1.0);
            sphereProjection(mvPosition.xyz, vRadius, mapping);
        }
    #endif

    vec4 vPoint4 = uInvProjection * gl_Position;
    vPoint = vPoint4.xyz / vPoint4.w;
    vPointViewPosition = -mvPosition.xyz / mvPosition.w;

    if (gl_Position.z < -gl_Position.w) {
        mvPosition.z -= 2.0 * vRadius; // avoid clipping
        gl_Position.z = (uProjection * vec4(mvPosition.xyz, 1.0)).z;
    }

    if (uLod.w != 0.0 && (uLod.x != 0.0 || uLod.y != 0.0)) {
        if (d < uLod.x || d > uLod.y) {
            // move out of [ -w, +w ] to 'discard' in vert shader
            gl_Position.z = 2.0 * gl_Position.w;
        }
    }

    #if defined(dClipPrimitive) && !defined(dClipVariant_instance) && dClipObjectCount != 0
        if (clipTest(vModelPosition)) {
            // move out of [ -w, +w ] to 'discard' in vert shader
            gl_Position.z = 2.0 * gl_Position.w;
        }
    #else
        #include clip_instance
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/spheres.frag.js
var spheres_frag = `
precision highp float;
precision highp int;

#define bumpEnabled

#include common
#include common_frag_params
#include color_frag_params
#include light_frag_params
#include common_clip

uniform mat4 uInvView;
uniform float uAlphaThickness;

varying float vRadius;
varying vec3 vPoint;
varying vec3 vPointViewPosition;

#ifdef dSolidInterior
    const bool solidInterior = true;
#else
    const bool solidInterior = false;
#endif

bool SphereImpostor(out vec3 modelPos, out vec3 cameraPos, out vec3 cameraNormal, out bool interior, out float fragmentDepth){
    vec3 cameraSpherePos = -vPointViewPosition;

    vec3 rayOrigin = mix(vec3(0.0, 0.0, 0.0), vPoint, uIsOrtho);
    vec3 rayDirection = mix(normalize(vPoint), vec3(0.0, 0.0, 1.0), uIsOrtho);
    vec3 cameraSphereDir = mix(cameraSpherePos, rayOrigin - cameraSpherePos, uIsOrtho);

    float B = dot(rayDirection, cameraSphereDir);
    float det = B * B + vRadius * vRadius - dot(cameraSphereDir, cameraSphereDir);

    if (det < 0.0) return false;

    float sqrtDet = sqrt(det);
    float posT = mix(B + sqrtDet, B - sqrtDet, uIsOrtho);
    float negT = mix(B - sqrtDet, B + sqrtDet, uIsOrtho);

    cameraPos = rayDirection * negT + rayOrigin;
    modelPos = (uInvView * vec4(cameraPos, 1.0)).xyz;
    fragmentDepth = calcDepth(cameraPos);

    bool objectClipped = false;

    #if !defined(dClipPrimitive) && defined(dClipVariant_pixel) && dClipObjectCount != 0
        if (clipTest(modelPos)) {
            objectClipped = true;
            fragmentDepth = -1.0;
        }
    #endif

    if (fragmentDepth > 0.0) {
        cameraNormal = normalize(cameraPos - cameraSpherePos);
        interior = false;
        return true;
    } else if (uDoubleSided || solidInterior) {
        cameraPos = rayDirection * posT + rayOrigin;
        modelPos = (uInvView * vec4(cameraPos, 1.0)).xyz;
        fragmentDepth = calcDepth(cameraPos);
        cameraNormal = -normalize(cameraPos - cameraSpherePos);
        interior = true;
        if (fragmentDepth > 0.0) {
            #ifdef dSolidInterior
                if (!objectClipped) {
                    fragmentDepth = 0.0 + (0.0000001 / vRadius);
                    cameraNormal = -mix(normalize(vPoint), vec3(0.0, 0.0, -1.0), uIsOrtho);
                }
            #endif
            return true;
        }
    }

    return false;
}

void main(void){
    vec3 cameraNormal;
    float fragmentDepth;

    #ifdef dApproximate
        vec3 pointDir = -vPointViewPosition - vPoint;
        if (dot(pointDir, pointDir) > vRadius * vRadius) discard;
        vec3 vViewPosition = -vPointViewPosition;
        fragmentDepth = gl_FragCoord.z;
        #if !defined(dIgnoreLight) || defined(dXrayShaded) || defined(dRenderVariant_tracing)
            pointDir.z -= cos(length(pointDir));
            cameraNormal = -normalize(pointDir);
        #endif
        interior = false;
    #else
        vec3 modelPos;
        vec3 cameraPos;
        bool hit = SphereImpostor(modelPos, cameraPos, cameraNormal, interior, fragmentDepth);
        if (!hit) discard;

        if (fragmentDepth < 0.0) discard;
        if (fragmentDepth > 1.0) discard;

        gl_FragDepthEXT = fragmentDepth;

        vec3 vModelPosition = modelPos;
        vec3 vViewPosition = cameraPos;
    #endif

    #include fade_lod
    #if !defined(dClipPrimitive) && defined(dClipVariant_pixel) && dClipObjectCount != 0
        #include clip_pixel
    #endif

    #ifdef dNeedsNormal
        vec3 normal = -cameraNormal;
    #endif

    #include assign_material_color

    #if defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
        if (uRenderMask == MaskTransparent && uAlphaThickness > 0.0) {
            material.a *= min(1.0, vRadius / uAlphaThickness);
        }
    #endif

    #include check_transparency

    #if defined(dRenderVariant_pick)
        #include check_picking_alpha
        #ifdef requiredDrawBuffers
            gl_FragColor = vObject;
            gl_FragData[1] = vInstance;
            gl_FragData[2] = vGroup;
            gl_FragData[3] = packDepthToRGBA(fragmentDepth);
        #else
            gl_FragColor = vColor;
        #endif
    #elif defined(dRenderVariant_depth)
        gl_FragColor = material;
    #elif defined(dRenderVariant_marking)
        gl_FragColor = material;
    #elif defined(dRenderVariant_emissive)
        gl_FragColor = material;
    #elif defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
        #include apply_light_color
        #include apply_interior_color
        #include apply_marker_color

        #if defined(dRenderVariant_color)
            #include apply_fog
            #include wboit_write
            #include dpoit_write
        #elif defined(dRenderVariant_tracing)
            gl_FragData[1] = vec4(normal, emissive);
            gl_FragData[2] = vec4(material.rgb, uDensity);
        #endif
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/cylinders.vert.js
var cylinders_vert = `
precision highp float;
precision highp int;

#include common
#include read_from_texture
#include common_vert_params
#include color_vert_params
#include size_vert_params
#include common_clip

uniform mat4 uModelView;

attribute mat4 aTransform;
attribute float aInstance;
attribute float aGroup;

attribute vec3 aMapping;
attribute vec3 aStart;
attribute vec3 aEnd;
attribute float aScale;
attribute float aCap;
attribute float aColorMode;

varying mat4 vTransform;
varying vec3 vStart;
varying vec3 vEnd;
varying float vSize;
varying float vCap;

uniform float uIsOrtho;
uniform vec3 uCameraDir;

void main() {
    int vertexId = VertexID;

    #include assign_group
    #include assign_color_varying
    #include assign_marker_varying
    #include assign_clipping_varying
    #include assign_size

    mat4 modelTransform = uModel * aTransform;

    vTransform = aTransform;
    vStart = (modelTransform * vec4(aStart, 1.0)).xyz;
    vEnd = (modelTransform * vec4(aEnd, 1.0)).xyz;
    vSize = size * aScale;
    vCap = aCap;

    vModelPosition = (vStart + vEnd) * 0.5;
    vec3 camDir = -mix(normalize(vModelPosition - uCameraPosition), uCameraDir, uIsOrtho);
    vec3 dir = vEnd - vStart;
    float f = aMapping.x > 0.0 ? 1.0 : 0.0;
    // ensure cylinder 'dir' is pointing towards the camera
    if(dot(camDir, dir) < 0.0) {
        dir = -dir;
        f = 1.0 - f;
    }

    vec3 left = cross(camDir, dir);
    vec3 up = cross(left, dir);
    left = vSize * normalize(left);
    up = vSize * normalize(up);

    // move vertex in object-space from center to corner
    vModelPosition += aMapping.x * dir + aMapping.y * left + aMapping.z * up;

    vec4 mvPosition = uView * vec4(vModelPosition, 1.0);
    vViewPosition = mvPosition.xyz;
    gl_Position = uProjection * mvPosition;

    if (gl_Position.z < -gl_Position.w) {
        mvPosition.z -= 2.0 * (length(vEnd - vStart) + vSize); // avoid clipping
        gl_Position.z = (uProjection * mvPosition).z;
    }

    #if defined(dDualColor) && defined(dRenderVariant_color) && (defined(dColorType_group) || defined(dColorType_groupInstance))
        // dual-color mixing
        // - for aColorMode between 0 and 1 use aColorMode to interpolate
        // - for aColorMode == 2 do nothing, i.e., use vColor
        // - for aColorMode == 3 use position on cylinder axis to interpolate
        if (aColorMode <= 1.0){
            vColor.rgb = mix(vColor.rgb, color2.rgb, aColorMode);
        } else if (aColorMode == 3.0) {
            vColor.rgb = mix(vColor.rgb, color2.rgb, mix(-0.25, 1.25, f / 1.5));
        }
    #endif

    #include clip_instance
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/cylinders.frag.js
var cylinders_frag = `
precision highp float;
precision highp int;

#define bumpEnabled

uniform mat4 uView;

varying mat4 vTransform;
varying vec3 vStart;
varying vec3 vEnd;
varying float vSize;
varying float vCap;

uniform vec3 uCameraDir;
uniform vec3 uCameraPosition;
uniform mat4 uInvView;

#include common
#include common_frag_params
#include color_frag_params
#include light_frag_params
#include common_clip

#ifdef dSolidInterior
    const bool solidInterior = true;
#else
    const bool solidInterior = false;
#endif

// adapted from https://www.shadertoy.com/view/4lcSRn
// The MIT License, Copyright 2016 Inigo Quilez
bool CylinderImpostor(
    in vec3 rayOrigin, in vec3 rayDir,
    in vec3 start, in vec3 end, in float radius,
    out vec3 cameraNormal, out bool interior,
    out vec3 modelPosition, out vec3 viewPosition, out float fragmentDepth
){
    vec3 ba = end - start;
    vec3 oc = rayOrigin - start;

    float baba = dot(ba, ba);
    float bard = dot(ba, rayDir);
    float baoc = dot(ba, oc);

    float k2 = baba - bard * bard;
    float k1 = baba * dot(oc, rayDir) - baoc * bard;
    float k0 = baba * dot(oc, oc) - baoc * baoc - radius * radius * baba;

    float h = k1 * k1 - k2 * k0;
    if (h < 0.0) return false;

    bool topCap = (vCap > 0.9 && vCap < 1.1) || vCap >= 2.9;
    bool bottomCap = (vCap > 1.9 && vCap < 2.1) || vCap >= 2.9;

    #ifdef dSolidInterior
        bool topInterior = !topCap;
        bool bottomInterior = !bottomCap;
        topCap = true;
        bottomCap = true;
    #else
        bool topInterior = false;
        bool bottomInterior = false;
    #endif

    bool clipped = false;
    bool objectClipped = false;

    // body outside
    h = sqrt(h);
    float t = (-k1 - h) / k2;
    float y = baoc + t * bard;
    if (y > 0.0 && y < baba) {
        interior = false;
        cameraNormal = (oc + t * rayDir - ba * y / baba) / radius;
        modelPosition = rayOrigin + t * rayDir;
        viewPosition = (uView * vec4(modelPosition, 1.0)).xyz;
        fragmentDepth = calcDepth(viewPosition);
        #if defined(dClipVariant_pixel) && dClipObjectCount != 0
            if (clipTest(modelPosition)) {
                objectClipped = true;
                fragmentDepth = -1.0;
                #ifdef dSolidInterior
                    topCap = !topInterior;
                    bottomCap = !bottomInterior;
                #endif
            }
        #endif
        if (fragmentDepth > 0.0) return true;
        clipped = true;
    }

    if (!clipped) {
        if (topCap && y < 0.0) {
            // top cap
            t = -baoc / bard;
            if (abs(k1 + k2 * t) < h) {
                interior = topInterior;
                cameraNormal = -ba / baba;
                modelPosition = rayOrigin + t * rayDir;
                viewPosition = (uView * vec4(modelPosition, 1.0)).xyz;
                fragmentDepth = calcDepth(viewPosition);
                #if defined(dClipVariant_pixel) && dClipObjectCount != 0
                    if (clipTest(modelPosition)) {
                        objectClipped = true;
                        fragmentDepth = -1.0;
                        #ifdef dSolidInterior
                            topCap = !topInterior;
                            bottomCap = !bottomInterior;
                        #endif
                    }
                #endif
                if (fragmentDepth > 0.0) {
                    #ifdef dSolidInterior
                        if (interior) cameraNormal = -rayDir;
                    #endif
                    #if defined(dClipVariant_pixel) && dClipObjectCount != 0
                        return true;
                    #else
                        return !interior;
                    #endif
                }
            }
        } else if (bottomCap && y >= 0.0) {
            // bottom cap
            t = (baba - baoc) / bard;
            if (abs(k1 + k2 * t) < h) {
                interior = bottomInterior;
                cameraNormal = ba / baba;
                modelPosition = rayOrigin + t * rayDir;
                viewPosition = (uView * vec4(modelPosition, 1.0)).xyz;
                fragmentDepth = calcDepth(viewPosition);
                #if defined(dClipVariant_pixel) && dClipObjectCount != 0
                    if (clipTest(modelPosition)) {
                        objectClipped = true;
                        fragmentDepth = -1.0;
                        #ifdef dSolidInterior
                            topCap = !topInterior;
                            bottomCap = !bottomInterior;
                        #endif
                    }
                #endif
                if (fragmentDepth > 0.0) {
                    #ifdef dSolidInterior
                        if (interior) cameraNormal = -rayDir;
                    #endif
                    #if defined(dClipVariant_pixel) && dClipObjectCount != 0
                        return true;
                    #else
                        return !interior;
                    #endif
                }
            }
        }
    }

    if (uDoubleSided || solidInterior) {
        // body inside
        h = -h;
        t = (-k1 - h) / k2;
        y = baoc + t * bard;
        if (y > 0.0 && y < baba) {
            interior = true;
            cameraNormal = -(oc + t * rayDir - ba * y / baba) / radius;
            modelPosition = rayOrigin + t * rayDir;
            viewPosition = (uView * vec4(modelPosition, 1.0)).xyz;
            fragmentDepth = calcDepth(viewPosition);
            if (fragmentDepth > 0.0) {
                #ifdef dSolidInterior
                    if (!objectClipped) {
                        fragmentDepth = 0.0 + (0.0000002 / vSize);
                        cameraNormal = -rayDir;
                    }
                #endif
                return true;
            }
        }

        if (topCap && y < 0.0) {
            // top cap
            t = -baoc / bard;
            if (abs(k1 + k2 * t) < -h) {
                interior = true;
                cameraNormal = ba / baba;
                modelPosition = rayOrigin + t * rayDir;
                viewPosition = (uView * vec4(modelPosition, 1.0)).xyz;
                fragmentDepth = calcDepth(viewPosition);
                if (fragmentDepth > 0.0) {
                    #ifdef dSolidInterior
                        if (!objectClipped) {
                            fragmentDepth = 0.0 + (0.0000002 / vSize);
                            cameraNormal = -rayDir;
                        }
                    #endif
                    return true;
                }
            }
        } else if (bottomCap && y >= 0.0) {
            // bottom cap
            t = (baba - baoc) / bard;
            if (abs(k1 + k2 * t) < -h) {
                interior = true;
                cameraNormal = -ba / baba;
                modelPosition = rayOrigin + t * rayDir;
                viewPosition = (uView * vec4(modelPosition, 1.0)).xyz;
                fragmentDepth = calcDepth(viewPosition);
                if (fragmentDepth > 0.0) {
                    #ifdef dSolidInterior
                        if (!objectClipped) {
                            fragmentDepth = 0.0 + (0.0000002 / vSize);
                            cameraNormal = -rayDir;
                        }
                    #endif
                    return true;
                }
            }
        }
    }

    return false;
}

void main() {
    vec3 rayOrigin = vModelPosition;
    vec3 rayDir = mix(normalize(vModelPosition - uCameraPosition), uCameraDir, uIsOrtho);

    vec3 cameraNormal;
    vec3 modelPosition;
    vec3 viewPosition;
    float fragmentDepth;
    bool hit = CylinderImpostor(rayOrigin, rayDir, vStart, vEnd, vSize, cameraNormal, interior, modelPosition, viewPosition, fragmentDepth);
    if (!hit) discard;

    if (fragmentDepth < 0.0) discard;
    if (fragmentDepth > 1.0) discard;

    gl_FragDepthEXT = fragmentDepth;

    vec3 vViewPosition = viewPosition;
    vec3 vModelPosition = modelPosition;

    #include fade_lod
    #include clip_pixel

    #ifdef dNeedsNormal
        mat3 normalMatrix = adjoint(uView);
        vec3 normal = normalize(normalMatrix * -normalize(cameraNormal));
    #endif

    #include assign_material_color
    #include check_transparency

    #if defined(dRenderVariant_pick)
        #include check_picking_alpha
        #ifdef requiredDrawBuffers
            gl_FragColor = vObject;
            gl_FragData[1] = vInstance;
            gl_FragData[2] = vGroup;
            gl_FragData[3] = packDepthToRGBA(fragmentDepth);
        #else
            gl_FragColor = vColor;
        #endif
    #elif defined(dRenderVariant_depth)
        gl_FragColor = material;
    #elif defined(dRenderVariant_marking)
        gl_FragColor = material;
    #elif defined(dRenderVariant_emissive)
        gl_FragColor = material;
    #elif defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
        #include apply_light_color
        #include apply_interior_color
        #include apply_marker_color

        #if defined(dRenderVariant_color)
            #include apply_fog
            #include wboit_write
            #include dpoit_write
        #elif defined(dRenderVariant_tracing)
            gl_FragData[1] = vec4(normal, emissive);
            gl_FragData[2] = vec4(material.rgb, uDensity);
        #endif
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/text.vert.js
var text_vert = `
precision highp float;
precision highp int;

#include common
#include read_from_texture
#include common_vert_params
#include color_vert_params
#include size_vert_params
#include common_clip

uniform mat4 uModelView;

attribute vec3 aPosition;
attribute vec2 aMapping;
attribute float aDepth;
attribute vec2 aTexCoord;
attribute mat4 aTransform;
attribute float aInstance;
attribute float aGroup;

uniform float uOffsetX;
uniform float uOffsetY;
uniform float uOffsetZ;

uniform float uIsOrtho;
uniform float uPixelRatio;
uniform vec4 uViewport;

varying vec2 vTexCoord;

#include matrix_scale

void main(void){
    int vertexId = VertexID;

    #include assign_group
    #include assign_color_varying
    #include assign_marker_varying
    #include assign_clipping_varying
    #include assign_size

    vTexCoord = aTexCoord;

    float scale = matrixScale(uModelView);

    float offsetX = uOffsetX * scale;
    float offsetY = uOffsetY * scale;
    float offsetZ = (uOffsetZ + aDepth * 0.95) * scale;

    vec4 position4 = vec4(aPosition, 1.0);
    vec4 mvPosition = uModelView * aTransform * position4;

    vModelPosition = (uModel * aTransform * position4).xyz; // for clipping in frag shader

    // TODO
    // #ifdef FIXED_SIZE
    //     if (ortho) {
    //         scale /= pixelRatio * ((uViewport.w / 2.0) / -uCameraPosition.z) * 0.1;
    //     } else {
    //         scale /= pixelRatio * ((uViewport.w / 2.0) / -mvPosition.z) * 0.1;
    //     }
    // #endif

    vec4 mvCorner = vec4(mvPosition.xyz, 1.0);

    if (vTexCoord.x == 10.0) { // indicates background plane
        // move a bit to the back, taking distance to camera into account to avoid z-fighting
        offsetZ -= 0.001 * distance(uCameraPosition, (uProjection * mvCorner).xyz);
    }

    mvCorner.xy += aMapping * size * scale;
    mvCorner.x += offsetX;
    mvCorner.y += offsetY;

    if (uIsOrtho == 1.0) {
        mvCorner.z += offsetZ;
    } else {
        mvCorner.xyz += normalize(-mvCorner.xyz) * offsetZ;
    }

    gl_Position = uProjection * mvCorner;

    vViewPosition = -mvCorner.xyz;

    #include clip_instance
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/text.frag.js
var text_frag = `
precision highp float;
precision highp int;

#include common
#include common_frag_params
#include color_frag_params
#include common_clip

uniform sampler2D tFont;

uniform vec3 uBorderColor;
uniform float uBorderWidth;
uniform vec3 uBackgroundColor;
uniform float uBackgroundOpacity;

varying vec2 vTexCoord;

void main(){
    #include fade_lod
    #include clip_pixel

    float fragmentDepth = gl_FragCoord.z;
    #include assign_material_color

    if (vTexCoord.x > 1.0) {
        #if defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
            material = vec4(uBackgroundColor, uBackgroundOpacity * material.a);
        #endif
    } else {
        // retrieve signed distance
        float sdf = texture2D(tFont, vTexCoord).a + uBorderWidth;

        if (sdf < 0.5) discard;

        #if defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
            // add border
            float t = 0.5 + uBorderWidth;
            if (uBorderWidth > 0.0 && sdf < t) {
                material.xyz = uBorderColor;
            }
        #endif
    }

    #include check_transparency

    #if defined(dRenderVariant_pick)
        #include check_picking_alpha
        #ifdef requiredDrawBuffers
            gl_FragColor = vObject;
            gl_FragData[1] = vInstance;
            gl_FragData[2] = vGroup;
            gl_FragData[3] = packDepthToRGBA(fragmentDepth);
        #else
            gl_FragColor = vColor;
        #endif
    #elif defined(dRenderVariant_depth)
        gl_FragColor = material;
    #elif defined(dRenderVariant_marking)
        gl_FragColor = material;
    #elif defined(dRenderVariant_emissive)
        gl_FragColor = material;
    #elif defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
        gl_FragColor = material;
        #include apply_marker_color

        #if defined(dRenderVariant_color)
            #include apply_fog
            #include wboit_write
            #include dpoit_write
        #elif defined(dRenderVariant_tracing)
            gl_FragData[1] = vec4(-normalize(vViewPosition), emissive);
            gl_FragData[2] = vec4(material.rgb, uDensity);
        #endif
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/lines.vert.js
var lines_vert = `
precision highp float;
precision highp int;

#include common
#include read_from_texture
#include common_vert_params
#include color_vert_params
#include size_vert_params
#include common_clip

uniform float uPixelRatio;
uniform vec4 uViewport;

attribute mat4 aTransform;
attribute float aInstance;
attribute float aGroup;

attribute vec2 aMapping;
attribute vec3 aStart;
attribute vec3 aEnd;

void trimSegment(const in vec4 start, inout vec4 end) {
    // trim end segment so it terminates between the camera plane and the near plane
    // conservative estimate of the near plane
    float a = uProjection[2][2];  // 3rd entry in 3rd column
    float b = uProjection[3][2];  // 3rd entry in 4th column
    float nearEstimate = -0.5 * b / a;
    float alpha = (nearEstimate - start.z) / (end.z - start.z);
    end.xyz = mix(start.xyz, end.xyz, alpha);
}

void main(){
    float aspect = uViewport.z / uViewport.w;
    int vertexId = VertexID;

    #include assign_group
    #include assign_color_varying
    #include assign_marker_varying
    #include assign_clipping_varying
    #include assign_size

    mat4 modelView = uView * uModel * aTransform;

    // camera space
    vec4 start = modelView * vec4(aStart, 1.0);
    vec4 end = modelView * vec4(aEnd, 1.0);

    // assign position
    vec4 position4 = vec4((aMapping.y < 0.5) ? aStart : aEnd, 1.0);
    vec4 mvPosition = modelView * position4;
    vViewPosition = mvPosition.xyz;

    vModelPosition = (uModel * aTransform * position4).xyz; // for clipping in frag shader

    // special case for perspective projection, and segments that terminate either in, or behind, the camera plane
    // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
    // but we need to perform ndc-space calculations in the shader, so we must address this issue directly
    // perhaps there is a more elegant solution -- WestLangley
    bool perspective = (uProjection[2][3] == -1.0); // 4th entry in the 3rd column
    if (perspective) {
        if (start.z < 0.0 && end.z >= 0.0) {
            trimSegment(start, end);
        } else if (end.z < 0.0 && start.z >= 0.0) {
            trimSegment(end, start);
        }
    }

    // clip space
    vec4 clipStart = uProjection * start;
    vec4 clipEnd = uProjection * end;

    // ndc space
    vec2 ndcStart = clipStart.xy / clipStart.w;
    vec2 ndcEnd = clipEnd.xy / clipEnd.w;

    // direction
    vec2 dir = ndcEnd - ndcStart;

    // account for clip-space aspect ratio
    dir.x *= aspect;
    dir = normalize(dir);

    // perpendicular to dir
    vec2 offset = vec2(dir.y, - dir.x);

    // undo aspect ratio adjustment
    dir.x /= aspect;
    offset.x /= aspect;

    // sign flip
    if (aMapping.x < 0.0) offset *= -1.0;

    // calculate linewidth
    float linewidth;
    #ifdef dLineSizeAttenuation
        linewidth = size * uPixelRatio * ((uViewport.w / 2.0) / -start.z) * 5.0;
    #else
        linewidth = size * uPixelRatio;
    #endif
    linewidth = max(1.0, linewidth);

    // adjust for linewidth
    offset *= linewidth;

    // adjust for clip-space to screen-space conversion
    offset /= uViewport.w;

    // select end
    vec4 clip = (aMapping.y < 0.5) ? clipStart : clipEnd;

    // back to clip space
    offset *= clip.w;
    clip.xy += offset;
    gl_Position = clip;

    #include clip_instance
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/lines.frag.js
var lines_frag = `
precision highp float;
precision highp int;

#include common
#include common_frag_params
#include color_frag_params
#include common_clip

void main(){
    #include fade_lod
    #include clip_pixel

    float fragmentDepth = gl_FragCoord.z;
    #include assign_material_color
    #include check_transparency

    #if defined(dRenderVariant_pick)
        #include check_picking_alpha
        #ifdef requiredDrawBuffers
            gl_FragColor = vObject;
            gl_FragData[1] = vInstance;
            gl_FragData[2] = vGroup;
            gl_FragData[3] = packDepthToRGBA(fragmentDepth);
        #else
            gl_FragColor = vColor;
        #endif
    #elif defined(dRenderVariant_depth)
        gl_FragColor = material;
    #elif defined(dRenderVariant_marking)
        gl_FragColor = material;
    #elif defined(dRenderVariant_emissive)
        gl_FragColor = material;
    #elif defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
        gl_FragColor = material;
        #include apply_marker_color

        #if defined(dRenderVariant_color)
            #include apply_fog
            #include wboit_write
            #include dpoit_write
        #elif defined(dRenderVariant_tracing)
            gl_FragData[1] = vec4(normalize(vViewPosition), emissive);
            gl_FragData[2] = vec4(material.rgb, uDensity);
        #endif
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/mesh.vert.js
var mesh_vert = `
precision highp float;
precision highp int;
precision highp sampler2D;

#include common
#include read_from_texture
#include common_vert_params
#include color_vert_params
#include common_clip
#include texture3d_from_2d_linear

#ifdef dGeometryType_textureMesh
    uniform vec2 uGeoTexDim;
    uniform sampler2D tPosition;
    uniform sampler2D tGroup;
    uniform sampler2D tNormal;
#else
    attribute vec3 aPosition;
    attribute float aGroup;
    attribute vec3 aNormal;
#endif
attribute mat4 aTransform;
attribute float aInstance;

varying vec3 vNormal;

void main(){
    int vertexId = VertexID;

    #include assign_group
    #include assign_marker_varying
    #include assign_clipping_varying
    #include assign_position
    #include assign_color_varying
    #include clip_instance

    #ifdef dGeometryType_textureMesh
        vec3 normal = readFromTexture(tNormal, vertexId, uGeoTexDim).xyz;
    #else
        vec3 normal = aNormal;
    #endif
    mat3 normalMatrix = adjoint(modelView);
    vec3 transformedNormal = normalize(normalMatrix * normalize(normal));
    #if defined(dFlipSided)
        if (!uDoubleSided) { // TODO checking uDoubleSided should not be required, ASR
            transformedNormal = -transformedNormal;
        }
    #endif
    vNormal = transformedNormal;
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/mesh.frag.js
var mesh_frag = `
precision highp float;
precision highp int;

#define bumpEnabled

#include common
#include common_frag_params
#include color_frag_params
#include light_frag_params
#include normal_frag_params
#include common_clip

void main() {
    #include fade_lod
    #include clip_pixel

    // Workaround for buggy gl_FrontFacing (e.g. on some integrated Intel GPUs)
    vec3 fdx = dFdx(vViewPosition);
    vec3 fdy = dFdy(vViewPosition);
    vec3 faceNormal = normalize(cross(fdx,fdy));
    bool frontFacing = dot(vNormal, faceNormal) > 0.0;

    #if defined(dFlipSided)
        interior = frontFacing;
    #else
        interior = !frontFacing;
    #endif

    float fragmentDepth = gl_FragCoord.z;

    #ifdef dNeedsNormal
        #if defined(dFlatShaded)
            vec3 normal = -faceNormal;
        #else
            vec3 normal = -normalize(vNormal);
            if (uDoubleSided) normal *= float(frontFacing) * 2.0 - 1.0;
        #endif
    #endif

    #include assign_material_color
    #include check_transparency

    #if defined(dRenderVariant_pick)
        #include check_picking_alpha
        #ifdef requiredDrawBuffers
            gl_FragColor = vObject;
            gl_FragData[1] = vInstance;
            gl_FragData[2] = vGroup;
            gl_FragData[3] = packDepthToRGBA(fragmentDepth);
        #else
            gl_FragColor = vColor;
        #endif
    #elif defined(dRenderVariant_depth)
        gl_FragColor = material;
    #elif defined(dRenderVariant_marking)
        gl_FragColor = material;
    #elif defined(dRenderVariant_emissive)
        gl_FragColor = material;
    #elif defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
        #include apply_light_color
        #include apply_interior_color
        #include apply_marker_color

        #if defined(dRenderVariant_color)
            #include apply_fog
            #include wboit_write
            #include dpoit_write
        #elif defined(dRenderVariant_tracing)
            gl_FragData[1] = vec4(normal, emissive);
            gl_FragData[2] = vec4(material.rgb, uDensity);
        #endif
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/direct-volume.vert.js
var directVolume_vert = `
precision highp float;

attribute vec3 aPosition;
attribute mat4 aTransform;
attribute float aInstance;

uniform mat4 uModelView;
uniform mat4 uProjection;
uniform vec4 uInvariantBoundingSphere;

varying vec3 vOrigPos;
varying float vInstance;
varying vec4 vBoundingSphere;
varying mat4 vTransform;

uniform vec3 uBboxSize;
uniform vec3 uBboxMin;
uniform vec3 uBboxMax;
uniform vec3 uGridDim;
uniform mat4 uTransform;

uniform mat4 uUnitToCartn;

void main() {
    vec4 unitCoord = vec4(aPosition + vec3(0.5), 1.0);
    vec4 mvPosition = uModelView * aTransform * uUnitToCartn * unitCoord;

    vOrigPos = (aTransform * uUnitToCartn * unitCoord).xyz;
    vInstance = aInstance;
    vBoundingSphere = vec4(
        (aTransform * vec4(uInvariantBoundingSphere.xyz, 1.0)).xyz,
        uInvariantBoundingSphere.w
    );
    vTransform = aTransform;

    gl_Position = uProjection * mvPosition;

    // move z position to near clip plane (but not too close to get precision issues)
    gl_Position.z = gl_Position.w - 0.01;
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/direct-volume.frag.js
var directVolume_frag = `
precision highp float;
precision highp int;

#include common
#include light_frag_params

#if dClipObjectCount != 0
    uniform int uClipObjectType[dClipObjectCount];
    uniform bool uClipObjectInvert[dClipObjectCount];
    uniform vec3 uClipObjectPosition[dClipObjectCount];
    uniform vec4 uClipObjectRotation[dClipObjectCount];
    uniform vec3 uClipObjectScale[dClipObjectCount];
    uniform mat4 uClipObjectTransform[dClipObjectCount];
#endif
#include common_clip

#include read_from_texture
#include texture3d_from_1d_trilinear
#include texture3d_from_2d_nearest
#include texture3d_from_2d_linear

uniform mat4 uProjection, uTransform, uModelView, uModel, uView;
uniform vec3 uCameraDir;

uniform sampler2D tDepth;
uniform vec2 uDrawingBufferSize;

varying vec3 vOrigPos;
varying float vInstance;
varying vec4 vBoundingSphere;
varying mat4 vTransform;

uniform mat4 uInvView;
uniform vec3 uGridDim;
uniform vec3 uBboxSize;
uniform sampler2D tTransferTex;
uniform float uTransferScale;
uniform float uStepScale;
uniform float uJumpLength;

uniform int uObjectId;
uniform int uVertexCount;
uniform int uInstanceCount;
uniform int uGroupCount;

#if defined(dColorMarker)
    uniform vec3 uHighlightColor;
    uniform vec3 uSelectColor;
    uniform vec3 uDimColor;
    uniform float uHighlightStrength;
    uniform float uSelectStrength;
    uniform float uDimStrength;
    uniform int uMarkerPriority;
    uniform float uMarkerAverage;

    uniform float uMarker;
    uniform vec2 uMarkerTexDim;
    uniform sampler2D tMarker;
#endif

uniform float uMetalness;
uniform float uRoughness;
uniform float uEmissive;

// Density value to estimate object thickness
uniform float uDensity;

uniform bool uFog;
uniform float uFogNear;
uniform float uFogFar;
uniform vec3 uFogColor;

uniform float uAlpha;
uniform bool uTransparentBackground;
uniform float uXrayEdgeFalloff;
uniform float uCelSteps;
uniform float uExposure;

uniform int uRenderMask;

uniform float uNear;
uniform float uFar;
uniform float uIsOrtho;

uniform vec3 uCellDim;
uniform vec3 uCameraPosition;
uniform mat4 uCartnToUnit;

#if __VERSION__ != 100
    // for webgl1 this is given as a 'define'
    uniform int uMaxSteps;
#endif

#if defined(dGridTexType_2d)
    precision highp sampler2D;
    uniform sampler2D tGridTex;
    uniform vec3 uGridTexDim;
#elif defined(dGridTexType_3d)
    precision highp sampler3D;
    uniform sampler3D tGridTex;
#endif

#if defined(dColorType_uniform)
    uniform vec3 uColor;
#elif defined(dColorType_texture)
    uniform vec2 uColorTexDim;
    uniform sampler2D tColor;
#endif

#ifdef dOverpaint
    #if defined(dOverpaintType_groupInstance) || defined(dOverpaintType_vertexInstance)
        uniform vec2 uOverpaintTexDim;
        uniform sampler2D tOverpaint;
    #endif
#endif

#ifdef dUsePalette
    uniform vec2 uPaletteDomain;
    uniform sampler2D tPalette;
#endif

#if defined(dGridTexType_2d)
    vec4 textureVal(vec3 pos) {
        return texture3dFrom2dLinear(tGridTex, pos + (vec3(0.5, 0.5, 0.0) / uGridDim), uGridDim, uGridTexDim.xy);
    }
    vec4 textureGroup(vec3 pos) {
        return texture3dFrom2dNearest(tGridTex, pos + (vec3(0.5, 0.5, 0.0) / uGridDim), uGridDim, uGridTexDim.xy);
    }
#elif defined(dGridTexType_3d)
    vec4 textureVal(vec3 pos) {
        return texture(tGridTex, pos + (vec3(0.5) / uGridDim));
    }
    vec4 textureGroup(vec3 pos) {
        return texelFetch(tGridTex, ivec3(pos * uGridDim), 0);
    }
#endif

float calcDepth(const in vec3 pos) {
    vec2 clipZW = pos.z * uProjection[2].zw + uProjection[3].zw;
    return 0.5 + 0.5 * clipZW.x / clipZW.y;
}

float transferFunction(float value) {
    return texture2D(tTransferTex, vec2(value, 0.0)).a;
}

float getDepth(const in vec2 coords) {
    #ifdef depthTextureSupport
        return texture2D(tDepth, coords).r;
    #else
        return unpackRGBAToDepth(texture2D(tDepth, coords));
    #endif
}

const float gradOffset = 0.5;

vec3 v3m4(vec3 p, mat4 m) {
    return (m * vec4(p, 1.0)).xyz;
}

float preFogAlphaBlended = 0.0;

vec4 raymarch(vec3 startLoc, vec3 step, vec3 rayDir) {
    mat3 normalMatrix = adjoint(uModelView * vTransform);
    mat4 cartnToUnit = uCartnToUnit * inverse4(vTransform);
    #if defined(dClipVariant_pixel) && dClipObjectCount != 0
        mat4 modelTransform = uModel * vTransform * uTransform;
    #endif
    mat4 modelViewTransform = uModelView * vTransform * uTransform;

    vec3 scaleVol = vec3(1.0) / uGridDim;
    vec3 pos = startLoc;
    vec4 cell;
    float prevValue = -1.0;
    float value = 0.0;
    vec4 src = vec4(0.0);
    vec4 dst = vec4(0.0);
    float fragmentDepth;

    vec3 posMin = vec3(0.0);
    vec3 posMax = vec3(1.0) - vec3(1.0) / uGridDim;

    vec3 unitPos;

    vec3 nextPos;
    float nextValue;

    vec4 material;
    vec4 overpaint;
    float metalness = uMetalness;
    float roughness = uRoughness;
    float emissive = uEmissive;

    vec3 gradient = vec3(1.0);
    vec3 dx = vec3(gradOffset * scaleVol.x, 0.0, 0.0);
    vec3 dy = vec3(0.0, gradOffset * scaleVol.y, 0.0);
    vec3 dz = vec3(0.0, 0.0, gradOffset * scaleVol.z);

    float maxDist = min(vBoundingSphere.w * 2.0, uFar - uNear);
    float maxDistSq = maxDist * maxDist;

    for (int i = 0; i < uMaxSteps; ++i) {
        // break when beyond bounding-sphere or far-plane
        vec3 distVec = startLoc - pos;
        if (dot(distVec, distVec) > maxDistSq) break;

        unitPos = v3m4(pos, cartnToUnit);

        // continue when outside of grid
        if (unitPos.x > posMax.x || unitPos.y > posMax.y || unitPos.z > posMax.z ||
            unitPos.x < posMin.x || unitPos.y < posMin.y || unitPos.z < posMin.z
        ) {
            prevValue = value;
            pos += step;
            continue;
        }

        cell = textureVal(unitPos);
        value = cell.a; // current voxel value

        if (uJumpLength > 0.0 && value < 0.01) {
            nextPos = pos + rayDir * uJumpLength;
            nextValue = textureVal(v3m4(nextPos, cartnToUnit)).a;
            if (nextValue < 0.01) {
                prevValue = nextValue;
                pos = nextPos;
                continue;
            }
        }

        vec4 mvPosition = modelViewTransform * vec4(unitPos * uGridDim, 1.0);
        if (calcDepth(mvPosition.xyz) > getDepth(gl_FragCoord.xy / uDrawingBufferSize))
            break;

        #if defined(dClipVariant_pixel) && dClipObjectCount != 0
            vec3 vModelPosition = v3m4(unitPos * uGridDim, modelTransform);
            if (clipTest(modelPosition)) {
                prevValue = value;
                pos += step;
                continue;
            }
        #endif

        vec3 vViewPosition = mvPosition.xyz;
        material.a = transferFunction(value);

        #ifdef dPackedGroup
            float group = unpackRGBToInt(textureGroup(floor(unitPos * uGridDim + 0.5) / uGridDim).rgb);
        #else
            vec3 g = floor(unitPos * uGridDim + 0.5);
            // note that we swap x and z because the texture is flipped around y
            #if defined(dAxisOrder_012)
                float group = g.z + g.y * uGridDim.z + g.x * uGridDim.z * uGridDim.y; // 210
            #elif defined(dAxisOrder_021)
                float group = g.y + g.z * uGridDim.y + g.x * uGridDim.y * uGridDim.z; // 120
            #elif defined(dAxisOrder_102)
                float group = g.z + g.x * uGridDim.z + g.y * uGridDim.z * uGridDim.x; // 201
            #elif defined(dAxisOrder_120)
                float group = g.x + g.z * uGridDim.x + g.y * uGridDim.x * uGridDim.z; // 021
            #elif defined(dAxisOrder_201)
                float group = g.y + g.x * uGridDim.y + g.z * uGridDim.y * uGridDim.x; // 102
            #elif defined(dAxisOrder_210)
                float group = g.x + g.y * uGridDim.x + g.z * uGridDim.x * uGridDim.y; // 012
            #endif
        #endif

        #if defined(dColorType_direct) && defined(dUsePalette)
            float paletteValue = (value - uPaletteDomain[0]) / (uPaletteDomain[1] - uPaletteDomain[0]);
            material.rgb = texture2D(tPalette, vec2(clamp(paletteValue, 0.0, 1.0), 0.0)).rgb;
        #elif defined(dColorType_uniform)
            material.rgb = uColor;
        #elif defined(dColorType_instance)
            material.rgb = readFromTexture(tColor, vInstance, uColorTexDim).rgb;
        #elif defined(dColorType_group)
            material.rgb = readFromTexture(tColor, group, uColorTexDim).rgb;
        #elif defined(dColorType_groupInstance)
            material.rgb = readFromTexture(tColor, vInstance * float(uGroupCount) + group, uColorTexDim).rgb;
        #elif defined(dColorType_vertex)
            material.rgb = texture3dFrom1dTrilinear(tColor, unitPos, uGridDim, uColorTexDim, 0.0).rgb;
        #elif defined(dColorType_vertexInstance)
            material.rgb = texture3dFrom1dTrilinear(tColor, unitPos, uGridDim, uColorTexDim, vInstance * float(uVertexCount)).rgb;
        #endif

        #ifdef dOverpaint
            #if defined(dOverpaintType_groupInstance)
                overpaint = readFromTexture(tOverpaint, vInstance * float(uGroupCount) + group, uOverpaintTexDim);
            #elif defined(dOverpaintType_vertexInstance)
                overpaint = texture3dFrom1dTrilinear(tOverpaint, unitPos, uGridDim, uOverpaintTexDim, vInstance * float(uVertexCount));
            #endif

            material.rgb = mix(material.rgb, overpaint.rgb, overpaint.a);
        #endif

        #if defined(dIgnoreLight)
            gl_FragColor.rgb = material.rgb;
        #else
            if (material.a >= 0.01) {
                #ifdef dPackedGroup
                    // compute gradient by central differences
                    gradient.x = textureVal(unitPos - dx).a - textureVal(unitPos + dx).a;
                    gradient.y = textureVal(unitPos - dy).a - textureVal(unitPos + dy).a;
                    gradient.z = textureVal(unitPos - dz).a - textureVal(unitPos + dz).a;
                #else
                    gradient = cell.xyz * 2.0 - 1.0;
                #endif
                vec3 normal = -normalize(normalMatrix * normalize(gradient));
                #include apply_light_color
            } else {
                gl_FragColor.rgb = material.rgb;
            }
        #endif

        gl_FragColor.a = material.a * uAlpha * uTransferScale;

        #if defined(dColorMarker)
            float marker = uMarker;
            if (uMarker == -1.0) {
                marker = readFromTexture(tMarker, vInstance * float(uGroupCount) + group, uMarkerTexDim).a;
                marker = floor(marker * 255.0 + 0.5); // rounding required to work on some cards on win
            }
        #endif
        #include apply_marker_color

        preFogAlphaBlended = (1.0 - preFogAlphaBlended) * gl_FragColor.a + preFogAlphaBlended;
        fragmentDepth = calcDepth(mvPosition.xyz);
        #include apply_fog

        src = gl_FragColor;

        if (!uTransparentBackground || !uFog) {
            // done in 'apply_fog' otherwise
            src.rgb *= src.a;
        }
        dst = (1.0 - dst.a) * src + dst; // standard blending

        // break if the color is opaque enough
        if (dst.a > 0.95)
            break;

        pos += step;
    }

    return dst;
}

// TODO: support float texture for higher precision values???
// TODO: support clipping exclusion texture support

void main() {
    #if defined(dRenderVariant_tracing) || defined(dRenderVariant_emissive)
        discard;
    #else
        if (gl_FrontFacing)
            discard;

        vec3 rayDir = mix(normalize(vOrigPos - uCameraPosition), uCameraDir, uIsOrtho);
        vec3 step = rayDir * uStepScale;

        float boundingSphereNear = distance(vBoundingSphere.xyz, uCameraPosition) - vBoundingSphere.w;
        float d = max(uNear, boundingSphereNear) - mix(0.0, distance(vOrigPos, uCameraPosition), uIsOrtho);
        vec3 start = mix(uCameraPosition, vOrigPos, uIsOrtho) + (d * rayDir);
        gl_FragColor = raymarch(start, step, rayDir);

        float fragmentDepth = calcDepth((uModelView * vec4(start, 1.0)).xyz);
        float preFogAlpha = clamp(preFogAlphaBlended, 0.0, 1.0);
        #include wboit_write
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/image.vert.js
var image_vert = `
precision highp float;
precision highp int;

#include common
#include common_vert_params

attribute vec3 aPosition;
attribute vec2 aUv;
attribute mat4 aTransform;
attribute float aInstance;

varying vec2 vUv;
varying float vInstance;

void main() {
    int vertexId = VertexID;

    #include assign_position

    vUv = aUv;
    vInstance = aInstance;
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/image.frag.js
var image_frag = `
precision highp float;
precision highp int;

#include common
#include read_from_texture
#include common_frag_params
#include common_clip

uniform float uEmissive;

// Density value to estimate object thickness
uniform float uDensity;

#if defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
    #ifdef dOverpaint
        #if defined(dOverpaintType_instance) || defined(dOverpaintType_groupInstance)
            varying vec4 vOverpaint;
            uniform vec2 uOverpaintTexDim;
            uniform sampler2D tOverpaint;
        #endif
        uniform float uOverpaintStrength;
    #endif
#endif

#if defined(dRenderVariant_color) || defined(dRenderVariant_tracing) || defined(dRenderVariant_emissive)
    #ifdef dEmissive
        #if defined(dEmissiveType_instance) || defined(dEmissiveType_groupInstance)
            varying float vEmissive;
            uniform vec2 uEmissiveTexDim;
            uniform sampler2D tEmissive;
        #endif
        uniform float uEmissiveStrength;
    #endif
#endif

#ifdef dTransparency
    #if defined(dTransparencyType_instance) || defined(dTransparencyType_groupInstance)
        varying float vTransparency;
        uniform vec2 uTransparencyTexDim;
        uniform sampler2D tTransparency;
    #endif
    uniform float uTransparencyStrength;
#endif

uniform vec2 uImageTexDim;
uniform sampler2D tImageTex;
uniform sampler2D tGroupTex;
uniform sampler2D tValueTex;

uniform vec2 uMarkerTexDim;
uniform sampler2D tMarker;

varying vec2 vUv;
varying float vInstance;

#ifdef dUsePalette
    uniform sampler2D tPalette;
    uniform vec3 uPaletteDefault;
#endif

uniform int uTrimType;
uniform vec3 uTrimCenter;
uniform vec4 uTrimRotation;
uniform vec3 uTrimScale;
uniform mat4 uTrimTransform;

uniform float uIsoLevel;

#if defined(dInterpolation_catmulrom) || defined(dInterpolation_mitchell) || defined(dInterpolation_bspline)
    #define dInterpolation_cubic
#endif

#if defined(dInterpolation_cubic)
    #if defined(dInterpolation_catmulrom) || defined(dInterpolation_mitchell)
        #if defined(dInterpolation_catmulrom)
            const float B = 0.0;
            const float C = 0.5;
        #elif defined(dInterpolation_mitchell)
            const float B = 0.333;
            const float C = 0.333;
        #endif

        float cubicFilter(float x){
            float f = x;
            if (f < 0.0) {
                f = -f;
            }
            if (f < 1.0) {
                return ((12.0 - 9.0 * B - 6.0 * C) * (f * f * f) +
                    (-18.0 + 12.0 * B + 6.0 * C) * (f * f) +
                    (6.0 - 2.0 * B)) / 6.0;
            }else if (f >= 1.0 && f < 2.0){
                return ((-B - 6.0 * C) * ( f * f * f)
                    + (6.0 * B + 30.0 * C) * (f * f) +
                    (-(12.0 * B) - 48.0 * C) * f +
                    8.0 * B + 24.0 * C) / 6.0;
            }else{
                return 0.0;
            }
        }
    #elif defined(dInterpolation_bspline)
        float cubicFilter(float x) {
            float f = x;
            if (f < 0.0) {
                f = -f;
            }
            if (f >= 0.0 && f <= 1.0){
                return (2.0 / 3.0) + (0.5) * (f * f * f) - (f * f);
            } else if (f > 1.0 && f <= 2.0) {
                return 1.0 / 6.0 * pow((2.0 - f), 3.0);
            }
            return 1.0;
        }
    #endif

    vec4 biCubic(sampler2D tex, vec2 texCoord) {
        vec2 texelSize = 1.0 / uImageTexDim;
        texCoord -= texelSize / 2.0;
        vec4 nSum = vec4(0.0);
        float nDenom = 0.0;
        vec2 cell = fract(texCoord * uImageTexDim);
        for (float m = -1.0; m <= 2.0; ++m) {
            for (float n = -1.0; n <= 2.0; ++n) {
                vec4 vecData = texture2D(tex, texCoord + texelSize * vec2(m, n));
                float c = abs(cubicFilter(m - cell.x) * cubicFilter(-n + cell.y));
                nSum += vecData * c;
                nDenom += c;
            }
        }
        return nSum / nDenom;
    }
#endif

void main() {
    if (uTrimType != 0 && getSignedDistance(vModelPosition, uTrimType, uTrimCenter, uTrimRotation, uTrimScale, uTrimTransform) > 0.0) discard;

    #include fade_lod
    #include clip_pixel

    #if defined(dInterpolation_cubic)
        #ifdef dUsePalette
            vec4 material = texture2D(tImageTex, vUv);
            if (material.rgb != vec3(1.0)) {
                material = biCubic(tImageTex, vUv);
            }
        #else
            vec4 material = biCubic(tImageTex, vUv);
        #endif
    #else
        vec4 material = texture2D(tImageTex, vUv);
    #endif

    if (uIsoLevel >= 0.0) {
        if (texture2D(tValueTex, vUv).r < uIsoLevel) discard;

        material.a = uAlpha;
    } else {
        if (material.a == 0.0) discard;

        material.a *= uAlpha;
    }

    float fragmentDepth = gl_FragCoord.z;

    vec3 packedGroup = texture2D(tGroupTex, vUv).rgb;
    float group = packedGroup == vec3(0.0) ? -1.0 : unpackRGBToInt(packedGroup);

    // apply per-group transparency
    #if defined(dTransparency) && (defined(dRenderVariant_pick) || defined(dRenderVariant_color) || defined(dRenderVariant_emissive) || defined(dRenderVariant_tracing))
        float transparency = 0.0;
        #if defined(dTransparencyType_instance)
            transparency = readFromTexture(tTransparency, vInstance, uTransparencyTexDim).a;
        #elif defined(dTransparencyType_groupInstance)
            transparency = readFromTexture(tTransparency, vInstance * float(uGroupCount) + group, uTransparencyTexDim).a;
        #endif
        transparency *= uTransparencyStrength;

        float ta = 1.0 - transparency;
        if (transparency < 0.09) ta = 1.0; // hard cutoff looks better

        #if defined(dRenderVariant_pick)
            if (ta * uAlpha < uPickingAlphaThreshold)
                discard; // ignore so the element below can be picked
        #elif defined(dRenderVariant_emissive)
            if (ta < 1.0)
                discard; // emissive not supported with transparency
        #elif defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
            material.a *= ta;
        #endif
    #endif

    if ((uRenderMask == MaskOpaque && material.a < 1.0) ||
        (uRenderMask == MaskTransparent && material.a == 1.0)
    ) {
        discard;
    }

    #if defined(dNeedsMarker)
        float marker = uMarker;
        if (group == -1.0) {
            marker = 0.0;
        } else if (uMarker == -1.0) {
            marker = readFromTexture(tMarker, vInstance * float(uGroupCount) + group, uMarkerTexDim).a;
            marker = floor(marker * 255.0 + 0.5); // rounding required to work on some cards on win
        }
    #endif

    #if defined(dRenderVariant_color) || defined(dRenderVariant_tracing) || defined(dRenderVariant_emissive)
        float emissive = uEmissive;
        if (group == -1.0) {
            emissive = 0.0;
        } else {
            #ifdef dEmissive
                #if defined(dEmissiveType_instance)
                    emissive += readFromTexture(tEmissive, vInstance, uEmissiveTexDim).a * uEmissiveStrength;
                #elif defined(dEmissiveType_groupInstance)
                    emissive += readFromTexture(tEmissive, vInstance * float(uGroupCount) + group, uEmissiveTexDim).a * uEmissiveStrength;
                #endif
            #endif
        }
    #endif

    #if defined(dRenderVariant_pick)
        if (group == -1.0) discard;

        #include check_picking_alpha
        #ifdef requiredDrawBuffers
            gl_FragColor = vec4(packIntToRGB(float(uObjectId)), 1.0);
            gl_FragData[1] = vec4(packIntToRGB(vInstance), 1.0);
            gl_FragData[2] = vec4(packIntToRGB(group), 1.0);
            gl_FragData[3] = packDepthToRGBA(fragmentDepth);
        #else
            gl_FragColor = vColor;
            if (uPickType == 1) {
                gl_FragColor = vec4(packIntToRGB(float(uObjectId)), 1.0);
            } else if (uPickType == 2) {
                gl_FragColor = vec4(packIntToRGB(vInstance), 1.0);
            } else {
                gl_FragColor = vec4(packIntToRGB(group), 1.0);
            }
        #endif
    #elif defined(dRenderVariant_depth)
        if (uRenderMask == MaskOpaque) {
            gl_FragColor = packDepthToRGBA(fragmentDepth);
        } else if (uRenderMask == MaskTransparent) {
            gl_FragColor = packDepthWithAlphaToRGBA(fragmentDepth, material.a);
        }
    #elif defined(dRenderVariant_marking)
        if (uMarkingType == 1) {
            if (marker > 0.0)
                discard;
            gl_FragColor = packDepthToRGBA(fragmentDepth);
        } else {
            if (marker == 0.0)
                discard;
            float depthTest = 1.0;
            if (uMarkingDepthTest) {
                depthTest = (fragmentDepth >= getDepthPacked(gl_FragCoord.xy / uDrawingBufferSize)) ? 1.0 : 0.0;
            }
            bool isHighlight = intMod(marker, 2.0) > 0.1;
            float viewZ = depthToViewZ(uIsOrtho, fragmentDepth, uNear, uFar);
            float fogFactor = smoothstep(uFogNear, uFogFar, abs(viewZ));
            if (fogFactor == 1.0)
                discard;
            gl_FragColor = vec4(0.0, depthTest, isHighlight ? 1.0 : 0.0, 1.0 - fogFactor);
        }
    #elif defined(dRenderVariant_emissive)
        gl_FragColor = vec4(emissive);
    #elif defined(dRenderVariant_color) || defined(dRenderVariant_tracing)
        #ifdef dUsePalette
            if (material.rgb == vec3(1.0)) {
                material.rgb = uPaletteDefault;
            } else {
                float v = ((material.r * 256.0 * 256.0 * 255.0 + material.g * 256.0 * 255.0 + material.b * 255.0) - 1.0) / PALETTE_SCALE;
                material.rgb = texture2D(tPalette, vec2(v, 0.0)).rgb;
            }
        #endif

        // mix material with overpaint
        #if defined(dOverpaint)
            vec4 overpaint = vec4(0.0);
            if (group != -1.0) {
                #if defined(dOverpaintType_instance)
                    overpaint = readFromTexture(tOverpaint, vInstance, uOverpaintTexDim);
                #elif defined(dOverpaintType_groupInstance)
                    overpaint = readFromTexture(tOverpaint, vInstance * float(uGroupCount) + group, uOverpaintTexDim);
                #endif
                overpaint *= uOverpaintStrength;
            }
            material.rgb = mix(material.rgb, overpaint.rgb, overpaint.a);
        #endif

        gl_FragColor = material;
        #include apply_marker_color

        #if defined(dRenderVariant_color)
            #include apply_fog
            #include wboit_write
            #include dpoit_write
        #elif defined(dRenderVariant_tracing)
            gl_FragData[1] = vec4(normalize(vViewPosition), emissive);
            gl_FragData[2] = vec4(material.rgb, uDensity);
        #endif
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader-code.js
var shaderCodeId = idFactory();
var ShaderChunks = {
  apply_fog,
  apply_interior_color,
  apply_light_color,
  apply_marker_color,
  assign_clipping_varying,
  assign_color_varying,
  assign_group,
  assign_marker_varying,
  assign_material_color,
  assign_position,
  assign_size,
  check_picking_alpha,
  check_transparency,
  clip_instance,
  clip_pixel,
  color_frag_params,
  color_vert_params,
  common_clip,
  common_frag_params,
  common_vert_params,
  common,
  fade_lod,
  float_to_rgba,
  light_frag_params,
  matrix_scale,
  normal_frag_params,
  read_from_texture,
  rgba_to_float,
  size_vert_params,
  texture3d_from_1d_trilinear,
  texture3d_from_2d_linear,
  texture3d_from_2d_nearest,
  wboit_write,
  dpoit_write
};
var reInclude = /^(?!\/\/)\s*#include\s+(\S+)/gm;
var reUnrollLoop = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*\+\+i\s*\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
var reSingleLineComment = /[ \t]*\/\/.*\n/g;
var reMultiLineComment = /[ \t]*\/\*[\s\S]*?\*\//g;
var reMultipleLinebreaks = /\n{2,}/g;
function addIncludes(text) {
  return text.replace(reInclude, (_, p1) => {
    const chunk = ShaderChunks[p1];
    if (!chunk)
      throw new Error(`empty chunk, '${p1}'`);
    return chunk;
  }).trim().replace(reSingleLineComment, "\n").replace(reMultiLineComment, "\n").replace(reMultipleLinebreaks, "\n");
}
function unrollLoops(str3) {
  return str3.replace(reUnrollLoop, loopReplacer);
}
function loopReplacer(_match, start, end, snippet) {
  let out = "";
  for (let i = parseInt(start); i < parseInt(end); ++i) {
    out += snippet.replace(/\[\s*i\s*\]/g, `[${i}]`).replace(/UNROLLED_LOOP_INDEX/g, `${i}`);
  }
  return out;
}
function replaceCounts(str3, defines) {
  if (defines.dLightCount)
    str3 = str3.replace(/dLightCount/g, `${defines.dLightCount.ref.value}`);
  if (defines.dClipObjectCount)
    str3 = str3.replace(/dClipObjectCount/g, `${defines.dClipObjectCount.ref.value}`);
  return str3;
}
function preprocess(str3, defines) {
  return unrollLoops(replaceCounts(str3, defines));
}
function ShaderCode(name, vert, frag, extensions = {}, outTypes = {}, ignoreDefine2) {
  return { id: shaderCodeId(), name, vert: addIncludes(vert), frag: addIncludes(frag), extensions, outTypes, ignoreDefine: ignoreDefine2 };
}
function ignoreDefine(name, variant, defines) {
  var _a;
  if (variant.startsWith("color") || variant === "tracing") {
    if (name === "dLightCount") {
      return !!((_a = defines.dIgnoreLight) === null || _a === void 0 ? void 0 : _a.ref.value);
    }
  } else {
    const ignore = [
      "dColorType",
      "dUsePalette",
      "dOverpaintType",
      "dOverpaint",
      "dSubstanceType",
      "dSubstance",
      "dColorMarker",
      "dCelShaded",
      "dLightCount"
    ];
    if (variant !== "depth" && !variant.startsWith("pick")) {
      ignore.push("dXrayShaded");
    }
    if (variant !== "emissive") {
      ignore.push("dEmissiveType", "dEmissive");
    }
    return ignore.includes(name);
  }
  return false;
}
function ignoreDefineUnlit(name, variant, defines) {
  if (name === "dLightCount")
    return true;
  return ignoreDefine(name, variant, defines);
}
var PointsShaderCode = ShaderCode("points", points_vert, points_frag, { drawBuffers: "optional" }, {}, ignoreDefineUnlit);
var SpheresShaderCode = ShaderCode("spheres", spheres_vert, spheres_frag, { fragDepth: "required", drawBuffers: "optional" }, {}, ignoreDefine);
var CylindersShaderCode = ShaderCode("cylinders", cylinders_vert, cylinders_frag, { fragDepth: "required", drawBuffers: "optional" }, {}, ignoreDefine);
var TextShaderCode = ShaderCode("text", text_vert, text_frag, { drawBuffers: "optional" }, {}, ignoreDefineUnlit);
var LinesShaderCode = ShaderCode("lines", lines_vert, lines_frag, { drawBuffers: "optional" }, {}, ignoreDefineUnlit);
var MeshShaderCode = ShaderCode("mesh", mesh_vert, mesh_frag, { drawBuffers: "optional" }, {}, ignoreDefine);
var DirectVolumeShaderCode = ShaderCode("direct-volume", directVolume_vert, directVolume_frag, { fragDepth: "optional", drawBuffers: "optional" }, {}, ignoreDefine);
var ImageShaderCode = ShaderCode("image", image_vert, image_frag, { drawBuffers: "optional" }, {}, ignoreDefineUnlit);
function getDefinesCode(defines, ignore) {
  var _a;
  if (defines === void 0)
    return "";
  const variant = ((_a = defines.dRenderVariant) === null || _a === void 0 ? void 0 : _a.ref.value) || "";
  const lines = [];
  for (const name in defines) {
    if (ignore === null || ignore === void 0 ? void 0 : ignore(name, variant, defines))
      continue;
    const define = defines[name];
    const v3 = define.ref.value;
    if (v3 !== void 0) {
      if (typeof v3 === "string") {
        lines.push(`#define ${name}_${v3}`);
      } else if (typeof v3 === "number") {
        lines.push(`#define ${name} ${v3}`);
      } else if (typeof v3 === "boolean") {
        if (v3)
          lines.push(`#define ${name}`);
      } else {
        assertUnreachable(v3);
      }
    }
  }
  return lines.join("\n") + "\n";
}
function getGlsl100VertPrefix(extensions, shaderExtensions) {
  const prefix2 = [];
  if (shaderExtensions.drawBuffers) {
    if (extensions.drawBuffers) {
      prefix2.push("#define requiredDrawBuffers");
    } else if (shaderExtensions.drawBuffers === "required") {
      throw new Error(`required 'GL_EXT_draw_buffers' extension not available`);
    }
  }
  if (shaderExtensions.multiDraw) {
    if (extensions.multiDraw) {
      prefix2.push("#extension GL_ANGLE_multi_draw : require");
      prefix2.push("#define enabledMultiDraw");
    } else if (shaderExtensions.multiDraw === "required") {
      throw new Error(`required 'GL_ANGLE_multi_draw' extension not available`);
    }
  }
  return prefix2.join("\n") + "\n";
}
function getGlsl100FragPrefix(extensions, shaderExtensions) {
  const prefix2 = [
    "#extension GL_OES_standard_derivatives : enable"
  ];
  if (shaderExtensions.fragDepth) {
    if (extensions.fragDepth) {
      prefix2.push("#extension GL_EXT_frag_depth : enable");
      prefix2.push("#define enabledFragDepth");
    } else if (shaderExtensions.fragDepth === "required") {
      throw new Error(`required 'GL_EXT_frag_depth' extension not available`);
    }
  }
  if (shaderExtensions.drawBuffers) {
    if (extensions.drawBuffers) {
      prefix2.push("#extension GL_EXT_draw_buffers : require");
      prefix2.push("#define requiredDrawBuffers");
      prefix2.push("#define gl_FragColor gl_FragData[0]");
    } else if (shaderExtensions.drawBuffers === "required") {
      throw new Error(`required 'GL_EXT_draw_buffers' extension not available`);
    }
  }
  if (shaderExtensions.shaderTextureLod) {
    if (extensions.shaderTextureLod) {
      prefix2.push("#extension GL_EXT_shader_texture_lod : enable");
      prefix2.push("#define enabledShaderTextureLod");
    } else if (shaderExtensions.shaderTextureLod === "required") {
      throw new Error(`required 'GL_EXT_shader_texture_lod' extension not available`);
    }
  }
  if (extensions.depthTexture) {
    prefix2.push("#define depthTextureSupport");
  }
  return prefix2.join("\n") + "\n";
}
var glsl300VertPrefixCommon = `
#define attribute in
#define varying out
#define texture2D texture
`;
var glsl300FragPrefixCommon = `
#define varying in
#define texture2D texture
#define textureCube texture
#define texture2DLodEXT textureLod
#define textureCubeLodEXT textureLod

#define gl_FragColor out_FragData0
#define gl_FragDepthEXT gl_FragDepth
`;
function getGlsl300VertPrefix(extensions, shaderExtensions) {
  const prefix2 = [
    "#version 300 es"
  ];
  if (shaderExtensions.drawBuffers) {
    if (extensions.drawBuffers) {
      prefix2.push("#define requiredDrawBuffers");
    }
  }
  if (shaderExtensions.multiDraw) {
    if (extensions.multiDraw) {
      prefix2.push("#extension GL_ANGLE_multi_draw : require");
      prefix2.push("#define enabledMultiDraw");
    } else if (shaderExtensions.multiDraw === "required") {
      throw new Error(`required 'GL_ANGLE_multi_draw' extension not available`);
    }
  }
  if (shaderExtensions.clipCullDistance) {
    if (extensions.clipCullDistance) {
      prefix2.push("#extension GL_ANGLE_clip_cull_distance : enable");
      prefix2.push("#define enabledClipCullDistance");
    } else if (shaderExtensions.clipCullDistance === "required") {
      throw new Error(`required 'GL_ANGLE_clip_cull_distance' extension not available`);
    }
  }
  if (shaderExtensions.conservativeDepth) {
    if (extensions.conservativeDepth) {
      prefix2.push("#extension GL_EXT_conservative_depth : enable");
      prefix2.push("#define enabledConservativeDepth");
    } else if (shaderExtensions.conservativeDepth === "required") {
      throw new Error(`required 'GL_EXT_conservative_depth' extension not available`);
    }
  }
  if (extensions.noNonInstancedActiveAttribs) {
    prefix2.push("#define noNonInstancedActiveAttribs");
  }
  prefix2.push(glsl300VertPrefixCommon);
  return prefix2.join("\n") + "\n";
}
function getGlsl300FragPrefix(gl, extensions, shaderExtensions, outTypes) {
  const prefix2 = [
    "#version 300 es",
    `layout(location = 0) out highp ${outTypes[0] || "vec4"} out_FragData0;`
  ];
  if (shaderExtensions.fragDepth) {
    if (extensions.fragDepth) {
      prefix2.push("#define enabledFragDepth");
    }
  }
  if (shaderExtensions.drawBuffers) {
    if (extensions.drawBuffers) {
      prefix2.push("#define requiredDrawBuffers");
      const maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);
      for (let i = 1, il = maxDrawBuffers; i < il; ++i) {
        prefix2.push(`layout(location = ${i}) out highp ${outTypes[i] || "vec4"} out_FragData${i};`);
      }
    }
  }
  if (shaderExtensions.shaderTextureLod) {
    if (extensions.shaderTextureLod) {
      prefix2.push("#define enabledShaderTextureLod");
    }
  }
  if (extensions.depthTexture) {
    prefix2.push("#define depthTextureSupport");
  }
  prefix2.push(glsl300FragPrefixCommon);
  return prefix2.join("\n") + "\n";
}
function transformGlsl300Frag(frag) {
  return frag.replace(/gl_FragData\[([0-9]+)\]/g, "out_FragData$1");
}
function addShaderDefines(gl, extensions, defines, shaders) {
  const vertHeader = getDefinesCode(defines, shaders.ignoreDefine);
  const fragHeader = getDefinesCode(defines, shaders.ignoreDefine);
  const vertPrefix = isWebGL2(gl) ? getGlsl300VertPrefix(extensions, shaders.extensions) : getGlsl100VertPrefix(extensions, shaders.extensions);
  const fragPrefix = isWebGL2(gl) ? getGlsl300FragPrefix(gl, extensions, shaders.extensions, shaders.outTypes) : getGlsl100FragPrefix(extensions, shaders.extensions);
  const frag = isWebGL2(gl) ? transformGlsl300Frag(shaders.frag) : shaders.frag;
  return {
    id: shaderCodeId(),
    name: shaders.name,
    vert: `${vertPrefix}${vertHeader}${preprocess(shaders.vert, defines)}`,
    frag: `${fragPrefix}${fragHeader}${preprocess(frag, defines)}`,
    extensions: shaders.extensions,
    outTypes: shaders.outTypes
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/uniform.js
function getUniformType(gl, kind) {
  switch (kind) {
    case "b":
    case "b[]":
      return gl.BOOL;
    case "f":
    case "f[]":
      return gl.FLOAT;
    case "i":
    case "i[]":
      return gl.INT;
    case "v2":
    case "v2[]":
      return gl.FLOAT_VEC2;
    case "v3":
    case "v3[]":
      return gl.FLOAT_VEC3;
    case "v4":
    case "v4[]":
      return gl.FLOAT_VEC4;
    case "q":
    case "q[]":
      return gl.FLOAT_VEC4;
    case "iv2":
    case "iv2[]":
      return gl.INT_VEC2;
    case "iv3":
    case "iv3[]":
      return gl.INT_VEC3;
    case "iv4":
    case "iv4[]":
      return gl.INT_VEC4;
    case "m3":
    case "m3[]":
      return gl.FLOAT_MAT3;
    case "m4":
    case "m4[]":
      return gl.FLOAT_MAT4;
    default:
      console.error(`unknown uniform kind '${kind}'`);
  }
}
function isArrayUniform(kind) {
  return kind.endsWith("[]");
}
function uniform1f(gl, location, value) {
  gl.uniform1f(location, value);
}
function uniform1fv(gl, location, value) {
  gl.uniform1fv(location, value);
}
function uniform1i(gl, location, value) {
  gl.uniform1i(location, value);
}
function uniform1iv(gl, location, value) {
  gl.uniform1iv(location, value);
}
function uniform2fv(gl, location, value) {
  gl.uniform2fv(location, value);
}
function uniform3fv(gl, location, value) {
  gl.uniform3fv(location, value);
}
function uniform4fv(gl, location, value) {
  gl.uniform4fv(location, value);
}
function uniform2iv(gl, location, value) {
  gl.uniform2iv(location, value);
}
function uniform3iv(gl, location, value) {
  gl.uniform3iv(location, value);
}
function uniform4iv(gl, location, value) {
  gl.uniform4iv(location, value);
}
function uniformMatrix3fv(gl, location, value) {
  gl.uniformMatrix3fv(location, false, value);
}
function uniformMatrix4fv(gl, location, value) {
  gl.uniformMatrix4fv(location, false, value);
}
function getUniformSetter(kind) {
  switch (kind) {
    case "f":
      return uniform1f;
    case "f[]":
      return uniform1fv;
    case "i":
    case "t":
    case "b":
      return uniform1i;
    case "i[]":
    case "t[]":
    case "b[]":
      return uniform1iv;
    case "v2":
    case "v2[]":
      return uniform2fv;
    case "v3":
    case "v3[]":
      return uniform3fv;
    case "v4":
    case "v4[]":
      return uniform4fv;
    case "q":
    case "q[]":
      return uniform4fv;
    case "iv2":
    case "iv2[]":
      return uniform2iv;
    case "iv3":
    case "iv3[]":
      return uniform3iv;
    case "iv4":
    case "iv4[]":
      return uniform4iv;
    case "m3":
    case "m3[]":
      return uniformMatrix3fv;
    case "m4":
    case "m4[]":
      return uniformMatrix4fv;
  }
}
function getUniformSetters(schema) {
  const setters = {};
  Object.keys(schema).forEach((k) => {
    const spec = schema[k];
    if (spec.type === "uniform") {
      setters[k] = getUniformSetter(spec.kind);
    } else if (spec.type === "texture") {
      setters[k] = getUniformSetter("t");
    }
  });
  return setters;
}
function cloneUniformValues(uniformValues) {
  const clonedValues = {};
  Object.keys(uniformValues).forEach((k) => {
    clonedValues[k] = ValueCell.create(deepClone(uniformValues[k].ref.value));
  });
  return clonedValues;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/buffer.js
var getNextBufferId = idFactory();
function getUsageHint(gl, usageHint) {
  switch (usageHint) {
    case "static":
      return gl.STATIC_DRAW;
    case "dynamic":
      return gl.DYNAMIC_DRAW;
    case "stream":
      return gl.STREAM_DRAW;
  }
}
function dataTypeFromArray(gl, array) {
  if (array instanceof Uint8Array) {
    return gl.UNSIGNED_BYTE;
  } else if (array instanceof Int8Array) {
    return gl.BYTE;
  } else if (array instanceof Uint16Array) {
    return gl.UNSIGNED_SHORT;
  } else if (array instanceof Int16Array) {
    return gl.SHORT;
  } else if (array instanceof Uint32Array) {
    return gl.UNSIGNED_INT;
  } else if (array instanceof Int32Array) {
    return gl.INT;
  } else if (array instanceof Float32Array) {
    return gl.FLOAT;
  }
  assertUnreachable(array);
}
function getBufferType(gl, bufferType) {
  switch (bufferType) {
    case "attribute":
      return gl.ARRAY_BUFFER;
    case "elements":
      return gl.ELEMENT_ARRAY_BUFFER;
    case "uniform":
      if (isWebGL2(gl)) {
        return gl.UNIFORM_BUFFER;
      } else {
        throw new Error("WebGL2 is required for uniform buffers");
      }
  }
}
function getBuffer(gl) {
  const buffer2 = gl.createBuffer();
  if (buffer2 === null) {
    throw new Error("Could not create WebGL buffer");
  }
  return buffer2;
}
function createBuffer(gl, array, usageHint, bufferType) {
  let _buffer = getBuffer(gl);
  const _usageHint = getUsageHint(gl, usageHint);
  const _bufferType = getBufferType(gl, bufferType);
  const _dataType = dataTypeFromArray(gl, array);
  const _bpe = array.BYTES_PER_ELEMENT;
  const _length = array.length;
  function updateData(array2) {
    gl.bindBuffer(_bufferType, _buffer);
    gl.bufferData(_bufferType, array2, _usageHint);
  }
  updateData(array);
  let destroyed = false;
  return {
    id: getNextBufferId(),
    _usageHint,
    _bufferType,
    _dataType,
    _bpe,
    length: _length,
    getBuffer: () => _buffer,
    updateData,
    updateSubData: (array2, offset, count3) => {
      gl.bindBuffer(_bufferType, _buffer);
      if (count3 - offset === array2.length) {
        gl.bufferSubData(_bufferType, 0, array2);
      } else {
        gl.bufferSubData(_bufferType, offset * _bpe, array2.subarray(offset, offset + count3));
      }
    },
    reset: () => {
      _buffer = getBuffer(gl);
      updateData(array);
    },
    destroy: () => {
      if (destroyed)
        return;
      gl.deleteBuffer(_buffer);
      destroyed = true;
    }
  };
}
function getAttribType(gl, kind, itemSize) {
  switch (kind) {
    case "float32":
      switch (itemSize) {
        case 1:
          return gl.FLOAT;
        case 2:
          return gl.FLOAT_VEC2;
        case 3:
          return gl.FLOAT_VEC3;
        case 4:
          return gl.FLOAT_VEC4;
        case 16:
          return gl.FLOAT_MAT4;
      }
    default:
      assertUnreachable(kind);
  }
}
function createAttributeBuffer(gl, state, extensions, array, itemSize, divisor, usageHint = "static") {
  const { instancedArrays } = extensions;
  const buffer2 = createBuffer(gl, array, usageHint, "attribute");
  const { _bufferType, _dataType, _bpe } = buffer2;
  return {
    ...buffer2,
    divisor,
    bind: (location) => {
      gl.bindBuffer(_bufferType, buffer2.getBuffer());
      if (itemSize === 16) {
        for (let i = 0; i < 4; ++i) {
          state.enableVertexAttrib(location + i);
          gl.vertexAttribPointer(location + i, 4, _dataType, false, 4 * 4 * _bpe, i * 4 * _bpe);
          instancedArrays.vertexAttribDivisor(location + i, divisor);
        }
      } else {
        state.enableVertexAttrib(location);
        gl.vertexAttribPointer(location, itemSize, _dataType, false, 0, 0);
        instancedArrays.vertexAttribDivisor(location, divisor);
      }
    },
    changeOffset: (location, offset) => {
      const o = offset * _bpe * itemSize;
      gl.bindBuffer(_bufferType, buffer2.getBuffer());
      if (itemSize === 16) {
        for (let i = 0; i < 4; ++i) {
          gl.vertexAttribPointer(location + i, 4, _dataType, false, 4 * 4 * _bpe, i * 4 * _bpe + o);
        }
      } else {
        gl.vertexAttribPointer(location, itemSize, _dataType, false, 0, o);
      }
    }
  };
}
function createAttributeBuffers(ctx, schema, values2) {
  const buffers = [];
  Object.keys(schema).forEach((k) => {
    const spec = schema[k];
    if (spec.type === "attribute") {
      buffers[buffers.length] = [k, ctx.resources.attribute(values2[k].ref.value, spec.itemSize, spec.divisor)];
    }
  });
  return buffers;
}
function createElementsBuffer(gl, array, usageHint = "static") {
  const buffer2 = createBuffer(gl, array, usageHint, "elements");
  return {
    ...buffer2,
    bind: () => {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer2.getBuffer());
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/program.js
var getNextProgramId = idFactory();
function getLocations(gl, program, schema) {
  const locations = {};
  Object.keys(schema).forEach((k) => {
    const spec = schema[k];
    if (spec.type === "attribute") {
      const loc = gl.getAttribLocation(program, k);
      locations[k] = loc;
    } else if (spec.type === "uniform") {
      let loc = gl.getUniformLocation(program, k);
      if (loc === null && isArrayUniform(spec.kind))
        loc = gl.getUniformLocation(program, k + "[0]");
      locations[k] = loc;
    } else if (spec.type === "texture") {
      const loc = gl.getUniformLocation(program, k);
      locations[k] = loc;
    }
  });
  return locations;
}
function checkActiveAttributes(gl, program, schema) {
  const attribCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < attribCount; ++i) {
    const info = gl.getActiveAttrib(program, i);
    if (info) {
      const { name, type } = info;
      if (name.startsWith("__activeAttribute")) {
        continue;
      }
      if (name === "gl_InstanceID")
        continue;
      if (name === "gl_VertexID")
        continue;
      if (name === "gl_DrawID")
        continue;
      const spec = schema[name];
      if (spec === void 0) {
        throw new Error(`missing 'uniform' or 'texture' with name '${name}' in schema`);
      }
      if (spec.type !== "attribute") {
        throw new Error(`'${name}' must be of type 'attribute' but is '${spec.type}'`);
      }
      const attribType = getAttribType(gl, spec.kind, spec.itemSize);
      if (attribType !== type) {
        throw new Error(`unexpected attribute type '${attribType}' for ${name}, expected '${type}'`);
      }
    }
  }
}
function checkActiveUniforms(gl, program, schema) {
  const attribCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  for (let i = 0; i < attribCount; ++i) {
    const info = gl.getActiveUniform(program, i);
    if (info) {
      const { name, type } = info;
      if (name.startsWith("__activeUniform")) {
        continue;
      }
      if (name === "gl_InstanceID")
        continue;
      if (name === "gl_VertexID")
        continue;
      if (name === "gl_DrawID")
        continue;
      const baseName = name.replace(/[[0-9]+\]$/, "");
      const spec = schema[baseName];
      if (spec === void 0) {
        throw new Error(`missing 'uniform' or 'texture' with name '${name}' in schema`);
      }
      if (spec.type === "uniform") {
        const uniformType = getUniformType(gl, spec.kind);
        if (uniformType !== type) {
          throw new Error(`unexpected uniform type for ${name}`);
        }
      } else if (spec.type === "texture") {
        if (spec.kind === "image-float32" || spec.kind === "image-uint8") {
          if (type !== gl.SAMPLER_2D) {
            throw new Error(`unexpected sampler type for '${name}'`);
          }
        } else if (spec.kind === "volume-float32" || spec.kind === "volume-uint8") {
          if (isWebGL2(gl)) {
            if (type !== gl.SAMPLER_3D) {
              throw new Error(`unexpected sampler type for '${name}'`);
            }
          } else {
            throw new Error(`WebGL2 is required to use SAMPLER_3D`);
          }
        } else {
        }
      } else {
        throw new Error(`'${name}' must be of type 'uniform' or 'texture' but is '${spec.type}'`);
      }
    }
  }
}
function checkProgram(gl, program) {
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error(`Could not compile WebGL program. 

${gl.getProgramInfoLog(program)}`);
  }
}
function getProgram(gl) {
  const program = gl.createProgram();
  if (program === null) {
    throw new Error("Could not create WebGL program");
  }
  return program;
}
function createProgram(gl, state, extensions, getShader2, props) {
  const { defineValues, shaderCode: _shaderCode, schema } = props;
  let program = getProgram(gl);
  const programId = getNextProgramId();
  const shaderCode = addShaderDefines(gl, extensions, defineValues, _shaderCode);
  const vertShader = getShader2("vert", shaderCode.vert);
  const fragShader = getShader2("frag", shaderCode.frag);
  let locations;
  let uniformSetters;
  function init() {
    vertShader.attach(program);
    fragShader.attach(program);
    gl.linkProgram(program);
    if (isDebugMode) {
      checkProgram(gl, program);
    }
    locations = getLocations(gl, program, schema);
    uniformSetters = getUniformSetters(schema);
    if (isDebugMode) {
      checkActiveAttributes(gl, program, schema);
      checkActiveUniforms(gl, program, schema);
    }
  }
  init();
  let destroyed = false;
  return {
    id: programId,
    use: () => {
      state.currentProgramId = programId;
      gl.useProgram(program);
    },
    setUniforms: (uniformValues) => {
      for (let i = 0, il = uniformValues.length; i < il; ++i) {
        const [k, v3] = uniformValues[i];
        if (v3) {
          const l = locations[k];
          if (l !== null)
            uniformSetters[k](gl, l, v3.ref.value);
        }
      }
    },
    uniform: (k, v3) => {
      const l = locations[k];
      if (l !== null)
        uniformSetters[k](gl, l, v3);
    },
    bindAttributes: (attributeBuffers) => {
      state.clearVertexAttribsState();
      for (let i = 0, il = attributeBuffers.length; i < il; ++i) {
        const [k, buffer2] = attributeBuffers[i];
        const l = locations[k];
        if (l !== -1)
          buffer2.bind(l);
      }
      state.disableUnusedVertexAttribs();
    },
    offsetAttributes: (attributeBuffers, offset) => {
      for (let i = 0, il = attributeBuffers.length; i < il; ++i) {
        const [k, buffer2] = attributeBuffers[i];
        const l = locations[k];
        if (l !== -1)
          buffer2.changeOffset(l, offset);
      }
    },
    bindTextures: (textures, startingTargetUnit) => {
      for (let i = 0, il = textures.length; i < il; ++i) {
        const [k, texture] = textures[i];
        const l = locations[k];
        if (l !== null && l !== void 0) {
          texture.bind(i + startingTargetUnit);
          uniformSetters[k](gl, l, i + startingTargetUnit);
        }
      }
    },
    reset: () => {
      program = getProgram(gl);
      init();
    },
    destroy: () => {
      if (destroyed)
        return;
      vertShader.destroy();
      fragShader.destroy();
      gl.deleteProgram(program);
      destroyed = true;
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/shader.js
var getNextShaderId = idFactory();
function addLineNumbers(source) {
  const lines = source.split("\n");
  for (let i = 0; i < lines.length; ++i) {
    lines[i] = i + 1 + ": " + lines[i];
  }
  return lines.join("\n");
}
function getShader(gl, props) {
  const { type, source } = props;
  const shader = gl.createShader(type === "vert" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
  if (shader === null) {
    throw new Error(`Error creating ${type} shader`);
  }
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (isDebugMode && gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false) {
    console.warn(`'${type}' shader info log '${gl.getShaderInfoLog(shader)}'
${addLineNumbers(source)}`);
    throw new Error(`Error compiling ${type} shader`);
  }
  return shader;
}
function createShader(gl, props) {
  let shader = getShader(gl, props);
  return {
    id: getNextShaderId(),
    attach: (program) => {
      gl.attachShader(program, shader);
    },
    reset: () => {
      shader = getShader(gl, props);
    },
    destroy: () => {
      gl.deleteShader(shader);
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/reference-cache.js
function createReference(value, usageCount = 0) {
  return { value, usageCount };
}
function createReferenceItem(ref) {
  return {
    free: () => {
      ref.usageCount -= 1;
    },
    value: ref.value
  };
}
function createReferenceCache(hashFn, ctor, deleteFn) {
  const map3 = /* @__PURE__ */ new Map();
  return {
    get: (props) => {
      const id = hashFn(props);
      let ref = map3.get(id);
      if (!ref) {
        ref = createReference(ctor(props));
        map3.set(id, ref);
      }
      ref.usageCount += 1;
      return createReferenceItem(ref);
    },
    clear: () => {
      map3.forEach((ref, id) => {
        if (ref.usageCount <= 0) {
          if (ref.usageCount < 0) {
            console.warn("Reference usageCount below zero.");
          }
          deleteFn(ref.value);
          map3.delete(id);
        }
      });
    },
    get count() {
      return map3.size;
    },
    dispose: () => {
      map3.forEach((ref) => deleteFn(ref.value));
      map3.clear();
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/renderbuffer.js
var getNextRenderbufferId = idFactory();
function getFormat(gl, format) {
  switch (format) {
    case "depth16":
      return gl.DEPTH_COMPONENT16;
    case "stencil8":
      return gl.STENCIL_INDEX8;
    case "rgba4":
      return gl.RGBA4;
    case "depth-stencil":
      return gl.DEPTH_STENCIL;
    case "depth24":
      if (isWebGL2(gl))
        return gl.DEPTH_COMPONENT24;
      else
        throw new Error("WebGL2 needed for `depth24` renderbuffer format");
    case "depth32f":
      if (isWebGL2(gl))
        return gl.DEPTH_COMPONENT32F;
      else
        throw new Error("WebGL2 needed for `depth32f` renderbuffer format");
    case "depth24-stencil8":
      if (isWebGL2(gl))
        return gl.DEPTH24_STENCIL8;
      else
        throw new Error("WebGL2 needed for `depth24-stencil8` renderbuffer format");
    case "depth32f-stencil8":
      if (isWebGL2(gl))
        return gl.DEPTH32F_STENCIL8;
      else
        throw new Error("WebGL2 needed for `depth32f-stencil8` renderbuffer format");
  }
}
function getAttachment(gl, attachment) {
  switch (attachment) {
    case "depth":
      return gl.DEPTH_ATTACHMENT;
    case "stencil":
      return gl.STENCIL_ATTACHMENT;
    case "depth-stencil":
      return gl.DEPTH_STENCIL_ATTACHMENT;
    case "color0":
      return gl.COLOR_ATTACHMENT0;
  }
}
function getRenderbuffer(gl) {
  const renderbuffer = gl.createRenderbuffer();
  if (renderbuffer === null) {
    throw new Error("Could not create WebGL renderbuffer");
  }
  return renderbuffer;
}
function createRenderbuffer(gl, format, attachment, _width, _height) {
  let _renderbuffer = getRenderbuffer(gl);
  const bind2 = () => gl.bindRenderbuffer(gl.RENDERBUFFER, _renderbuffer);
  const _format = getFormat(gl, format);
  const _attachment = getAttachment(gl, attachment);
  function init() {
    bind2();
    gl.renderbufferStorage(gl.RENDERBUFFER, _format, _width, _height);
  }
  init();
  let destroyed = false;
  return {
    id: getNextRenderbufferId(),
    bind: bind2,
    attachFramebuffer: (framebuffer) => {
      framebuffer.bind();
      bind2();
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, _attachment, gl.RENDERBUFFER, _renderbuffer);
      if (isDebugMode)
        checkFramebufferStatus(gl);
    },
    detachFramebuffer: (framebuffer) => {
      framebuffer.bind();
      bind2();
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, _attachment, gl.RENDERBUFFER, null);
      if (isDebugMode)
        checkFramebufferStatus(gl);
    },
    setSize: (width, height) => {
      _width = width;
      _height = height;
      init();
    },
    reset: () => {
      _renderbuffer = getRenderbuffer(gl);
      init();
    },
    destroy: () => {
      if (destroyed)
        return;
      gl.deleteRenderbuffer(_renderbuffer);
      destroyed = true;
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/vertex-array.js
var getNextVertexArrayId = idFactory();
function getVertexArray(extensions) {
  const { vertexArrayObject } = extensions;
  if (!vertexArrayObject) {
    throw new Error("VertexArrayObject not supported");
  }
  const vertexArray = vertexArrayObject.createVertexArray();
  if (!vertexArray) {
    throw new Error("Could not create WebGL vertex array");
  }
  return vertexArray;
}
function getVertexArrayObject2(extensions) {
  const { vertexArrayObject } = extensions;
  if (vertexArrayObject === null) {
    throw new Error("VertexArrayObject not supported");
  }
  return vertexArrayObject;
}
function createVertexArray(gl, extensions, program, attributeBuffers, elementsBuffer) {
  const id = getNextVertexArrayId();
  let vertexArray = getVertexArray(extensions);
  let vertexArrayObject = getVertexArrayObject2(extensions);
  function update10() {
    vertexArrayObject.bindVertexArray(vertexArray);
    if (elementsBuffer)
      elementsBuffer.bind();
    program.bindAttributes(attributeBuffers);
    vertexArrayObject.bindVertexArray(null);
  }
  update10();
  let destroyed = false;
  return {
    id,
    bind: () => {
      vertexArrayObject.bindVertexArray(vertexArray);
    },
    update: update10,
    reset: () => {
      vertexArray = getVertexArray(extensions);
      vertexArrayObject = getVertexArrayObject2(extensions);
      update10();
    },
    destroy: () => {
      if (destroyed)
        return;
      if (elementsBuffer) {
        vertexArrayObject.bindVertexArray(vertexArray);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      }
      vertexArrayObject.deleteVertexArray(vertexArray);
      destroyed = true;
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/resources.js
function defineValueHash(v3) {
  return typeof v3 === "boolean" ? v3 ? 1 : 0 : typeof v3 === "number" ? v3 * 1e4 : hashString(v3);
}
function wrapCached(resourceItem) {
  const wrapped = {
    ...resourceItem.value,
    destroy: () => {
      resourceItem.free();
    }
  };
  return wrapped;
}
function createResources(gl, state, stats, extensions) {
  const sets = {
    attribute: /* @__PURE__ */ new Set(),
    elements: /* @__PURE__ */ new Set(),
    framebuffer: /* @__PURE__ */ new Set(),
    program: /* @__PURE__ */ new Set(),
    renderbuffer: /* @__PURE__ */ new Set(),
    shader: /* @__PURE__ */ new Set(),
    texture: /* @__PURE__ */ new Set(),
    cubeTexture: /* @__PURE__ */ new Set(),
    vertexArray: /* @__PURE__ */ new Set()
  };
  function wrap(name, resource) {
    sets[name].add(resource);
    stats.resourceCounts[name] += 1;
    return {
      ...resource,
      destroy: () => {
        resource.destroy();
        sets[name].delete(resource);
        stats.resourceCounts[name] -= 1;
      }
    };
  }
  const shaderCache = createReferenceCache((props) => JSON.stringify(props), (props) => wrap("shader", createShader(gl, props)), (shader) => {
    shader.destroy();
  });
  function getShader2(type, source) {
    return wrapCached(shaderCache.get({ type, source }));
  }
  const programCache = createReferenceCache((props) => {
    var _a;
    const array = [props.shaderCode.id];
    const variant = ((_a = props.defineValues.dRenderVariant) === null || _a === void 0 ? void 0 : _a.ref.value) || "";
    Object.keys(props.defineValues).forEach((k) => {
      var _a2, _b;
      if (!((_b = (_a2 = props.shaderCode).ignoreDefine) === null || _b === void 0 ? void 0 : _b.call(_a2, k, variant, props.defineValues))) {
        array.push(hashString(k), defineValueHash(props.defineValues[k].ref.value));
      }
    });
    return hashFnv32a(array).toString();
  }, (props) => wrap("program", createProgram(gl, state, extensions, getShader2, props)), (program) => {
    program.destroy();
  });
  return {
    attribute: (array, itemSize, divisor, usageHint) => {
      return wrap("attribute", createAttributeBuffer(gl, state, extensions, array, itemSize, divisor, usageHint));
    },
    elements: (array, usageHint) => {
      return wrap("elements", createElementsBuffer(gl, array, usageHint));
    },
    framebuffer: () => {
      return wrap("framebuffer", createFramebuffer(gl));
    },
    program: (defineValues, shaderCode, schema) => {
      return wrapCached(programCache.get({ defineValues, shaderCode, schema }));
    },
    renderbuffer: (format, attachment, width, height) => {
      return wrap("renderbuffer", createRenderbuffer(gl, format, attachment, width, height));
    },
    shader: getShader2,
    texture: (kind, format, type, filter4) => {
      return wrap("texture", createTexture(gl, extensions, kind, format, type, filter4));
    },
    cubeTexture: (faces, mipmaps, onload) => {
      return wrap("cubeTexture", createCubeTexture(gl, faces, mipmaps, onload));
    },
    vertexArray: (program, attributeBuffers, elementsBuffer) => {
      return wrap("vertexArray", createVertexArray(gl, extensions, program, attributeBuffers, elementsBuffer));
    },
    getByteCounts: () => {
      let texture = 0;
      sets.texture.forEach((r) => {
        texture += r.getByteCount();
      });
      sets.cubeTexture.forEach((r) => {
        texture += r.getByteCount();
      });
      let attribute = 0;
      sets.attribute.forEach((r) => {
        attribute += r.length * 4;
      });
      let elements = 0;
      sets.elements.forEach((r) => {
        elements += r.length * 4;
      });
      return { texture, attribute, elements };
    },
    reset: () => {
      sets.attribute.forEach((r) => r.reset());
      sets.elements.forEach((r) => r.reset());
      sets.framebuffer.forEach((r) => r.reset());
      sets.renderbuffer.forEach((r) => r.reset());
      sets.shader.forEach((r) => r.reset());
      sets.program.forEach((r) => r.reset());
      sets.vertexArray.forEach((r) => r.reset());
      sets.texture.forEach((r) => r.reset());
      sets.cubeTexture.forEach((r) => r.reset());
    },
    destroy: () => {
      sets.attribute.forEach((r) => r.destroy());
      sets.elements.forEach((r) => r.destroy());
      sets.framebuffer.forEach((r) => r.destroy());
      sets.renderbuffer.forEach((r) => r.destroy());
      sets.shader.forEach((r) => r.destroy());
      sets.program.forEach((r) => r.destroy());
      sets.vertexArray.forEach((r) => r.destroy());
      sets.texture.forEach((r) => r.destroy());
      sets.cubeTexture.forEach((r) => r.destroy());
      shaderCache.clear();
      programCache.clear();
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/render-target.js
var getNextRenderTargetId = idFactory();
function createRenderTarget(gl, resources, _width, _height, depth = true, type = "uint8", filter4 = "nearest", format = "rgba") {
  if (format === "alpha" && !isWebGL2(gl)) {
    throw new Error("cannot render to alpha format in webgl1");
  }
  const framebuffer = resources.framebuffer();
  const targetTexture = type === "fp16" ? resources.texture("image-float16", format, "fp16", filter4) : type === "float32" ? resources.texture("image-float32", format, "float", filter4) : resources.texture("image-uint8", format, "ubyte", filter4);
  const depthRenderbuffer = !depth ? null : isWebGL2(gl) ? resources.renderbuffer("depth32f", "depth", _width, _height) : resources.renderbuffer("depth16", "depth", _width, _height);
  function init() {
    targetTexture.define(_width, _height);
    targetTexture.attachFramebuffer(framebuffer, "color0");
    if (depthRenderbuffer)
      depthRenderbuffer.attachFramebuffer(framebuffer);
  }
  init();
  let destroyed = false;
  return {
    id: getNextRenderTargetId(),
    texture: targetTexture,
    framebuffer,
    depthRenderbuffer,
    getWidth: () => _width,
    getHeight: () => _height,
    bind: () => {
      framebuffer.bind();
    },
    setSize: (width, height) => {
      if (_width === width && _height === height) {
        return;
      }
      _width = width;
      _height = height;
      targetTexture.define(_width, _height);
      if (depthRenderbuffer)
        depthRenderbuffer.setSize(_width, _height);
    },
    reset: () => {
      init();
    },
    destroy: () => {
      if (destroyed)
        return;
      targetTexture.destroy();
      framebuffer.destroy();
      if (depthRenderbuffer)
        depthRenderbuffer.destroy();
      destroyed = true;
    }
  };
}
function createNullRenderTarget(gl) {
  return {
    id: getNextRenderTargetId(),
    texture: createNullTexture(gl),
    framebuffer: createNullFramebuffer(),
    depthRenderbuffer: null,
    getWidth: () => 0,
    getHeight: () => 0,
    bind: () => {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    },
    setSize: () => {
    },
    reset: () => {
    },
    destroy: () => {
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/timer.js
function movingAverage(avg, sample2, count3) {
  avg -= avg / count3;
  avg += sample2 / count3;
  return avg;
}
var MovingAverage = class {
  add(label2, sample2) {
    let avg = this.avgs.get(label2) || sample2;
    avg = movingAverage(avg, sample2, this.count);
    this.avgs.set(label2, avg);
    return avg;
  }
  get(label2) {
    return this.avgs.get(label2);
  }
  stats() {
    return Object.fromEntries(this.avgs.entries());
  }
  clear() {
    this.avgs.clear();
  }
  constructor(count3) {
    this.count = count3;
    this.avgs = /* @__PURE__ */ new Map();
  }
};
function clearStats(stats) {
  stats.calls.drawInstanced = 0;
  stats.calls.drawInstancedBase = 0;
  stats.calls.multiDrawInstancedBase = 0;
  stats.calls.counts = 0;
  stats.culled.lod = 0;
  stats.culled.frustum = 0;
  stats.culled.occlusion = 0;
}
function getQuery(extensions) {
  return extensions.disjointTimerQuery ? extensions.disjointTimerQuery.createQuery() : null;
}
function createTimer(gl, extensions, stats, options) {
  var _a;
  const dtq = extensions.disjointTimerQuery;
  const avgCount = (_a = options === null || options === void 0 ? void 0 : options.avgCount) !== null && _a !== void 0 ? _a : 30;
  const queries = /* @__PURE__ */ new Map();
  const pending = /* @__PURE__ */ new Map();
  const stack = [];
  const gpuAvgs = new MovingAverage(avgCount);
  const cpuAvgs = new MovingAverage(avgCount);
  let measures = [];
  let current3 = null;
  let capturingStats = false;
  const clear2 = () => {
    pending.clear();
    stack.length = 0;
    gpuAvgs.clear();
    cpuAvgs.clear();
    measures = [];
    current3 = null;
    capturingStats = false;
    if (dtq) {
      queries.forEach((_, query) => {
        dtq.deleteQuery(query);
      });
    }
    queries.clear();
  };
  const add = () => {
    if (!dtq)
      return;
    const query = getQuery(extensions);
    if (!query)
      return;
    dtq.beginQuery(dtq.TIME_ELAPSED, query);
    pending.forEach((measure, _) => {
      measure.queries.push(query);
    });
    queries.set(query, { refCount: pending.size });
    current3 = query;
  };
  return {
    resolve: () => {
      const results = [];
      if (!dtq || !measures.length || capturingStats)
        return results;
      queries.forEach((result, query) => {
        if (result.timeElapsed !== void 0)
          return;
        const available = dtq.getQueryParameter(query, dtq.QUERY_RESULT_AVAILABLE);
        const disjoint = gl.getParameter(dtq.GPU_DISJOINT);
        if (available && !disjoint) {
          const timeElapsed = dtq.getQueryParameter(query, dtq.QUERY_RESULT);
          result.timeElapsed = timeElapsed;
        }
        if (available || disjoint) {
          dtq.deleteQuery(query);
        }
      });
      const unresolved = [];
      for (const measure of measures) {
        if (measure.queries.every((q) => {
          var _a2;
          return ((_a2 = queries.get(q)) === null || _a2 === void 0 ? void 0 : _a2.timeElapsed) !== void 0;
        })) {
          let timeElapsed = 0;
          for (const query of measure.queries) {
            const result = queries.get(query);
            timeElapsed += result.timeElapsed;
            result.refCount -= 1;
          }
          measure.timeElapsed = timeElapsed;
          if (measure.root) {
            const children = [];
            const add2 = (measures2, children2) => {
              for (const measure2 of measures2) {
                const timeElapsed2 = measure2.timeElapsed;
                const cpuElapsed2 = measure2.cpu.end - measure2.cpu.start;
                const result = {
                  label: measure2.label,
                  gpuElapsed: timeElapsed2,
                  gpuAvg: gpuAvgs.add(measure2.label, timeElapsed2),
                  cpuElapsed: cpuElapsed2,
                  cpuAvg: cpuAvgs.add(measure2.label, cpuElapsed2),
                  children: [],
                  calls: measure2.calls,
                  note: measure2.note
                };
                children2.push(result);
                add2(measure2.children, result.children);
              }
            };
            add2(measure.children, children);
            const cpuElapsed = measure.cpu.end - measure.cpu.start;
            results.push({
              label: measure.label,
              gpuElapsed: timeElapsed,
              gpuAvg: gpuAvgs.add(measure.label, timeElapsed),
              cpuElapsed,
              cpuAvg: cpuAvgs.add(measure.label, cpuElapsed),
              children,
              calls: measure.calls,
              note: measure.note
            });
          }
        } else {
          unresolved.push(measure);
        }
      }
      measures = unresolved;
      queries.forEach((result, query) => {
        if (result.refCount === 0) {
          queries.delete(query);
        }
      });
      return results;
    },
    mark: (label2, options2) => {
      var _a2;
      if (!dtq)
        return;
      if (pending.has(label2)) {
        throw new Error(`Timer mark for '${label2}' already exists`);
      }
      const captureStats = (_a2 = options2 === null || options2 === void 0 ? void 0 : options2.captureStats) !== null && _a2 !== void 0 ? _a2 : false;
      if (current3 !== null) {
        dtq.endQuery(dtq.TIME_ELAPSED);
      }
      const measure = {
        label: label2,
        queries: [],
        children: [],
        root: current3 === null,
        cpu: { start: now(), end: -1 },
        captureStats
      };
      if (options2 === null || options2 === void 0 ? void 0 : options2.note)
        measure.note = options2.note;
      pending.set(label2, measure);
      if (stack.length) {
        stack[stack.length - 1].children.push(measure);
      }
      stack.push(measure);
      if (captureStats) {
        if (capturingStats) {
          throw new Error("Already capturing stats");
        }
        clearStats(stats);
        capturingStats = true;
      }
      add();
    },
    markEnd: (label2) => {
      var _a2;
      if (!dtq)
        return;
      const measure = pending.get(label2);
      if (!measure) {
        throw new Error(`Timer mark for '${label2}' does not exist`);
      }
      if (((_a2 = stack.pop()) === null || _a2 === void 0 ? void 0 : _a2.label) !== label2) {
        throw new Error(`Timer mark for '${label2}' has pending nested mark`);
      }
      dtq.endQuery(dtq.TIME_ELAPSED);
      pending.delete(label2);
      measure.cpu.end = now();
      if (measure.captureStats) {
        measure.calls = { ...stats.calls };
        capturingStats = false;
      }
      measures.push(measure);
      if (pending.size > 0) {
        add();
      } else {
        current3 = null;
      }
    },
    stats: () => {
      return {
        gpu: gpuAvgs.stats(),
        cpu: cpuAvgs.stats()
      };
    },
    formatedStats: () => {
      const stats2 = {};
      const gpu = gpuAvgs.stats();
      const cpu = cpuAvgs.stats();
      for (const l of Object.keys(gpu)) {
        const g = `${(gpu[l] / 1e3 / 1e3).toFixed(2)}`;
        const c5 = `${cpu[l].toFixed(2)}`;
        stats2[l] = `${g} ms | CPU: ${c5} ms`;
      }
      return stats2;
    },
    clear: clear2,
    destroy: () => {
      clear2();
    }
  };
}
function formatTimerResult(result) {
  const gpu = `${(result.gpuElapsed / 1e3 / 1e3).toFixed(2)}`;
  const gpuAvg = `${(result.gpuAvg / 1e3 / 1e3).toFixed(2)}`;
  const cpu = `${result.cpuElapsed.toFixed(2)}`;
  const cpuAvg = `${result.cpuAvg.toFixed(2)}`;
  return `${result.label} ${gpu} ms (avg. ${gpuAvg} ms) | CPU: ${cpu} ms (avg. ${cpuAvg} ms)`;
}
function printTimerResults(results) {
  results.map((r) => {
    const f = formatTimerResult(r);
    if (r.children.length || r.calls || r.note) {
      console.groupCollapsed(f);
      if (r.calls)
        console.log(r.calls);
      if (r.note)
        console.log(r.note);
      printTimerResults(r.children);
      console.groupEnd();
    } else {
      console.log(f);
    }
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/context.js
function getGLContext(canvas, attribs) {
  function get11(id) {
    try {
      return canvas.getContext(id, attribs);
    } catch (e) {
      return null;
    }
  }
  const gl = ((attribs === null || attribs === void 0 ? void 0 : attribs.preferWebGl1) ? null : get11("webgl2")) || get11("webgl") || get11("experimental-webgl");
  if (isDebugMode)
    console.log(`isWebgl2: ${isWebGL2(gl)}`);
  return gl;
}
function getErrorDescription(gl, error) {
  switch (error) {
    case gl.NO_ERROR:
      return "no error";
    case gl.INVALID_ENUM:
      return "invalid enum";
    case gl.INVALID_VALUE:
      return "invalid value";
    case gl.INVALID_OPERATION:
      return "invalid operation";
    case gl.INVALID_FRAMEBUFFER_OPERATION:
      return "invalid framebuffer operation";
    case gl.OUT_OF_MEMORY:
      return "out of memory";
    case gl.CONTEXT_LOST_WEBGL:
      return "context lost";
  }
  return "unknown error";
}
function checkError(gl) {
  const error = gl.getError();
  if (error !== gl.NO_ERROR) {
    throw new Error(`WebGL error: '${getErrorDescription(gl, error)}'`);
  }
}
function unbindResources(gl) {
  const maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  for (let i = 0; i < maxTextureImageUnits; ++i) {
    gl.activeTexture(gl.TEXTURE0 + i);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
    if (isWebGL2(gl)) {
      gl.bindTexture(gl.TEXTURE_2D_ARRAY, null);
      gl.bindTexture(gl.TEXTURE_3D, null);
    }
  }
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  const maxVertexAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  for (let i = 0; i < maxVertexAttribs; ++i) {
    gl.vertexAttribPointer(i, 1, gl.FLOAT, false, 0, 0);
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  unbindFramebuffer(gl);
}
function unbindFramebuffer(gl) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}
var tmpPixel = new Uint8Array(1 * 4);
function checkSync(gl, sync, resolve) {
  if (gl.getSyncParameter(sync, gl.SYNC_STATUS) === gl.SIGNALED) {
    gl.deleteSync(sync);
    resolve();
  } else {
    Scheduler.setImmediate(checkSync, gl, sync, resolve);
  }
}
function fence(gl, resolve) {
  const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
  if (!sync) {
    console.warn("Could not create a WebGLSync object");
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, tmpPixel);
    resolve();
  } else {
    Scheduler.setImmediate(checkSync, gl, sync, resolve);
  }
}
var SentWebglSyncObjectNotSupportedInWebglMessage = false;
function waitForGpuCommandsComplete(gl) {
  return new Promise((resolve) => {
    if (isWebGL2(gl)) {
      fence(gl, resolve);
    } else {
      if (!SentWebglSyncObjectNotSupportedInWebglMessage) {
        console.info("Sync object not supported in WebGL");
        SentWebglSyncObjectNotSupportedInWebglMessage = true;
      }
      waitForGpuCommandsCompleteSync(gl);
      resolve();
    }
  });
}
function waitForGpuCommandsCompleteSync(gl) {
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, tmpPixel);
}
function readPixels(gl, x, y, width, height, buffer2) {
  if (isDebugMode)
    checkFramebufferStatus(gl);
  if (buffer2 instanceof Uint8Array) {
    gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, buffer2);
  } else if (buffer2 instanceof Float32Array) {
    gl.readPixels(x, y, width, height, gl.RGBA, gl.FLOAT, buffer2);
  } else if (buffer2 instanceof Int32Array && isWebGL2(gl)) {
    gl.readPixels(x, y, width, height, gl.RGBA_INTEGER, gl.INT, buffer2);
  } else {
    throw new Error("unsupported readPixels buffer type");
  }
  if (isDebugMode)
    checkError(gl);
}
function getDrawingBufferPixelData(gl, state) {
  const w = gl.drawingBufferWidth;
  const h = gl.drawingBufferHeight;
  const buffer2 = new Uint8Array(w * h * 4);
  unbindFramebuffer(gl);
  state.viewport(0, 0, w, h);
  readPixels(gl, 0, 0, w, h, buffer2);
  return PixelData.flipY(PixelData.create(buffer2, w, h));
}
function getShaderPrecisionFormat(gl, shader, precision, type) {
  const glShader = shader === "vertex" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;
  const glPrecisionType = gl[`${precision.toUpperCase()}_${type.toUpperCase()}`];
  return gl.getShaderPrecisionFormat(glShader, glPrecisionType);
}
function getShaderPrecisionFormats(gl, shader) {
  return {
    lowFloat: getShaderPrecisionFormat(gl, shader, "low", "float"),
    mediumFloat: getShaderPrecisionFormat(gl, shader, "medium", "float"),
    highFloat: getShaderPrecisionFormat(gl, shader, "high", "float"),
    lowInt: getShaderPrecisionFormat(gl, shader, "low", "int"),
    mediumInt: getShaderPrecisionFormat(gl, shader, "medium", "int"),
    highInt: getShaderPrecisionFormat(gl, shader, "high", "int")
  };
}
function createStats() {
  const stats = {
    resourceCounts: {
      attribute: 0,
      elements: 0,
      framebuffer: 0,
      program: 0,
      renderbuffer: 0,
      shader: 0,
      texture: 0,
      cubeTexture: 0,
      vertexArray: 0
    },
    drawCount: 0,
    instanceCount: 0,
    instancedDrawCount: 0,
    calls: {
      drawInstanced: 0,
      drawInstancedBase: 0,
      multiDrawInstancedBase: 0,
      counts: 0
    },
    culled: {
      lod: 0,
      frustum: 0,
      occlusion: 0
    }
  };
  return stats;
}
function createContext(gl, props = {}) {
  const extensions = createExtensions(gl);
  const state = createState(gl, extensions);
  const stats = createStats();
  const resources = createResources(gl, state, stats, extensions);
  const timer2 = createTimer(gl, extensions, stats);
  const parameters = {
    maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
    max3dTextureSize: isWebGL2(gl) ? gl.getParameter(gl.MAX_3D_TEXTURE_SIZE) : 0,
    maxRenderbufferSize: gl.getParameter(gl.MAX_RENDERBUFFER_SIZE),
    maxDrawBuffers: extensions.drawBuffers ? gl.getParameter(extensions.drawBuffers.MAX_DRAW_BUFFERS) : 0,
    maxTextureImageUnits: gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
    maxVertexTextureImageUnits: gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
  };
  if (parameters.maxVertexTextureImageUnits < 8) {
    throw new Error('Need "MAX_VERTEX_TEXTURE_IMAGE_UNITS" >= 8');
  }
  const shaderPrecisionFormats = {
    vertex: getShaderPrecisionFormats(gl, "vertex"),
    fragment: getShaderPrecisionFormats(gl, "fragment")
  };
  if (isDebugMode) {
    console.log({ parameters, shaderPrecisionFormats });
  }
  const epv = extensions.provokingVertex;
  epv === null || epv === void 0 ? void 0 : epv.provokingVertex(epv.FIRST_VERTEX_CONVENTION);
  let isContextLost = false;
  const contextRestored = new Subject();
  let pixelScale = props.pixelScale || 1;
  let readPixelsAsync;
  if (isWebGL2(gl)) {
    const pbo = gl.createBuffer();
    let _buffer = void 0;
    let _resolve = void 0;
    let _reading = false;
    const bindPBO = () => {
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);
      gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, _buffer);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
      _reading = false;
      _resolve();
      _resolve = void 0;
      _buffer = void 0;
    };
    readPixelsAsync = (x, y, width, height, buffer2) => new Promise((resolve, reject) => {
      if (_reading) {
        reject("Can not call multiple readPixelsAsync at the same time");
        return;
      }
      _reading = true;
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);
      gl.bufferData(gl.PIXEL_PACK_BUFFER, width * height * 4, gl.STREAM_READ);
      gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
      _resolve = resolve;
      _buffer = buffer2;
      fence(gl, bindPBO);
    });
  } else {
    readPixelsAsync = async (x, y, width, height, buffer2) => {
      readPixels(gl, x, y, width, height, buffer2);
    };
  }
  const renderTargets = /* @__PURE__ */ new Set();
  return {
    gl,
    isWebGL2: isWebGL2(gl),
    get pixelRatio() {
      const dpr = typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;
      return dpr * (pixelScale || 1);
    },
    extensions,
    state,
    stats,
    resources,
    timer: timer2,
    get maxTextureSize() {
      return parameters.maxTextureSize;
    },
    get max3dTextureSize() {
      return parameters.max3dTextureSize;
    },
    get maxRenderbufferSize() {
      return parameters.maxRenderbufferSize;
    },
    get maxDrawBuffers() {
      return parameters.maxDrawBuffers;
    },
    get maxTextureImageUnits() {
      return parameters.maxTextureImageUnits;
    },
    get shaderPrecisionFormats() {
      return shaderPrecisionFormats;
    },
    namedComputeRenderables: /* @__PURE__ */ Object.create(null),
    namedFramebuffers: /* @__PURE__ */ Object.create(null),
    namedTextures: /* @__PURE__ */ Object.create(null),
    get isContextLost() {
      return isContextLost || gl.isContextLost();
    },
    contextRestored,
    setContextLost: () => {
      isContextLost = true;
      timer2.clear();
    },
    handleContextRestored: (extraResets) => {
      resetExtensions(gl, extensions);
      state.reset();
      state.currentMaterialId = -1;
      state.currentProgramId = -1;
      state.currentRenderItemId = -1;
      resources.reset();
      renderTargets.forEach((rt) => rt.reset());
      extraResets === null || extraResets === void 0 ? void 0 : extraResets();
      isContextLost = false;
      contextRestored.next(now());
    },
    setPixelScale: (value) => {
      pixelScale = value;
    },
    createRenderTarget: (width, height, depth, type, filter4, format) => {
      const renderTarget = createRenderTarget(gl, resources, width, height, depth, type, filter4, format);
      renderTargets.add(renderTarget);
      return {
        ...renderTarget,
        destroy: () => {
          renderTarget.destroy();
          renderTargets.delete(renderTarget);
        }
      };
    },
    unbindFramebuffer: () => unbindFramebuffer(gl),
    readPixels: (x, y, width, height, buffer2) => {
      readPixels(gl, x, y, width, height, buffer2);
    },
    readPixelsAsync,
    waitForGpuCommandsComplete: () => waitForGpuCommandsComplete(gl),
    waitForGpuCommandsCompleteSync: () => waitForGpuCommandsCompleteSync(gl),
    getFenceSync: () => {
      return isWebGL2(gl) ? gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0) : null;
    },
    checkSyncStatus: (sync) => {
      if (!isWebGL2(gl))
        return true;
      if (gl.getSyncParameter(sync, gl.SYNC_STATUS) === gl.SIGNALED) {
        gl.deleteSync(sync);
        return true;
      } else {
        return false;
      }
    },
    deleteSync: (sync) => {
      if (isWebGL2(gl))
        gl.deleteSync(sync);
    },
    getDrawingBufferPixelData: () => getDrawingBufferPixelData(gl, state),
    clear: (red, green, blue, alpha) => {
      unbindFramebuffer(gl);
      state.enable(gl.SCISSOR_TEST);
      state.depthMask(true);
      state.colorMask(true, true, true, true);
      state.clearColor(red, green, blue, alpha);
      state.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      state.scissor(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    },
    destroy: (options) => {
      var _a, _b;
      resources.destroy();
      unbindResources(gl);
      if (!(options === null || options === void 0 ? void 0 : options.doNotForceWebGLContextLoss)) {
        (_a = gl.getExtension("WEBGL_lose_context")) === null || _a === void 0 ? void 0 : _a.loseContext();
        (_b = gl.getExtension("STACKGL_destroy_context")) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/compat.js
function isWebGL2(gl) {
  return typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
}
function getInstancedArrays(gl) {
  if (isWebGL2(gl)) {
    return {
      drawArraysInstanced: gl.drawArraysInstanced.bind(gl),
      drawElementsInstanced: gl.drawElementsInstanced.bind(gl),
      vertexAttribDivisor: gl.vertexAttribDivisor.bind(gl),
      VERTEX_ATTRIB_ARRAY_DIVISOR: gl.VERTEX_ATTRIB_ARRAY_DIVISOR
    };
  } else {
    const ext = gl.getExtension("ANGLE_instanced_arrays");
    if (ext === null)
      return null;
    return {
      drawArraysInstanced: ext.drawArraysInstancedANGLE.bind(ext),
      drawElementsInstanced: ext.drawElementsInstancedANGLE.bind(ext),
      vertexAttribDivisor: ext.vertexAttribDivisorANGLE.bind(ext),
      VERTEX_ATTRIB_ARRAY_DIVISOR: ext.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE
    };
  }
}
function getStandardDerivatives(gl) {
  if (isWebGL2(gl)) {
    return { FRAGMENT_SHADER_DERIVATIVE_HINT: gl.FRAGMENT_SHADER_DERIVATIVE_HINT };
  } else {
    const ext = gl.getExtension("OES_standard_derivatives");
    if (ext === null)
      return null;
    return { FRAGMENT_SHADER_DERIVATIVE_HINT: ext.FRAGMENT_SHADER_DERIVATIVE_HINT_OES };
  }
}
function getElementIndexUint(gl) {
  return isWebGL2(gl) ? {} : gl.getExtension("OES_element_index_uint");
}
function getVertexArrayObject(gl) {
  if (isWebGL2(gl)) {
    return {
      VERTEX_ARRAY_BINDING: gl.VERTEX_ARRAY_BINDING,
      bindVertexArray: gl.bindVertexArray.bind(gl),
      createVertexArray: gl.createVertexArray.bind(gl),
      deleteVertexArray: gl.deleteVertexArray.bind(gl),
      isVertexArray: gl.isVertexArray.bind(gl)
    };
  } else {
    const ext = gl.getExtension("OES_vertex_array_object");
    if (ext === null)
      return null;
    return {
      VERTEX_ARRAY_BINDING: ext.VERTEX_ARRAY_BINDING_OES,
      bindVertexArray: ext.bindVertexArrayOES.bind(ext),
      createVertexArray: ext.createVertexArrayOES.bind(ext),
      deleteVertexArray: ext.deleteVertexArrayOES.bind(ext),
      isVertexArray: ext.isVertexArrayOES.bind(ext)
    };
  }
}
function getTextureFloat(gl) {
  return isWebGL2(gl) ? {} : gl.getExtension("OES_texture_float");
}
function getTextureFloatLinear(gl) {
  return gl.getExtension("OES_texture_float_linear");
}
function getTextureHalfFloat(gl) {
  if (isWebGL2(gl)) {
    return { HALF_FLOAT: gl.HALF_FLOAT };
  } else {
    const ext = gl.getExtension("OES_texture_half_float");
    if (ext === null)
      return null;
    return { HALF_FLOAT: ext.HALF_FLOAT_OES };
  }
}
function getTextureHalfFloatLinear(gl) {
  return gl.getExtension("OES_texture_half_float_linear");
}
function getBlendMinMax(gl) {
  if (isWebGL2(gl)) {
    return { MIN: gl.MIN, MAX: gl.MAX };
  } else {
    const ext = gl.getExtension("EXT_blend_minmax");
    if (ext === null)
      return null;
    return { MIN: ext.MIN_EXT, MAX: ext.MAX_EXT };
  }
}
function getFragDepth(gl) {
  return isWebGL2(gl) ? {} : gl.getExtension("EXT_frag_depth");
}
function getColorBufferFloat(gl) {
  if (isWebGL2(gl)) {
    if (gl.getExtension("EXT_color_buffer_float") === null)
      return null;
    gl.getExtension("EXT_float_blend");
    return { RGBA32F: gl.RGBA32F };
  } else {
    const ext = gl.getExtension("WEBGL_color_buffer_float");
    if (ext === null) {
      gl.getExtension("OES_texture_float");
      return testColorBuffer(gl, gl.FLOAT) ? { RGBA32F: 34836 } : null;
    }
    gl.getExtension("EXT_float_blend");
    return { RGBA32F: ext.RGBA32F_EXT };
  }
}
function getColorBufferHalfFloat(gl) {
  if (isWebGL2(gl)) {
    if (gl.getExtension("EXT_color_buffer_half_float") === null)
      return null;
    gl.getExtension("EXT_float_blend");
    return { RGBA16F: gl.RGBA16F };
  } else {
    const ext = gl.getExtension("EXT_color_buffer_half_float");
    if (ext === null) {
      gl.getExtension("OES_texture_half_float");
      return testColorBuffer(gl, 36193) ? { RGBA16F: 34842 } : null;
    }
    gl.getExtension("EXT_float_blend");
    return { RGBA16F: ext.RGBA16F_EXT };
  }
}
function getDrawBuffers(gl) {
  if (isWebGL2(gl)) {
    return {
      drawBuffers: gl.drawBuffers.bind(gl),
      COLOR_ATTACHMENT0: gl.COLOR_ATTACHMENT0,
      COLOR_ATTACHMENT1: gl.COLOR_ATTACHMENT1,
      COLOR_ATTACHMENT2: gl.COLOR_ATTACHMENT2,
      COLOR_ATTACHMENT3: gl.COLOR_ATTACHMENT3,
      COLOR_ATTACHMENT4: gl.COLOR_ATTACHMENT4,
      COLOR_ATTACHMENT5: gl.COLOR_ATTACHMENT5,
      COLOR_ATTACHMENT6: gl.COLOR_ATTACHMENT6,
      COLOR_ATTACHMENT7: gl.COLOR_ATTACHMENT7,
      DRAW_BUFFER0: gl.DRAW_BUFFER0,
      DRAW_BUFFER1: gl.DRAW_BUFFER1,
      DRAW_BUFFER2: gl.DRAW_BUFFER2,
      DRAW_BUFFER3: gl.DRAW_BUFFER3,
      DRAW_BUFFER4: gl.DRAW_BUFFER4,
      DRAW_BUFFER5: gl.DRAW_BUFFER5,
      DRAW_BUFFER6: gl.DRAW_BUFFER6,
      DRAW_BUFFER7: gl.DRAW_BUFFER7,
      MAX_COLOR_ATTACHMENTS: gl.MAX_COLOR_ATTACHMENTS,
      MAX_DRAW_BUFFERS: gl.MAX_DRAW_BUFFERS
    };
  } else {
    const ext = gl.getExtension("WEBGL_draw_buffers");
    if (ext === null)
      return null;
    return {
      drawBuffers: ext.drawBuffersWEBGL.bind(ext),
      COLOR_ATTACHMENT0: ext.COLOR_ATTACHMENT0_WEBGL,
      COLOR_ATTACHMENT1: ext.COLOR_ATTACHMENT1_WEBGL,
      COLOR_ATTACHMENT2: ext.COLOR_ATTACHMENT2_WEBGL,
      COLOR_ATTACHMENT3: ext.COLOR_ATTACHMENT3_WEBGL,
      COLOR_ATTACHMENT4: ext.COLOR_ATTACHMENT4_WEBGL,
      COLOR_ATTACHMENT5: ext.COLOR_ATTACHMENT5_WEBGL,
      COLOR_ATTACHMENT6: ext.COLOR_ATTACHMENT6_WEBGL,
      COLOR_ATTACHMENT7: ext.COLOR_ATTACHMENT7_WEBGL,
      DRAW_BUFFER0: ext.DRAW_BUFFER0_WEBGL,
      DRAW_BUFFER1: ext.DRAW_BUFFER1_WEBGL,
      DRAW_BUFFER2: ext.DRAW_BUFFER2_WEBGL,
      DRAW_BUFFER3: ext.DRAW_BUFFER3_WEBGL,
      DRAW_BUFFER4: ext.DRAW_BUFFER4_WEBGL,
      DRAW_BUFFER5: ext.DRAW_BUFFER5_WEBGL,
      DRAW_BUFFER6: ext.DRAW_BUFFER6_WEBGL,
      DRAW_BUFFER7: ext.DRAW_BUFFER7_WEBGL,
      MAX_COLOR_ATTACHMENTS: ext.MAX_COLOR_ATTACHMENTS_WEBGL,
      MAX_DRAW_BUFFERS: ext.MAX_DRAW_BUFFERS_WEBGL
    };
  }
}
function getDrawBuffersIndexed(gl) {
  const ext = gl.getExtension("OES_draw_buffers_indexed");
  if (ext === null)
    return null;
  return {
    enablei: ext.enableiOES.bind(ext),
    disablei: ext.disableiOES.bind(ext),
    blendEquationi: ext.blendEquationiOES.bind(ext),
    blendEquationSeparatei: ext.blendEquationSeparateiOES.bind(ext),
    blendFunci: ext.blendFunciOES.bind(ext),
    blendFuncSeparatei: ext.blendFuncSeparateiOES.bind(ext),
    colorMaski: ext.colorMaskiOES.bind(ext)
  };
}
function getShaderTextureLod(gl) {
  return isWebGL2(gl) ? {} : gl.getExtension("EXT_shader_texture_lod");
}
function getDepthTexture(gl) {
  if (isWebGL2(gl)) {
    return {
      UNSIGNED_INT_24_8: gl.UNSIGNED_INT_24_8
    };
  } else {
    const ext = gl.getExtension("WEBGL_depth_texture");
    if (ext === null)
      return null;
    return {
      UNSIGNED_INT_24_8: ext.UNSIGNED_INT_24_8_WEBGL
    };
  }
}
function getSRGB(gl) {
  if (isWebGL2(gl)) {
    return {
      FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: gl.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING,
      SRGB8_ALPHA8: gl.SRGB8_ALPHA8,
      SRGB8: gl.SRGB8,
      SRGB: gl.SRGB
    };
  } else {
    const ext = gl.getExtension("EXT_sRGB");
    if (ext === null)
      return null;
    return {
      FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: ext.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT,
      SRGB8_ALPHA8: ext.SRGB8_ALPHA8_EXT,
      SRGB8: ext.SRGB_ALPHA_EXT,
      SRGB: ext.SRGB_EXT
    };
  }
}
function getDisjointTimerQuery(gl) {
  if (isWebGL2(gl)) {
    const ext = gl.getExtension("EXT_disjoint_timer_query_webgl2") || gl.getExtension("EXT_disjoint_timer_query");
    if (ext === null)
      return null;
    return {
      QUERY_COUNTER_BITS: ext.QUERY_COUNTER_BITS_EXT,
      CURRENT_QUERY: gl.CURRENT_QUERY,
      QUERY_RESULT: gl.QUERY_RESULT,
      QUERY_RESULT_AVAILABLE: gl.QUERY_RESULT_AVAILABLE,
      TIME_ELAPSED: ext.TIME_ELAPSED_EXT,
      TIMESTAMP: ext.TIMESTAMP_EXT,
      GPU_DISJOINT: ext.GPU_DISJOINT_EXT,
      createQuery: gl.createQuery.bind(gl),
      deleteQuery: gl.deleteQuery.bind(gl),
      isQuery: gl.isQuery.bind(gl),
      beginQuery: gl.beginQuery.bind(gl),
      endQuery: gl.endQuery.bind(gl),
      queryCounter: ext.queryCounterEXT.bind(ext),
      getQuery: gl.getQuery.bind(gl),
      getQueryParameter: gl.getQueryParameter.bind(gl)
    };
  } else {
    const ext = gl.getExtension("EXT_disjoint_timer_query");
    if (ext === null)
      return null;
    return {
      QUERY_COUNTER_BITS: ext.QUERY_COUNTER_BITS_EXT,
      CURRENT_QUERY: ext.CURRENT_QUERY_EXT,
      QUERY_RESULT: ext.QUERY_RESULT_EXT,
      QUERY_RESULT_AVAILABLE: ext.QUERY_RESULT_AVAILABLE_EXT,
      TIME_ELAPSED: ext.TIME_ELAPSED_EXT,
      TIMESTAMP: ext.TIMESTAMP_EXT,
      GPU_DISJOINT: ext.GPU_DISJOINT_EXT,
      createQuery: ext.createQueryEXT.bind(ext),
      deleteQuery: ext.deleteQueryEXT.bind(ext),
      isQuery: ext.isQueryEXT.bind(ext),
      beginQuery: ext.beginQueryEXT.bind(ext),
      endQuery: ext.endQueryEXT.bind(ext),
      queryCounter: ext.queryCounterEXT.bind(ext),
      getQuery: ext.getQueryEXT.bind(ext),
      getQueryParameter: ext.getQueryObjectEXT.bind(ext)
    };
  }
}
function getMultiDraw(gl) {
  const ext = gl.getExtension("WEBGL_multi_draw");
  if (ext) {
    return {
      multiDrawArrays: ext.multiDrawArraysWEBGL.bind(ext),
      multiDrawElements: ext.multiDrawElementsWEBGL.bind(ext),
      multiDrawArraysInstanced: ext.multiDrawArraysInstancedWEBGL.bind(ext),
      multiDrawElementsInstanced: ext.multiDrawElementsInstancedWEBGL.bind(ext)
    };
  } else {
    return null;
  }
}
function getDrawInstancedBaseVertexBaseInstance(gl) {
  const ext = gl.getExtension("WEBGL_draw_instanced_base_vertex_base_instance");
  if (ext) {
    return {
      drawArraysInstancedBaseInstance: ext.drawArraysInstancedBaseInstanceWEBGL.bind(ext),
      drawElementsInstancedBaseVertexBaseInstance: ext.drawElementsInstancedBaseVertexBaseInstanceWEBGL.bind(ext)
    };
  } else {
    return null;
  }
}
function getMultiDrawInstancedBaseVertexBaseInstance(gl) {
  const ext = gl.getExtension("WEBGL_multi_draw_instanced_base_vertex_base_instance");
  if (ext) {
    return {
      multiDrawArraysInstancedBaseInstance: ext.multiDrawArraysInstancedBaseInstanceWEBGL.bind(ext),
      multiDrawElementsInstancedBaseVertexBaseInstance: ext.multiDrawElementsInstancedBaseVertexBaseInstanceWEBGL.bind(ext)
    };
  } else {
    return null;
  }
}
function getParallelShaderCompile(gl) {
  const ext = gl.getExtension("KHR_parallel_shader_compile");
  if (ext === null)
    return null;
  return {
    COMPLETION_STATUS: ext.COMPLETION_STATUS_KHR
  };
}
function getFboRenderMipmap(gl) {
  return isWebGL2(gl) ? {} : gl.getExtension("OES_fbo_render_mipmap");
}
function getProvokingVertex(gl) {
  if (isWebGL2(gl)) {
    const ext = gl.getExtension("WEBGL_provoking_vertex");
    if (ext) {
      return {
        FIRST_VERTEX_CONVENTION: ext.FIRST_VERTEX_CONVENTION_WEBGL,
        LAST_VERTEX_CONVENTION: ext.LAST_VERTEX_CONVENTION_WEBGL,
        PROVOKING_VERTEX: ext.PROVOKING_VERTEX_WEBGL,
        provokingVertex: ext.provokingVertexWEBGL.bind(ext)
      };
    }
  }
  return null;
}
function getClipCullDistance(gl) {
  if (isWebGL2(gl)) {
    const ext = gl.getExtension("WEBGL_clip_cull_distance");
    if (ext) {
      return {
        MAX_CLIP_DISTANCES: ext.MAX_CLIP_DISTANCES_WEBGL,
        MAX_CULL_DISTANCES: ext.MAX_CULL_DISTANCES_WEBGL,
        MAX_COMBINED_CLIP_AND_CULL_DISTANCES: ext.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL,
        CLIP_DISTANCE0: ext.CLIP_DISTANCE0_WEBGL,
        CLIP_DISTANCE1: ext.CLIP_DISTANCE1_WEBGL,
        CLIP_DISTANCE2: ext.CLIP_DISTANCE2_WEBGL,
        CLIP_DISTANCE3: ext.CLIP_DISTANCE3_WEBGL,
        CLIP_DISTANCE4: ext.CLIP_DISTANCE4_WEBGL,
        CLIP_DISTANCE5: ext.CLIP_DISTANCE5_WEBGL,
        CLIP_DISTANCE6: ext.CLIP_DISTANCE6_WEBGL,
        CLIP_DISTANCE7: ext.CLIP_DISTANCE7_WEBGL
      };
    }
  }
  return null;
}
function getConservativeDepth(gl) {
  if (isWebGL2(gl)) {
    const ext = gl.getExtension("EXT_conservative_depth");
    if (ext) {
      return {};
    }
  }
  return null;
}
function getStencilTexturing(gl) {
  if (isWebGL2(gl)) {
    const ext = gl.getExtension("WEBGL_stencil_texturing");
    if (ext) {
      return {
        DEPTH_STENCIL_TEXTURE_MODE: ext.DEPTH_STENCIL_TEXTURE_MODE_WEBGL,
        STENCIL_INDEX: ext.STENCIL_INDEX_WEBGL
      };
    }
  }
  return null;
}
function getClipControl(gl) {
  const ext = gl.getExtension("EXT_clip_control");
  if (ext) {
    return {
      LOWER_LEFT: ext.LOWER_LEFT_EXT,
      UPPER_LEFT: ext.UPPER_LEFT_EXT,
      NEGATIVE_ONE_TO_ONE: ext.NEGATIVE_ONE_TO_ONE_EXT,
      ZERO_TO_ONE: ext.ZERO_TO_ONE_EXT,
      CLIP_ORIGIN: ext.CLIP_ORIGIN_EXT,
      CLIP_DEPTH_MODE: ext.CLIP_DEPTH_MODE_EXT,
      clipControl: ext.clipControlEXT.bind(ext)
    };
  }
  return null;
}
function getRenderSnorm(gl) {
  if (isWebGL2(gl)) {
    const ext = gl.getExtension("EXT_render_snorm");
    if (ext) {
      return {};
    }
  }
  return null;
}
function getRenderSharedExponent(gl) {
  if (isWebGL2(gl)) {
    const ext = gl.getExtension("WEBGL_render_shared_exponent");
    if (ext) {
      return {};
    }
  }
  return null;
}
function getTextureNorm16(gl) {
  const ext = gl.getExtension("EXT_texture_norm16");
  if (ext) {
    return {
      R16: ext.R16_EXT,
      RG16: ext.RG16_EXT,
      RGB16: ext.RGB16_EXT,
      RGBA16: ext.RGBA16_EXT,
      R16_SNORM: ext.R16_SNORM_EXT,
      RG16_SNORM: ext.RG16_SNORM_EXT,
      RGB16_SNORM: ext.RGB16_SNORM_EXT,
      RGBA16_SNORM: ext.RGBA16_SNORM_EXT
    };
  }
  return null;
}
function getDepthClamp(gl) {
  const ext = gl.getExtension("EXT_depth_clamp");
  if (ext) {
    return {
      DEPTH_CLAMP: ext.DEPTH_CLAMP_EXT
    };
  }
  return null;
}
function getNoNonInstancedActiveAttribs(gl) {
  if (!isWebGL2(gl))
    return false;
  if (typeof navigator !== "undefined") {
    const ffMatch = window.navigator.userAgent.match(/Firefox\/([0-9]+)\./);
    if (!ffMatch)
      return true;
    const ffVersion = parseInt(ffMatch[1]);
    return ffVersion >= 85;
  }
  return false;
}
var TextureTestVertShader = `
attribute vec4 aPosition;

void main() {
    gl_Position = aPosition;
}`;
var TextureTestFragShader = `
precision mediump float;
uniform vec4 uColor;
uniform sampler2D uTexture;

void main() {
    gl_FragColor = texture2D(uTexture, vec2(0.5, 0.5)) * uColor;
}`;
var TextureTestTexCoords = new Float32Array([
  -1,
  -1,
  1,
  -1,
  -1,
  1,
  -1,
  1,
  1,
  -1,
  1,
  1
]);
function testColorBuffer(gl, type) {
  const vertShader = getShader(gl, { type: "vert", source: TextureTestVertShader });
  const fragShader = getShader(gl, { type: "frag", source: TextureTestFragShader });
  if (!vertShader || !fragShader)
    return false;
  const program = getProgram(gl);
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  gl.useProgram(program);
  const positionLocation = gl.getAttribLocation(program, "aPosition");
  const colorLoc = gl.getUniformLocation(program, "uColor");
  if (!colorLoc) {
    if (isDebugMode) {
      console.log(`error getting 'uColor' uniform location`);
    }
    return false;
  }
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, TextureTestTexCoords, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  const whiteTex = gl.createTexture();
  const whiteData = new Uint8Array([255, 255, 255, 255]);
  gl.bindTexture(gl.TEXTURE_2D, whiteTex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whiteData);
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, type, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  if (status !== gl.FRAMEBUFFER_COMPLETE) {
    if (isDebugMode) {
      console.log(`error creating framebuffer for '${type}'`);
    }
    return false;
  }
  gl.bindTexture(gl.TEXTURE_2D, whiteTex);
  gl.uniform4fv(colorLoc, [0, 10, 20, 1]);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.clearColor(1, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.uniform4fv(colorLoc, [0, 1 / 10, 1 / 20, 1]);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  const pixel = new Uint8Array(4);
  gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
  if (pixel[0] !== 0 || pixel[1] < 248 || pixel[2] < 248 || pixel[3] < 254) {
    if (isDebugMode) {
      console.log(`not able to actually render to '${type}' texture`);
    }
    return false;
  }
  if (type === gl.FLOAT) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    const floatPixel = new Float32Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, floatPixel);
    const error = gl.getError();
    if (error) {
      if (isDebugMode) {
        console.log(`error reading float pixels: '${getErrorDescription(gl, error)}'`);
      }
      return false;
    }
  }
  return true;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/texture.js
var getNextTextureId = idFactory();
function getTarget(gl, kind) {
  switch (kind) {
    case "image-uint8":
      return gl.TEXTURE_2D;
    case "image-float32":
      return gl.TEXTURE_2D;
    case "image-float16":
      return gl.TEXTURE_2D;
    case "image-depth":
      return gl.TEXTURE_2D;
  }
  if (isWebGL2(gl)) {
    switch (kind) {
      case "image-int32":
        return gl.TEXTURE_2D;
      case "volume-uint8":
        return gl.TEXTURE_3D;
      case "volume-float32":
        return gl.TEXTURE_3D;
      case "volume-float16":
        return gl.TEXTURE_3D;
    }
  }
  throw new Error(`unknown texture kind '${kind}'`);
}
function getFormat2(gl, format, type) {
  switch (format) {
    case "alpha":
      if (isWebGL2(gl) && (type === "float" || type === "fp16"))
        return gl.RED;
      else if (isWebGL2(gl) && type === "int")
        return gl.RED_INTEGER;
      else
        return gl.ALPHA;
    case "rgb":
      if (isWebGL2(gl) && type === "int")
        return gl.RGB_INTEGER;
      return gl.RGB;
    case "rg":
      if (isWebGL2(gl) && (type === "float" || type === "fp16"))
        return gl.RG;
      else if (isWebGL2(gl) && type === "int")
        return gl.RG_INTEGER;
      else
        throw new Error('texture format "rg" requires webgl2 and type "float" or int"');
    case "rgba":
      if (isWebGL2(gl) && type === "int")
        return gl.RGBA_INTEGER;
      return gl.RGBA;
    case "depth":
      return gl.DEPTH_COMPONENT;
  }
}
function getInternalFormat(gl, format, type) {
  if (isWebGL2(gl)) {
    switch (format) {
      case "alpha":
        switch (type) {
          case "ubyte":
            return gl.ALPHA;
          case "float":
            return gl.R32F;
          case "fp16":
            return gl.R16F;
          case "int":
            return gl.R32I;
        }
      case "rg":
        switch (type) {
          case "ubyte":
            return gl.RG;
          case "float":
            return gl.RG32F;
          case "fp16":
            return gl.RG16F;
          case "int":
            return gl.RG32I;
        }
      case "rgb":
        switch (type) {
          case "ubyte":
            return gl.RGB;
          case "float":
            return gl.RGB32F;
          case "fp16":
            return gl.RGB16F;
          case "int":
            return gl.RGB32I;
        }
      case "rgba":
        switch (type) {
          case "ubyte":
            return gl.RGBA;
          case "float":
            return gl.RGBA32F;
          case "fp16":
            return gl.RGBA16F;
          case "int":
            return gl.RGBA32I;
        }
      case "depth":
        switch (type) {
          case "ushort":
            return gl.DEPTH_COMPONENT16;
          case "float":
            return gl.DEPTH_COMPONENT32F;
        }
    }
  }
  return getFormat2(gl, format, type);
}
function getByteCount(format, type, width, height, depth) {
  const bpe = getFormatSize(format) * getTypeSize(type);
  return bpe * width * height * (depth || 1);
}
function getFormatSize(format) {
  switch (format) {
    case "alpha":
      return 1;
    case "rg":
      return 2;
    case "rgb":
      return 3;
    case "rgba":
      return 4;
    case "depth":
      return 4;
  }
}
function getTypeSize(type) {
  switch (type) {
    case "ubyte":
      return 1;
    case "ushort":
      return 2;
    case "float":
      return 4;
    case "fp16":
      return 2;
    case "int":
      return 4;
  }
}
function getType(gl, extensions, type) {
  switch (type) {
    case "ubyte":
      return gl.UNSIGNED_BYTE;
    case "ushort":
      return gl.UNSIGNED_SHORT;
    case "float":
      return gl.FLOAT;
    case "fp16":
      if (extensions.textureHalfFloat)
        return extensions.textureHalfFloat.HALF_FLOAT;
      else
        throw new Error('extension "texture_half_float" unavailable');
    case "int":
      if (isWebGL2(gl))
        return gl.INT;
      else
        throw new Error('texture type "int" requires webgl2');
  }
}
function getFilter(gl, type) {
  switch (type) {
    case "nearest":
      return gl.NEAREST;
    case "linear":
      return gl.LINEAR;
  }
}
function getAttachment2(gl, extensions, attachment) {
  switch (attachment) {
    case "depth":
      return gl.DEPTH_ATTACHMENT;
    case "stencil":
      return gl.STENCIL_ATTACHMENT;
    case "color0":
    case 0:
      return gl.COLOR_ATTACHMENT0;
  }
  if (extensions.drawBuffers) {
    switch (attachment) {
      case "color1":
      case 1:
        return extensions.drawBuffers.COLOR_ATTACHMENT1;
      case "color2":
      case 2:
        return extensions.drawBuffers.COLOR_ATTACHMENT2;
      case "color3":
      case 3:
        return extensions.drawBuffers.COLOR_ATTACHMENT3;
      case "color4":
      case 4:
        return extensions.drawBuffers.COLOR_ATTACHMENT4;
      case "color5":
      case 5:
        return extensions.drawBuffers.COLOR_ATTACHMENT5;
      case "color6":
      case 6:
        return extensions.drawBuffers.COLOR_ATTACHMENT6;
      case "color7":
      case 7:
        return extensions.drawBuffers.COLOR_ATTACHMENT7;
    }
  }
  throw new Error("unknown texture attachment");
}
function isImage(x) {
  return typeof HTMLImageElement !== "undefined" && x instanceof HTMLImageElement;
}
function isTexture2d(x, target, gl) {
  return target === gl.TEXTURE_2D;
}
function isTexture3d(x, target, gl) {
  return target === gl.TEXTURE_3D;
}
function getTexture(gl) {
  const texture = gl.createTexture();
  if (texture === null) {
    throw new Error("Could not create WebGL texture");
  }
  return texture;
}
function createTexture(gl, extensions, kind, _format, _type, _filter) {
  const id = getNextTextureId();
  let texture = getTexture(gl);
  if (kind.endsWith("float32") && _type !== "float" || kind.endsWith("float16") && _type !== "fp16" || kind.endsWith("uint8") && _type !== "ubyte" || kind.endsWith("int32") && _type !== "int" || kind.endsWith("depth") && _type !== "ushort" && _type !== "float") {
    throw new Error(`texture kind '${kind}' and type '${_type}' are incompatible`);
  }
  if (!extensions.depthTexture && _format === "depth") {
    throw new Error(`extension 'WEBGL_depth_texture' needed for 'depth' texture format`);
  }
  const target = getTarget(gl, kind);
  const filter4 = getFilter(gl, _filter);
  const format = getFormat2(gl, _format, _type);
  const internalFormat = getInternalFormat(gl, _format, _type);
  const type = getType(gl, extensions, _type);
  function init() {
    gl.bindTexture(target, texture);
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filter4);
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filter4);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.bindTexture(target, null);
  }
  init();
  let width = 0, height = 0, depth = 0;
  let loadedData;
  let hasMipmap = false;
  let destroyed = false;
  function define(_width, _height, _depth) {
    if (_width === 0 || _height === 0 || isWebGL2(gl) && target === gl.TEXTURE_3D && _depth === 0) {
      throw new Error("empty textures are not allowed");
    }
    if (width === _width && height === _height && depth === (_depth || 0))
      return;
    width = _width, height = _height, depth = _depth || 0;
    gl.bindTexture(target, texture);
    if (target === gl.TEXTURE_2D) {
      gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, null);
    } else if (isWebGL2(gl) && target === gl.TEXTURE_3D && depth !== void 0) {
      gl.texImage3D(target, 0, internalFormat, width, height, depth, 0, format, type, null);
    } else {
      throw new Error("unknown texture target");
    }
  }
  define(1, 1, isWebGL2(gl) && target === gl.TEXTURE_3D ? 1 : 0);
  function load(data, sub = false) {
    if (data.width === 0 || data.height === 0 || !isImage(data) && isWebGL2(gl) && isTexture3d(data, target, gl) && data.depth === 0) {
      throw new Error("empty textures are not allowed");
    }
    gl.bindTexture(target, texture);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
    if (isImage(data)) {
      width = data.width, height = data.height;
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, format, type, data);
    } else if (isTexture2d(data, target, gl)) {
      const _filter2 = data.filter ? getFilter(gl, data.filter) : filter4;
      gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, _filter2);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _filter2);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);
      if (sub) {
        gl.texSubImage2D(target, 0, 0, 0, data.width, data.height, format, type, data.array);
      } else {
        width = data.width, height = data.height;
        gl.texImage2D(target, 0, internalFormat, width, height, 0, format, type, data.array);
      }
    } else if (isWebGL2(gl) && isTexture3d(data, target, gl)) {
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
      if (sub) {
        gl.texSubImage3D(target, 0, 0, 0, 0, data.width, data.height, data.depth, format, type, data.array);
      } else {
        width = data.width, height = data.height, depth = data.depth;
        gl.texImage3D(target, 0, internalFormat, width, height, depth, 0, format, type, data.array);
      }
    } else {
      throw new Error("unknown texture target");
    }
    gl.bindTexture(target, null);
    loadedData = data;
  }
  function mipmap() {
    if (target !== gl.TEXTURE_2D) {
      throw new Error("mipmap only supported for 2d textures");
    }
    if (isWebGL2(gl) || isPowerOfTwo(width) && isPowerOfTwo(height)) {
      gl.bindTexture(target, texture);
      gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      gl.generateMipmap(target);
      gl.bindTexture(target, null);
      hasMipmap = true;
    } else {
      throw new Error("mipmap unsupported for non-power-of-two textures and webgl1");
    }
  }
  function attachFramebuffer(framebuffer, attachment, layer) {
    framebuffer.bind();
    if (target === gl.TEXTURE_2D) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, getAttachment2(gl, extensions, attachment), gl.TEXTURE_2D, texture, 0);
    } else if (isWebGL2(gl) && target === gl.TEXTURE_3D) {
      if (layer === void 0)
        throw new Error("need `layer` to attach 3D texture");
      gl.framebufferTextureLayer(gl.FRAMEBUFFER, getAttachment2(gl, extensions, attachment), texture, 0, layer);
    } else {
      throw new Error("unknown/unsupported texture target");
    }
  }
  return {
    id,
    target,
    format,
    internalFormat,
    type,
    filter: filter4,
    getWidth: () => width,
    getHeight: () => height,
    getDepth: () => depth,
    getByteCount: () => getByteCount(_format, _type, width, height, depth),
    define,
    load,
    mipmap,
    bind: (id2) => {
      gl.activeTexture(gl.TEXTURE0 + id2);
      gl.bindTexture(target, texture);
    },
    unbind: (id2) => {
      gl.activeTexture(gl.TEXTURE0 + id2);
      gl.bindTexture(target, null);
    },
    attachFramebuffer,
    detachFramebuffer: (framebuffer, attachment) => {
      framebuffer.bind();
      if (target === gl.TEXTURE_2D) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, getAttachment2(gl, extensions, attachment), gl.TEXTURE_2D, null, 0);
      } else if (isWebGL2(gl) && target === gl.TEXTURE_3D) {
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, getAttachment2(gl, extensions, attachment), null, 0, 0);
      } else {
        throw new Error("unknown texture target");
      }
    },
    reset: () => {
      texture = getTexture(gl);
      init();
      const [_width, _height, _depth] = [width, height, depth];
      width = 0, height = 0, depth = 0;
      define(_width, _height, _depth);
      if (loadedData)
        load(loadedData);
      if (hasMipmap)
        mipmap();
    },
    destroy: () => {
      if (destroyed)
        return;
      gl.deleteTexture(texture);
      destroyed = true;
    }
  };
}
function createTextures(ctx, schema, values2) {
  const { resources } = ctx;
  const textures = [];
  Object.keys(schema).forEach((k) => {
    const spec = schema[k];
    if (spec.type === "texture") {
      const value = values2[k];
      if (value) {
        if (spec.kind === "texture") {
          textures[textures.length] = [k, value.ref.value];
        } else {
          const texture = resources.texture(spec.kind, spec.format, spec.dataType, spec.filter);
          texture.load(value.ref.value);
          textures[textures.length] = [k, texture];
        }
      }
    }
  });
  return textures;
}
function loadImageTexture(src, cell, texture) {
  const img = new Image();
  img.onload = function() {
    texture.load(img);
    ValueCell.update(cell, texture);
  };
  img.src = src;
}
function getCubeTarget(gl, side) {
  switch (side) {
    case "nx":
      return gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
    case "ny":
      return gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
    case "nz":
      return gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
    case "px":
      return gl.TEXTURE_CUBE_MAP_POSITIVE_X;
    case "py":
      return gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
    case "pz":
      return gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
  }
}
function createCubeTexture(gl, faces, mipmaps, onload) {
  const target = gl.TEXTURE_CUBE_MAP;
  const filter4 = gl.LINEAR;
  const internalFormat = gl.RGBA;
  const format = gl.RGBA;
  const type = gl.UNSIGNED_BYTE;
  let size = 0;
  let texture = gl.createTexture();
  gl.bindTexture(target, texture);
  function load(cubeTarget, level, image, isReset) {
    if (size === 0)
      size = image.width;
    gl.bindTexture(target, texture);
    gl.texImage2D(cubeTarget, level, internalFormat, size, size, 0, format, type, null);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.bindTexture(target, texture);
    gl.texImage2D(cubeTarget, level, internalFormat, format, type, image);
    loadedCount += 1;
    if (loadedCount === 6) {
      if (!destroyed) {
        if (mipmaps) {
          gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
          gl.generateMipmap(target);
        } else {
          gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filter4);
        }
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filter4);
      }
      if (!isReset)
        onload === null || onload === void 0 ? void 0 : onload(destroyed);
    }
  }
  const facesData = [];
  let loadedCount = 0;
  objectForEach(faces, (source, side) => {
    if (!source)
      return;
    const level = 0;
    const cubeTarget = getCubeTarget(gl, side);
    const image = new Image();
    if (source instanceof File) {
      image.src = URL.createObjectURL(source);
    } else if (isPromiseLike(source)) {
      source.then((blob) => {
        image.src = URL.createObjectURL(blob);
      });
    } else {
      image.src = source;
    }
    facesData.push({ cubeTarget, level, image });
    image.addEventListener("load", () => {
      load(cubeTarget, level, image, false);
    });
    image.addEventListener("error", () => {
      onload === null || onload === void 0 ? void 0 : onload(true);
    });
  });
  let destroyed = false;
  return {
    id: getNextTextureId(),
    target,
    format,
    internalFormat,
    type,
    filter: filter4,
    getWidth: () => size,
    getHeight: () => size,
    getDepth: () => 0,
    getByteCount: () => {
      return getByteCount("rgba", "ubyte", size, size, 0) * 6 * (mipmaps ? 2 : 1);
    },
    define: () => {
    },
    load: () => {
    },
    mipmap: () => {
    },
    bind: (id) => {
      gl.activeTexture(gl.TEXTURE0 + id);
      gl.bindTexture(target, texture);
    },
    unbind: (id) => {
      gl.activeTexture(gl.TEXTURE0 + id);
      gl.bindTexture(target, null);
    },
    attachFramebuffer: () => {
    },
    detachFramebuffer: () => {
    },
    reset: () => {
      texture = getTexture(gl);
      gl.bindTexture(target, texture);
      loadedCount = 0;
      for (const { cubeTarget, level, image } of facesData) {
        load(cubeTarget, level, image, true);
      }
    },
    destroy: () => {
      if (destroyed)
        return;
      gl.deleteTexture(texture);
      destroyed = true;
    }
  };
}
var NullTextureFormat = -1;
function isNullTexture(texture) {
  return texture.format === NullTextureFormat;
}
function createNullTexture(gl) {
  var _a;
  const target = (_a = gl === null || gl === void 0 ? void 0 : gl.TEXTURE_2D) !== null && _a !== void 0 ? _a : 3553;
  return {
    id: getNextTextureId(),
    target,
    format: NullTextureFormat,
    internalFormat: 0,
    type: 0,
    filter: 0,
    getWidth: () => 0,
    getHeight: () => 0,
    getDepth: () => 0,
    getByteCount: () => 0,
    define: () => {
    },
    load: () => {
    },
    mipmap: () => {
    },
    bind: (id) => {
      if (gl) {
        gl.activeTexture(gl.TEXTURE0 + id);
        gl.bindTexture(target, null);
      }
    },
    unbind: (id) => {
      if (gl) {
        gl.activeTexture(gl.TEXTURE0 + id);
        gl.bindTexture(target, null);
      }
    },
    attachFramebuffer: () => {
      throw new Error("cannot attach null-texture to a framebuffer");
    },
    detachFramebuffer: () => {
      throw new Error("cannot detach null-texture from a framebuffer");
    },
    reset: () => {
    },
    destroy: () => {
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/color-data.js
function createColors(locationIt, positionIt, colorTheme, colorData) {
  var _a;
  const data = _createColors(locationIt, positionIt, colorTheme, colorData);
  if (colorTheme.palette) {
    ValueCell.updateIfChanged(data.dUsePalette, true);
    const [min3, max3] = colorTheme.palette.domain || [0, 1];
    ValueCell.update(data.uPaletteDomain, Vec2.set(data.uPaletteDomain.ref.value, min3, max3));
    ValueCell.update(data.uPaletteDefault, Color.toVec3Normalized(data.uPaletteDefault.ref.value, (_a = colorTheme.palette.defaultColor) !== null && _a !== void 0 ? _a : Color(13421772)));
    updatePaletteTexture(colorTheme.palette, data.tPalette);
  } else {
    ValueCell.updateIfChanged(data.dUsePalette, false);
  }
  return data;
}
function _createColors(locationIt, positionIt, colorTheme, colorData) {
  switch (colorTheme.granularity) {
    case "uniform":
      return createUniformColor(locationIt, colorTheme.color, colorData);
    case "instance":
      return locationIt.nonInstanceable ? createGroupColor(locationIt, colorTheme.color, colorData) : createInstanceColor(locationIt, colorTheme.color, colorData);
    case "group":
      return createGroupColor(locationIt, colorTheme.color, colorData);
    case "groupInstance":
      return createGroupInstanceColor(locationIt, colorTheme.color, colorData);
    case "vertex":
      return createVertexColor(positionIt, colorTheme.color, colorData);
    case "vertexInstance":
      return createVertexInstanceColor(positionIt, colorTheme.color, colorData);
    case "volume":
      return createGridColor(colorTheme.grid, "volume", colorData);
    case "volumeInstance":
      return createGridColor(colorTheme.grid, "volumeInstance", colorData);
    case "direct":
      return createDirectColor(colorData);
  }
}
function updatePaletteTexture(palette, cell) {
  let isSynced = true;
  const texture = cell.ref.value;
  if (palette.colors.length !== texture.width || texture.filter !== palette.filter) {
    isSynced = false;
  } else {
    const data = texture.array;
    let o2 = 0;
    for (const c5 of palette.colors) {
      const [r, g, b5] = Color.toRgb(c5);
      if (data[o2++] !== r || data[o2++] !== g || data[o2++] !== b5) {
        isSynced = false;
        break;
      }
    }
  }
  if (isSynced)
    return;
  const array = new Uint8Array(palette.colors.length * 3);
  let o = 0;
  for (const c5 of palette.colors) {
    const [r, g, b5] = Color.toRgb(c5);
    array[o++] = r;
    array[o++] = g;
    array[o++] = b5;
  }
  ValueCell.update(cell, { array, height: 1, width: palette.colors.length, filter: palette.filter });
}
function createValueColor(value, colorData) {
  if (colorData) {
    ValueCell.update(colorData.uColor, Color.toVec3Normalized(colorData.uColor.ref.value, value));
    ValueCell.updateIfChanged(colorData.dColorType, "uniform");
    return colorData;
  } else {
    return {
      uColor: ValueCell.create(Color.toVec3Normalized(Vec3(), value)),
      tColor: ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
      tColorGrid: ValueCell.create(createNullTexture()),
      uPaletteDomain: ValueCell.create(Vec2.create(0, 1)),
      uPaletteDefault: ValueCell.create(Vec3()),
      tPalette: ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
      uColorTexDim: ValueCell.create(Vec2.create(1, 1)),
      uColorGridDim: ValueCell.create(Vec3.create(1, 1, 1)),
      uColorGridTransform: ValueCell.create(Vec4.create(0, 0, 0, 1)),
      dColorType: ValueCell.create("uniform"),
      dUsePalette: ValueCell.create(false)
    };
  }
}
function createUniformColor(locationIt, color, colorData) {
  return createValueColor(color(NullLocation, false), colorData);
}
function createTextureColor(colors, type, colorData) {
  if (colorData) {
    ValueCell.update(colorData.tColor, colors);
    ValueCell.update(colorData.uColorTexDim, Vec2.create(colors.width, colors.height));
    ValueCell.updateIfChanged(colorData.dColorType, type);
    return colorData;
  } else {
    return {
      uColor: ValueCell.create(Vec3()),
      tColor: ValueCell.create(colors),
      tColorGrid: ValueCell.create(createNullTexture()),
      uPaletteDomain: ValueCell.create(Vec2.create(0, 1)),
      uPaletteDefault: ValueCell.create(Vec3()),
      tPalette: ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
      uColorTexDim: ValueCell.create(Vec2.create(colors.width, colors.height)),
      uColorGridDim: ValueCell.create(Vec3.create(1, 1, 1)),
      uColorGridTransform: ValueCell.create(Vec4.create(0, 0, 0, 1)),
      dColorType: ValueCell.create(type),
      dUsePalette: ValueCell.create(false)
    };
  }
}
function createInstanceColor(locationIt, color, colorData) {
  const { instanceCount } = locationIt;
  const colors = createTextureImage(Math.max(1, instanceCount), 3, Uint8Array, colorData && colorData.tColor.ref.value.array);
  locationIt.reset();
  while (locationIt.hasNext) {
    const { location, isSecondary, instanceIndex } = locationIt.move();
    Color.toArray(color(location, isSecondary), colors.array, instanceIndex * 3);
    locationIt.skipInstance();
  }
  return createTextureColor(colors, "instance", colorData);
}
function createGroupColor(locationIt, color, colorData) {
  const { groupCount, hasLocation2 } = locationIt;
  const colors = createTextureImage(Math.max(1, groupCount * (hasLocation2 ? 2 : 1)), 3, Uint8Array, colorData && colorData.tColor.ref.value.array);
  locationIt.reset();
  const indexMultiplier = hasLocation2 ? 6 : 3;
  while (locationIt.hasNext && !locationIt.isNextNewInstance) {
    const { location, location2, isSecondary, groupIndex } = locationIt.move();
    Color.toArray(color(location, isSecondary), colors.array, groupIndex * indexMultiplier);
    if (hasLocation2)
      Color.toArray(color(location2, isSecondary), colors.array, groupIndex * indexMultiplier + 3);
  }
  return createTextureColor(colors, "group", colorData);
}
function createGroupInstanceColor(locationIt, color, colorData) {
  const { groupCount, instanceCount, hasLocation2 } = locationIt;
  const count3 = instanceCount * groupCount * (hasLocation2 ? 2 : 1);
  const colors = createTextureImage(Math.max(1, count3), 3, Uint8Array, colorData && colorData.tColor.ref.value.array);
  locationIt.reset();
  const indexMultiplier = hasLocation2 ? 6 : 3;
  while (locationIt.hasNext) {
    const { location, location2, isSecondary, index } = locationIt.move();
    Color.toArray(color(location, isSecondary), colors.array, index * indexMultiplier);
    if (hasLocation2)
      Color.toArray(color(location2, isSecondary), colors.array, index * indexMultiplier + 3);
  }
  return createTextureColor(colors, "groupInstance", colorData);
}
function createVertexColor(locationIt, color, colorData) {
  const { groupCount, stride } = locationIt;
  const colors = createTextureImage(Math.max(1, groupCount), 3, Uint8Array, colorData && colorData.tColor.ref.value.array);
  locationIt.reset();
  locationIt.voidInstances();
  while (locationIt.hasNext && !locationIt.isNextNewInstance) {
    const { location, isSecondary, groupIndex } = locationIt.move();
    const c5 = color(location, isSecondary);
    for (let i = 0; i < stride; ++i) {
      Color.toArray(c5, colors.array, (groupIndex + i) * 3);
    }
  }
  return createTextureColor(colors, "vertex", colorData);
}
function createVertexInstanceColor(locationIt, color, colorData) {
  const { groupCount, instanceCount, stride } = locationIt;
  const count3 = instanceCount * groupCount;
  const colors = createTextureImage(Math.max(1, count3), 3, Uint8Array, colorData && colorData.tColor.ref.value.array);
  locationIt.reset();
  while (locationIt.hasNext) {
    const { location, isSecondary, index } = locationIt.move();
    const c5 = color(location, isSecondary);
    for (let i = 0; i < stride; ++i) {
      Color.toArray(c5, colors.array, (index + i) * 3);
    }
  }
  return createTextureColor(colors, "vertexInstance", colorData);
}
function createGridColor(grid, type, colorData) {
  const { colors, dimension, transform } = grid;
  const width = colors.getWidth();
  const height = colors.getHeight();
  if (colorData) {
    ValueCell.update(colorData.tColorGrid, colors);
    ValueCell.update(colorData.uColorTexDim, Vec2.create(width, height));
    ValueCell.update(colorData.uColorGridDim, Vec3.clone(dimension));
    ValueCell.update(colorData.uColorGridTransform, Vec4.clone(transform));
    ValueCell.updateIfChanged(colorData.dColorType, type);
    return colorData;
  } else {
    return {
      uColor: ValueCell.create(Vec3()),
      tColor: ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
      tColorGrid: ValueCell.create(colors),
      uPaletteDomain: ValueCell.create(Vec2.create(0, 1)),
      uPaletteDefault: ValueCell.create(Vec3()),
      tPalette: ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
      uColorTexDim: ValueCell.create(Vec2.create(width, height)),
      uColorGridDim: ValueCell.create(Vec3.clone(dimension)),
      uColorGridTransform: ValueCell.create(Vec4.clone(transform)),
      dColorType: ValueCell.create(type),
      dUsePalette: ValueCell.create(false)
    };
  }
}
function createDirectColor(colorData) {
  if (colorData) {
    ValueCell.updateIfChanged(colorData.dColorType, "direct");
    return colorData;
  } else {
    return {
      uColor: ValueCell.create(Vec3()),
      tColor: ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
      tColorGrid: ValueCell.create(createNullTexture()),
      uPaletteDomain: ValueCell.create(Vec2.create(0, 1)),
      uPaletteDefault: ValueCell.create(Vec3()),
      tPalette: ValueCell.create({ array: new Uint8Array(3), width: 1, height: 1 }),
      uColorTexDim: ValueCell.create(Vec2.create(1, 1)),
      uColorGridDim: ValueCell.create(Vec3.create(1, 1, 1)),
      uColorGridTransform: ValueCell.create(Vec4.create(0, 0, 0, 1)),
      dColorType: ValueCell.create("direct"),
      dUsePalette: ValueCell.create(false)
    };
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/instance-grid.js
var v3transformMat4Offset2 = Vec3.transformMat4Offset;
var v3fromArray2 = Vec3.fromArray;
var b3add = Box3D.add;
function createEmptyInstanceGrid() {
  return {
    cellSize: 0,
    cellCount: 0,
    cellOffsets: new Uint32Array(),
    cellSpheres: new Float32Array(),
    cellTransform: new Float32Array(),
    cellInstance: new Float32Array(),
    batchSize: 0,
    batchCount: 0,
    batchOffsets: new Uint32Array(),
    batchSpheres: new Float32Array(),
    batchCell: new Uint32Array()
  };
}
function calcInstanceGrid(instanceData, cellSize, batchSize) {
  const bottomGrid = calcBottomGrid(instanceData, cellSize);
  const topGrid = calcTopGrid(bottomGrid, batchSize);
  const cellOffsets = new Uint32Array(bottomGrid.cellOffsets.length);
  const cellSpheres = new Float32Array(bottomGrid.cellSpheres.length);
  const cellInstance = new Float32Array(bottomGrid.cellInstance.length);
  let offset = 0;
  for (let i = 0, il = topGrid.batchCell.length; i < il; ++i) {
    const cellIdx = topGrid.batchCell[i];
    const start = bottomGrid.cellOffsets[cellIdx];
    const end = bottomGrid.cellOffsets[cellIdx + 1];
    const count3 = end - start;
    cellOffsets[i + 1] = cellOffsets[i] + count3;
    for (let j = 0; j < 4; ++j) {
      cellSpheres[i * 4 + j] = bottomGrid.cellSpheres[cellIdx * 4 + j];
    }
    for (let j = 0; j < count3; ++j) {
      const idx = start + j;
      const id = bottomGrid.cellInstance[idx];
      for (let k = 0; k < 16; ++k) {
        bottomGrid.cellTransform[offset * 16 + k] = instanceData.transform[id * 16 + k];
      }
      cellInstance[offset] = id;
      offset += 1;
    }
  }
  const instanceGrid = {
    cellSize: bottomGrid.cellSize,
    cellCount: bottomGrid.cellCount,
    cellOffsets,
    cellSpheres,
    cellTransform: bottomGrid.cellTransform,
    cellInstance,
    batchSize: topGrid.batchSize,
    batchCount: topGrid.batchCount,
    batchOffsets: topGrid.batchOffsets,
    batchSpheres: topGrid.batchSpheres,
    batchCell: fillSerial(topGrid.batchCell)
  };
  return instanceGrid;
}
function calcBottomGrid(instanceData, cellSize) {
  const { instanceCount, instance, transform, invariantBoundingSphere } = instanceData;
  const x = new Float32Array(instanceCount);
  const y = new Float32Array(instanceCount);
  const z = new Float32Array(instanceCount);
  const indices2 = OrderedSet.ofBounds(0, instanceCount);
  const box2 = Box3D.setEmpty(Box3D());
  const { center, radius } = invariantBoundingSphere;
  const rv = Vec3.create(radius, radius, radius);
  const v3 = Vec3();
  for (let i = 0; i < instanceCount; ++i) {
    v3transformMat4Offset2(v3, center, transform, 0, 0, i * 16);
    x[i] = v3[0];
    y[i] = v3[1];
    z[i] = v3[2];
    b3add(box2, v3);
  }
  Box3D.expand(box2, box2, rv);
  const positionData = { x, y, z, indices: indices2 };
  const boundary = { box: box2, sphere: Sphere3D.fromBox3D(Sphere3D(), box2) };
  const lookup = GridLookup3D(positionData, boundary, Vec3.create(cellSize, cellSize, cellSize));
  const { array, offset, count: count3 } = lookup.buckets;
  const cellCount = offset.length;
  const cellOffsets = new Uint32Array(cellCount + 1);
  const cellSpheres = new Float32Array(cellCount * 4);
  const cellTransform = new Float32Array(instanceCount * 16);
  const cellInstance = new Float32Array(instanceCount);
  const b5 = Box3D();
  const s = Sphere3D();
  let k = 0;
  for (let i = 0; i < cellCount; ++i) {
    const start = offset[i];
    const size = count3[i];
    cellOffsets[i] = start;
    const kStart = k;
    for (let j = start, jl = start + size; j < jl; ++j) {
      const idx = array[j];
      cellInstance[k] = instance[idx];
      for (let l = 0; l < 16; ++l) {
        cellTransform[k * 16 + l] = transform[idx * 16 + l];
      }
      k += 1;
    }
    if (size === 1) {
      v3transformMat4Offset2(cellSpheres, center, cellTransform, i * 4, 0, kStart * 16);
      cellSpheres[i * 4 + 3] = radius;
    } else {
      Box3D.setEmpty(b5);
      const o = kStart * 16;
      for (let l = 0; l < size; ++l) {
        v3transformMat4Offset2(v3, center, cellTransform, 0, 0, l * 16 + o);
        b3add(b5, v3);
      }
      Box3D.expand(b5, b5, rv);
      Sphere3D.fromBox3D(s, b5);
      Sphere3D.toArray(s, cellSpheres, i * 4);
    }
  }
  cellOffsets[cellCount] = offset[cellCount - 1] + count3[cellCount - 1];
  return {
    cellSize,
    cellCount,
    cellOffsets,
    cellSpheres,
    cellTransform,
    cellInstance
  };
}
function calcTopGrid(bottomGrid, batchSize) {
  const { cellCount, cellSpheres } = bottomGrid;
  const x = new Float32Array(cellCount);
  const y = new Float32Array(cellCount);
  const z = new Float32Array(cellCount);
  const indices2 = OrderedSet.ofBounds(0, cellCount);
  const box2 = Box3D.setEmpty(Box3D());
  const v3 = Vec3();
  let maxRadius = 0;
  for (let i = 0; i < cellCount; ++i) {
    const i4 = i * 4;
    v3fromArray2(v3, cellSpheres, i4);
    x[i] = v3[0];
    y[i] = v3[1];
    z[i] = v3[2];
    b3add(box2, v3);
    maxRadius = Math.max(maxRadius, cellSpheres[i4 + 3]);
  }
  const rv = Vec3.create(maxRadius, maxRadius, maxRadius);
  Box3D.expand(box2, box2, rv);
  const positionData = { x, y, z, indices: indices2 };
  const boundary = { box: box2, sphere: Sphere3D.fromBox3D(Sphere3D(), box2) };
  const lookup = GridLookup3D(positionData, boundary, Vec3.create(batchSize, batchSize, batchSize));
  const { array, offset, count: count3 } = lookup.buckets;
  const batchCount = offset.length;
  const batchOffsets = new Uint32Array(batchCount + 1);
  const batchSpheres = new Float32Array(batchCount * 4);
  const batchCell = new Uint32Array(cellCount);
  const b5 = Box3D();
  const s = Sphere3D();
  let k = 0;
  for (let i = 0; i < batchCount; ++i) {
    const start = offset[i];
    const size = count3[i];
    batchOffsets[i] = start;
    for (let j = start, jl = start + size; j < jl; ++j) {
      batchCell[k] = array[j];
      k += 1;
    }
    if (size === 1) {
      const l = array[start];
      batchSpheres[i * 4] = cellSpheres[l * 4];
      batchSpheres[i * 4 + 1] = cellSpheres[l * 4 + 1];
      batchSpheres[i * 4 + 2] = cellSpheres[l * 4 + 2];
      batchSpheres[i * 4 + 3] = cellSpheres[l * 4 + 3];
    } else {
      Box3D.setEmpty(b5);
      maxRadius = 0;
      for (let j = start, jl = start + size; j < jl; ++j) {
        const l = array[j];
        v3[0] = cellSpheres[l * 4];
        v3[1] = cellSpheres[l * 4 + 1];
        v3[2] = cellSpheres[l * 4 + 2];
        b3add(b5, v3);
        maxRadius = Math.max(maxRadius, cellSpheres[l * 4 + 3]);
      }
      Vec3.set(rv, maxRadius, maxRadius, maxRadius);
      Box3D.expand(b5, b5, rv);
      Sphere3D.fromBox3D(s, b5);
      Sphere3D.toArray(s, batchSpheres, i * 4);
    }
  }
  batchOffsets[batchCount] = offset[batchCount - 1] + count3[batchCount - 1];
  return {
    batchSize,
    batchCount,
    batchOffsets,
    batchSpheres,
    batchCell
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/transform-data.js
var _m3 = Mat3();
var _m4 = Mat4();
function checkReflection(transformArray, instanceCount) {
  for (let i = 0; i < instanceCount; i++) {
    Mat3.fromMat4(_m3, Mat4.fromArray(_m4, transformArray, i * 16));
    if (Mat3.determinant(_m3) < 0)
      return true;
  }
  return false;
}
function createTransform(transformArray, instanceCount, invariantBoundingSphere, cellSize, batchSize, transformData) {
  const hasReflection = checkReflection(transformArray, instanceCount);
  if (transformData) {
    ValueCell.update(transformData.matrix, transformData.matrix.ref.value);
    const transform = transformData.transform.ref.value.length >= instanceCount * 16 ? transformData.transform.ref.value : new Float32Array(instanceCount * 16);
    transform.set(transformArray);
    ValueCell.update(transformData.transform, transform);
    ValueCell.updateIfChanged(transformData.uInstanceCount, instanceCount);
    ValueCell.updateIfChanged(transformData.instanceCount, instanceCount);
    const aTransform = transformData.aTransform.ref.value.length >= instanceCount * 16 ? transformData.aTransform.ref.value : new Float32Array(instanceCount * 16);
    ValueCell.update(transformData.aTransform, aTransform);
    const extraTransform = transformData.extraTransform.ref.value.length >= instanceCount * 16 ? transformData.extraTransform.ref.value : new Float32Array(instanceCount * 16);
    ValueCell.update(transformData.extraTransform, fillIdentityTransform(extraTransform, instanceCount));
    const aInstance = transformData.aInstance.ref.value.length >= instanceCount ? transformData.aInstance.ref.value : new Float32Array(instanceCount);
    ValueCell.update(transformData.aInstance, fillSerial(aInstance, instanceCount));
    ValueCell.update(transformData.hasReflection, hasReflection);
  } else {
    transformData = {
      aTransform: ValueCell.create(new Float32Array(instanceCount * 16)),
      matrix: ValueCell.create(Mat4.identity()),
      transform: ValueCell.create(new Float32Array(transformArray)),
      extraTransform: ValueCell.create(fillIdentityTransform(new Float32Array(instanceCount * 16), instanceCount)),
      uInstanceCount: ValueCell.create(instanceCount),
      instanceCount: ValueCell.create(instanceCount),
      aInstance: ValueCell.create(fillSerial(new Float32Array(instanceCount))),
      hasReflection: ValueCell.create(hasReflection),
      instanceGrid: ValueCell.create(createEmptyInstanceGrid())
    };
  }
  updateTransformData(transformData, invariantBoundingSphere, cellSize, batchSize);
  return transformData;
}
var identityTransform = new Float32Array(16);
Mat4.toArray(Mat4.identity(), identityTransform, 0);
function createIdentityTransform(transformData) {
  return createTransform(new Float32Array(identityTransform), 1, void 0, 0, 0, transformData);
}
function fillIdentityTransform(transform, count3) {
  for (let i = 0; i < count3; i++) {
    transform.set(identityTransform, i * 16);
  }
  return transform;
}
function updateTransformData(transformData, invariantBoundingSphere, cellSize, batchSize) {
  const aTransform = transformData.aTransform.ref.value;
  const aInstance = transformData.aInstance.ref.value;
  const instanceCount = transformData.instanceCount.ref.value;
  const matrix = transformData.matrix.ref.value;
  const transform = transformData.transform.ref.value;
  const extraTransform = transformData.extraTransform.ref.value;
  for (let i = 0; i < instanceCount; i++) {
    const i16 = i * 16;
    Mat4.mulOffset(aTransform, extraTransform, transform, i16, i16, i16);
    Mat4.mulOffset(aTransform, matrix, aTransform, i16, 0, i16);
    aInstance[i] = i;
  }
  if (invariantBoundingSphere && instanceCount > 0) {
    const instanceGrid = calcInstanceGrid({
      instanceCount,
      instance: aInstance,
      transform: aTransform,
      invariantBoundingSphere
    }, cellSize, batchSize);
    ValueCell.update(transformData.instanceGrid, instanceGrid);
    ValueCell.update(transformData.aInstance, instanceGrid.cellInstance);
    ValueCell.update(transformData.aTransform, instanceGrid.cellTransform);
  } else {
    ValueCell.update(transformData.aInstance, aInstance);
    ValueCell.update(transformData.aTransform, aTransform);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/categories.js
var ColorThemeCategory = {
  Atom: "Atom Property",
  Chain: "Chain Property",
  Residue: "Residue Property",
  Symmetry: "Symmetry",
  Validation: "Validation",
  Misc: "Miscellaneous"
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/uniform.js
var DefaultColor = Color(13421772);
var Description = "Gives everything the same, uniform color.";
var UniformColorThemeParams = {
  value: ParamDefinition.Color(DefaultColor),
  saturation: ParamDefinition.Numeric(0, { min: -6, max: 6, step: 0.1 }),
  lightness: ParamDefinition.Numeric(0, { min: -6, max: 6, step: 0.1 })
};
function getUniformColorThemeParams(ctx) {
  return UniformColorThemeParams;
}
function UniformColorTheme(ctx, props) {
  let color = defaults(props.value, DefaultColor);
  color = Color.saturate(color, props.saturation);
  color = Color.lighten(color, props.lightness);
  return {
    factory: UniformColorTheme,
    granularity: "uniform",
    color: () => color,
    props,
    description: Description,
    legend: TableLegend([["uniform", color]])
  };
}
var UniformColorThemeProvider = {
  name: "uniform",
  label: "Uniform",
  category: ColorThemeCategory.Misc,
  factory: UniformColorTheme,
  getParams: getUniformColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(UniformColorThemeParams),
  isApplicable: (ctx) => true
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/size/uniform.js
var Description2 = "Gives everything the same, uniform size.";
var UniformSizeThemeParams = {
  value: ParamDefinition.Numeric(1, { min: 0, max: 20, step: 0.1 })
};
function getUniformSizeThemeParams(ctx) {
  return UniformSizeThemeParams;
}
function UniformSizeTheme(ctx, props) {
  const size = props.value;
  return {
    factory: UniformSizeTheme,
    granularity: "uniform",
    size: () => size,
    props,
    description: Description2
  };
}
var UniformSizeThemeProvider = {
  name: "uniform",
  label: "Uniform",
  category: "",
  factory: UniformSizeTheme,
  getParams: getUniformSizeThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(UniformSizeThemeParams),
  isApplicable: (ctx) => true
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/material.js
function Material(values2) {
  return { ...Material.Zero, ...values2 };
}
(function(Material2) {
  Material2.Zero = { metalness: 0, roughness: 0, bumpiness: 0 };
  function toArray3(material, array, offset) {
    array[offset] = material.metalness * 255;
    array[offset + 1] = material.roughness * 255;
    array[offset + 2] = material.bumpiness * 255;
    return array;
  }
  Material2.toArray = toArray3;
  function toString5({ metalness, roughness, bumpiness }) {
    return `M ${metalness.toFixed(2)} | R ${roughness.toFixed(2)} | B ${bumpiness.toFixed(2)}`;
  }
  Material2.toString = toString5;
  function getParam(info) {
    return ParamDefinition.Group({
      metalness: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.01 }),
      roughness: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.01 }),
      bumpiness: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.01 })
    }, {
      ...info,
      presets: [
        [{ metalness: 0, roughness: 1, bumpiness: 0 }, "Matte"],
        [{ metalness: 0, roughness: 0.2, bumpiness: 0 }, "Plastic"],
        [{ metalness: 0, roughness: 0.6, bumpiness: 0 }, "Glossy"],
        [{ metalness: 1, roughness: 0.6, bumpiness: 0 }, "Metallic"]
      ]
    });
  }
  Material2.getParam = getParam;
})(Material || (Material = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/clip.js
function Clip() {
}
(function(Clip2) {
  Clip2.Type = {
    none: 0,
    // to switch clipping off
    plane: 1,
    sphere: 2,
    cube: 3,
    cylinder: 4,
    infiniteCone: 5
  };
  Clip2.Params = {
    variant: ParamDefinition.Select("pixel", ParamDefinition.arrayToOptions(["instance", "pixel"])),
    objects: ParamDefinition.ObjectList({
      type: ParamDefinition.Select("plane", ParamDefinition.objectToOptions(Clip2.Type, (t2) => stringToWords(t2))),
      invert: ParamDefinition.Boolean(false),
      position: ParamDefinition.Vec3(Vec3()),
      rotation: ParamDefinition.Group({
        axis: ParamDefinition.Vec3(Vec3.create(1, 0, 0)),
        angle: ParamDefinition.Numeric(0, { min: -180, max: 180, step: 1 }, { description: "Angle in Degrees" })
      }, { isExpanded: true }),
      scale: ParamDefinition.Vec3(Vec3.create(1, 1, 1)),
      transform: ParamDefinition.Mat4(Mat4.identity())
    }, (o) => stringToWords(o.type))
  };
  function createClipObjects(count3) {
    return {
      count: 0,
      type: new Array(count3).fill(1),
      invert: new Array(count3).fill(false),
      position: new Array(count3 * 3).fill(0),
      rotation: new Array(count3 * 4).fill(0),
      scale: new Array(count3 * 3).fill(1),
      transform: new Array(count3 * 16).fill(0)
    };
  }
  const qA = Quat();
  const qB = Quat();
  const vA = Vec3();
  const vB = Vec3();
  const mA = Mat4();
  const mB = Mat4();
  function getClip(props, clip) {
    const count3 = props.objects.length;
    const { type, invert, position, rotation, scale, transform } = (clip === null || clip === void 0 ? void 0 : clip.objects) || createClipObjects(count3);
    for (let i = 0; i < count3; ++i) {
      const p = props.objects[i];
      type[i] = Clip2.Type[p.type];
      invert[i] = p.invert;
      Vec3.toArray(p.position, position, i * 3);
      Quat.toArray(Quat.setAxisAngle(qA, p.rotation.axis, degToRad(p.rotation.angle)), rotation, i * 4);
      Vec3.toArray(p.scale, scale, i * 3);
      Mat4.toArray(p.transform, transform, i * 16);
    }
    return {
      variant: props.variant,
      objects: { count: count3, type, invert, position, rotation, scale, transform }
    };
  }
  Clip2.getClip = getClip;
  function areEqual(cA, cB) {
    if (cA.variant !== cB.variant)
      return false;
    if (cA.objects.count !== cB.objects.count)
      return false;
    const oA = cA.objects, oB = cB.objects;
    for (let i = 0, il = oA.count; i < il; ++i) {
      if (oA.invert[i] !== oB.invert[i])
        return false;
      if (oA.type[i] !== oB.type[i])
        return false;
      Vec3.fromArray(vA, oA.position, i * 3);
      Vec3.fromArray(vB, oB.position, i * 3);
      if (!Vec3.equals(vA, vB))
        return false;
      Vec3.fromArray(vA, oA.scale, i * 3);
      Vec3.fromArray(vB, oB.scale, i * 3);
      if (!Vec3.equals(vA, vB))
        return false;
      Quat.fromArray(qA, oA.rotation, i * 4);
      Quat.fromArray(qB, oB.rotation, i * 4);
      if (!Quat.equals(qA, qB))
        return false;
      Mat4.fromArray(mA, oA.transform, i * 16);
      Mat4.fromArray(mB, oB.transform, i * 16);
      if (!Mat4.areEqual(mA, mB, EPSILON))
        return false;
    }
    return true;
  }
  Clip2.areEqual = areEqual;
})(Clip || (Clip = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/base.js
var VisualQualityInfo = {
  "custom": {},
  "auto": {},
  "highest": {},
  "higher": {},
  "high": {},
  "medium": {},
  "low": {},
  "lower": {},
  "lowest": {}
};
var VisualQualityNames = Object.keys(VisualQualityInfo);
var VisualQualityOptions = ParamDefinition.arrayToOptions(VisualQualityNames);
var ColorSmoothingParams = {
  smoothColors: ParamDefinition.MappedStatic("auto", {
    auto: ParamDefinition.Group({}),
    on: ParamDefinition.Group({
      resolutionFactor: ParamDefinition.Numeric(2, { min: 0.5, max: 6, step: 0.1 }),
      sampleStride: ParamDefinition.Numeric(3, { min: 1, max: 12, step: 1 })
    }),
    off: ParamDefinition.Group({})
  })
};
function hasColorSmoothingProp(props) {
  return !!props.smoothColors;
}
function getColorSmoothingProps(smoothColors, preferSmoothing, resolution) {
  if ((smoothColors.name === "on" || smoothColors.name === "auto" && preferSmoothing) && resolution && resolution < 3) {
    let stride = 3;
    if (smoothColors.name === "on") {
      resolution *= smoothColors.params.resolutionFactor;
      stride = smoothColors.params.sampleStride;
    } else {
      resolution *= 2 - smoothstep(0, 1.1, resolution);
      resolution = Math.max(0.5, resolution);
      if (resolution > 1.2)
        stride = 2;
    }
    return { resolution, stride };
  }
  ;
}
var BaseGeometry;
(function(BaseGeometry2) {
  BaseGeometry2.MaterialCategory = { category: "Material" };
  BaseGeometry2.ShadingCategory = { category: "Shading" };
  BaseGeometry2.CullingLodCategory = { category: "Culling & LOD" };
  BaseGeometry2.CustomQualityParamInfo = {
    category: "Custom Quality",
    hideIf: (params) => typeof params.quality !== "undefined" && params.quality !== "custom"
  };
  BaseGeometry2.Params = {
    alpha: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.01 }, { label: "Opacity", isEssential: true, description: "How opaque/transparent the representation is rendered." }),
    quality: ParamDefinition.Select("auto", VisualQualityOptions, { isEssential: true, description: "Visual/rendering quality of the representation." }),
    material: Material.getParam(),
    clip: ParamDefinition.Group(Clip.Params),
    emissive: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.01 }),
    density: ParamDefinition.Numeric(0.2, { min: 0, max: 1, step: 0.01 }, { description: "Density value to estimate object thickness." }),
    instanceGranularity: ParamDefinition.Boolean(false, { description: "Use instance granularity for marker, transparency, clipping, overpaint, substance data to save memory." }),
    lod: ParamDefinition.Vec3(Vec3(), void 0, { ...BaseGeometry2.CullingLodCategory, description: "Level of detail.", fieldLabels: { x: "Min Distance", y: "Max Distance", z: "Overlap (Shader)" } }),
    cellSize: ParamDefinition.Numeric(200, { min: 0, max: 5e3, step: 100 }, { ...BaseGeometry2.CullingLodCategory, description: "Instance grid cell size." }),
    batchSize: ParamDefinition.Numeric(2e3, { min: 0, max: 5e4, step: 500 }, { ...BaseGeometry2.CullingLodCategory, description: "Instance grid batch size." })
  };
  function createSimple(colorValue = ColorNames.grey, sizeValue = 1, transform) {
    if (!transform)
      transform = createIdentityTransform();
    const locationIterator = LocationIterator(1, transform.instanceCount.ref.value, 1, () => NullLocation, false, () => false);
    const theme = {
      color: UniformColorTheme({}, { value: colorValue, lightness: 0, saturation: 0 }),
      size: UniformSizeTheme({}, { value: sizeValue })
    };
    return { transform, locationIterator, theme };
  }
  BaseGeometry2.createSimple = createSimple;
  function createValues(props, counts) {
    const clip = Clip.getClip(props.clip);
    return {
      alpha: ValueCell.create(props.alpha),
      uAlpha: ValueCell.create(props.alpha),
      uVertexCount: ValueCell.create(counts.vertexCount),
      uGroupCount: ValueCell.create(counts.groupCount),
      drawCount: ValueCell.create(counts.drawCount),
      uMetalness: ValueCell.create(props.material.metalness),
      uRoughness: ValueCell.create(props.material.roughness),
      uBumpiness: ValueCell.create(props.material.bumpiness),
      uEmissive: ValueCell.create(props.emissive),
      uDensity: ValueCell.create(props.density),
      dLightCount: ValueCell.create(1),
      dColorMarker: ValueCell.create(true),
      dClipObjectCount: ValueCell.create(clip.objects.count),
      dClipVariant: ValueCell.create(clip.variant),
      uClipObjectType: ValueCell.create(clip.objects.type),
      uClipObjectInvert: ValueCell.create(clip.objects.invert),
      uClipObjectPosition: ValueCell.create(clip.objects.position),
      uClipObjectRotation: ValueCell.create(clip.objects.rotation),
      uClipObjectScale: ValueCell.create(clip.objects.scale),
      uClipObjectTransform: ValueCell.create(clip.objects.transform),
      instanceGranularity: ValueCell.create(props.instanceGranularity),
      uLod: ValueCell.create(Vec4.create(props.lod[0], props.lod[1], props.lod[2], 0))
    };
  }
  BaseGeometry2.createValues = createValues;
  function updateValues(values2, props) {
    ValueCell.updateIfChanged(values2.alpha, props.alpha);
    ValueCell.updateIfChanged(values2.uMetalness, props.material.metalness);
    ValueCell.updateIfChanged(values2.uRoughness, props.material.roughness);
    ValueCell.updateIfChanged(values2.uBumpiness, props.material.bumpiness);
    ValueCell.updateIfChanged(values2.uEmissive, props.emissive);
    ValueCell.updateIfChanged(values2.uDensity, props.density);
    const clip = Clip.getClip(props.clip);
    ValueCell.updateIfChanged(values2.dClipObjectCount, clip.objects.count);
    ValueCell.updateIfChanged(values2.dClipVariant, clip.variant);
    ValueCell.update(values2.uClipObjectType, clip.objects.type);
    ValueCell.update(values2.uClipObjectInvert, clip.objects.invert);
    ValueCell.update(values2.uClipObjectPosition, clip.objects.position);
    ValueCell.update(values2.uClipObjectRotation, clip.objects.rotation);
    ValueCell.update(values2.uClipObjectScale, clip.objects.scale);
    ValueCell.update(values2.uClipObjectTransform, clip.objects.transform);
    ValueCell.updateIfChanged(values2.instanceGranularity, props.instanceGranularity);
    ValueCell.update(values2.uLod, Vec4.set(values2.uLod.ref.value, props.lod[0], props.lod[1], props.lod[2], 0));
  }
  BaseGeometry2.updateValues = updateValues;
  function createRenderableState(props = {}) {
    const opaque = props.alpha === void 0 ? true : props.alpha === 1;
    return {
      disposed: false,
      visible: true,
      alphaFactor: 1,
      pickable: true,
      colorOnly: false,
      opaque,
      writeDepth: opaque
    };
  }
  BaseGeometry2.createRenderableState = createRenderableState;
  function updateRenderableState(state, props) {
    state.opaque = props.alpha * state.alphaFactor >= 1;
    state.writeDepth = state.opaque;
  }
  BaseGeometry2.updateRenderableState = updateRenderableState;
})(BaseGeometry || (BaseGeometry = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/overpaint-data.js
function applyOverpaintColor(array, start, end, color) {
  for (let i = start; i < end; ++i) {
    Color.toArray(color, array, i * 4);
    array[i * 4 + 3] = 255;
  }
  return true;
}
function clearOverpaint(array, start, end) {
  array.fill(0, start * 4, end * 4);
  return true;
}
function createOverpaint(count3, type, overpaintData) {
  const overpaint = createTextureImage(Math.max(1, count3), 4, Uint8Array, overpaintData && overpaintData.tOverpaint.ref.value.array);
  if (overpaintData) {
    ValueCell.update(overpaintData.tOverpaint, overpaint);
    ValueCell.update(overpaintData.uOverpaintTexDim, Vec2.create(overpaint.width, overpaint.height));
    ValueCell.updateIfChanged(overpaintData.dOverpaint, count3 > 0);
    ValueCell.updateIfChanged(overpaintData.dOverpaintType, type);
    return overpaintData;
  } else {
    return {
      tOverpaint: ValueCell.create(overpaint),
      uOverpaintTexDim: ValueCell.create(Vec2.create(overpaint.width, overpaint.height)),
      dOverpaint: ValueCell.create(count3 > 0),
      tOverpaintGrid: ValueCell.create(createNullTexture()),
      uOverpaintGridDim: ValueCell.create(Vec3.create(1, 1, 1)),
      uOverpaintGridTransform: ValueCell.create(Vec4.create(0, 0, 0, 1)),
      dOverpaintType: ValueCell.create(type),
      uOverpaintStrength: ValueCell.create(1)
    };
  }
}
var emptyOverpaintTexture = { array: new Uint8Array(4), width: 1, height: 1 };
function createEmptyOverpaint(overpaintData) {
  if (overpaintData) {
    ValueCell.update(overpaintData.tOverpaint, emptyOverpaintTexture);
    ValueCell.update(overpaintData.uOverpaintTexDim, Vec2.create(1, 1));
    return overpaintData;
  } else {
    return {
      tOverpaint: ValueCell.create(emptyOverpaintTexture),
      uOverpaintTexDim: ValueCell.create(Vec2.create(1, 1)),
      dOverpaint: ValueCell.create(false),
      tOverpaintGrid: ValueCell.create(createNullTexture()),
      uOverpaintGridDim: ValueCell.create(Vec3.create(1, 1, 1)),
      uOverpaintGridTransform: ValueCell.create(Vec4.create(0, 0, 0, 1)),
      dOverpaintType: ValueCell.create("groupInstance"),
      uOverpaintStrength: ValueCell.create(1)
    };
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/transparency-data.js
function applyTransparencyValue(array, start, end, value) {
  for (let i = start; i < end; ++i) {
    array[i] = value * 255;
  }
  return true;
}
function getTransparencyAverage(array, count3) {
  if (count3 === 0 || array.length < count3)
    return 0;
  let sum = 0;
  for (let i = 0; i < count3; ++i) {
    sum += array[i];
  }
  return sum / (255 * count3);
}
function getTransparencyMin(array, count3) {
  if (count3 === 0 || array.length < count3)
    return 1;
  let min3 = 255;
  for (let i = 0; i < count3; ++i) {
    if (array[i] > 0 && array[i] < min3)
      min3 = array[i];
  }
  return min3 / 255;
}
function clearTransparency(array, start, end) {
  array.fill(0, start, end);
}
function createTransparency(count3, type, transparencyData) {
  const transparency = createTextureImage(Math.max(1, count3), 1, Uint8Array, transparencyData && transparencyData.tTransparency.ref.value.array);
  if (transparencyData) {
    ValueCell.update(transparencyData.tTransparency, transparency);
    ValueCell.update(transparencyData.uTransparencyTexDim, Vec2.create(transparency.width, transparency.height));
    ValueCell.updateIfChanged(transparencyData.dTransparency, count3 > 0);
    ValueCell.updateIfChanged(transparencyData.transparencyAverage, getTransparencyAverage(transparency.array, count3));
    ValueCell.updateIfChanged(transparencyData.transparencyMin, getTransparencyMin(transparency.array, count3));
    ValueCell.updateIfChanged(transparencyData.dTransparencyType, type);
    return transparencyData;
  } else {
    return {
      tTransparency: ValueCell.create(transparency),
      uTransparencyTexDim: ValueCell.create(Vec2.create(transparency.width, transparency.height)),
      dTransparency: ValueCell.create(count3 > 0),
      transparencyAverage: ValueCell.create(0),
      transparencyMin: ValueCell.create(1),
      tTransparencyGrid: ValueCell.create(createNullTexture()),
      uTransparencyGridDim: ValueCell.create(Vec3.create(1, 1, 1)),
      uTransparencyGridTransform: ValueCell.create(Vec4.create(0, 0, 0, 1)),
      dTransparencyType: ValueCell.create(type),
      uTransparencyStrength: ValueCell.create(1)
    };
  }
}
var emptyTransparencyTexture = { array: new Uint8Array(1), width: 1, height: 1 };
function createEmptyTransparency(transparencyData) {
  if (transparencyData) {
    ValueCell.update(transparencyData.tTransparency, emptyTransparencyTexture);
    ValueCell.update(transparencyData.uTransparencyTexDim, Vec2.create(1, 1));
    return transparencyData;
  } else {
    return {
      tTransparency: ValueCell.create(emptyTransparencyTexture),
      uTransparencyTexDim: ValueCell.create(Vec2.create(1, 1)),
      dTransparency: ValueCell.create(false),
      transparencyAverage: ValueCell.create(0),
      transparencyMin: ValueCell.create(1),
      tTransparencyGrid: ValueCell.create(createNullTexture()),
      uTransparencyGridDim: ValueCell.create(Vec3.create(1, 1, 1)),
      uTransparencyGridTransform: ValueCell.create(Vec4.create(0, 0, 0, 1)),
      dTransparencyType: ValueCell.create("groupInstance"),
      uTransparencyStrength: ValueCell.create(1)
    };
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/clipping-data.js
function applyClippingGroups(array, start, end, groups) {
  array.fill(groups, start, end);
  return true;
}
function clearClipping(array, start, end) {
  array.fill(0, start, end);
}
function createClipping(count3, type, clippingData) {
  const clipping = createTextureImage(Math.max(1, count3), 1, Uint8Array, clippingData && clippingData.tClipping.ref.value.array);
  if (clippingData) {
    ValueCell.update(clippingData.tClipping, clipping);
    ValueCell.update(clippingData.uClippingTexDim, Vec2.create(clipping.width, clipping.height));
    ValueCell.updateIfChanged(clippingData.dClipping, count3 > 0);
    ValueCell.updateIfChanged(clippingData.dClippingType, type);
    return clippingData;
  } else {
    return {
      tClipping: ValueCell.create(clipping),
      uClippingTexDim: ValueCell.create(Vec2.create(clipping.width, clipping.height)),
      dClipping: ValueCell.create(count3 > 0),
      dClippingType: ValueCell.create(type)
    };
  }
}
var emptyClippingTexture = { array: new Uint8Array(1), width: 1, height: 1 };
function createEmptyClipping(clippingData) {
  if (clippingData) {
    ValueCell.update(clippingData.tClipping, emptyClippingTexture);
    ValueCell.update(clippingData.uClippingTexDim, Vec2.create(1, 1));
    ValueCell.updateIfChanged(clippingData.dClipping, false);
    return clippingData;
  } else {
    return {
      tClipping: ValueCell.create(emptyClippingTexture),
      uClippingTexDim: ValueCell.create(Vec2.create(1, 1)),
      dClipping: ValueCell.create(false),
      dClippingType: ValueCell.create("groupInstance")
    };
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/substance-data.js
function applySubstanceMaterial(array, start, end, material) {
  for (let i = start; i < end; ++i) {
    Material.toArray(material, array, i * 4);
    array[i * 4 + 3] = 255;
  }
  return true;
}
function clearSubstance(array, start, end) {
  array.fill(0, start * 4, end * 4);
  return true;
}
function createSubstance(count3, type, substanceData) {
  const substance = createTextureImage(Math.max(1, count3), 4, Uint8Array, substanceData && substanceData.tSubstance.ref.value.array);
  if (substanceData) {
    ValueCell.update(substanceData.tSubstance, substance);
    ValueCell.update(substanceData.uSubstanceTexDim, Vec2.create(substance.width, substance.height));
    ValueCell.updateIfChanged(substanceData.dSubstance, count3 > 0);
    ValueCell.updateIfChanged(substanceData.dSubstanceType, type);
    return substanceData;
  } else {
    return {
      tSubstance: ValueCell.create(substance),
      uSubstanceTexDim: ValueCell.create(Vec2.create(substance.width, substance.height)),
      dSubstance: ValueCell.create(count3 > 0),
      tSubstanceGrid: ValueCell.create(createNullTexture()),
      uSubstanceGridDim: ValueCell.create(Vec3.create(1, 1, 1)),
      uSubstanceGridTransform: ValueCell.create(Vec4.create(0, 0, 0, 1)),
      dSubstanceType: ValueCell.create(type),
      uSubstanceStrength: ValueCell.create(1)
    };
  }
}
var emptySubstanceTexture = { array: new Uint8Array(4), width: 1, height: 1 };
function createEmptySubstance(substanceData) {
  if (substanceData) {
    ValueCell.update(substanceData.tSubstance, emptySubstanceTexture);
    ValueCell.update(substanceData.uSubstanceTexDim, Vec2.create(1, 1));
    return substanceData;
  } else {
    return {
      tSubstance: ValueCell.create(emptySubstanceTexture),
      uSubstanceTexDim: ValueCell.create(Vec2.create(1, 1)),
      dSubstance: ValueCell.create(false),
      tSubstanceGrid: ValueCell.create(createNullTexture()),
      uSubstanceGridDim: ValueCell.create(Vec3.create(1, 1, 1)),
      uSubstanceGridTransform: ValueCell.create(Vec4.create(0, 0, 0, 1)),
      dSubstanceType: ValueCell.create("groupInstance"),
      uSubstanceStrength: ValueCell.create(1)
    };
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/emissive-data.js
function applyEmissiveValue(array, start, end, value) {
  for (let i = start; i < end; ++i) {
    array[i] = value * 255;
  }
  return true;
}
function getEmissiveAverage(array, count3) {
  if (count3 === 0 || array.length < count3)
    return 0;
  let sum = 0;
  for (let i = 0; i < count3; ++i) {
    sum += array[i];
  }
  return sum / (255 * count3);
}
function clearEmissive(array, start, end) {
  array.fill(0, start, end);
}
function createEmissive(count3, type, emissiveData) {
  const emissive = createTextureImage(Math.max(1, count3), 1, Uint8Array, emissiveData && emissiveData.tEmissive.ref.value.array);
  if (emissiveData) {
    ValueCell.update(emissiveData.tEmissive, emissive);
    ValueCell.update(emissiveData.uEmissiveTexDim, Vec2.create(emissive.width, emissive.height));
    ValueCell.updateIfChanged(emissiveData.dEmissive, count3 > 0);
    ValueCell.updateIfChanged(emissiveData.emissiveAverage, getEmissiveAverage(emissive.array, count3));
    ValueCell.updateIfChanged(emissiveData.dEmissiveType, type);
    return emissiveData;
  } else {
    return {
      tEmissive: ValueCell.create(emissive),
      uEmissiveTexDim: ValueCell.create(Vec2.create(emissive.width, emissive.height)),
      dEmissive: ValueCell.create(count3 > 0),
      emissiveAverage: ValueCell.create(0),
      tEmissiveGrid: ValueCell.create(createNullTexture()),
      uEmissiveGridDim: ValueCell.create(Vec3.create(1, 1, 1)),
      uEmissiveGridTransform: ValueCell.create(Vec4.create(0, 0, 0, 1)),
      dEmissiveType: ValueCell.create(type),
      uEmissiveStrength: ValueCell.create(1)
    };
  }
}
var emptyEmissiveTexture = { array: new Uint8Array(1), width: 1, height: 1 };
function createEmptyEmissive(emissiveData) {
  if (emissiveData) {
    ValueCell.update(emissiveData.tEmissive, emptyEmissiveTexture);
    ValueCell.update(emissiveData.uEmissiveTexDim, Vec2.create(1, 1));
    return emissiveData;
  } else {
    return {
      tEmissive: ValueCell.create(emptyEmissiveTexture),
      uEmissiveTexDim: ValueCell.create(Vec2.create(1, 1)),
      dEmissive: ValueCell.create(false),
      emissiveAverage: ValueCell.create(0),
      tEmissiveGrid: ValueCell.create(createNullTexture()),
      uEmissiveGridDim: ValueCell.create(Vec3.create(1, 1, 1)),
      uEmissiveGridTransform: ValueCell.create(Vec4.create(0, 0, 0, 1)),
      dEmissiveType: ValueCell.create("groupInstance"),
      uEmissiveStrength: ValueCell.create(1)
    };
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/mesh/mesh.js
var Mesh;
(function(Mesh2) {
  function create(vertices2, indices2, normals, groups, vertexCount, triangleCount, mesh) {
    return mesh ? update10(vertices2, indices2, normals, groups, vertexCount, triangleCount, mesh) : fromArrays(vertices2, indices2, normals, groups, vertexCount, triangleCount);
  }
  Mesh2.create = create;
  function createEmpty(mesh) {
    const vb = mesh ? mesh.vertexBuffer.ref.value : new Float32Array(0);
    const ib = mesh ? mesh.indexBuffer.ref.value : new Uint32Array(0);
    const nb = mesh ? mesh.normalBuffer.ref.value : new Float32Array(0);
    const gb = mesh ? mesh.groupBuffer.ref.value : new Float32Array(0);
    return create(vb, ib, nb, gb, 0, 0, mesh);
  }
  Mesh2.createEmpty = createEmpty;
  function hashCode3(mesh) {
    return hashFnv32a([
      mesh.vertexCount,
      mesh.triangleCount,
      mesh.vertexBuffer.ref.version,
      mesh.indexBuffer.ref.version,
      mesh.normalBuffer.ref.version,
      mesh.groupBuffer.ref.version
    ]);
  }
  function fromArrays(vertices2, indices2, normals, groups, vertexCount, triangleCount) {
    const boundingSphere = Sphere3D();
    let groupMapping;
    let currentHash = -1;
    let currentGroup = -1;
    const mesh = {
      kind: "mesh",
      vertexCount,
      triangleCount,
      vertexBuffer: ValueCell.create(vertices2),
      indexBuffer: ValueCell.create(indices2),
      normalBuffer: ValueCell.create(normals),
      groupBuffer: ValueCell.create(groups),
      varyingGroup: ValueCell.create(false),
      get boundingSphere() {
        const newHash = hashCode3(mesh);
        if (newHash !== currentHash) {
          const b5 = calculateInvariantBoundingSphere(mesh.vertexBuffer.ref.value, mesh.vertexCount, 1);
          Sphere3D.copy(boundingSphere, b5);
          currentHash = newHash;
        }
        return boundingSphere;
      },
      get groupMapping() {
        if (mesh.groupBuffer.ref.version !== currentGroup) {
          groupMapping = createGroupMapping(mesh.groupBuffer.ref.value, mesh.vertexCount);
          currentGroup = mesh.groupBuffer.ref.version;
        }
        return groupMapping;
      },
      setBoundingSphere(sphere) {
        Sphere3D.copy(boundingSphere, sphere);
        currentHash = hashCode3(mesh);
      },
      meta: {}
    };
    return mesh;
  }
  function update10(vertices2, indices2, normals, groups, vertexCount, triangleCount, mesh) {
    mesh.vertexCount = vertexCount;
    mesh.triangleCount = triangleCount;
    ValueCell.update(mesh.vertexBuffer, vertices2);
    ValueCell.update(mesh.indexBuffer, indices2);
    ValueCell.update(mesh.normalBuffer, normals);
    ValueCell.update(mesh.groupBuffer, groups);
    return mesh;
  }
  function computeNormals(mesh) {
    const { vertexCount, triangleCount } = mesh;
    const vertices2 = mesh.vertexBuffer.ref.value;
    const indices2 = mesh.indexBuffer.ref.value;
    const normals = mesh.normalBuffer.ref.value.length >= vertexCount * 3 ? mesh.normalBuffer.ref.value : new Float32Array(vertexCount * 3);
    if (normals === mesh.normalBuffer.ref.value) {
      normals.fill(0, 0, vertexCount * 3);
    }
    computeIndexedVertexNormals(vertices2, indices2, normals, vertexCount, triangleCount);
    ValueCell.update(mesh.normalBuffer, normals);
  }
  Mesh2.computeNormals = computeNormals;
  function checkForDuplicateVertices(mesh, fractionDigits = 3) {
    const v3 = mesh.vertexBuffer.ref.value;
    const map3 = /* @__PURE__ */ new Map();
    const hash3 = (v4, d3) => `${v4[0].toFixed(d3)}|${v4[1].toFixed(d3)}|${v4[2].toFixed(d3)}`;
    let duplicates = 0;
    const a5 = Vec3();
    for (let i = 0, il = mesh.vertexCount; i < il; ++i) {
      Vec3.fromArray(a5, v3, i * 3);
      const k = hash3(a5, fractionDigits);
      const count3 = map3.get(k);
      if (count3 !== void 0) {
        duplicates += 1;
        map3.set(k, count3 + 1);
      } else {
        map3.set(k, 1);
      }
    }
    return duplicates;
  }
  Mesh2.checkForDuplicateVertices = checkForDuplicateVertices;
  const tmpMat33 = Mat3();
  function transform(mesh, t2) {
    const v3 = mesh.vertexBuffer.ref.value;
    transformPositionArray(t2, v3, 0, mesh.vertexCount);
    if (!Mat4.isTranslationAndUniformScaling(t2)) {
      const n = Mat3.directionTransform(tmpMat33, t2);
      transformDirectionArray(n, mesh.normalBuffer.ref.value, 0, mesh.vertexCount);
    }
    ValueCell.update(mesh.vertexBuffer, v3);
  }
  Mesh2.transform = transform;
  function getOriginalData(x) {
    const { originalData } = "kind" in x ? x.meta : x.meta.ref.value;
    return originalData;
  }
  Mesh2.getOriginalData = getOriginalData;
  function uniformTriangleGroup(mesh, splitTriangles = true) {
    const { indexBuffer, vertexBuffer, groupBuffer, normalBuffer, triangleCount, vertexCount } = mesh;
    const ib = indexBuffer.ref.value;
    const vb = vertexBuffer.ref.value;
    const gb = groupBuffer.ref.value;
    const nb = normalBuffer.ref.value;
    const index = ChunkedArray.create(Uint32Array, 3, 1024, triangleCount);
    const vertex = ChunkedArray.create(Float32Array, 3, 1024, vb);
    vertex.currentIndex = vertexCount * 3;
    vertex.elementCount = vertexCount;
    const normal = ChunkedArray.create(Float32Array, 3, 1024, nb);
    normal.currentIndex = vertexCount * 3;
    normal.elementCount = vertexCount;
    const group = ChunkedArray.create(Float32Array, 1, 1024, gb);
    group.currentIndex = vertexCount;
    group.elementCount = vertexCount;
    const vi = Vec3();
    const vj = Vec3();
    const vk = Vec3();
    const ni = Vec3();
    const nj = Vec3();
    const nk = Vec3();
    function add(i) {
      Vec3.fromArray(vi, vb, i * 3);
      Vec3.fromArray(ni, nb, i * 3);
      ChunkedArray.add3(vertex, vi[0], vi[1], vi[2]);
      ChunkedArray.add3(normal, ni[0], ni[1], ni[2]);
    }
    function addMid(i, j) {
      Vec3.fromArray(vi, vb, i * 3);
      Vec3.fromArray(vj, vb, j * 3);
      Vec3.scale(vi, Vec3.add(vi, vi, vj), 0.5);
      Vec3.fromArray(ni, nb, i * 3);
      Vec3.fromArray(nj, nb, j * 3);
      Vec3.scale(ni, Vec3.add(ni, ni, nj), 0.5);
      ChunkedArray.add3(vertex, vi[0], vi[1], vi[2]);
      ChunkedArray.add3(normal, ni[0], ni[1], ni[2]);
    }
    function addCenter(i, j, k) {
      Vec3.fromArray(vi, vb, i * 3);
      Vec3.fromArray(vj, vb, j * 3);
      Vec3.fromArray(vk, vb, k * 3);
      Vec3.scale(vi, Vec3.add(vi, Vec3.add(vi, vi, vj), vk), 1 / 3);
      Vec3.fromArray(ni, nb, i * 3);
      Vec3.fromArray(nj, nb, j * 3);
      Vec3.fromArray(nk, nb, k * 3);
      Vec3.scale(ni, Vec3.add(ni, Vec3.add(ni, ni, nj), nk), 1 / 3);
      ChunkedArray.add3(vertex, vi[0], vi[1], vi[2]);
      ChunkedArray.add3(normal, ni[0], ni[1], ni[2]);
    }
    function split2(i0, i1, i2, g0, g1) {
      ++newTriangleCount;
      add(i0);
      addMid(i0, i1);
      addMid(i0, i2);
      ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 2);
      for (let j = 0; j < 3; ++j)
        ChunkedArray.add(group, g0);
      newVertexCount += 3;
      newTriangleCount += 2;
      add(i1);
      add(i2);
      addMid(i0, i1);
      addMid(i0, i2);
      ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 3);
      ChunkedArray.add3(index, newVertexCount, newVertexCount + 3, newVertexCount + 2);
      for (let j = 0; j < 4; ++j)
        ChunkedArray.add(group, g1);
      newVertexCount += 4;
    }
    let newVertexCount = vertexCount;
    let newTriangleCount = 0;
    if (splitTriangles) {
      for (let i = 0, il = triangleCount; i < il; ++i) {
        const i0 = ib[i * 3], i1 = ib[i * 3 + 1], i2 = ib[i * 3 + 2];
        const g0 = gb[i0], g1 = gb[i1], g2 = gb[i2];
        if (g0 === g1 && g0 === g2) {
          ++newTriangleCount;
          ChunkedArray.add3(index, i0, i1, i2);
        } else if (g0 === g1) {
          split2(i2, i0, i1, g2, g0);
        } else if (g0 === g2) {
          split2(i1, i2, i0, g1, g2);
        } else if (g1 === g2) {
          split2(i0, i1, i2, g0, g1);
        } else {
          newTriangleCount += 2;
          add(i0);
          addMid(i0, i1);
          addMid(i0, i2);
          addCenter(i0, i1, i2);
          ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 3);
          ChunkedArray.add3(index, newVertexCount, newVertexCount + 3, newVertexCount + 2);
          for (let j = 0; j < 4; ++j)
            ChunkedArray.add(group, g0);
          newVertexCount += 4;
          newTriangleCount += 2;
          add(i1);
          addMid(i1, i2);
          addMid(i1, i0);
          addCenter(i0, i1, i2);
          ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 3);
          ChunkedArray.add3(index, newVertexCount, newVertexCount + 3, newVertexCount + 2);
          for (let j = 0; j < 4; ++j)
            ChunkedArray.add(group, g1);
          newVertexCount += 4;
          newTriangleCount += 2;
          add(i2);
          addMid(i2, i1);
          addMid(i2, i0);
          addCenter(i0, i1, i2);
          ChunkedArray.add3(index, newVertexCount + 3, newVertexCount + 1, newVertexCount);
          ChunkedArray.add3(index, newVertexCount + 2, newVertexCount + 3, newVertexCount);
          for (let j = 0; j < 4; ++j)
            ChunkedArray.add(group, g2);
          newVertexCount += 4;
        }
      }
    } else {
      for (let i = 0, il = triangleCount; i < il; ++i) {
        const i0 = ib[i * 3], i1 = ib[i * 3 + 1], i2 = ib[i * 3 + 2];
        const g0 = gb[i0], g1 = gb[i1], g2 = gb[i2];
        if (g0 !== g1 || g0 !== g2) {
          ++newTriangleCount;
          add(i0);
          add(i1);
          add(i2);
          ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 2);
          const g = g1 === g2 ? g1 : g0;
          for (let j = 0; j < 3; ++j)
            ChunkedArray.add(group, g);
          newVertexCount += 3;
        } else {
          ++newTriangleCount;
          ChunkedArray.add3(index, i0, i1, i2);
        }
      }
    }
    const newIb = ChunkedArray.compact(index);
    const newVb = ChunkedArray.compact(vertex);
    const newNb = ChunkedArray.compact(normal);
    const newGb = ChunkedArray.compact(group);
    mesh.vertexCount = newVertexCount;
    mesh.triangleCount = newTriangleCount;
    ValueCell.update(vertexBuffer, newVb);
    ValueCell.update(groupBuffer, newGb);
    ValueCell.update(indexBuffer, newIb);
    ValueCell.update(normalBuffer, newNb);
    mesh.meta.originalData = { indexBuffer: ib, vertexCount, triangleCount };
    return mesh;
  }
  Mesh2.uniformTriangleGroup = uniformTriangleGroup;
  function getNeighboursMap(mesh) {
    const { vertexCount, triangleCount } = mesh;
    const elements = mesh.indexBuffer.ref.value;
    const neighboursMap = [];
    for (let i = 0; i < vertexCount; ++i) {
      neighboursMap[i] = [];
    }
    for (let i = 0; i < triangleCount; ++i) {
      const v1 = elements[i * 3];
      const v22 = elements[i * 3 + 1];
      const v3 = elements[i * 3 + 2];
      arraySetAdd(neighboursMap[v1], v22);
      arraySetAdd(neighboursMap[v1], v3);
      arraySetAdd(neighboursMap[v22], v1);
      arraySetAdd(neighboursMap[v22], v3);
      arraySetAdd(neighboursMap[v3], v1);
      arraySetAdd(neighboursMap[v3], v22);
    }
    return neighboursMap;
  }
  function getEdgeCounts(mesh) {
    const { triangleCount } = mesh;
    const elements = mesh.indexBuffer.ref.value;
    const edgeCounts = /* @__PURE__ */ new Map();
    const add = (a5, b5) => {
      const z = sortedCantorPairing(a5, b5);
      const c5 = edgeCounts.get(z) || 0;
      edgeCounts.set(z, c5 + 1);
    };
    for (let i = 0; i < triangleCount; ++i) {
      const a5 = elements[i * 3];
      const b5 = elements[i * 3 + 1];
      const c5 = elements[i * 3 + 2];
      add(a5, b5);
      add(a5, c5);
      add(b5, c5);
    }
    return edgeCounts;
  }
  function getBorderVertices(edgeCounts) {
    const borderVertices = /* @__PURE__ */ new Set();
    const pair = [0, 0];
    edgeCounts.forEach((c5, z) => {
      if (c5 === 1) {
        invertCantorPairing(pair, z);
        borderVertices.add(pair[0]);
        borderVertices.add(pair[1]);
      }
    });
    return borderVertices;
  }
  function getBorderNeighboursMap(neighboursMap, borderVertices, edgeCounts) {
    const borderNeighboursMap = /* @__PURE__ */ new Map();
    const add = (v3, nb) => {
      if (borderNeighboursMap.has(v3))
        arraySetAdd(borderNeighboursMap.get(v3), nb);
      else
        borderNeighboursMap.set(v3, [nb]);
    };
    borderVertices.forEach((v3) => {
      const neighbours = neighboursMap[v3];
      for (const nb of neighbours) {
        if (borderVertices.has(nb) && edgeCounts.get(sortedCantorPairing(v3, nb)) === 1) {
          add(v3, nb);
        }
      }
    });
    return borderNeighboursMap;
  }
  function trimEdges(mesh, neighboursMap) {
    const { indexBuffer, triangleCount } = mesh;
    const ib = indexBuffer.ref.value;
    const index = ChunkedArray.create(Uint32Array, 3, 1024, triangleCount);
    let newTriangleCount = 0;
    for (let i = 0; i < triangleCount; ++i) {
      const a5 = ib[i * 3];
      const b5 = ib[i * 3 + 1];
      const c5 = ib[i * 3 + 2];
      if (neighboursMap[a5].length === 2 || neighboursMap[b5].length === 2 || neighboursMap[c5].length === 2)
        continue;
      ChunkedArray.add3(index, a5, b5, c5);
      newTriangleCount += 1;
    }
    const newIb = ChunkedArray.compact(index);
    mesh.triangleCount = newTriangleCount;
    ValueCell.update(indexBuffer, newIb);
    return mesh;
  }
  function fillEdges(mesh, neighboursMap, borderNeighboursMap, maxLengthSquared) {
    var _a;
    const { vertexBuffer, indexBuffer, normalBuffer, triangleCount } = mesh;
    const vb = vertexBuffer.ref.value;
    const ib = indexBuffer.ref.value;
    const nb = normalBuffer.ref.value;
    const index = ChunkedArray.create(Uint32Array, 3, 1024, triangleCount);
    let newTriangleCount = 0;
    for (let i = 0; i < triangleCount; ++i) {
      ChunkedArray.add3(index, ib[i * 3], ib[i * 3 + 1], ib[i * 3 + 2]);
      newTriangleCount += 1;
    }
    const vA = Vec3();
    const vB = Vec3();
    const vC = Vec3();
    const vD = Vec3();
    const vAB = Vec3();
    const vAC = Vec3();
    const vAD = Vec3();
    const vABC = Vec3();
    const vAN = Vec3();
    const vN = Vec3();
    const AngleThreshold = degToRad(120);
    const added = /* @__PURE__ */ new Set();
    const indices2 = Array.from(borderNeighboursMap.keys()).filter((v3) => borderNeighboursMap.get(v3).length < 2).map((v3) => {
      const bnd = borderNeighboursMap.get(v3);
      Vec3.fromArray(vA, vb, v3 * 3);
      Vec3.fromArray(vB, vb, bnd[0] * 3);
      Vec3.fromArray(vC, vb, bnd[1] * 3);
      Vec3.sub(vAB, vB, vA);
      Vec3.sub(vAC, vC, vA);
      return [v3, Vec3.angle(vAB, vAC)];
    });
    indices2.sort(([, a5], [, b5]) => a5 - b5);
    for (const [v3, angle] of indices2) {
      if (added.has(v3) || angle > AngleThreshold)
        continue;
      const nbs = borderNeighboursMap.get(v3);
      if (neighboursMap[nbs[0]].includes(nbs[1]) && !((_a = borderNeighboursMap.get(nbs[0])) === null || _a === void 0 ? void 0 : _a.includes(nbs[1])))
        continue;
      Vec3.fromArray(vA, vb, v3 * 3);
      Vec3.fromArray(vB, vb, nbs[0] * 3);
      Vec3.fromArray(vC, vb, nbs[1] * 3);
      Vec3.sub(vAB, vB, vA);
      Vec3.sub(vAC, vC, vA);
      Vec3.add(vABC, vAB, vAC);
      if (Vec3.squaredDistance(vA, vB) >= maxLengthSquared)
        continue;
      let add = false;
      for (const nb2 of neighboursMap[v3]) {
        if (nbs.includes(nb2))
          continue;
        Vec3.fromArray(vD, vb, nb2 * 3);
        Vec3.sub(vAD, vD, vA);
        if (Vec3.dot(vABC, vAD) < 0) {
          add = true;
          break;
        }
      }
      if (!add)
        continue;
      Vec3.fromArray(vAN, nb, v3 * 3);
      Vec3.triangleNormal(vN, vA, vB, vC);
      if (Vec3.dot(vN, vAN) > 0) {
        ChunkedArray.add3(index, v3, nbs[0], nbs[1]);
      } else {
        ChunkedArray.add3(index, nbs[1], nbs[0], v3);
      }
      added.add(v3);
      added.add(nbs[0]);
      added.add(nbs[1]);
      newTriangleCount += 1;
    }
    const newIb = ChunkedArray.compact(index);
    mesh.triangleCount = newTriangleCount;
    ValueCell.update(indexBuffer, newIb);
    return mesh;
  }
  function laplacianEdgeSmoothing(mesh, borderNeighboursMap, options) {
    const { iterations, lambda } = options;
    const a5 = Vec3();
    const b5 = Vec3();
    const c5 = Vec3();
    const t2 = Vec3();
    const mu = -lambda;
    let dst = new Float32Array(mesh.vertexBuffer.ref.value.length);
    const step = (f) => {
      const pos = mesh.vertexBuffer.ref.value;
      dst.set(pos);
      borderNeighboursMap.forEach((nbs, v3) => {
        if (nbs.length !== 2)
          return;
        Vec3.fromArray(a5, pos, v3 * 3);
        Vec3.fromArray(b5, pos, nbs[0] * 3);
        Vec3.fromArray(c5, pos, nbs[1] * 3);
        const wab = 1 / Vec3.distance(a5, b5);
        const wac = 1 / Vec3.distance(a5, c5);
        Vec3.scale(b5, b5, wab);
        Vec3.scale(c5, c5, wac);
        Vec3.add(t2, b5, c5);
        Vec3.scale(t2, t2, 1 / (wab + wac));
        Vec3.sub(t2, t2, a5);
        Vec3.scale(t2, t2, f);
        Vec3.add(t2, a5, t2);
        Vec3.toArray(t2, dst, v3 * 3);
      });
      const tmp = mesh.vertexBuffer.ref.value;
      ValueCell.update(mesh.vertexBuffer, dst);
      dst = tmp;
    };
    for (let k = 0; k < iterations; ++k) {
      step(lambda);
      step(mu);
    }
  }
  function smoothEdges(mesh, options) {
    trimEdges(mesh, getNeighboursMap(mesh));
    for (let k = 0; k < 10; ++k) {
      const oldTriangleCount = mesh.triangleCount;
      const edgeCounts2 = getEdgeCounts(mesh);
      const neighboursMap2 = getNeighboursMap(mesh);
      const borderVertices2 = getBorderVertices(edgeCounts2);
      const borderNeighboursMap2 = getBorderNeighboursMap(neighboursMap2, borderVertices2, edgeCounts2);
      fillEdges(mesh, neighboursMap2, borderNeighboursMap2, options.maxNewEdgeLength * options.maxNewEdgeLength);
      if (mesh.triangleCount === oldTriangleCount)
        break;
    }
    const edgeCounts = getEdgeCounts(mesh);
    const neighboursMap = getNeighboursMap(mesh);
    const borderVertices = getBorderVertices(edgeCounts);
    const borderNeighboursMap = getBorderNeighboursMap(neighboursMap, borderVertices, edgeCounts);
    laplacianEdgeSmoothing(mesh, borderNeighboursMap, { iterations: options.iterations, lambda: 0.5 });
    return mesh;
  }
  Mesh2.smoothEdges = smoothEdges;
  Mesh2.Params = {
    ...BaseGeometry.Params,
    doubleSided: ParamDefinition.Boolean(false, BaseGeometry.CustomQualityParamInfo),
    flipSided: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    flatShaded: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    ignoreLight: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    celShaded: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    xrayShaded: ParamDefinition.Select(false, [[false, "Off"], [true, "On"], ["inverted", "Inverted"]], BaseGeometry.ShadingCategory),
    transparentBackfaces: ParamDefinition.Select("off", ParamDefinition.arrayToOptions(["off", "on", "opaque"]), BaseGeometry.ShadingCategory),
    bumpFrequency: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
    bumpAmplitude: ParamDefinition.Numeric(1, { min: 0, max: 5, step: 0.1 }, BaseGeometry.ShadingCategory)
  };
  Mesh2.Utils = {
    Params: Mesh2.Params,
    createEmpty,
    createValues,
    createValuesSimple,
    updateValues,
    updateBoundingSphere,
    createRenderableState,
    updateRenderableState,
    createPositionIterator
  };
  function createPositionIterator(mesh, transform2) {
    const groupCount = mesh.vertexCount;
    const instanceCount = transform2.instanceCount.ref.value;
    const location = PositionLocation();
    const p = location.position;
    const n = location.normal;
    const vs = mesh.vertexBuffer.ref.value;
    const ns = mesh.normalBuffer.ref.value;
    const m = transform2.aTransform.ref.value;
    const getLocation = (groupIndex, instanceIndex) => {
      if (instanceIndex < 0) {
        Vec3.fromArray(p, vs, groupIndex * 3);
        Vec3.fromArray(n, ns, groupIndex * 3);
      } else {
        Vec3.transformMat4Offset(p, vs, m, 0, groupIndex * 3, instanceIndex * 16);
        Vec3.transformDirectionOffset(n, ns, m, 0, groupIndex * 3, instanceIndex * 16);
      }
      return location;
    };
    return LocationIterator(groupCount, instanceCount, 1, getLocation);
  }
  function createValues(mesh, transform2, locationIt, theme, props) {
    const { instanceCount, groupCount } = locationIt;
    const positionIt = createPositionIterator(mesh, transform2);
    const color = createColors(locationIt, positionIt, theme.color);
    const marker = props.instanceGranularity ? createMarkers(instanceCount, "instance") : createMarkers(instanceCount * groupCount, "groupInstance");
    const overpaint = createEmptyOverpaint();
    const transparency = createEmptyTransparency();
    const emissive = createEmptyEmissive();
    const material = createEmptySubstance();
    const clipping = createEmptyClipping();
    const counts = { drawCount: mesh.triangleCount * 3, vertexCount: mesh.vertexCount, groupCount, instanceCount };
    const invariantBoundingSphere = Sphere3D.clone(mesh.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform2.aTransform.ref.value, instanceCount, 0);
    return {
      dGeometryType: ValueCell.create("mesh"),
      aPosition: mesh.vertexBuffer,
      aNormal: mesh.normalBuffer,
      aGroup: mesh.groupBuffer,
      elements: mesh.indexBuffer,
      dVaryingGroup: mesh.varyingGroup,
      boundingSphere: ValueCell.create(boundingSphere),
      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),
      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)),
      ...color,
      ...marker,
      ...overpaint,
      ...transparency,
      ...emissive,
      ...material,
      ...clipping,
      ...transform2,
      ...BaseGeometry.createValues(props, counts),
      uDoubleSided: ValueCell.create(props.doubleSided),
      dFlatShaded: ValueCell.create(props.flatShaded),
      dFlipSided: ValueCell.create(props.flipSided),
      dIgnoreLight: ValueCell.create(props.ignoreLight),
      dCelShaded: ValueCell.create(props.celShaded),
      dXrayShaded: ValueCell.create(props.xrayShaded === "inverted" ? "inverted" : props.xrayShaded === true ? "on" : "off"),
      dTransparentBackfaces: ValueCell.create(props.transparentBackfaces),
      uBumpFrequency: ValueCell.create(props.bumpFrequency),
      uBumpAmplitude: ValueCell.create(props.bumpAmplitude),
      meta: ValueCell.create(mesh.meta)
    };
  }
  function createValuesSimple(mesh, props, colorValue, sizeValue, transform2) {
    const s = BaseGeometry.createSimple(colorValue, sizeValue, transform2);
    const p = { ...ParamDefinition.getDefaultValues(Mesh2.Params), ...props };
    return createValues(mesh, s.transform, s.locationIterator, s.theme, p);
  }
  function updateValues(values2, props) {
    BaseGeometry.updateValues(values2, props);
    ValueCell.updateIfChanged(values2.uDoubleSided, props.doubleSided);
    ValueCell.updateIfChanged(values2.dFlatShaded, props.flatShaded);
    ValueCell.updateIfChanged(values2.dFlipSided, props.flipSided);
    ValueCell.updateIfChanged(values2.dIgnoreLight, props.ignoreLight);
    ValueCell.updateIfChanged(values2.dCelShaded, props.celShaded);
    ValueCell.updateIfChanged(values2.dXrayShaded, props.xrayShaded === "inverted" ? "inverted" : props.xrayShaded === true ? "on" : "off");
    ValueCell.updateIfChanged(values2.dTransparentBackfaces, props.transparentBackfaces);
    ValueCell.updateIfChanged(values2.uBumpFrequency, props.bumpFrequency);
    ValueCell.updateIfChanged(values2.uBumpAmplitude, props.bumpAmplitude);
  }
  function updateBoundingSphere(values2, mesh) {
    const invariantBoundingSphere = Sphere3D.clone(mesh.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values2.aTransform.ref.value, values2.instanceCount.ref.value, 0);
    if (!Sphere3D.equals(boundingSphere, values2.boundingSphere.ref.value)) {
      ValueCell.update(values2.boundingSphere, boundingSphere);
    }
    if (!Sphere3D.equals(invariantBoundingSphere, values2.invariantBoundingSphere.ref.value)) {
      ValueCell.update(values2.invariantBoundingSphere, invariantBoundingSphere);
      ValueCell.update(values2.uInvariantBoundingSphere, Vec4.fromSphere(values2.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));
    }
  }
  function createRenderableState(props) {
    const state = BaseGeometry.createRenderableState(props);
    updateRenderableState(state, props);
    return state;
  }
  function updateRenderableState(state, props) {
    BaseGeometry.updateRenderableState(state, props);
    state.opaque = state.opaque && !props.xrayShaded;
    state.writeDepth = state.opaque;
  }
})(Mesh || (Mesh = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/primitive/polyhedron.js
var DefaultPolyhedronProps = {
  radius: 1,
  detail: 0
};
function Polyhedron(_vertices, _indices, props) {
  const { radius, detail } = { ...DefaultPolyhedronProps, ...props };
  const builder = createBuilder();
  const { vertices: vertices2, indices: indices2 } = builder;
  subdivide(detail);
  appplyRadius(vertices2, radius);
  const normals = new Float32Array(vertices2.length);
  computeIndexedVertexNormals(vertices2, indices2, normals, vertices2.length / 3, indices2.length / 3);
  return {
    vertices: new Float32Array(vertices2),
    normals: new Float32Array(normals),
    indices: new Uint32Array(indices2)
  };
  function subdivide(detail2) {
    const a5 = Vec3();
    const b5 = Vec3();
    const c5 = Vec3();
    for (let i = 0; i < _indices.length; i += 3) {
      Vec3.fromArray(a5, _vertices, _indices[i + 0] * 3);
      Vec3.fromArray(b5, _vertices, _indices[i + 1] * 3);
      Vec3.fromArray(c5, _vertices, _indices[i + 2] * 3);
      subdivideFace(a5, b5, c5, detail2);
    }
  }
  function subdivideFace(a5, b5, c5, detail2) {
    const cols = Math.pow(2, detail2);
    const v3 = [];
    for (let i = 0; i <= cols; ++i) {
      v3[i] = [];
      const aj = Vec3();
      Vec3.lerp(aj, a5, c5, i / cols);
      const bj = Vec3();
      Vec3.lerp(bj, b5, c5, i / cols);
      const rows = cols - i;
      for (let j = 0; j <= rows; ++j) {
        if (j === 0 && i === cols) {
          v3[i][j] = aj;
        } else {
          const abj = Vec3();
          Vec3.lerp(abj, aj, bj, j / rows);
          v3[i][j] = abj;
        }
      }
    }
    for (let i = 0; i < cols; ++i) {
      for (let j = 0; j < 2 * (cols - i) - 1; ++j) {
        const k = Math.floor(j / 2);
        if (j % 2 === 0) {
          builder.add(v3[i][k + 1], v3[i + 1][k], v3[i][k]);
        } else {
          builder.add(v3[i][k + 1], v3[i + 1][k + 1], v3[i + 1][k]);
        }
      }
    }
  }
}
function createBuilder() {
  const vertices2 = [];
  const indices2 = [];
  const vertexMap = /* @__PURE__ */ new Map();
  function addVertex(v3) {
    const key2 = `${v3[0].toFixed(5)}|${v3[1].toFixed(5)}|${v3[2].toFixed(5)}`;
    let idx = vertexMap.get(key2);
    if (idx === void 0) {
      idx = vertices2.length / 3;
      vertexMap.set(key2, idx);
      vertices2.push(...v3);
    }
    return idx;
  }
  return {
    vertices: vertices2,
    indices: indices2,
    add: (v1, v22, v3) => {
      indices2.push(addVertex(v1), addVertex(v22), addVertex(v3));
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/primitive/primitive.js
var a2 = Vec3();
var b2 = Vec3();
var c2 = Vec3();
function createPrimitive(vertices2, indices2) {
  const count3 = indices2.length;
  const builder = PrimitiveBuilder(count3 / 3);
  for (let i = 0; i < count3; i += 3) {
    Vec3.fromArray(a2, vertices2, indices2[i] * 3);
    Vec3.fromArray(b2, vertices2, indices2[i + 1] * 3);
    Vec3.fromArray(c2, vertices2, indices2[i + 2] * 3);
    builder.add(a2, b2, c2);
  }
  return builder.getPrimitive();
}
var vn = Vec3();
function PrimitiveBuilder(triangleCount, vertexCount) {
  if (vertexCount === void 0)
    vertexCount = triangleCount * 3;
  const vertices2 = new Float32Array(vertexCount * 3);
  const normals = new Float32Array(vertexCount * 3);
  const indices2 = new Uint32Array(triangleCount * 3);
  let vOffset = 0;
  let iOffset = 0;
  return {
    add: (a5, b5, c5) => {
      Vec3.toArray(a5, vertices2, vOffset);
      Vec3.toArray(b5, vertices2, vOffset + 3);
      Vec3.toArray(c5, vertices2, vOffset + 6);
      Vec3.triangleNormal(vn, a5, b5, c5);
      for (let j = 0; j < 3; ++j) {
        Vec3.toArray(vn, normals, vOffset + 3 * j);
        indices2[iOffset + j] = vOffset / 3 + j;
      }
      vOffset += 9;
      iOffset += 3;
    },
    addQuad: (a5, b5, c5, d3) => {
      Vec3.toArray(a5, vertices2, vOffset);
      Vec3.toArray(b5, vertices2, vOffset + 3);
      Vec3.toArray(c5, vertices2, vOffset + 6);
      Vec3.toArray(d3, vertices2, vOffset + 9);
      Vec3.triangleNormal(vn, a5, b5, c5);
      for (let j = 0; j < 4; ++j) {
        Vec3.toArray(vn, normals, vOffset + 3 * j);
      }
      const vOffset3 = vOffset / 3;
      indices2[iOffset] = vOffset3;
      indices2[iOffset + 1] = vOffset3 + 1;
      indices2[iOffset + 2] = vOffset3 + 2;
      indices2[iOffset + 3] = vOffset3 + 2;
      indices2[iOffset + 4] = vOffset3 + 3;
      indices2[iOffset + 5] = vOffset3;
      vOffset += 12;
      iOffset += 6;
    },
    getPrimitive: () => ({ vertices: vertices2, normals, indices: indices2 })
  };
}
var tmpV = Vec3();
var tmpMat3 = Mat3();
function transformPrimitive(primitive, t2) {
  const { vertices: vertices2, normals } = primitive;
  const n = Mat3.directionTransform(tmpMat3, t2);
  for (let i = 0, il = vertices2.length; i < il; i += 3) {
    Vec3.transformMat4(tmpV, Vec3.fromArray(tmpV, vertices2, i), t2);
    Vec3.toArray(tmpV, vertices2, i);
    Vec3.transformMat3(tmpV, Vec3.fromArray(tmpV, normals, i), n);
    Vec3.toArray(tmpV, normals, i);
  }
  return primitive;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/primitive/cage.js
function createCage(vertices2, edges) {
  return { vertices: vertices2, edges };
}
function cloneCage(cage) {
  return {
    vertices: new Float32Array(cage.vertices),
    edges: new Uint32Array(cage.edges)
  };
}
var tmpV2 = Vec3.zero();
function transformCage(cage, t2) {
  const { vertices: vertices2 } = cage;
  for (let i = 0, il = vertices2.length; i < il; i += 3) {
    Vec3.transformMat4(tmpV2, Vec3.fromArray(tmpV2, vertices2, i), t2);
    Vec3.toArray(tmpV2, vertices2, i);
  }
  return cage;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/primitive/icosahedron.js
var t = (1 + Math.sqrt(5)) / 2;
var icosahedronVertices = [
  -1,
  t,
  0,
  1,
  t,
  0,
  -1,
  -t,
  0,
  1,
  -t,
  0,
  0,
  -1,
  t,
  0,
  1,
  t,
  0,
  -1,
  -t,
  0,
  1,
  -t,
  t,
  0,
  -1,
  t,
  0,
  1,
  -t,
  0,
  -1,
  -t,
  0,
  1
];
var icosahedronIndices = [
  0,
  11,
  5,
  0,
  5,
  1,
  0,
  1,
  7,
  0,
  7,
  10,
  0,
  10,
  11,
  1,
  5,
  9,
  5,
  11,
  4,
  11,
  10,
  2,
  10,
  7,
  6,
  7,
  1,
  8,
  3,
  9,
  4,
  3,
  4,
  2,
  3,
  2,
  6,
  3,
  6,
  8,
  3,
  8,
  9,
  4,
  9,
  5,
  2,
  4,
  11,
  6,
  2,
  10,
  8,
  6,
  7,
  9,
  8,
  1
];
var icosahedronEdges = [
  0,
  11,
  5,
  11,
  0,
  5,
  1,
  5,
  0,
  1,
  1,
  7,
  0,
  7,
  7,
  10,
  0,
  10,
  10,
  11,
  5,
  9,
  4,
  11,
  2,
  10,
  6,
  7,
  1,
  8,
  3,
  9,
  4,
  9,
  3,
  4,
  2,
  4,
  2,
  3,
  2,
  6,
  3,
  6,
  6,
  8,
  3,
  8,
  8,
  9,
  4,
  5,
  2,
  11,
  6,
  10,
  7,
  8,
  1,
  9
];
var icosahedron;
function Icosahedron() {
  if (!icosahedron)
    icosahedron = createPrimitive(icosahedronVertices, icosahedronIndices);
  return icosahedron;
}
var icosahedronCage = createCage(icosahedronVertices, icosahedronEdges);

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/primitive/sphere.js
var { vertices, indices } = Icosahedron();
function sphereVertexCount(detail) {
  return 10 * Math.pow(Math.pow(2, detail), 2) + 2;
}
function Sphere(detail) {
  return Polyhedron(vertices, indices, { detail, radius: 1 });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/mesh/builder/sphere.js
var sphereMap = /* @__PURE__ */ new Map();
var tmpSphereMat = Mat4.identity();
function setSphereMat(m, center, radius) {
  return Mat4.scaleUniformly(m, Mat4.fromTranslation(m, center), radius);
}
function getSphere(detail) {
  let sphere = sphereMap.get(detail);
  if (sphere === void 0) {
    sphere = Sphere(detail);
    sphereMap.set(detail, sphere);
  }
  return sphere;
}
function addSphere(state, center, radius, detail) {
  MeshBuilder.addPrimitive(state, setSphereMat(tmpSphereMat, center, radius), getSphere(detail));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/primitive/cylinder.js
var DefaultCylinderProps = {
  radiusTop: 1,
  radiusBottom: 1,
  height: 1,
  radialSegments: 8,
  heightSegments: 1,
  topCap: false,
  bottomCap: false,
  thetaStart: 0,
  thetaLength: Math.PI * 2
};
function Cylinder(props) {
  const { radiusTop, radiusBottom, height, radialSegments, heightSegments, topCap, bottomCap, thetaStart, thetaLength } = { ...DefaultCylinderProps, ...props };
  const indices2 = [];
  const vertices2 = [];
  const normals = [];
  let index = 0;
  const indexArray = [];
  const halfHeight = height / 2;
  generateTorso();
  if (topCap && radiusTop > 0)
    generateCap(true);
  if (bottomCap && radiusBottom > 0)
    generateCap(false);
  return {
    vertices: new Float32Array(vertices2),
    normals: new Float32Array(normals),
    indices: new Uint32Array(indices2)
  };
  function generateTorso() {
    const normal = Vec3.zero();
    const slope = (radiusBottom - radiusTop) / height;
    for (let y = 0; y <= heightSegments; ++y) {
      const indexRow = [];
      const v3 = y / heightSegments;
      const radius = v3 * (radiusBottom - radiusTop) + radiusTop;
      for (let x = 0; x <= radialSegments; ++x) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        vertices2.push(radius * sinTheta, -v3 * height + halfHeight, radius * cosTheta);
        Vec3.normalize(normal, Vec3.set(normal, sinTheta, slope, cosTheta));
        normals.push(...normal);
        indexRow.push(index++);
      }
      indexArray.push(indexRow);
    }
    for (let x = 0; x < radialSegments; ++x) {
      for (let y = 0; y < heightSegments; ++y) {
        const a5 = indexArray[y][x];
        const b5 = indexArray[y + 1][x];
        const c5 = indexArray[y + 1][x + 1];
        const d3 = indexArray[y][x + 1];
        indices2.push(a5, b5, d3);
        indices2.push(b5, c5, d3);
      }
    }
  }
  function generateCap(top) {
    const radius = top === true ? radiusTop : radiusBottom;
    const sign = top === true ? 1 : -1;
    const centerIndexStart = index;
    for (let x = 1; x <= radialSegments; ++x) {
      vertices2.push(0, halfHeight * sign, 0);
      normals.push(0, sign, 0);
      ++index;
    }
    const centerIndexEnd = index;
    for (let x = 0; x <= radialSegments; ++x) {
      const u = x / radialSegments;
      const theta = u * thetaLength + thetaStart;
      const cosTheta = Math.cos(theta);
      const sinTheta = Math.sin(theta);
      vertices2.push(radius * sinTheta, halfHeight * sign, radius * cosTheta);
      normals.push(0, sign, 0);
      ++index;
    }
    for (let x = 0; x < radialSegments; ++x) {
      const c5 = centerIndexStart + x;
      const i = centerIndexEnd + x;
      if (top === true) {
        indices2.push(i, i + 1, c5);
      } else {
        indices2.push(i + 1, i, c5);
      }
    }
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/primitive/polygon.js
function polygon(sideCount, shift, radius = -1) {
  const points2 = new Float32Array(sideCount * 3);
  const r = radius === -1 ? sideCount <= 4 ? Math.sqrt(2) / 2 : 0.6 : radius;
  const offset = shift ? 1 : 0;
  for (let i = 0, il = sideCount; i < il; ++i) {
    const c5 = (i * 2 + offset) / sideCount * Math.PI;
    points2[i * 3] = Math.cos(c5) * r;
    points2[i * 3 + 1] = Math.sin(c5) * r;
    points2[i * 3 + 2] = 0;
  }
  return points2;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/primitive/prism.js
var on = Vec3();
var op = Vec3();
var a3 = Vec3();
var b3 = Vec3();
var c3 = Vec3();
var d = Vec3();
var DefaultPrismProps = {
  height: 1,
  topCap: true,
  bottomCap: true
};
function Prism(points2, props) {
  const sideCount = points2.length / 3;
  if (sideCount < 3)
    throw new Error("need at least 3 points to build a prism");
  const { height, topCap, bottomCap } = { ...DefaultPrismProps, ...props };
  let triangleCount = sideCount * 2;
  let vertexCount = sideCount * 4;
  const capCount = (topCap ? 1 : 0) + (bottomCap ? 1 : 0);
  if (sideCount === 3) {
    triangleCount += capCount;
    vertexCount += capCount * 3;
  } else if (sideCount === 4) {
    triangleCount += capCount * 2;
    vertexCount += capCount * 4;
  } else {
    triangleCount += capCount * sideCount;
    vertexCount += capCount * sideCount * 3;
  }
  const builder = PrimitiveBuilder(triangleCount, vertexCount);
  const halfHeight = height * 0.5;
  Vec3.set(on, 0, 0, -halfHeight);
  Vec3.set(op, 0, 0, halfHeight);
  for (let i = 0; i < sideCount; ++i) {
    const ni = (i + 1) % sideCount;
    Vec3.set(a3, points2[i * 3], points2[i * 3 + 1], -halfHeight);
    Vec3.set(b3, points2[ni * 3], points2[ni * 3 + 1], -halfHeight);
    Vec3.set(c3, points2[ni * 3], points2[ni * 3 + 1], halfHeight);
    Vec3.set(d, points2[i * 3], points2[i * 3 + 1], halfHeight);
    builder.addQuad(a3, b3, c3, d);
  }
  if (sideCount === 3) {
    if (topCap) {
      Vec3.set(a3, points2[0], points2[1], -halfHeight);
      Vec3.set(b3, points2[3], points2[4], -halfHeight);
      Vec3.set(c3, points2[6], points2[7], -halfHeight);
      builder.add(c3, b3, a3);
    }
    if (bottomCap) {
      Vec3.set(a3, points2[0], points2[1], halfHeight);
      Vec3.set(b3, points2[3], points2[4], halfHeight);
      Vec3.set(c3, points2[6], points2[7], halfHeight);
      builder.add(a3, b3, c3);
    }
  } else if (sideCount === 4) {
    if (topCap) {
      Vec3.set(a3, points2[0], points2[1], -halfHeight);
      Vec3.set(b3, points2[3], points2[4], -halfHeight);
      Vec3.set(c3, points2[6], points2[7], -halfHeight);
      Vec3.set(d, points2[9], points2[10], -halfHeight);
      builder.addQuad(d, c3, b3, a3);
    }
    if (bottomCap) {
      Vec3.set(a3, points2[0], points2[1], halfHeight);
      Vec3.set(b3, points2[3], points2[4], halfHeight);
      Vec3.set(c3, points2[6], points2[7], halfHeight);
      Vec3.set(d, points2[9], points2[10], halfHeight);
      builder.addQuad(a3, b3, c3, d);
    }
  } else {
    for (let i = 0; i < sideCount; ++i) {
      const ni = (i + 1) % sideCount;
      if (topCap) {
        Vec3.set(a3, points2[i * 3], points2[i * 3 + 1], -halfHeight);
        Vec3.set(b3, points2[ni * 3], points2[ni * 3 + 1], -halfHeight);
        builder.add(on, b3, a3);
      }
      if (bottomCap) {
        Vec3.set(a3, points2[i * 3], points2[i * 3 + 1], halfHeight);
        Vec3.set(b3, points2[ni * 3], points2[ni * 3 + 1], halfHeight);
        builder.add(a3, b3, op);
      }
    }
  }
  return builder.getPrimitive();
}
var diamond;
function DiamondPrism() {
  if (!diamond)
    diamond = Prism(polygon(4, false));
  return diamond;
}
var pentagonalPrism;
function PentagonalPrism() {
  if (!pentagonalPrism)
    pentagonalPrism = Prism(polygon(5, false));
  return pentagonalPrism;
}
var hexagonalPrism;
function HexagonalPrism() {
  if (!hexagonalPrism)
    hexagonalPrism = Prism(polygon(6, false));
  return hexagonalPrism;
}
var shiftedHexagonalPrism;
function ShiftedHexagonalPrism() {
  if (!shiftedHexagonalPrism)
    shiftedHexagonalPrism = Prism(polygon(6, true));
  return shiftedHexagonalPrism;
}
var heptagonalPrism;
function HeptagonalPrism() {
  if (!heptagonalPrism)
    heptagonalPrism = Prism(polygon(7, false));
  return heptagonalPrism;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/mesh/builder/cylinder.js
var cylinderMap = /* @__PURE__ */ new Map();
var up = Vec3.create(0, 1, 0);
var tmpCylinderDir = Vec3();
var tmpCylinderMatDir = Vec3();
var tmpCylinderCenter = Vec3();
var tmpCylinderMat = Mat4();
var tmpCylinderMatRot = Mat4();
var tmpCylinderScale = Vec3();
var tmpCylinderStart = Vec3();
var tmpUp = Vec3();
function setCylinderMat(m, start, dir, length, matchDir) {
  Vec3.setMagnitude(tmpCylinderMatDir, dir, length / 2);
  Vec3.add(tmpCylinderCenter, start, tmpCylinderMatDir);
  if (matchDir)
    Vec3.matchDirection(tmpUp, up, tmpCylinderMatDir);
  else
    Vec3.copy(tmpUp, up);
  Vec3.set(tmpCylinderScale, 1, length, 1);
  Vec3.makeRotation(tmpCylinderMatRot, tmpUp, tmpCylinderMatDir);
  Mat4.scale(m, tmpCylinderMatRot, tmpCylinderScale);
  return Mat4.setTranslation(m, tmpCylinderCenter);
}
var tmpPropValues = new Int32Array(9);
function getCylinderPropsKey(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j;
  tmpPropValues[0] = Math.round(1e3 * ((_a = props.radiusTop) !== null && _a !== void 0 ? _a : DefaultCylinderProps.radiusTop));
  tmpPropValues[1] = Math.round(1e3 * ((_b = props.radiusBottom) !== null && _b !== void 0 ? _b : DefaultCylinderProps.radiusBottom));
  tmpPropValues[2] = Math.round(1e3 * ((_c = props.height) !== null && _c !== void 0 ? _c : DefaultCylinderProps.height));
  tmpPropValues[3] = (_d = props.radialSegments) !== null && _d !== void 0 ? _d : DefaultCylinderProps.radialSegments;
  tmpPropValues[4] = (_e = props.heightSegments) !== null && _e !== void 0 ? _e : DefaultCylinderProps.heightSegments;
  tmpPropValues[5] = ((_f = props.topCap) !== null && _f !== void 0 ? _f : DefaultCylinderProps.topCap) ? 1 : 0;
  tmpPropValues[6] = ((_g = props.bottomCap) !== null && _g !== void 0 ? _g : DefaultCylinderProps.bottomCap) ? 1 : 0;
  tmpPropValues[7] = Math.round(1e3 * ((_h = props.thetaStart) !== null && _h !== void 0 ? _h : DefaultCylinderProps.thetaStart));
  tmpPropValues[8] = Math.round(1e3 * ((_j = props.thetaLength) !== null && _j !== void 0 ? _j : DefaultCylinderProps.thetaLength));
  return hashFnv32a(tmpPropValues);
}
function getCylinder(props) {
  const key2 = getCylinderPropsKey(props);
  let cylinder = cylinderMap.get(key2);
  if (cylinder === void 0) {
    if (props.radialSegments && props.radialSegments <= 4) {
      const sideCount = Math.max(3, props.radialSegments);
      const prism = Prism(polygon(sideCount, true, props.radiusTop), props);
      cylinder = transformPrimitive(prism, Mat4.rotX90);
    } else {
      cylinder = Cylinder(props);
    }
    cylinderMap.set(key2, cylinder);
  }
  return cylinder;
}
function addSimpleCylinder(state, start, end, props) {
  const d3 = Vec3.distance(start, end);
  Vec3.sub(tmpCylinderDir, end, start);
  setCylinderMat(tmpCylinderMat, start, tmpCylinderDir, d3, false);
  MeshBuilder.addPrimitive(state, tmpCylinderMat, getCylinder(props));
}
function addCylinder(state, start, end, lengthScale, props) {
  const d3 = Vec3.distance(start, end) * lengthScale;
  Vec3.sub(tmpCylinderDir, end, start);
  setCylinderMat(tmpCylinderMat, start, tmpCylinderDir, d3, true);
  MeshBuilder.addPrimitive(state, tmpCylinderMat, getCylinder(props));
}
function addDoubleCylinder(state, start, end, lengthScale, shift, props) {
  const d3 = Vec3.distance(start, end) * lengthScale;
  const cylinder = getCylinder(props);
  Vec3.sub(tmpCylinderDir, end, start);
  Vec3.add(tmpCylinderStart, start, shift);
  setCylinderMat(tmpCylinderMat, tmpCylinderStart, tmpCylinderDir, d3, true);
  MeshBuilder.addPrimitive(state, tmpCylinderMat, cylinder);
  Vec3.sub(tmpCylinderStart, start, shift);
  setCylinderMat(tmpCylinderMat, tmpCylinderStart, tmpCylinderDir, d3, true);
  MeshBuilder.addPrimitive(state, tmpCylinderMat, cylinder);
}
function addFixedCountDashedCylinder(state, start, end, lengthScale, segmentCount, stubCap, props) {
  const d3 = Vec3.distance(start, end) * lengthScale;
  const isOdd = segmentCount % 2 !== 0;
  const s = Math.floor((segmentCount + 1) / 2);
  let step = d3 / (segmentCount + 0.5);
  let cylinder = getCylinder(props);
  Vec3.setMagnitude(tmpCylinderDir, Vec3.sub(tmpCylinderDir, end, start), step);
  Vec3.copy(tmpCylinderStart, start);
  for (let j = 0; j < s; ++j) {
    Vec3.add(tmpCylinderStart, tmpCylinderStart, tmpCylinderDir);
    if (isOdd && j === s - 1) {
      if (!stubCap && props.topCap) {
        props.topCap = false;
        cylinder = getCylinder(props);
      }
      step /= 2;
    }
    setCylinderMat(tmpCylinderMat, tmpCylinderStart, tmpCylinderDir, step, false);
    MeshBuilder.addPrimitive(state, tmpCylinderMat, cylinder);
    Vec3.add(tmpCylinderStart, tmpCylinderStart, tmpCylinderDir);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/mesh/mesh-builder.js
var tmpV4 = Vec3();
var tmpMat32 = Mat3();
var tmpVecA = Vec3();
var tmpVecB = Vec3();
var tmpVecC = Vec3();
var tmpVecD = Vec3();
var v3fromArray3 = Vec3.fromArray;
var v3triangleNormal = Vec3.triangleNormal;
var v3copy = Vec3.copy;
var v3transformMat4 = Vec3.transformMat4;
var v3transformMat3 = Vec3.transformMat3;
var mat3directionTransform = Mat3.directionTransform;
var caAdd3 = ChunkedArray.add3;
var caAdd = ChunkedArray.add;
var MeshBuilder;
(function(MeshBuilder2) {
  function createState2(initialCount = 2048, chunkSize = 1024, mesh) {
    return {
      currentGroup: -1,
      vertices: ChunkedArray.create(Float32Array, 3, chunkSize, mesh ? mesh.vertexBuffer.ref.value : initialCount),
      normals: ChunkedArray.create(Float32Array, 3, chunkSize, mesh ? mesh.normalBuffer.ref.value : initialCount),
      indices: ChunkedArray.create(Uint32Array, 3, chunkSize * 3, mesh ? mesh.indexBuffer.ref.value : initialCount * 3),
      groups: ChunkedArray.create(Float32Array, 1, chunkSize, mesh ? mesh.groupBuffer.ref.value : initialCount),
      mesh
    };
  }
  MeshBuilder2.createState = createState2;
  function addTriangle(state, a5, b5, c5) {
    const { vertices: vertices2, normals, indices: indices2, groups, currentGroup } = state;
    const offset = vertices2.elementCount;
    caAdd3(vertices2, a5[0], a5[1], a5[2]);
    caAdd3(vertices2, b5[0], b5[1], b5[2]);
    caAdd3(vertices2, c5[0], c5[1], c5[2]);
    v3triangleNormal(tmpV4, a5, b5, c5);
    for (let i = 0; i < 3; ++i) {
      caAdd3(normals, tmpV4[0], tmpV4[1], tmpV4[2]);
      caAdd(groups, currentGroup);
    }
    caAdd3(indices2, offset, offset + 1, offset + 2);
  }
  MeshBuilder2.addTriangle = addTriangle;
  function addTriangleWithNormal(state, a5, b5, c5, n) {
    const { vertices: vertices2, normals, indices: indices2, groups, currentGroup } = state;
    const offset = vertices2.elementCount;
    caAdd3(vertices2, a5[0], a5[1], a5[2]);
    caAdd3(vertices2, b5[0], b5[1], b5[2]);
    caAdd3(vertices2, c5[0], c5[1], c5[2]);
    for (let i = 0; i < 3; ++i) {
      caAdd3(normals, n[0], n[1], n[2]);
      caAdd(groups, currentGroup);
    }
    caAdd3(indices2, offset, offset + 1, offset + 2);
  }
  MeshBuilder2.addTriangleWithNormal = addTriangleWithNormal;
  function addTriangleStrip(state, vertices2, indices2) {
    v3fromArray3(tmpVecC, vertices2, indices2[0] * 3);
    v3fromArray3(tmpVecD, vertices2, indices2[1] * 3);
    for (let i = 2, il = indices2.length; i < il; i += 2) {
      v3copy(tmpVecA, tmpVecC);
      v3copy(tmpVecB, tmpVecD);
      v3fromArray3(tmpVecC, vertices2, indices2[i] * 3);
      v3fromArray3(tmpVecD, vertices2, indices2[i + 1] * 3);
      addTriangle(state, tmpVecA, tmpVecB, tmpVecC);
      addTriangle(state, tmpVecB, tmpVecD, tmpVecC);
    }
  }
  MeshBuilder2.addTriangleStrip = addTriangleStrip;
  function addTriangleFan(state, vertices2, indices2) {
    v3fromArray3(tmpVecA, vertices2, indices2[0] * 3);
    for (let i = 2, il = indices2.length; i < il; ++i) {
      v3fromArray3(tmpVecB, vertices2, indices2[i - 1] * 3);
      v3fromArray3(tmpVecC, vertices2, indices2[i] * 3);
      addTriangle(state, tmpVecA, tmpVecC, tmpVecB);
    }
  }
  MeshBuilder2.addTriangleFan = addTriangleFan;
  function addTriangleFanWithNormal(state, vertices2, indices2, normal) {
    v3fromArray3(tmpVecA, vertices2, indices2[0] * 3);
    for (let i = 2, il = indices2.length; i < il; ++i) {
      v3fromArray3(tmpVecB, vertices2, indices2[i - 1] * 3);
      v3fromArray3(tmpVecC, vertices2, indices2[i] * 3);
      addTriangleWithNormal(state, tmpVecA, tmpVecC, tmpVecB, normal);
    }
  }
  MeshBuilder2.addTriangleFanWithNormal = addTriangleFanWithNormal;
  function addPrimitive(state, t2, primitive) {
    const { vertices: va, normals: na, indices: ia } = primitive;
    const { vertices: vertices2, normals, indices: indices2, groups, currentGroup } = state;
    const offset = vertices2.elementCount;
    const n = mat3directionTransform(tmpMat32, t2);
    for (let i = 0, il = va.length; i < il; i += 3) {
      v3transformMat4(tmpV4, v3fromArray3(tmpV4, va, i), t2);
      caAdd3(vertices2, tmpV4[0], tmpV4[1], tmpV4[2]);
      v3transformMat3(tmpV4, v3fromArray3(tmpV4, na, i), n);
      caAdd3(normals, tmpV4[0], tmpV4[1], tmpV4[2]);
      caAdd(groups, currentGroup);
    }
    for (let i = 0, il = ia.length; i < il; i += 3) {
      caAdd3(indices2, ia[i] + offset, ia[i + 1] + offset, ia[i + 2] + offset);
    }
  }
  MeshBuilder2.addPrimitive = addPrimitive;
  function addPrimitiveFlipped(state, t2, primitive) {
    const { vertices: va, normals: na, indices: ia } = primitive;
    const { vertices: vertices2, normals, indices: indices2, groups, currentGroup } = state;
    const offset = vertices2.elementCount;
    const n = mat3directionTransform(tmpMat32, t2);
    for (let i = 0, il = va.length; i < il; i += 3) {
      v3transformMat4(tmpV4, v3fromArray3(tmpV4, va, i), t2);
      caAdd3(vertices2, tmpV4[0], tmpV4[1], tmpV4[2]);
      v3transformMat3(tmpV4, v3fromArray3(tmpV4, na, i), n);
      caAdd3(normals, -tmpV4[0], -tmpV4[1], -tmpV4[2]);
      caAdd(groups, currentGroup);
    }
    for (let i = 0, il = ia.length; i < il; i += 3) {
      caAdd3(indices2, ia[i + 2] + offset, ia[i + 1] + offset, ia[i] + offset);
    }
  }
  MeshBuilder2.addPrimitiveFlipped = addPrimitiveFlipped;
  function addCage(state, t2, cage, radius, detail, radialSegments) {
    const { vertices: va, edges: ea } = cage;
    const cylinderProps = { radiusTop: radius, radiusBottom: radius, radialSegments };
    for (let i = 0, il = ea.length; i < il; i += 2) {
      v3fromArray3(tmpVecA, va, ea[i] * 3);
      v3fromArray3(tmpVecB, va, ea[i + 1] * 3);
      v3transformMat4(tmpVecA, tmpVecA, t2);
      v3transformMat4(tmpVecB, tmpVecB, t2);
      addSphere(state, tmpVecA, radius, detail);
      addSphere(state, tmpVecB, radius, detail);
      addCylinder(state, tmpVecA, tmpVecB, 1, cylinderProps);
    }
  }
  MeshBuilder2.addCage = addCage;
  function addMesh(state, t2, mesh) {
    addPrimitive(state, t2, {
      vertices: mesh.vertexBuffer.ref.value.subarray(0, mesh.vertexCount * 3),
      normals: mesh.normalBuffer.ref.value.subarray(0, mesh.vertexCount * 3),
      indices: mesh.indexBuffer.ref.value.subarray(0, mesh.triangleCount * 3)
    });
  }
  MeshBuilder2.addMesh = addMesh;
  function getMesh2(state) {
    const { vertices: vertices2, normals, indices: indices2, groups, mesh } = state;
    const vb = ChunkedArray.compact(vertices2, true);
    const ib = ChunkedArray.compact(indices2, true);
    const nb = ChunkedArray.compact(normals, true);
    const gb = ChunkedArray.compact(groups, true);
    return Mesh.create(vb, ib, nb, gb, state.vertices.elementCount, state.indices.elementCount, mesh);
  }
  MeshBuilder2.getMesh = getMesh2;
})(MeshBuilder || (MeshBuilder = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/number-packing.js
function packIntToRGBArray(value, array, offset) {
  value = clamp(Math.round(value), 0, 16777216 - 1) + 1;
  array[offset + 2] = value % 256;
  value = Math.floor(value / 256);
  array[offset + 1] = value % 256;
  value = Math.floor(value / 256);
  array[offset] = value % 256;
  return array;
}
function unpackRGBToInt(r, g, b5) {
  return Math.floor(r) * 256 * 256 + Math.floor(g) * 256 + Math.floor(b5) - 1;
}
var UnpackDownscale = 255 / 256;
var PackFactors = Vec3.create(256 * 256 * 256, 256 * 256, 256);
var UnpackFactors = Vec4.create(UnpackDownscale / PackFactors[0], UnpackDownscale / PackFactors[1], UnpackDownscale / PackFactors[2], UnpackDownscale / 1);
var tmpDepthRGBA = Vec4();
function unpackRGBAToDepth(r, g, b5, a5) {
  Vec4.set(tmpDepthRGBA, r / 255, g / 255, b5 / 255, a5 / 255);
  return Vec4.dot(tmpDepthRGBA, UnpackFactors);
}
function arrayMaxPackedIntToRGB(array, stride) {
  let max3 = -Infinity;
  for (let i = 0, il = array.length; i < il; i += stride) {
    const v3 = unpackRGBToInt(array[i], array[i + 1], array[i + 2]);
    if (v3 > max3)
      max3 = v3;
  }
  return max3;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/size-data.js
function createSizes(locationIt, sizeTheme, sizeData) {
  switch (Geometry.getGranularity(locationIt, sizeTheme.granularity)) {
    case "uniform":
      return createUniformSize(locationIt, sizeTheme.size, sizeData);
    case "group":
      return createGroupSize(locationIt, sizeTheme.size, sizeData);
    case "groupInstance":
      return createGroupInstanceSize(locationIt, sizeTheme.size, sizeData);
    case "instance":
      return createInstanceSize(locationIt, sizeTheme.size, sizeData);
  }
}
var sizeDataFactor = 100;
function getMaxSize(sizeData) {
  const type = sizeData.dSizeType.ref.value;
  switch (type) {
    case "uniform":
      return sizeData.uSize.ref.value;
    case "instance":
    case "group":
    case "groupInstance":
      let maxSize = 0;
      const array = sizeData.tSize.ref.value.array;
      for (let i = 0, il = array.length; i < il; i += 3) {
        const value = unpackRGBToInt(array[i], array[i + 1], array[i + 2]);
        if (maxSize < value)
          maxSize = value;
      }
      return maxSize / sizeDataFactor;
  }
}
var emptySizeTexture = { array: new Uint8Array(3), width: 1, height: 1 };
function createEmptySizeTexture() {
  return {
    tSize: ValueCell.create(emptySizeTexture),
    uSizeTexDim: ValueCell.create(Vec2.create(1, 1))
  };
}
function createValueSize(value, sizeData) {
  if (sizeData) {
    ValueCell.update(sizeData.uSize, value);
    ValueCell.updateIfChanged(sizeData.dSizeType, "uniform");
    return sizeData;
  } else {
    return {
      uSize: ValueCell.create(value),
      ...createEmptySizeTexture(),
      dSizeType: ValueCell.create("uniform")
    };
  }
}
function createUniformSize(locationIt, sizeFn, sizeData) {
  return createValueSize(sizeFn(NullLocation), sizeData);
}
function createTextureSize(sizes, type, sizeData) {
  if (sizeData) {
    ValueCell.update(sizeData.tSize, sizes);
    ValueCell.update(sizeData.uSizeTexDim, Vec2.create(sizes.width, sizes.height));
    ValueCell.updateIfChanged(sizeData.dSizeType, type);
    return sizeData;
  } else {
    return {
      uSize: ValueCell.create(0),
      tSize: ValueCell.create(sizes),
      uSizeTexDim: ValueCell.create(Vec2.create(sizes.width, sizes.height)),
      dSizeType: ValueCell.create(type)
    };
  }
}
function createInstanceSize(locationIt, sizeFn, sizeData) {
  const { instanceCount } = locationIt;
  const sizes = createTextureImage(Math.max(1, instanceCount), 3, Uint8Array, sizeData && sizeData.tSize.ref.value.array);
  locationIt.reset();
  while (locationIt.hasNext && !locationIt.isNextNewInstance) {
    const v3 = locationIt.move();
    packIntToRGBArray(sizeFn(v3.location) * sizeDataFactor, sizes.array, v3.instanceIndex * 3);
    locationIt.skipInstance();
  }
  return createTextureSize(sizes, "instance", sizeData);
}
function createGroupSize(locationIt, sizeFn, sizeData) {
  const { groupCount } = locationIt;
  const sizes = createTextureImage(Math.max(1, groupCount), 3, Uint8Array, sizeData && sizeData.tSize.ref.value.array);
  locationIt.reset();
  while (locationIt.hasNext && !locationIt.isNextNewInstance) {
    const v3 = locationIt.move();
    packIntToRGBArray(sizeFn(v3.location) * sizeDataFactor, sizes.array, v3.groupIndex * 3);
  }
  return createTextureSize(sizes, "group", sizeData);
}
function createGroupInstanceSize(locationIt, sizeFn, sizeData) {
  const { groupCount, instanceCount } = locationIt;
  const count3 = instanceCount * groupCount;
  const sizes = createTextureImage(Math.max(1, count3), 3, Uint8Array, sizeData && sizeData.tSize.ref.value.array);
  locationIt.reset();
  while (locationIt.hasNext) {
    const v3 = locationIt.move();
    packIntToRGBArray(sizeFn(v3.location) * sizeDataFactor, sizes.array, v3.index * 3);
  }
  return createTextureSize(sizes, "groupInstance", sizeData);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/points/points.js
var Points;
(function(Points2) {
  function create(centers, groups, pointCount, points2) {
    return points2 ? update10(centers, groups, pointCount, points2) : fromArrays(centers, groups, pointCount);
  }
  Points2.create = create;
  function createEmpty(points2) {
    const cb2 = points2 ? points2.centerBuffer.ref.value : new Float32Array(0);
    const gb = points2 ? points2.groupBuffer.ref.value : new Float32Array(0);
    return create(cb2, gb, 0, points2);
  }
  Points2.createEmpty = createEmpty;
  function hashCode3(points2) {
    return hashFnv32a([
      points2.pointCount,
      points2.centerBuffer.ref.version,
      points2.groupBuffer.ref.version
    ]);
  }
  function fromArrays(centers, groups, pointCount) {
    const boundingSphere = Sphere3D();
    let groupMapping;
    let currentHash = -1;
    let currentGroup = -1;
    const points2 = {
      kind: "points",
      pointCount,
      centerBuffer: ValueCell.create(centers),
      groupBuffer: ValueCell.create(groups),
      get boundingSphere() {
        const newHash = hashCode3(points2);
        if (newHash !== currentHash) {
          const b5 = calculateInvariantBoundingSphere(points2.centerBuffer.ref.value, points2.pointCount, 1);
          Sphere3D.copy(boundingSphere, b5);
          currentHash = newHash;
        }
        return boundingSphere;
      },
      get groupMapping() {
        if (points2.groupBuffer.ref.version !== currentGroup) {
          groupMapping = createGroupMapping(points2.groupBuffer.ref.value, points2.pointCount);
          currentGroup = points2.groupBuffer.ref.version;
        }
        return groupMapping;
      },
      setBoundingSphere(sphere) {
        Sphere3D.copy(boundingSphere, sphere);
        currentHash = hashCode3(points2);
      }
    };
    return points2;
  }
  function update10(centers, groups, pointCount, points2) {
    points2.pointCount = pointCount;
    ValueCell.update(points2.centerBuffer, centers);
    ValueCell.update(points2.groupBuffer, groups);
    return points2;
  }
  function transform(points2, t2) {
    const c5 = points2.centerBuffer.ref.value;
    transformPositionArray(t2, c5, 0, points2.pointCount);
    ValueCell.update(points2.centerBuffer, c5);
  }
  Points2.transform = transform;
  Points2.StyleTypes = {
    "square": "Square",
    "circle": "Circle",
    "fuzzy": "Fuzzy"
  };
  Points2.StyleTypeNames = Object.keys(Points2.StyleTypes);
  Points2.Params = {
    ...BaseGeometry.Params,
    sizeFactor: ParamDefinition.Numeric(3, { min: 0, max: 10, step: 0.1 }),
    pointSizeAttenuation: ParamDefinition.Boolean(false),
    pointStyle: ParamDefinition.Select("square", ParamDefinition.objectToOptions(Points2.StyleTypes))
  };
  Points2.Utils = {
    Params: Points2.Params,
    createEmpty,
    createValues,
    createValuesSimple,
    updateValues,
    updateBoundingSphere,
    createRenderableState,
    updateRenderableState,
    createPositionIterator
  };
  function createPositionIterator(points2, transform2) {
    const groupCount = points2.pointCount;
    const instanceCount = transform2.instanceCount.ref.value;
    const location = PositionLocation();
    const p = location.position;
    const v3 = points2.centerBuffer.ref.value;
    const m = transform2.aTransform.ref.value;
    const getLocation = (groupIndex, instanceIndex) => {
      if (instanceIndex < 0) {
        Vec3.fromArray(p, v3, groupIndex * 3);
      } else {
        Vec3.transformMat4Offset(p, v3, m, 0, groupIndex * 3, instanceIndex * 16);
      }
      return location;
    };
    return LocationIterator(groupCount, instanceCount, 1, getLocation);
  }
  function createValues(points2, transform2, locationIt, theme, props) {
    const { instanceCount, groupCount } = locationIt;
    const positionIt = createPositionIterator(points2, transform2);
    const color = createColors(locationIt, positionIt, theme.color);
    const size = createSizes(locationIt, theme.size);
    const marker = props.instanceGranularity ? createMarkers(instanceCount, "instance") : createMarkers(instanceCount * groupCount, "groupInstance");
    const overpaint = createEmptyOverpaint();
    const transparency = createEmptyTransparency();
    const emissive = createEmptyEmissive();
    const material = createEmptySubstance();
    const clipping = createEmptyClipping();
    const counts = { drawCount: points2.pointCount, vertexCount: points2.pointCount, groupCount, instanceCount };
    const invariantBoundingSphere = Sphere3D.clone(points2.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform2.aTransform.ref.value, instanceCount, 0);
    return {
      dGeometryType: ValueCell.create("points"),
      aPosition: points2.centerBuffer,
      aGroup: points2.groupBuffer,
      boundingSphere: ValueCell.create(boundingSphere),
      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),
      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)),
      ...color,
      ...size,
      ...marker,
      ...overpaint,
      ...transparency,
      ...emissive,
      ...material,
      ...clipping,
      ...transform2,
      ...BaseGeometry.createValues(props, counts),
      uSizeFactor: ValueCell.create(props.sizeFactor),
      dPointSizeAttenuation: ValueCell.create(props.pointSizeAttenuation),
      dPointStyle: ValueCell.create(props.pointStyle)
    };
  }
  function createValuesSimple(points2, props, colorValue, sizeValue, transform2) {
    const s = BaseGeometry.createSimple(colorValue, sizeValue, transform2);
    const p = { ...ParamDefinition.getDefaultValues(Points2.Params), ...props };
    return createValues(points2, s.transform, s.locationIterator, s.theme, p);
  }
  function updateValues(values2, props) {
    BaseGeometry.updateValues(values2, props);
    ValueCell.updateIfChanged(values2.uSizeFactor, props.sizeFactor);
    ValueCell.updateIfChanged(values2.dPointSizeAttenuation, props.pointSizeAttenuation);
    ValueCell.updateIfChanged(values2.dPointStyle, props.pointStyle);
  }
  function updateBoundingSphere(values2, points2) {
    const invariantBoundingSphere = Sphere3D.clone(points2.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values2.aTransform.ref.value, values2.instanceCount.ref.value, 0);
    if (!Sphere3D.equals(boundingSphere, values2.boundingSphere.ref.value)) {
      ValueCell.update(values2.boundingSphere, boundingSphere);
    }
    if (!Sphere3D.equals(invariantBoundingSphere, values2.invariantBoundingSphere.ref.value)) {
      ValueCell.update(values2.invariantBoundingSphere, invariantBoundingSphere);
      ValueCell.update(values2.uInvariantBoundingSphere, Vec4.fromSphere(values2.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));
    }
  }
  function createRenderableState(props) {
    const state = BaseGeometry.createRenderableState(props);
    updateRenderableState(state, props);
    return state;
  }
  function updateRenderableState(state, props) {
    BaseGeometry.updateRenderableState(state, props);
    state.opaque = state.opaque && props.pointStyle !== "fuzzy";
    state.writeDepth = state.opaque;
  }
})(Points || (Points = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/distance-transform.js
function edt(data, width, height, f, d3, v3, z) {
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      f[y] = data[y * width + x];
    }
    edt1d(f, d3, v3, z, height);
    for (let y = 0; y < height; y++) {
      data[y * width + x] = d3[y];
    }
  }
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      f[x] = data[y * width + x];
    }
    edt1d(f, d3, v3, z, width);
    for (let x = 0; x < width; x++) {
      data[y * width + x] = Math.sqrt(d3[x]);
    }
  }
}
function edt1d(f, d3, v3, z, n) {
  v3[0] = 0;
  z[0] = Number.MIN_SAFE_INTEGER;
  z[1] = Number.MAX_SAFE_INTEGER;
  for (let q = 1, k = 0; q < n; q++) {
    let s = (f[q] + q * q - (f[v3[k]] + v3[k] * v3[k])) / (2 * q - 2 * v3[k]);
    while (s <= z[k]) {
      k--;
      s = (f[q] + q * q - (f[v3[k]] + v3[k] * v3[k])) / (2 * q - 2 * v3[k]);
    }
    k++;
    v3[k] = q;
    z[k] = s;
    z[k + 1] = Number.MAX_SAFE_INTEGER;
  }
  for (let q = 0, k = 0; q < n; q++) {
    while (z[k + 1] < q)
      k++;
    d3[q] = (q - v3[k]) * (q - v3[k]) + f[v3[k]];
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/text/font-atlas.js
var TextAtlasCache = {};
function getFontAtlas(props) {
  const hash3 = JSON.stringify(props);
  if (TextAtlasCache[hash3] === void 0) {
    TextAtlasCache[hash3] = new FontAtlas(props);
  }
  return TextAtlasCache[hash3];
}
var FontAtlasParams = {
  fontFamily: ParamDefinition.Select("sans-serif", [["sans-serif", "Sans Serif"], ["monospace", "Monospace"], ["serif", "Serif"], ["cursive", "Cursive"]]),
  fontQuality: ParamDefinition.Select(3, [[0, "lower"], [1, "low"], [2, "medium"], [3, "high"], [4, "higher"]]),
  fontStyle: ParamDefinition.Select("normal", [["normal", "Normal"], ["italic", "Italic"], ["oblique", "Oblique"]]),
  fontVariant: ParamDefinition.Select("normal", [["normal", "Normal"], ["small-caps", "Small Caps"]]),
  fontWeight: ParamDefinition.Select("normal", [["normal", "Normal"], ["bold", "Bold"]])
};
var FontAtlas = class {
  constructor(props = {}) {
    this.mapped = {};
    this.scratchW = 0;
    this.scratchH = 0;
    this.currentX = 0;
    this.currentY = 0;
    this.cutoff = 0.5;
    const p = { ...ParamDefinition.getDefaultValues(FontAtlasParams), ...props };
    this.props = p;
    const fontSize = 32 * (p.fontQuality + 1);
    this.buffer = fontSize / 8;
    this.radius = fontSize / 3;
    this.lineHeight = Math.round(fontSize + 2 * this.buffer + this.radius);
    this.maxWidth = Math.round(this.lineHeight * 0.75);
    this.texture = createTextureImage(350 * this.lineHeight * this.maxWidth, 1, Uint8Array);
    this.scratchContext = createCanvasContext(this.maxWidth, this.lineHeight, { willReadFrequently: true });
    this.scratchContext.font = `${p.fontStyle} ${p.fontVariant} ${p.fontWeight} ${fontSize}px ${p.fontFamily}`;
    this.scratchContext.fillStyle = "black";
    this.scratchContext.textBaseline = "middle";
    this.scratchData = new Uint8Array(this.lineHeight * this.maxWidth);
    this.gridOuter = new Float64Array(this.lineHeight * this.maxWidth);
    this.gridInner = new Float64Array(this.lineHeight * this.maxWidth);
    this.f = new Float64Array(Math.max(this.lineHeight, this.maxWidth));
    this.d = new Float64Array(Math.max(this.lineHeight, this.maxWidth));
    this.z = new Float64Array(Math.max(this.lineHeight, this.maxWidth) + 1);
    this.v = new Int16Array(Math.max(this.lineHeight, this.maxWidth));
    this.middle = Math.ceil(this.lineHeight / 2);
    this.placeholder = this.get(String.fromCharCode(65533));
  }
  get(char) {
    if (this.mapped[char] === void 0) {
      this.draw(char);
      const { array, width, height } = this.texture;
      const data = this.scratchData;
      if (this.currentX + this.scratchW > width) {
        this.currentX = 0;
        this.currentY += this.scratchH;
      }
      if (this.currentY + this.scratchH > height) {
        console.warn("canvas to small");
        return this.placeholder;
      }
      this.mapped[char] = {
        x: this.currentX,
        y: this.currentY,
        w: this.scratchW,
        h: this.scratchH,
        nw: this.scratchW / this.lineHeight,
        nh: this.scratchH / this.lineHeight
      };
      for (let y = 0; y < this.scratchH; ++y) {
        for (let x = 0; x < this.scratchW; ++x) {
          array[width * (this.currentY + y) + this.currentX + x] = data[y * this.scratchW + x];
        }
      }
      this.currentX += this.scratchW;
    }
    return this.mapped[char];
  }
  draw(char) {
    const h = this.lineHeight;
    const ctx = this.scratchContext;
    const data = this.scratchData;
    const m = ctx.measureText(char);
    const w = Math.min(this.maxWidth, Math.ceil(m.width + 2 * this.buffer));
    const n = w * h;
    ctx.clearRect(0, 0, w, h);
    ctx.fillText(char, this.buffer, this.middle);
    const imageData = ctx.getImageData(0, 0, w, h);
    for (let i = 0; i < n; i++) {
      const a5 = imageData.data[i * 4 + 3] / 255;
      this.gridOuter[i] = a5 === 1 ? 0 : a5 === 0 ? Number.MAX_SAFE_INTEGER : Math.pow(Math.max(0, 0.5 - a5), 2);
      this.gridInner[i] = a5 === 1 ? Number.MAX_SAFE_INTEGER : a5 === 0 ? 0 : Math.pow(Math.max(0, a5 - 0.5), 2);
    }
    edt(this.gridOuter, w, h, this.f, this.d, this.v, this.z);
    edt(this.gridInner, w, h, this.f, this.d, this.v, this.z);
    for (let i = 0; i < n; i++) {
      const d3 = this.gridOuter[i] - this.gridInner[i];
      data[i] = Math.max(0, Math.min(255, Math.round(255 - 255 * (d3 / this.radius + this.cutoff))));
    }
    this.scratchW = w;
    this.scratchH = h;
  }
};
var _canvas;
function getCanvasModule() {
  if (!_canvas)
    throw new Error("When running in Node.js and wanting to use Canvas API, call mol-util/data-source's setCanvasModule function first and pass imported `canvas` module to it.");
  return _canvas;
}
function createCanvasContext(width, height, options) {
  if (RUNNING_IN_NODEJS) {
    const canvas = getCanvasModule().createCanvas(width, height);
    return canvas.getContext("2d", options);
  } else {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas.getContext("2d", options);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/text/text.js
var Text;
(function(Text2) {
  function create(fontTexture, centers, mappings, depths, indices2, groups, tcoords, charCount, text) {
    return text ? update10(fontTexture, centers, mappings, depths, indices2, groups, tcoords, charCount, text) : fromData(fontTexture, centers, mappings, depths, indices2, groups, tcoords, charCount);
  }
  Text2.create = create;
  function createEmpty(text) {
    const ft = text ? text.fontTexture.ref.value : createTextureImage(0, 1, Uint8Array);
    const cb2 = text ? text.centerBuffer.ref.value : new Float32Array(0);
    const mb = text ? text.mappingBuffer.ref.value : new Float32Array(0);
    const db = text ? text.depthBuffer.ref.value : new Float32Array(0);
    const ib = text ? text.indexBuffer.ref.value : new Uint32Array(0);
    const gb = text ? text.groupBuffer.ref.value : new Float32Array(0);
    const tb = text ? text.tcoordBuffer.ref.value : new Float32Array(0);
    return create(ft, cb2, mb, db, ib, gb, tb, 0, text);
  }
  Text2.createEmpty = createEmpty;
  function hashCode3(text) {
    return hashFnv32a([
      text.charCount,
      text.fontTexture.ref.version,
      text.centerBuffer.ref.version,
      text.mappingBuffer.ref.version,
      text.depthBuffer.ref.version,
      text.indexBuffer.ref.version,
      text.groupBuffer.ref.version,
      text.tcoordBuffer.ref.version
    ]);
  }
  function fromData(fontTexture, centers, mappings, depths, indices2, groups, tcoords, charCount) {
    const boundingSphere = Sphere3D();
    let groupMapping;
    let currentHash = -1;
    let currentGroup = -1;
    const text = {
      kind: "text",
      charCount,
      fontTexture: ValueCell.create(fontTexture),
      centerBuffer: ValueCell.create(centers),
      mappingBuffer: ValueCell.create(mappings),
      depthBuffer: ValueCell.create(depths),
      indexBuffer: ValueCell.create(indices2),
      groupBuffer: ValueCell.create(groups),
      tcoordBuffer: ValueCell.create(tcoords),
      get boundingSphere() {
        const newHash = hashCode3(text);
        if (newHash !== currentHash) {
          const b5 = calculateInvariantBoundingSphere(text.centerBuffer.ref.value, text.charCount * 4, 4);
          Sphere3D.copy(boundingSphere, b5);
          currentHash = newHash;
        }
        return boundingSphere;
      },
      get groupMapping() {
        if (text.groupBuffer.ref.version !== currentGroup) {
          groupMapping = createGroupMapping(text.groupBuffer.ref.value, text.charCount, 4);
          currentGroup = text.groupBuffer.ref.version;
        }
        return groupMapping;
      },
      setBoundingSphere(sphere) {
        Sphere3D.copy(boundingSphere, sphere);
        currentHash = hashCode3(text);
      }
    };
    return text;
  }
  function update10(fontTexture, centers, mappings, depths, indices2, groups, tcoords, charCount, text) {
    text.charCount = charCount;
    ValueCell.update(text.fontTexture, fontTexture);
    ValueCell.update(text.centerBuffer, centers);
    ValueCell.update(text.mappingBuffer, mappings);
    ValueCell.update(text.depthBuffer, depths);
    ValueCell.update(text.indexBuffer, indices2);
    ValueCell.update(text.groupBuffer, groups);
    ValueCell.update(text.tcoordBuffer, tcoords);
    return text;
  }
  Text2.Params = {
    ...BaseGeometry.Params,
    ...FontAtlasParams,
    sizeFactor: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }),
    borderWidth: ParamDefinition.Numeric(0, { min: 0, max: 0.5, step: 0.01 }),
    borderColor: ParamDefinition.Color(ColorNames.grey),
    offsetX: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }),
    offsetY: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }),
    offsetZ: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }),
    background: ParamDefinition.Boolean(false),
    backgroundMargin: ParamDefinition.Numeric(0.2, { min: 0, max: 1, step: 0.01 }),
    backgroundColor: ParamDefinition.Color(ColorNames.grey),
    backgroundOpacity: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.01 }),
    tether: ParamDefinition.Boolean(false),
    tetherLength: ParamDefinition.Numeric(1, { min: 0, max: 5, step: 0.1 }),
    tetherBaseWidth: ParamDefinition.Numeric(0.3, { min: 0, max: 1, step: 0.01 }),
    attachment: ParamDefinition.Select("middle-center", [
      ["bottom-left", "bottom-left"],
      ["bottom-center", "bottom-center"],
      ["bottom-right", "bottom-right"],
      ["middle-left", "middle-left"],
      ["middle-center", "middle-center"],
      ["middle-right", "middle-right"],
      ["top-left", "top-left"],
      ["top-center", "top-center"],
      ["top-right", "top-right"]
    ])
  };
  Text2.Utils = {
    Params: Text2.Params,
    createEmpty,
    createValues,
    createValuesSimple,
    updateValues,
    updateBoundingSphere,
    createRenderableState,
    updateRenderableState,
    createPositionIterator
  };
  function createPositionIterator(text, transform) {
    const groupCount = text.charCount * 4;
    const instanceCount = transform.instanceCount.ref.value;
    const location = PositionLocation();
    const p = location.position;
    const v3 = text.centerBuffer.ref.value;
    const m = transform.aTransform.ref.value;
    const getLocation = (groupIndex, instanceIndex) => {
      if (instanceIndex < 0) {
        Vec3.fromArray(p, v3, groupIndex * 3);
      } else {
        Vec3.transformMat4Offset(p, v3, m, 0, groupIndex * 3, instanceIndex * 16);
      }
      return location;
    };
    return LocationIterator(groupCount, instanceCount, 4, getLocation);
  }
  function createValues(text, transform, locationIt, theme, props) {
    const { instanceCount, groupCount } = locationIt;
    const positionIt = createPositionIterator(text, transform);
    const color = createColors(locationIt, positionIt, theme.color);
    const size = createSizes(locationIt, theme.size);
    const marker = props.instanceGranularity ? createMarkers(instanceCount, "instance") : createMarkers(instanceCount * groupCount, "groupInstance");
    const overpaint = createEmptyOverpaint();
    const transparency = createEmptyTransparency();
    const emissive = createEmptyEmissive();
    const substance = createEmptySubstance();
    const clipping = createEmptyClipping();
    const counts = { drawCount: text.charCount * 2 * 3, vertexCount: text.charCount * 4, groupCount, instanceCount };
    const padding2 = getPadding(text.mappingBuffer.ref.value, text.depthBuffer.ref.value, text.charCount, getMaxSize(size));
    const invariantBoundingSphere = Sphere3D.expand(Sphere3D(), text.boundingSphere, padding2);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount, 0);
    return {
      dGeometryType: ValueCell.create("text"),
      aPosition: text.centerBuffer,
      aMapping: text.mappingBuffer,
      aDepth: text.depthBuffer,
      aGroup: text.groupBuffer,
      elements: text.indexBuffer,
      boundingSphere: ValueCell.create(boundingSphere),
      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),
      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)),
      ...color,
      ...size,
      ...marker,
      ...overpaint,
      ...transparency,
      ...emissive,
      ...substance,
      ...clipping,
      ...transform,
      aTexCoord: text.tcoordBuffer,
      tFont: text.fontTexture,
      padding: ValueCell.create(padding2),
      ...BaseGeometry.createValues(props, counts),
      uSizeFactor: ValueCell.create(props.sizeFactor),
      uBorderWidth: ValueCell.create(clamp(props.borderWidth, 0, 0.5)),
      uBorderColor: ValueCell.create(Color.toArrayNormalized(props.borderColor, Vec3.zero(), 0)),
      uOffsetX: ValueCell.create(props.offsetX),
      uOffsetY: ValueCell.create(props.offsetY),
      uOffsetZ: ValueCell.create(props.offsetZ),
      uBackgroundColor: ValueCell.create(Color.toArrayNormalized(props.backgroundColor, Vec3.zero(), 0)),
      uBackgroundOpacity: ValueCell.create(props.backgroundOpacity)
    };
  }
  function createValuesSimple(text, props, colorValue, sizeValue, transform) {
    const s = BaseGeometry.createSimple(colorValue, sizeValue, transform);
    const p = { ...ParamDefinition.getDefaultValues(Text2.Params), ...props };
    return createValues(text, s.transform, s.locationIterator, s.theme, p);
  }
  function updateValues(values2, props) {
    BaseGeometry.updateValues(values2, props);
    ValueCell.updateIfChanged(values2.uSizeFactor, props.sizeFactor);
    ValueCell.updateIfChanged(values2.uBorderWidth, props.borderWidth);
    if (Color.fromNormalizedArray(values2.uBorderColor.ref.value, 0) !== props.borderColor) {
      Color.toArrayNormalized(props.borderColor, values2.uBorderColor.ref.value, 0);
      ValueCell.update(values2.uBorderColor, values2.uBorderColor.ref.value);
    }
    ValueCell.updateIfChanged(values2.uOffsetX, props.offsetX);
    ValueCell.updateIfChanged(values2.uOffsetY, props.offsetY);
    ValueCell.updateIfChanged(values2.uOffsetZ, props.offsetZ);
    if (Color.fromNormalizedArray(values2.uBackgroundColor.ref.value, 0) !== props.backgroundColor) {
      Color.toArrayNormalized(props.backgroundColor, values2.uBackgroundColor.ref.value, 0);
      ValueCell.update(values2.uBackgroundColor, values2.uBackgroundColor.ref.value);
    }
    ValueCell.updateIfChanged(values2.uBackgroundOpacity, props.backgroundOpacity);
  }
  function updateBoundingSphere(values2, text) {
    const padding2 = getPadding(values2.aMapping.ref.value, values2.aDepth.ref.value, text.charCount, getMaxSize(values2));
    const invariantBoundingSphere = Sphere3D.expand(Sphere3D(), text.boundingSphere, padding2);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values2.aTransform.ref.value, values2.instanceCount.ref.value, 0);
    if (!Sphere3D.equals(boundingSphere, values2.boundingSphere.ref.value)) {
      ValueCell.update(values2.boundingSphere, boundingSphere);
    }
    if (!Sphere3D.equals(invariantBoundingSphere, values2.invariantBoundingSphere.ref.value)) {
      ValueCell.update(values2.invariantBoundingSphere, invariantBoundingSphere);
      ValueCell.update(values2.uInvariantBoundingSphere, Vec4.fromSphere(values2.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));
    }
    ValueCell.update(values2.padding, padding2);
  }
  function createRenderableState(props) {
    const state = BaseGeometry.createRenderableState(props);
    updateRenderableState(state, props);
    return state;
  }
  function updateRenderableState(state, props) {
    BaseGeometry.updateRenderableState(state, props);
    state.pickable = false;
    state.opaque = false;
    state.writeDepth = true;
  }
})(Text || (Text = {}));
function getPadding(mappings, depths, charCount, maxSize) {
  let maxOffset = 0;
  let maxDepth = 0;
  for (let i = 0, il = charCount * 4; i < il; ++i) {
    const i2 = 2 * i;
    const ox = Math.abs(mappings[i2]);
    if (ox > maxOffset)
      maxOffset = ox;
    const oy = Math.abs(mappings[i2 + 1]);
    if (oy > maxOffset)
      maxOffset = oy;
    const d3 = Math.abs(depths[i]);
    if (d3 > maxDepth)
      maxDepth = d3;
  }
  return Math.max(maxDepth, maxSize + maxSize * maxOffset);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/lines/lines-builder.js
var tmpVecA2 = Vec3();
var tmpVecB2 = Vec3();
var tmpDir = Vec3();
var caAdd2 = ChunkedArray.add;
var caAdd32 = ChunkedArray.add3;
var LinesBuilder;
(function(LinesBuilder2) {
  function create(initialCount = 2048, chunkSize = 1024, lines) {
    const groups = ChunkedArray.create(Float32Array, 1, chunkSize, lines ? lines.groupBuffer.ref.value : initialCount);
    const starts = ChunkedArray.create(Float32Array, 3, chunkSize, lines ? lines.startBuffer.ref.value : initialCount);
    const ends = ChunkedArray.create(Float32Array, 3, chunkSize, lines ? lines.endBuffer.ref.value : initialCount);
    const add = (startX, startY, startZ, endX, endY, endZ, group) => {
      for (let i = 0; i < 4; ++i) {
        caAdd32(starts, startX, startY, startZ);
        caAdd32(ends, endX, endY, endZ);
        caAdd2(groups, group);
      }
    };
    const addVec = (start, end, group) => {
      for (let i = 0; i < 4; ++i) {
        caAdd32(starts, start[0], start[1], start[2]);
        caAdd32(ends, end[0], end[1], end[2]);
        caAdd2(groups, group);
      }
    };
    const addFixedCountDashes = (start, end, segmentCount, group) => {
      const d3 = Vec3.distance(start, end);
      const isOdd = segmentCount % 2 !== 0;
      const s = Math.floor((segmentCount + 1) / 2);
      const step = d3 / (segmentCount + 0.5);
      Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, end, start), step);
      Vec3.copy(tmpVecA2, start);
      for (let j = 0; j < s; ++j) {
        Vec3.add(tmpVecA2, tmpVecA2, tmpDir);
        if (isOdd && j === s - 1) {
          Vec3.copy(tmpVecB2, end);
        } else {
          Vec3.add(tmpVecB2, tmpVecA2, tmpDir);
        }
        add(tmpVecA2[0], tmpVecA2[1], tmpVecA2[2], tmpVecB2[0], tmpVecB2[1], tmpVecB2[2], group);
        Vec3.add(tmpVecA2, tmpVecA2, tmpDir);
      }
    };
    return {
      add,
      addVec,
      addFixedCountDashes,
      addFixedLengthDashes: (start, end, segmentLength, group) => {
        const d3 = Vec3.distance(start, end);
        addFixedCountDashes(start, end, d3 / segmentLength, group);
      },
      addCage: (t2, cage, group) => {
        const { vertices: vertices2, edges } = cage;
        for (let i = 0, il = edges.length; i < il; i += 2) {
          Vec3.fromArray(tmpVecA2, vertices2, edges[i] * 3);
          Vec3.fromArray(tmpVecB2, vertices2, edges[i + 1] * 3);
          Vec3.transformMat4(tmpVecA2, tmpVecA2, t2);
          Vec3.transformMat4(tmpVecB2, tmpVecB2, t2);
          add(tmpVecA2[0], tmpVecA2[1], tmpVecA2[2], tmpVecB2[0], tmpVecB2[1], tmpVecB2[2], group);
        }
      },
      getLines: () => {
        const lineCount = groups.elementCount / 4;
        const gb = ChunkedArray.compact(groups, true);
        const sb = ChunkedArray.compact(starts, true);
        const eb = ChunkedArray.compact(ends, true);
        const mb = lines && lineCount <= lines.lineCount ? lines.mappingBuffer.ref.value : new Float32Array(lineCount * 8);
        const ib = lines && lineCount <= lines.lineCount ? lines.indexBuffer.ref.value : new Uint32Array(lineCount * 6);
        if (!lines || lineCount > lines.lineCount)
          fillMappingAndIndices(lineCount, mb, ib);
        return Lines.create(mb, ib, gb, sb, eb, lineCount, lines);
      }
    };
  }
  LinesBuilder2.create = create;
})(LinesBuilder || (LinesBuilder = {}));
function fillMappingAndIndices(n, mb, ib) {
  for (let i = 0; i < n; ++i) {
    const mo = i * 8;
    mb[mo] = -1;
    mb[mo + 1] = -1;
    mb[mo + 2] = 1;
    mb[mo + 3] = -1;
    mb[mo + 4] = -1;
    mb[mo + 5] = 1;
    mb[mo + 6] = 1;
    mb[mo + 7] = 1;
  }
  for (let i = 0; i < n; ++i) {
    const o = i * 4;
    const io = i * 6;
    ib[io] = o;
    ib[io + 1] = o + 1;
    ib[io + 2] = o + 2;
    ib[io + 3] = o + 1;
    ib[io + 4] = o + 3;
    ib[io + 5] = o + 2;
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/lines/lines.js
var Lines;
(function(Lines2) {
  function create(mappings, indices2, groups, starts, ends, lineCount, lines) {
    return lines ? update10(mappings, indices2, groups, starts, ends, lineCount, lines) : fromArrays(mappings, indices2, groups, starts, ends, lineCount);
  }
  Lines2.create = create;
  function createEmpty(lines) {
    const mb = lines ? lines.mappingBuffer.ref.value : new Float32Array(0);
    const ib = lines ? lines.indexBuffer.ref.value : new Uint32Array(0);
    const gb = lines ? lines.groupBuffer.ref.value : new Float32Array(0);
    const sb = lines ? lines.startBuffer.ref.value : new Float32Array(0);
    const eb = lines ? lines.endBuffer.ref.value : new Float32Array(0);
    return create(mb, ib, gb, sb, eb, 0, lines);
  }
  Lines2.createEmpty = createEmpty;
  function fromMesh(mesh, lines) {
    const vb = mesh.vertexBuffer.ref.value;
    const ib = mesh.indexBuffer.ref.value;
    const gb = mesh.groupBuffer.ref.value;
    const builder = LinesBuilder.create(mesh.triangleCount * 3, mesh.triangleCount / 10, lines);
    for (let i = 0, il = mesh.triangleCount * 3; i < il; i += 3) {
      const i0 = ib[i], i1 = ib[i + 1], i2 = ib[i + 2];
      const x0 = vb[i0 * 3], y0 = vb[i0 * 3 + 1], z0 = vb[i0 * 3 + 2];
      const x1 = vb[i1 * 3], y1 = vb[i1 * 3 + 1], z1 = vb[i1 * 3 + 2];
      const x2 = vb[i2 * 3], y2 = vb[i2 * 3 + 1], z2 = vb[i2 * 3 + 2];
      builder.add(x0, y0, z0, x1, y1, z1, gb[i0]);
      builder.add(x0, y0, z0, x2, y2, z2, gb[i0]);
      builder.add(x1, y1, z1, x2, y2, z2, gb[i1]);
    }
    return builder.getLines();
  }
  Lines2.fromMesh = fromMesh;
  function hashCode3(lines) {
    return hashFnv32a([
      lines.lineCount,
      lines.mappingBuffer.ref.version,
      lines.indexBuffer.ref.version,
      lines.groupBuffer.ref.version,
      lines.startBuffer.ref.version,
      lines.endBuffer.ref.version
    ]);
  }
  function fromArrays(mappings, indices2, groups, starts, ends, lineCount) {
    const boundingSphere = Sphere3D();
    let groupMapping;
    let currentHash = -1;
    let currentGroup = -1;
    const lines = {
      kind: "lines",
      lineCount,
      mappingBuffer: ValueCell.create(mappings),
      indexBuffer: ValueCell.create(indices2),
      groupBuffer: ValueCell.create(groups),
      startBuffer: ValueCell.create(starts),
      endBuffer: ValueCell.create(ends),
      get boundingSphere() {
        const newHash = hashCode3(lines);
        if (newHash !== currentHash) {
          const s = calculateInvariantBoundingSphere(lines.startBuffer.ref.value, lines.lineCount * 4, 4);
          const e = calculateInvariantBoundingSphere(lines.endBuffer.ref.value, lines.lineCount * 4, 4);
          Sphere3D.expandBySphere(boundingSphere, s, e);
          currentHash = newHash;
        }
        return boundingSphere;
      },
      get groupMapping() {
        if (lines.groupBuffer.ref.version !== currentGroup) {
          groupMapping = createGroupMapping(lines.groupBuffer.ref.value, lines.lineCount, 4);
          currentGroup = lines.groupBuffer.ref.version;
        }
        return groupMapping;
      },
      setBoundingSphere(sphere) {
        Sphere3D.copy(boundingSphere, sphere);
        currentHash = hashCode3(lines);
      }
    };
    return lines;
  }
  function update10(mappings, indices2, groups, starts, ends, lineCount, lines) {
    if (lineCount > lines.lineCount) {
      ValueCell.update(lines.mappingBuffer, mappings);
      ValueCell.update(lines.indexBuffer, indices2);
    }
    lines.lineCount = lineCount;
    ValueCell.update(lines.groupBuffer, groups);
    ValueCell.update(lines.startBuffer, starts);
    ValueCell.update(lines.endBuffer, ends);
    return lines;
  }
  function transform(lines, t2) {
    const start = lines.startBuffer.ref.value;
    transformPositionArray(t2, start, 0, lines.lineCount * 4);
    ValueCell.update(lines.startBuffer, start);
    const end = lines.endBuffer.ref.value;
    transformPositionArray(t2, end, 0, lines.lineCount * 4);
    ValueCell.update(lines.endBuffer, end);
  }
  Lines2.transform = transform;
  Lines2.Params = {
    ...BaseGeometry.Params,
    sizeFactor: ParamDefinition.Numeric(2, { min: 0, max: 10, step: 0.1 }),
    lineSizeAttenuation: ParamDefinition.Boolean(false)
  };
  Lines2.Utils = {
    Params: Lines2.Params,
    createEmpty,
    createValues,
    createValuesSimple,
    updateValues,
    updateBoundingSphere,
    createRenderableState: BaseGeometry.createRenderableState,
    updateRenderableState: BaseGeometry.updateRenderableState,
    createPositionIterator
  };
  function createPositionIterator(lines, transform2) {
    const groupCount = lines.lineCount * 4;
    const instanceCount = transform2.instanceCount.ref.value;
    const location = PositionLocation();
    const p = location.position;
    const s = lines.startBuffer.ref.value;
    const e = lines.endBuffer.ref.value;
    const m = transform2.aTransform.ref.value;
    const getLocation = (groupIndex, instanceIndex) => {
      const v3 = groupIndex % 4 === 0 ? s : e;
      if (instanceIndex < 0) {
        Vec3.fromArray(p, v3, groupIndex * 3);
      } else {
        Vec3.transformMat4Offset(p, v3, m, 0, groupIndex * 3, instanceIndex * 16);
      }
      return location;
    };
    return LocationIterator(groupCount, instanceCount, 2, getLocation);
  }
  function createValues(lines, transform2, locationIt, theme, props) {
    const { instanceCount, groupCount } = locationIt;
    const positionIt = createPositionIterator(lines, transform2);
    const color = createColors(locationIt, positionIt, theme.color);
    const size = createSizes(locationIt, theme.size);
    const marker = props.instanceGranularity ? createMarkers(instanceCount, "instance") : createMarkers(instanceCount * groupCount, "groupInstance");
    const overpaint = createEmptyOverpaint();
    const transparency = createEmptyTransparency();
    const emissive = createEmptyEmissive();
    const material = createEmptySubstance();
    const clipping = createEmptyClipping();
    const counts = { drawCount: lines.lineCount * 2 * 3, vertexCount: lines.lineCount * 4, groupCount, instanceCount };
    const invariantBoundingSphere = Sphere3D.clone(lines.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform2.aTransform.ref.value, instanceCount, 0);
    return {
      dGeometryType: ValueCell.create("lines"),
      aMapping: lines.mappingBuffer,
      aGroup: lines.groupBuffer,
      aStart: lines.startBuffer,
      aEnd: lines.endBuffer,
      elements: lines.indexBuffer,
      boundingSphere: ValueCell.create(boundingSphere),
      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),
      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)),
      ...color,
      ...size,
      ...marker,
      ...overpaint,
      ...transparency,
      ...emissive,
      ...material,
      ...clipping,
      ...transform2,
      ...BaseGeometry.createValues(props, counts),
      uSizeFactor: ValueCell.create(props.sizeFactor),
      dLineSizeAttenuation: ValueCell.create(props.lineSizeAttenuation),
      uDoubleSided: ValueCell.create(true),
      dFlipSided: ValueCell.create(false)
    };
  }
  function createValuesSimple(lines, props, colorValue, sizeValue, transform2) {
    const s = BaseGeometry.createSimple(colorValue, sizeValue, transform2);
    const p = { ...ParamDefinition.getDefaultValues(Lines2.Params), ...props };
    return createValues(lines, s.transform, s.locationIterator, s.theme, p);
  }
  function updateValues(values2, props) {
    BaseGeometry.updateValues(values2, props);
    ValueCell.updateIfChanged(values2.uSizeFactor, props.sizeFactor);
    ValueCell.updateIfChanged(values2.dLineSizeAttenuation, props.lineSizeAttenuation);
  }
  function updateBoundingSphere(values2, lines) {
    const invariantBoundingSphere = Sphere3D.clone(lines.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values2.aTransform.ref.value, values2.instanceCount.ref.value, 0);
    if (!Sphere3D.equals(boundingSphere, values2.boundingSphere.ref.value)) {
      ValueCell.update(values2.boundingSphere, boundingSphere);
    }
    if (!Sphere3D.equals(invariantBoundingSphere, values2.invariantBoundingSphere.ref.value)) {
      ValueCell.update(values2.invariantBoundingSphere, invariantBoundingSphere);
      ValueCell.update(values2.uInvariantBoundingSphere, Vec4.fromSphere(values2.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));
    }
  }
})(Lines || (Lines = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/primitive/box.js
var a4 = Vec3();
var b4 = Vec3();
var c4 = Vec3();
var d2 = Vec3();
var points = polygon(4, true);
function createBox(perforated) {
  const triangleCount = 12;
  const vertexCount = perforated ? 12 * 3 : 6 * 4;
  const builder = PrimitiveBuilder(triangleCount, vertexCount);
  for (let i = 0; i < 4; ++i) {
    const ni = (i + 1) % 4;
    Vec3.set(a4, points[i * 3], points[i * 3 + 1], -0.5);
    Vec3.set(b4, points[ni * 3], points[ni * 3 + 1], -0.5);
    Vec3.set(c4, points[ni * 3], points[ni * 3 + 1], 0.5);
    Vec3.set(d2, points[i * 3], points[i * 3 + 1], 0.5);
    if (perforated) {
      builder.add(a4, b4, c4);
    } else {
      builder.addQuad(a4, b4, c4, d2);
    }
  }
  Vec3.set(a4, points[0], points[1], -0.5);
  Vec3.set(b4, points[3], points[4], -0.5);
  Vec3.set(c4, points[6], points[7], -0.5);
  Vec3.set(d2, points[9], points[10], -0.5);
  if (perforated) {
    builder.add(c4, b4, a4);
  } else {
    builder.addQuad(d2, c4, b4, a4);
  }
  Vec3.set(a4, points[0], points[1], 0.5);
  Vec3.set(b4, points[3], points[4], 0.5);
  Vec3.set(c4, points[6], points[7], 0.5);
  Vec3.set(d2, points[9], points[10], 0.5);
  if (perforated) {
    builder.add(a4, b4, c4);
  } else {
    builder.addQuad(a4, b4, c4, d2);
  }
  return builder.getPrimitive();
}
var box;
function Box() {
  if (!box)
    box = createBox(false);
  return box;
}
var perforatedBox;
function PerforatedBox() {
  if (!perforatedBox)
    perforatedBox = createBox(true);
  return perforatedBox;
}
var boxCage;
function BoxCage() {
  if (!boxCage) {
    boxCage = createCage([
      0.5,
      0.5,
      -0.5,
      // bottom
      -0.5,
      0.5,
      -0.5,
      -0.5,
      -0.5,
      -0.5,
      0.5,
      -0.5,
      -0.5,
      0.5,
      0.5,
      0.5,
      // top
      -0.5,
      0.5,
      0.5,
      -0.5,
      -0.5,
      0.5,
      0.5,
      -0.5,
      0.5
    ], [
      0,
      4,
      1,
      5,
      2,
      6,
      3,
      7,
      // sides
      0,
      1,
      1,
      2,
      2,
      3,
      3,
      0,
      // bottom base
      4,
      5,
      5,
      6,
      6,
      7,
      7,
      4
      // top base
    ]);
  }
  return boxCage;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/direct-volume/transfer-function.js
function getControlPointsFromVec2Array(array) {
  return array.map((v3) => ({ x: v3[0], alpha: v3[1] }));
}
function createTransferFunctionTexture(controlPoints, texture) {
  const cp = [
    { x: 0, alpha: 0 },
    { x: 0, alpha: 0 },
    ...controlPoints,
    { x: 1, alpha: 0 },
    { x: 1, alpha: 0 }
  ];
  const n = 256;
  const array = texture ? texture.ref.value.array : new Uint8Array(n);
  let k = 0;
  let x1, x2;
  let a0, a1, a22, a32;
  const il = controlPoints.length + 1;
  for (let i = 0; i < il; ++i) {
    x1 = cp[i + 1].x;
    x2 = cp[i + 2].x;
    a0 = cp[i].alpha;
    a1 = cp[i + 1].alpha;
    a22 = cp[i + 2].alpha;
    a32 = cp[i + 3].alpha;
    const jl = Math.round((x2 - x1) * n);
    for (let j = 0; j < jl; ++j) {
      const t2 = j / jl;
      array[k] = Math.max(0, spline(a0, a1, a22, a32, t2, 0.5) * 255);
      ++k;
    }
  }
  const textureImage = { array, width: 256, height: 1 };
  if (texture) {
    ValueCell.update(texture, textureImage);
    return texture;
  } else {
    return ValueCell.create(textureImage);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/histogram.js
function calculateHistogram(data, binCount, options) {
  if (!options) {
    const [min3, max3] = arrayMinMax(data);
    return _calcHistogram(data, binCount, min3, max3);
  } else {
    return _calcHistogram(data, binCount, options.min, options.max);
  }
}
function _calcHistogram(data, binCount, min3, max3) {
  let binWidth = (max3 - min3) / binCount;
  if (binWidth === 0)
    binWidth = 1;
  const counts = new Int32Array(binCount);
  for (let i = 0, _i = data.length; i < _i; i++) {
    let bin = Math.floor((data[i] - min3) / binWidth);
    if (bin >= binCount)
      bin = binCount - 1;
    else if (bin < 0)
      bin = 0;
    counts[bin]++;
  }
  return { min: min3, max: max3, binWidth, counts };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/volume/grid.js
var Grid;
(function(Grid2) {
  Grid2.One = {
    transform: { kind: "matrix", matrix: Mat4.identity() },
    cells: Tensor.create(Tensor.Space([1, 1, 1], [0, 1, 2]), Tensor.Data1([0])),
    stats: { min: 0, max: 0, mean: 0, sigma: 0 }
  };
  const _scale = Mat4.zero(), _translate = Mat4.zero();
  function getGridToCartesianTransform(grid) {
    if (grid.transform.kind === "matrix") {
      return Mat4.copy(Mat4(), grid.transform.matrix);
    }
    if (grid.transform.kind === "spacegroup") {
      const { cells: { space } } = grid;
      const scale = Mat4.fromScaling(_scale, Vec3.div(Vec3.zero(), Box3D.size(Vec3.zero(), grid.transform.fractionalBox), Vec3.ofArray(space.dimensions)));
      const translate = Mat4.fromTranslation(_translate, grid.transform.fractionalBox.min);
      return Mat4.mul3(Mat4.zero(), grid.transform.cell.fromFractional, translate, scale);
    }
    return Mat4.identity();
  }
  Grid2.getGridToCartesianTransform = getGridToCartesianTransform;
  function areEquivalent(gridA, gridB) {
    return gridA === gridB;
  }
  Grid2.areEquivalent = areEquivalent;
  function isEmpty3(grid) {
    return grid.cells.data.length === 0;
  }
  Grid2.isEmpty = isEmpty3;
  function getBoundingSphere3(grid, boundingSphere) {
    if (!boundingSphere)
      boundingSphere = Sphere3D();
    const dimensions = grid.cells.space.dimensions;
    const transform = Grid2.getGridToCartesianTransform(grid);
    return Sphere3D.fromDimensionsAndTransform(boundingSphere, dimensions, transform);
  }
  Grid2.getBoundingSphere = getBoundingSphere3;
  function getHistogram(grid, binCount) {
    let histograms = grid._historams;
    if (!histograms) {
      histograms = grid._historams = {};
    }
    if (!histograms[binCount]) {
      histograms[binCount] = calculateHistogram(grid.cells.data, binCount, { min: grid.stats.min, max: grid.stats.max });
    }
    return histograms[binCount];
  }
  Grid2.getHistogram = getHistogram;
  function makeGetTrilinearlyInterpolated(grid, transform) {
    const cartnToGrid = Grid2.getGridToCartesianTransform(grid);
    Mat4.invert(cartnToGrid, cartnToGrid);
    const gridCoords = Vec3();
    const { stats } = grid;
    const { dimensions, get: get11 } = grid.cells.space;
    const data = grid.cells.data;
    const [mi, mj, mk] = dimensions;
    return function getTrilinearlyInterpolated2(position) {
      Vec3.copy(gridCoords, position);
      Vec3.transformMat4(gridCoords, gridCoords, cartnToGrid);
      const i = Math.trunc(gridCoords[0]);
      const j = Math.trunc(gridCoords[1]);
      const k = Math.trunc(gridCoords[2]);
      if (i < 0 || i >= mi || j < 0 || j >= mj || k < 0 || k >= mk) {
        return Number.NaN;
      }
      const u = gridCoords[0] - i;
      const v3 = gridCoords[1] - j;
      const w = gridCoords[2] - k;
      const ii = Math.min(i + 1, mi - 1);
      const jj = Math.min(j + 1, mj - 1);
      const kk = Math.min(k + 1, mk - 1);
      let a5 = get11(data, i, j, k);
      let b5 = get11(data, ii, j, k);
      let c5 = get11(data, i, jj, k);
      let d3 = get11(data, ii, jj, k);
      const x = lerp(lerp(a5, b5, u), lerp(c5, d3, u), v3);
      a5 = get11(data, i, j, kk);
      b5 = get11(data, ii, j, kk);
      c5 = get11(data, i, jj, kk);
      d3 = get11(data, ii, jj, kk);
      const y = lerp(lerp(a5, b5, u), lerp(c5, d3, u), v3);
      const value = lerp(x, y, w);
      if (transform === "relative") {
        return (value - stats.mean) / stats.sigma;
      } else {
        return value;
      }
    };
  }
  Grid2.makeGetTrilinearlyInterpolated = makeGetTrilinearlyInterpolated;
})(Grid || (Grid = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/volume/cube.js
function volumeFromCube(source, params) {
  return Task.create("Create Volume", async () => {
    const { header: header2, values: sourceValues } = source;
    const space = Tensor.Space(header2.dim, [0, 1, 2], Float64Array);
    let values2;
    if (header2.dataSetIds.length === 0) {
      values2 = sourceValues;
    } else {
      const [h, k, l] = header2.dim;
      const nth = ((params === null || params === void 0 ? void 0 : params.dataIndex) || 0) + 1;
      let o = 0, s = 0;
      values2 = new Float64Array(h * k * l);
      for (let u = 0; u < h; u++) {
        for (let v3 = 0; v3 < k; v3++) {
          for (let w = 0; w < l; w++) {
            values2[o++] = sourceValues[s];
            s += nth;
          }
        }
      }
    }
    const data = Tensor.create(space, Tensor.Data1(values2));
    const matrix = Mat4.fromTranslation(Mat4(), header2.origin);
    const basis = Mat4.fromBasis(Mat4(), header2.basisX, header2.basisY, header2.basisZ);
    Mat4.mul(matrix, matrix, basis);
    return {
      label: params === null || params === void 0 ? void 0 : params.label,
      entryId: params === null || params === void 0 ? void 0 : params.entryId,
      grid: {
        transform: { kind: "matrix", matrix },
        cells: data,
        stats: {
          min: arrayMin(values2),
          max: arrayMax(values2),
          mean: arrayMean(values2),
          sigma: arrayRms(values2)
        }
      },
      sourceData: CubeFormat.create(source),
      customProperties: new CustomProperties(),
      _propertyData: /* @__PURE__ */ Object.create(null)
    };
  });
}
var CubeFormat;
(function(CubeFormat3) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "cube";
  }
  CubeFormat3.is = is3;
  function create(cube) {
    return { kind: "cube", name: cube.name, data: cube };
  }
  CubeFormat3.create = create;
})(CubeFormat || (CubeFormat = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/volume/density-server.js
function volumeFromDensityServerData(source, params) {
  return Task.create("Create Volume", async (ctx) => {
    const { volume_data_3d_info: info, volume_data_3d: values2 } = source;
    const cell = SpacegroupCell.create(info.spacegroup_number.value(0), Vec3.ofArray(info.spacegroup_cell_size.value(0)), Vec3.scale(Vec3.zero(), Vec3.ofArray(info.spacegroup_cell_angles.value(0)), Math.PI / 180));
    const axis_order_fast_to_slow = info.axis_order.value(0);
    const normalizeOrder = Tensor.convertToCanonicalAxisIndicesFastToSlow(axis_order_fast_to_slow);
    const sample_count = normalizeOrder(info.sample_count.value(0));
    const tensorSpace = Tensor.Space(sample_count, Tensor.invertAxisOrder(axis_order_fast_to_slow), Float32Array);
    const data = Tensor.create(tensorSpace, Tensor.Data1(values2.values.toArray({ array: Float32Array })));
    const origin = Vec3.ofArray(normalizeOrder(info.origin.value(0)));
    const dimensions = Vec3.ofArray(normalizeOrder(info.dimensions.value(0)));
    return {
      label: params === null || params === void 0 ? void 0 : params.label,
      entryId: params === null || params === void 0 ? void 0 : params.entryId,
      grid: {
        transform: { kind: "spacegroup", cell, fractionalBox: Box3D.create(origin, Vec3.add(Vec3.zero(), origin, dimensions)) },
        cells: data,
        stats: {
          min: info.min_sampled.value(0),
          max: info.max_sampled.value(0),
          mean: info.mean_sampled.value(0),
          sigma: info.sigma_sampled.value(0)
        }
      },
      sourceData: DscifFormat.create(source),
      customProperties: new CustomProperties(),
      _propertyData: /* @__PURE__ */ Object.create(null)
    };
  });
}
var DscifFormat;
(function(DscifFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "dscif";
  }
  DscifFormat2.is = is3;
  function create(dscif) {
    return { kind: "dscif", name: dscif._name, data: dscif };
  }
  DscifFormat2.create = create;
})(DscifFormat || (DscifFormat = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/volume/volume.js
var Volume;
(function(Volume2) {
  function is3(x) {
    var _a, _b, _c, _d;
    return ((_d = (_c = (_b = (_a = x === null || x === void 0 ? void 0 : x.grid) === null || _a === void 0 ? void 0 : _a.cells) === null || _b === void 0 ? void 0 : _b.space) === null || _c === void 0 ? void 0 : _c.dimensions) === null || _d === void 0 ? void 0 : _d.length) && (x === null || x === void 0 ? void 0 : x.sourceData) && (x === null || x === void 0 ? void 0 : x.customProperties) && (x === null || x === void 0 ? void 0 : x._propertyData);
  }
  Volume2.is = is3;
  let IsoValue;
  (function(IsoValue2) {
    function areSame(a5, b5, stats) {
      return equalEps(toAbsolute(a5, stats).absoluteValue, toAbsolute(b5, stats).absoluteValue, stats.sigma / 100);
    }
    IsoValue2.areSame = areSame;
    function absolute(value) {
      return { kind: "absolute", absoluteValue: value };
    }
    IsoValue2.absolute = absolute;
    function relative(value) {
      return { kind: "relative", relativeValue: value };
    }
    IsoValue2.relative = relative;
    function calcAbsolute(stats, relativeValue) {
      return relativeValue * stats.sigma + stats.mean;
    }
    IsoValue2.calcAbsolute = calcAbsolute;
    function calcRelative(stats, absoluteValue) {
      return stats.sigma === 0 ? 0 : (absoluteValue - stats.mean) / stats.sigma;
    }
    IsoValue2.calcRelative = calcRelative;
    function toAbsolute(value, stats) {
      return value.kind === "absolute" ? value : { kind: "absolute", absoluteValue: IsoValue2.calcAbsolute(stats, value.relativeValue) };
    }
    IsoValue2.toAbsolute = toAbsolute;
    function toRelative(value, stats) {
      return value.kind === "relative" ? value : { kind: "relative", relativeValue: IsoValue2.calcRelative(stats, value.absoluteValue) };
    }
    IsoValue2.toRelative = toRelative;
    function toString5(value) {
      return value.kind === "relative" ? `${value.relativeValue.toFixed(2)} ` : `${value.absoluteValue.toPrecision(4)}`;
    }
    IsoValue2.toString = toString5;
  })(IsoValue = Volume2.IsoValue || (Volume2.IsoValue = {}));
  function adjustedIsoValue(volume, value, kind) {
    if (kind === "relative")
      return IsoValue.relative(value);
    const absolute = IsoValue.absolute(value);
    if (DscifFormat.is(volume.sourceData)) {
      const stats = {
        min: volume.sourceData.data.volume_data_3d_info.min_source.value(0),
        max: volume.sourceData.data.volume_data_3d_info.max_source.value(0),
        mean: volume.sourceData.data.volume_data_3d_info.mean_source.value(0),
        sigma: volume.sourceData.data.volume_data_3d_info.sigma_source.value(0)
      };
      return Volume2.IsoValue.toRelative(absolute, stats);
    }
    return absolute;
  }
  Volume2.adjustedIsoValue = adjustedIsoValue;
  const defaultStats = { min: -1, max: 1, mean: 0, sigma: 0.1 };
  function createIsoValueParam(defaultValue, stats) {
    const sts = stats || defaultStats;
    const { min: min3, max: max3, mean, sigma } = sts;
    const relMin = (min3 - mean) / sigma;
    const relMax = (max3 - mean) / sigma;
    let def = defaultValue;
    if (defaultValue.kind === "absolute") {
      if (defaultValue.absoluteValue < min3)
        def = Volume2.IsoValue.absolute(min3);
      else if (defaultValue.absoluteValue > max3)
        def = Volume2.IsoValue.absolute(max3);
    } else {
      if (defaultValue.relativeValue < relMin)
        def = Volume2.IsoValue.relative(relMin);
      else if (defaultValue.relativeValue > relMax)
        def = Volume2.IsoValue.relative(relMax);
    }
    return ParamDefinition.Conditioned(def, {
      "absolute": ParamDefinition.Converted((v3) => Volume2.IsoValue.toAbsolute(v3, Grid.One.stats).absoluteValue, (v3) => Volume2.IsoValue.absolute(v3), ParamDefinition.Numeric(mean, { min: min3, max: max3, step: toPrecision(sigma / 100, 2) }, { immediateUpdate: true })),
      "relative": ParamDefinition.Converted((v3) => Volume2.IsoValue.toRelative(v3, Grid.One.stats).relativeValue, (v3) => Volume2.IsoValue.relative(v3), ParamDefinition.Numeric(Math.min(1, relMax), { min: relMin, max: relMax, step: toPrecision(Math.round((max3 - min3) / sigma) / 100, 2) }, { immediateUpdate: true }))
    }, (v3) => v3.kind === "absolute" ? "absolute" : "relative", (v3, c5) => c5 === "absolute" ? Volume2.IsoValue.toAbsolute(v3, sts) : Volume2.IsoValue.toRelative(v3, sts), { isEssential: true });
  }
  Volume2.createIsoValueParam = createIsoValueParam;
  Volume2.IsoValueParam = createIsoValueParam(Volume2.IsoValue.relative(2));
  Volume2.One = {
    label: "",
    grid: Grid.One,
    sourceData: { kind: "", name: "", data: {} },
    customProperties: new CustomProperties(),
    _propertyData: /* @__PURE__ */ Object.create(null)
  };
  function areEquivalent(volA, volB) {
    return Grid.areEquivalent(volA.grid, volB.grid);
  }
  Volume2.areEquivalent = areEquivalent;
  function isEmpty3(vol) {
    return Grid.isEmpty(vol.grid);
  }
  Volume2.isEmpty = isEmpty3;
  function isOrbitals(volume) {
    if (!CubeFormat.is(volume.sourceData))
      return false;
    return volume.sourceData.data.header.orbitals;
  }
  Volume2.isOrbitals = isOrbitals;
  function Loci2(volume) {
    return { kind: "volume-loci", volume };
  }
  Volume2.Loci = Loci2;
  function isLoci(x) {
    return !!x && x.kind === "volume-loci";
  }
  Volume2.isLoci = isLoci;
  function areLociEqual(a5, b5) {
    return a5.volume === b5.volume;
  }
  Volume2.areLociEqual = areLociEqual;
  function isLociEmpty(loci) {
    return Grid.isEmpty(loci.volume.grid);
  }
  Volume2.isLociEmpty = isLociEmpty;
  function getBoundingSphere3(volume, boundingSphere) {
    return Grid.getBoundingSphere(volume.grid, boundingSphere);
  }
  Volume2.getBoundingSphere = getBoundingSphere3;
  let Isosurface;
  (function(Isosurface2) {
    function Loci3(volume, isoValue) {
      return { kind: "isosurface-loci", volume, isoValue };
    }
    Isosurface2.Loci = Loci3;
    function isLoci2(x) {
      return !!x && x.kind === "isosurface-loci";
    }
    Isosurface2.isLoci = isLoci2;
    function areLociEqual2(a5, b5) {
      return a5.volume === b5.volume && Volume2.IsoValue.areSame(a5.isoValue, b5.isoValue, a5.volume.grid.stats);
    }
    Isosurface2.areLociEqual = areLociEqual2;
    function isLociEmpty2(loci) {
      return loci.volume.grid.cells.data.length === 0;
    }
    Isosurface2.isLociEmpty = isLociEmpty2;
    const bbox = Box3D();
    function getBoundingSphere4(volume, isoValue, boundingSphere) {
      const value = Volume2.IsoValue.toAbsolute(isoValue, volume.grid.stats).absoluteValue;
      const neg2 = value < 0;
      const c5 = [0, 0, 0];
      const getCoords = volume.grid.cells.space.getCoords;
      const d3 = volume.grid.cells.data;
      const [xn, yn, zn] = volume.grid.cells.space.dimensions;
      let minx = xn - 1, miny = yn - 1, minz = zn - 1;
      let maxx = 0, maxy = 0, maxz = 0;
      for (let i = 0, il = d3.length; i < il; ++i) {
        if (neg2 && d3[i] <= value || !neg2 && d3[i] >= value) {
          getCoords(i, c5);
          if (c5[0] < minx)
            minx = c5[0];
          if (c5[1] < miny)
            miny = c5[1];
          if (c5[2] < minz)
            minz = c5[2];
          if (c5[0] > maxx)
            maxx = c5[0];
          if (c5[1] > maxy)
            maxy = c5[1];
          if (c5[2] > maxz)
            maxz = c5[2];
        }
      }
      Vec3.set(bbox.min, minx - 1, miny - 1, minz - 1);
      Vec3.set(bbox.max, maxx + 1, maxy + 1, maxz + 1);
      const transform = Grid.getGridToCartesianTransform(volume.grid);
      Box3D.transform(bbox, bbox, transform);
      return Sphere3D.fromBox3D(boundingSphere || Sphere3D(), bbox);
    }
    Isosurface2.getBoundingSphere = getBoundingSphere4;
  })(Isosurface = Volume2.Isosurface || (Volume2.Isosurface = {}));
  let Cell2;
  (function(Cell3) {
    function Loci3(volume, indices2) {
      return { kind: "cell-loci", volume, indices: indices2 };
    }
    Cell3.Loci = Loci3;
    function isLoci2(x) {
      return !!x && x.kind === "cell-loci";
    }
    Cell3.isLoci = isLoci2;
    function areLociEqual2(a5, b5) {
      return a5.volume === b5.volume && OrderedSet.areEqual(a5.indices, b5.indices);
    }
    Cell3.areLociEqual = areLociEqual2;
    function isLociEmpty2(loci) {
      return OrderedSet.size(loci.indices) === 0;
    }
    Cell3.isLociEmpty = isLociEmpty2;
    function Location(volume, cell) {
      return { kind: "cell-location", volume, cell };
    }
    Cell3.Location = Location;
    function isLocation(x) {
      return !!x && x.kind === "cell-location";
    }
    Cell3.isLocation = isLocation;
    const boundaryHelper2 = new BoundaryHelper("98");
    const tmpBoundaryPos = Vec3();
    function getBoundingSphere4(volume, indices2, boundingSphere) {
      boundaryHelper2.reset();
      const transform = Grid.getGridToCartesianTransform(volume.grid);
      const { getCoords } = volume.grid.cells.space;
      for (let i = 0, _i = OrderedSet.size(indices2); i < _i; i++) {
        const o = OrderedSet.getAt(indices2, i);
        getCoords(o, tmpBoundaryPos);
        Vec3.transformMat4(tmpBoundaryPos, tmpBoundaryPos, transform);
        boundaryHelper2.includePosition(tmpBoundaryPos);
      }
      boundaryHelper2.finishedIncludeStep();
      for (let i = 0, _i = OrderedSet.size(indices2); i < _i; i++) {
        const o = OrderedSet.getAt(indices2, i);
        getCoords(o, tmpBoundaryPos);
        Vec3.transformMat4(tmpBoundaryPos, tmpBoundaryPos, transform);
        boundaryHelper2.radiusPosition(tmpBoundaryPos);
      }
      const bs = boundaryHelper2.getSphere(boundingSphere);
      return Sphere3D.expand(bs, bs, Mat4.getMaxScaleOnAxis(transform) * 10);
    }
    Cell3.getBoundingSphere = getBoundingSphere4;
  })(Cell2 = Volume2.Cell || (Volume2.Cell = {}));
  let Segment;
  (function(Segment2) {
    function Loci3(volume, segments) {
      return { kind: "segment-loci", volume, segments: SortedArray.ofUnsortedArray(segments) };
    }
    Segment2.Loci = Loci3;
    function isLoci2(x) {
      return !!x && x.kind === "segment-loci";
    }
    Segment2.isLoci = isLoci2;
    function areLociEqual2(a5, b5) {
      return a5.volume === b5.volume && SortedArray.areEqual(a5.segments, b5.segments);
    }
    Segment2.areLociEqual = areLociEqual2;
    function isLociEmpty2(loci) {
      return loci.volume.grid.cells.data.length === 0 || loci.segments.length === 0;
    }
    Segment2.isLociEmpty = isLociEmpty2;
    const bbox = Box3D();
    function getBoundingSphere4(volume, segments, boundingSphere) {
      const segmentation = Volume2.Segmentation.get(volume);
      if (segmentation) {
        Box3D.setEmpty(bbox);
        for (let i = 0, il = segments.length; i < il; ++i) {
          const b5 = segmentation.bounds[segments[i]];
          Box3D.add(bbox, b5.min);
          Box3D.add(bbox, b5.max);
        }
        const transform = Grid.getGridToCartesianTransform(volume.grid);
        Box3D.transform(bbox, bbox, transform);
        return Sphere3D.fromBox3D(boundingSphere || Sphere3D(), bbox);
      } else {
        return Volume2.getBoundingSphere(volume, boundingSphere);
      }
    }
    Segment2.getBoundingSphere = getBoundingSphere4;
    function Location(volume, segment) {
      return { kind: "segment-location", volume, segment };
    }
    Segment2.Location = Location;
    function isLocation(x) {
      return !!x && x.kind === "segment-location";
    }
    Segment2.isLocation = isLocation;
  })(Segment = Volume2.Segment || (Volume2.Segment = {}));
  Volume2.PickingGranularity = {
    set(volume, granularity) {
      volume._propertyData["__picking_granularity__"] = granularity;
    },
    get(volume) {
      var _a;
      return (_a = volume._propertyData["__picking_granularity__"]) !== null && _a !== void 0 ? _a : "voxel";
    }
  };
  Volume2.Segmentation = {
    set(volume, segmentation) {
      volume._propertyData["__segmentation__"] = segmentation;
    },
    get(volume) {
      return volume._propertyData["__segmentation__"];
    }
  };
})(Volume || (Volume = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/direct-volume/direct-volume.js
var VolumeBox = Box();
var DirectVolume;
(function(DirectVolume2) {
  function create(bbox, gridDimension, transform, unitToCartn, cellDim, texture, stats, packedGroup, axisOrder, dataType, directVolume) {
    return directVolume ? update10(bbox, gridDimension, transform, unitToCartn, cellDim, texture, stats, packedGroup, axisOrder, dataType, directVolume) : fromData(bbox, gridDimension, transform, unitToCartn, cellDim, texture, stats, packedGroup, axisOrder, dataType);
  }
  DirectVolume2.create = create;
  function hashCode3(directVolume) {
    return hashFnv32a([
      directVolume.bboxSize.ref.version,
      directVolume.gridDimension.ref.version,
      directVolume.gridTexture.ref.version,
      directVolume.transform.ref.version,
      directVolume.gridStats.ref.version
    ]);
  }
  function fromData(bbox, gridDimension, transform, unitToCartn, cellDim, texture, stats, packedGroup, axisOrder, dataType) {
    const boundingSphere = Sphere3D();
    let currentHash = -1;
    const width = texture.getWidth();
    const height = texture.getHeight();
    const depth = texture.getDepth();
    const directVolume = {
      kind: "direct-volume",
      gridDimension: ValueCell.create(gridDimension),
      gridTexture: ValueCell.create(texture),
      gridTextureDim: ValueCell.create(Vec3.create(width, height, depth)),
      gridStats: ValueCell.create(Vec4.create(stats.min, stats.max, stats.mean, stats.sigma)),
      bboxMin: ValueCell.create(bbox.min),
      bboxMax: ValueCell.create(bbox.max),
      bboxSize: ValueCell.create(Vec3.sub(Vec3(), bbox.max, bbox.min)),
      transform: ValueCell.create(transform),
      cellDim: ValueCell.create(cellDim),
      unitToCartn: ValueCell.create(unitToCartn),
      cartnToUnit: ValueCell.create(Mat4.invert(Mat4(), unitToCartn)),
      get boundingSphere() {
        const newHash = hashCode3(directVolume);
        if (newHash !== currentHash) {
          const b5 = getBoundingSphere(directVolume.gridDimension.ref.value, directVolume.transform.ref.value);
          Sphere3D.copy(boundingSphere, b5);
          currentHash = newHash;
        }
        return boundingSphere;
      },
      packedGroup: ValueCell.create(packedGroup),
      axisOrder: ValueCell.create(axisOrder),
      dataType: ValueCell.create(dataType),
      setBoundingSphere(sphere) {
        Sphere3D.copy(boundingSphere, sphere);
        currentHash = hashCode3(directVolume);
      },
      meta: {}
    };
    return directVolume;
  }
  function update10(bbox, gridDimension, transform, unitToCartn, cellDim, texture, stats, packedGroup, axisOrder, dataType, directVolume) {
    const width = texture.getWidth();
    const height = texture.getHeight();
    const depth = texture.getDepth();
    ValueCell.update(directVolume.gridDimension, gridDimension);
    ValueCell.update(directVolume.gridTexture, texture);
    ValueCell.update(directVolume.gridTextureDim, Vec3.set(directVolume.gridTextureDim.ref.value, width, height, depth));
    ValueCell.update(directVolume.gridStats, Vec4.set(directVolume.gridStats.ref.value, stats.min, stats.max, stats.mean, stats.sigma));
    ValueCell.update(directVolume.bboxMin, bbox.min);
    ValueCell.update(directVolume.bboxMax, bbox.max);
    ValueCell.update(directVolume.bboxSize, Vec3.sub(directVolume.bboxSize.ref.value, bbox.max, bbox.min));
    ValueCell.update(directVolume.transform, transform);
    ValueCell.update(directVolume.cellDim, cellDim);
    ValueCell.update(directVolume.unitToCartn, unitToCartn);
    ValueCell.update(directVolume.cartnToUnit, Mat4.invert(Mat4(), unitToCartn));
    ValueCell.updateIfChanged(directVolume.packedGroup, packedGroup);
    ValueCell.updateIfChanged(directVolume.axisOrder, Vec3.fromArray(directVolume.axisOrder.ref.value, axisOrder, 0));
    ValueCell.updateIfChanged(directVolume.dataType, dataType);
    return directVolume;
  }
  function createEmpty(directVolume) {
    const bbox = Box3D();
    const gridDimension = Vec3();
    const transform = Mat4.identity();
    const unitToCartn = Mat4.identity();
    const cellDim = Vec3();
    const texture = createNullTexture();
    const stats = Grid.One.stats;
    const packedGroup = false;
    const axisOrder = Vec3.create(0, 1, 2);
    const dataType = "byte";
    return create(bbox, gridDimension, transform, unitToCartn, cellDim, texture, stats, packedGroup, axisOrder, dataType, directVolume);
  }
  DirectVolume2.createEmpty = createEmpty;
  DirectVolume2.Params = {
    ...BaseGeometry.Params,
    ignoreLight: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    celShaded: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    xrayShaded: ParamDefinition.Select(false, [[false, "Off"], [true, "On"], ["inverted", "Inverted"]], BaseGeometry.ShadingCategory),
    controlPoints: ParamDefinition.LineGraph([
      Vec2.create(0.19, 0),
      Vec2.create(0.2, 0.05),
      Vec2.create(0.25, 0.05),
      Vec2.create(0.26, 0),
      Vec2.create(0.79, 0),
      Vec2.create(0.8, 0.05),
      Vec2.create(0.85, 0.05),
      Vec2.create(0.86, 0)
    ], { isEssential: true }),
    stepsPerCell: ParamDefinition.Numeric(3, { min: 1, max: 10, step: 1 }),
    jumpLength: ParamDefinition.Numeric(0, { min: 0, max: 20, step: 0.1 })
  };
  DirectVolume2.Utils = {
    Params: DirectVolume2.Params,
    createEmpty,
    createValues,
    createValuesSimple,
    updateValues,
    updateBoundingSphere,
    createRenderableState,
    updateRenderableState,
    createPositionIterator
  };
  function createPositionIterator(directVolume, transform) {
    const t2 = directVolume.transform.ref.value;
    const [x, y, z] = directVolume.gridDimension.ref.value;
    const groupCount = x * y * z;
    const instanceCount = transform.instanceCount.ref.value;
    const location = PositionLocation();
    const p = location.position;
    const m = transform.aTransform.ref.value;
    const getLocation = (groupIndex, instanceIndex) => {
      const k = Math.floor(groupIndex / z);
      p[0] = Math.floor(k / y);
      p[1] = k % y;
      p[2] = groupIndex % z;
      Vec3.transformMat4(p, p, t2);
      if (instanceIndex >= 0) {
        Vec3.transformMat4Offset(p, p, m, 0, 0, instanceIndex * 16);
      }
      return location;
    };
    return LocationIterator(groupCount, instanceCount, 1, getLocation);
  }
  function getMaxSteps(gridDim, stepsPerCell) {
    return Math.ceil(Vec3.magnitude(gridDim) * stepsPerCell);
  }
  function getStepScale(cellDim, stepsPerCell) {
    return Math.min(...cellDim) * (1 / stepsPerCell);
  }
  function getTransferScale(stepsPerCell) {
    return 1 / stepsPerCell;
  }
  function createValues(directVolume, transform, locationIt, theme, props) {
    const { gridTexture, gridTextureDim, gridStats } = directVolume;
    const { bboxSize, bboxMin, bboxMax, gridDimension, transform: gridTransform } = directVolume;
    const { instanceCount, groupCount } = locationIt;
    const positionIt = createPositionIterator(directVolume, transform);
    const color = createColors(locationIt, positionIt, theme.color);
    const marker = props.instanceGranularity ? createMarkers(instanceCount, "instance") : createMarkers(instanceCount * groupCount, "groupInstance");
    const overpaint = createEmptyOverpaint();
    const transparency = createEmptyTransparency();
    const emissive = createEmptyEmissive();
    const material = createEmptySubstance();
    const clipping = createEmptyClipping();
    const [x, y, z] = gridDimension.ref.value;
    const counts = { drawCount: VolumeBox.indices.length, vertexCount: x * y * z, groupCount, instanceCount };
    const invariantBoundingSphere = Sphere3D.clone(directVolume.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount, 0);
    const controlPoints = getControlPointsFromVec2Array(props.controlPoints);
    const transferTex = createTransferFunctionTexture(controlPoints);
    return {
      dGeometryType: ValueCell.create("directVolume"),
      ...color,
      ...marker,
      ...overpaint,
      ...transparency,
      ...emissive,
      ...material,
      ...clipping,
      ...transform,
      ...BaseGeometry.createValues(props, counts),
      aPosition: ValueCell.create(VolumeBox.vertices),
      elements: ValueCell.create(VolumeBox.indices),
      boundingSphere: ValueCell.create(boundingSphere),
      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),
      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)),
      uBboxMin: bboxMin,
      uBboxMax: bboxMax,
      uBboxSize: bboxSize,
      uMaxSteps: ValueCell.create(getMaxSteps(gridDimension.ref.value, props.stepsPerCell)),
      uStepScale: ValueCell.create(getStepScale(directVolume.cellDim.ref.value, props.stepsPerCell)),
      uJumpLength: ValueCell.create(props.jumpLength),
      uTransform: gridTransform,
      uGridDim: gridDimension,
      tTransferTex: transferTex,
      uTransferScale: ValueCell.create(getTransferScale(props.stepsPerCell)),
      dGridTexType: ValueCell.create(gridTexture.ref.value.getDepth() > 0 ? "3d" : "2d"),
      uGridTexDim: gridTextureDim,
      tGridTex: gridTexture,
      uGridStats: gridStats,
      uCellDim: directVolume.cellDim,
      uCartnToUnit: directVolume.cartnToUnit,
      uUnitToCartn: directVolume.unitToCartn,
      dPackedGroup: directVolume.packedGroup,
      dAxisOrder: ValueCell.create(directVolume.axisOrder.ref.value.join("")),
      dIgnoreLight: ValueCell.create(props.ignoreLight),
      dCelShaded: ValueCell.create(props.celShaded),
      dXrayShaded: ValueCell.create(props.xrayShaded === "inverted" ? "inverted" : props.xrayShaded === true ? "on" : "off"),
      meta: ValueCell.create(directVolume.meta)
    };
  }
  function createValuesSimple(directVolume, props, colorValue, sizeValue, transform) {
    const s = BaseGeometry.createSimple(colorValue, sizeValue, transform);
    const p = { ...ParamDefinition.getDefaultValues(DirectVolume2.Params), ...props };
    return createValues(directVolume, s.transform, s.locationIterator, s.theme, p);
  }
  function updateValues(values2, props) {
    BaseGeometry.updateValues(values2, props);
    ValueCell.updateIfChanged(values2.dIgnoreLight, props.ignoreLight);
    ValueCell.updateIfChanged(values2.dCelShaded, props.celShaded);
    ValueCell.updateIfChanged(values2.dXrayShaded, props.xrayShaded === "inverted" ? "inverted" : props.xrayShaded === true ? "on" : "off");
    const controlPoints = getControlPointsFromVec2Array(props.controlPoints);
    createTransferFunctionTexture(controlPoints, values2.tTransferTex);
    ValueCell.updateIfChanged(values2.uMaxSteps, getMaxSteps(values2.uGridDim.ref.value, props.stepsPerCell));
    ValueCell.updateIfChanged(values2.uStepScale, getStepScale(values2.uCellDim.ref.value, props.stepsPerCell));
    ValueCell.updateIfChanged(values2.uTransferScale, getTransferScale(props.stepsPerCell));
    ValueCell.updateIfChanged(values2.uJumpLength, props.jumpLength);
  }
  function updateBoundingSphere(values2, directVolume) {
    const invariantBoundingSphere = Sphere3D.clone(directVolume.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values2.aTransform.ref.value, values2.instanceCount.ref.value, 0);
    if (!Sphere3D.equals(boundingSphere, values2.boundingSphere.ref.value)) {
      ValueCell.update(values2.boundingSphere, boundingSphere);
    }
    if (!Sphere3D.equals(invariantBoundingSphere, values2.invariantBoundingSphere.ref.value)) {
      ValueCell.update(values2.invariantBoundingSphere, invariantBoundingSphere);
      ValueCell.update(values2.uInvariantBoundingSphere, Vec4.fromSphere(values2.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));
    }
  }
  function createRenderableState(props) {
    const state = BaseGeometry.createRenderableState(props);
    state.opaque = false;
    state.writeDepth = false;
    return state;
  }
  function updateRenderableState(state, props) {
    BaseGeometry.updateRenderableState(state, props);
    state.opaque = false;
    state.writeDepth = false;
  }
})(DirectVolume || (DirectVolume = {}));
function getBoundingSphere(gridDimension, gridTransform) {
  return Sphere3D.fromDimensionsAndTransform(Sphere3D(), gridDimension, gridTransform);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/spheres/spheres.js
var Spheres;
(function(Spheres2) {
  function create(centers, groups, sphereCount, spheres) {
    return spheres ? update10(centers, groups, sphereCount, spheres) : fromArrays(centers, groups, sphereCount);
  }
  Spheres2.create = create;
  function createEmpty(spheres) {
    const cb2 = spheres ? spheres.centerBuffer.ref.value : new Float32Array(0);
    const gb = spheres ? spheres.groupBuffer.ref.value : new Float32Array(0);
    return create(cb2, gb, 0, spheres);
  }
  Spheres2.createEmpty = createEmpty;
  function hashCode3(spheres) {
    return hashFnv32a([
      spheres.sphereCount,
      spheres.centerBuffer.ref.version,
      spheres.groupBuffer.ref.version
    ]);
  }
  function fromArrays(centers, groups, sphereCount) {
    const boundingSphere = Sphere3D();
    let groupMapping;
    let currentHash = -1;
    let currentGroup = -1;
    const positionGroup = ValueCell.create(createTextureImage(1, 4, Float32Array));
    const texDim = ValueCell.create(Vec2.create(0, 0));
    const lodLevels = ValueCell.create([]);
    const sizeFactor = ValueCell.create(0);
    const spheres = {
      kind: "spheres",
      sphereCount,
      centerBuffer: ValueCell.create(centers),
      groupBuffer: ValueCell.create(groups),
      get boundingSphere() {
        const newHash = hashCode3(spheres);
        if (newHash !== currentHash) {
          const b5 = calculateInvariantBoundingSphere(spheres.centerBuffer.ref.value, spheres.sphereCount, 1);
          Sphere3D.copy(boundingSphere, b5);
          currentHash = newHash;
        }
        return boundingSphere;
      },
      get groupMapping() {
        if (spheres.groupBuffer.ref.version !== currentGroup) {
          groupMapping = createGroupMapping(spheres.groupBuffer.ref.value, spheres.sphereCount);
          currentGroup = spheres.groupBuffer.ref.version;
        }
        return groupMapping;
      },
      setBoundingSphere(sphere) {
        Sphere3D.copy(boundingSphere, sphere);
        currentHash = hashCode3(spheres);
      },
      shaderData: {
        positionGroup,
        texDim,
        lodLevels,
        sizeFactor,
        update(props) {
          var _a, _b;
          const lodLevelsProp = (_a = props === null || props === void 0 ? void 0 : props.lodLevels) !== null && _a !== void 0 ? _a : getLodLevels(lodLevels.ref.value);
          const sizeFactorProp = (_b = props === null || props === void 0 ? void 0 : props.sizeFactor) !== null && _b !== void 0 ? _b : sizeFactor.ref.value;
          const strides = getStrides(lodLevelsProp, sizeFactorProp);
          const pgt = createTextureImage(spheres.sphereCount, 4, Float32Array, positionGroup.ref.value.array);
          const offsets = getStrideOffsetsAndSetPositionGroup(pgt, spheres.centerBuffer.ref.value, spheres.groupBuffer.ref.value, spheres.sphereCount, strides);
          const newLodLevels = offsets ? getLodLevelsValue(lodLevelsProp, sizeFactorProp, offsets, spheres.sphereCount) : [];
          ValueCell.update(positionGroup, pgt);
          ValueCell.update(texDim, Vec2.set(texDim.ref.value, pgt.width, pgt.height));
          ValueCell.update(lodLevels, newLodLevels);
          ValueCell.update(sizeFactor, sizeFactorProp);
        }
      }
    };
    spheres.shaderData.update();
    return spheres;
  }
  function update10(centers, groups, sphereCount, spheres) {
    spheres.sphereCount = sphereCount;
    ValueCell.update(spheres.centerBuffer, centers);
    ValueCell.update(spheres.groupBuffer, groups);
    spheres.shaderData.update();
    return spheres;
  }
  function getStrideOffsetsAndSetPositionGroup(out, centers, groups, count3, strides) {
    const { array } = out;
    if (strides.length === 0) {
      for (let i = 0; i < count3; ++i) {
        array[i * 4 + 0] = centers[i * 3 + 0];
        array[i * 4 + 1] = centers[i * 3 + 1];
        array[i * 4 + 2] = centers[i * 3 + 2];
        array[i * 4 + 3] = groups[i];
      }
      return;
    }
    const offsets = [0];
    let o = 0;
    for (let i = 0, il = strides.length; i < il; ++i) {
      const s = strides[i];
      for (let j = 0; j < count3; ++j) {
        let handled = false;
        for (let k = 0; k < i; ++k) {
          if (j % strides[k] === 0) {
            handled = true;
            break;
          }
        }
        if (!handled && j % s === 0) {
          array[o * 4 + 0] = centers[j * 3 + 0];
          array[o * 4 + 1] = centers[j * 3 + 1];
          array[o * 4 + 2] = centers[j * 3 + 2];
          array[o * 4 + 3] = groups[j];
          o += 1;
        }
      }
      offsets.push(o * 6);
    }
    return offsets;
  }
  function areLodLevelsEqual(a5, b5) {
    if (a5.length !== b5.length)
      return false;
    for (let i = 0, il = a5.length; i < il; ++i) {
      if (a5[i].maxDistance !== b5[i].maxDistance)
        return false;
      if (a5[i].minDistance !== b5[i].minDistance)
        return false;
      if (a5[i].overlap !== b5[i].overlap)
        return false;
      if (a5[i].stride !== b5[i].stride)
        return false;
      if (a5[i].scaleBias !== b5[i].scaleBias)
        return false;
    }
    return true;
  }
  function getLodLevelsValue(prop, sizeFactor, offsets, count3) {
    return prop.map((l, i) => {
      const stride = getAdjustedStride(l, sizeFactor);
      return [
        l.minDistance,
        l.maxDistance,
        l.overlap,
        offsets[offsets.length - 1 - i],
        Math.pow(Math.min(count3, stride), 1 / l.scaleBias),
        l.stride,
        l.scaleBias
      ];
    });
  }
  function getLodLevels(lodLevelsValue) {
    return lodLevelsValue.map((l) => ({
      minDistance: l[0],
      maxDistance: l[1],
      overlap: l[2],
      stride: l[5],
      scaleBias: l[6]
    }));
  }
  function getAdjustedStride(lodLevel, sizeFactor) {
    return Math.max(1, Math.round(lodLevel.stride / Math.pow(sizeFactor, lodLevel.scaleBias)));
  }
  function getStrides(lodLevels, sizeFactor) {
    return lodLevels.map((l) => getAdjustedStride(l, sizeFactor)).reverse();
  }
  Spheres2.Params = {
    ...BaseGeometry.Params,
    sizeFactor: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }),
    doubleSided: ParamDefinition.Boolean(false, BaseGeometry.CustomQualityParamInfo),
    ignoreLight: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    celShaded: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    xrayShaded: ParamDefinition.Select(false, [[false, "Off"], [true, "On"], ["inverted", "Inverted"]], BaseGeometry.ShadingCategory),
    transparentBackfaces: ParamDefinition.Select("off", ParamDefinition.arrayToOptions(["off", "on", "opaque"]), BaseGeometry.ShadingCategory),
    solidInterior: ParamDefinition.Boolean(true, BaseGeometry.ShadingCategory),
    clipPrimitive: ParamDefinition.Boolean(false, { ...BaseGeometry.ShadingCategory, description: "Clip whole sphere instead of cutting it." }),
    approximate: ParamDefinition.Boolean(false, { ...BaseGeometry.ShadingCategory, description: "Faster rendering, but has artifacts." }),
    alphaThickness: ParamDefinition.Numeric(0, { min: 0, max: 20, step: 1 }, { ...BaseGeometry.ShadingCategory, description: "If not zero, adjusts alpha for radius." }),
    bumpFrequency: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
    bumpAmplitude: ParamDefinition.Numeric(1, { min: 0, max: 5, step: 0.1 }, BaseGeometry.ShadingCategory),
    lodLevels: ParamDefinition.ObjectList({
      minDistance: ParamDefinition.Numeric(0),
      maxDistance: ParamDefinition.Numeric(0),
      overlap: ParamDefinition.Numeric(0),
      stride: ParamDefinition.Numeric(0),
      scaleBias: ParamDefinition.Numeric(3, { min: 0.1, max: 10, step: 0.1 })
    }, (o) => `${o.stride}`, {
      ...BaseGeometry.CullingLodCategory,
      defaultValue: []
    })
  };
  Spheres2.Utils = {
    Params: Spheres2.Params,
    createEmpty,
    createValues,
    createValuesSimple,
    updateValues,
    updateBoundingSphere,
    createRenderableState,
    updateRenderableState,
    createPositionIterator
  };
  function createPositionIterator(spheres, transform) {
    const groupCount = spheres.sphereCount;
    const instanceCount = transform.instanceCount.ref.value;
    const location = PositionLocation();
    const p = location.position;
    const v3 = spheres.centerBuffer.ref.value;
    const m = transform.aTransform.ref.value;
    const getLocation = (groupIndex, instanceIndex) => {
      if (instanceIndex < 0) {
        Vec3.fromArray(p, v3, groupIndex * 3);
      } else {
        Vec3.transformMat4Offset(p, v3, m, 0, groupIndex * 3, instanceIndex * 16);
      }
      return location;
    };
    return LocationIterator(groupCount, instanceCount, 1, getLocation);
  }
  function createValues(spheres, transform, locationIt, theme, props) {
    const { instanceCount, groupCount } = locationIt;
    const positionIt = createPositionIterator(spheres, transform);
    const color = createColors(locationIt, positionIt, theme.color);
    const size = createSizes(locationIt, theme.size);
    const marker = props.instanceGranularity ? createMarkers(instanceCount, "instance") : createMarkers(instanceCount * groupCount, "groupInstance");
    const overpaint = createEmptyOverpaint();
    const transparency = createEmptyTransparency();
    const emissive = createEmptyEmissive();
    const material = createEmptySubstance();
    const clipping = createEmptyClipping();
    const counts = { drawCount: spheres.sphereCount * 2 * 3, vertexCount: spheres.sphereCount * 6, groupCount, instanceCount };
    const padding2 = spheres.boundingSphere.radius ? getMaxSize(size) * props.sizeFactor : 0;
    const invariantBoundingSphere = Sphere3D.expand(Sphere3D(), spheres.boundingSphere, padding2);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount, 0);
    spheres.shaderData.update({ lodLevels: props.lodLevels, sizeFactor: props.sizeFactor });
    return {
      dGeometryType: ValueCell.create("spheres"),
      uTexDim: spheres.shaderData.texDim,
      tPositionGroup: spheres.shaderData.positionGroup,
      boundingSphere: ValueCell.create(boundingSphere),
      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),
      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)),
      ...color,
      ...size,
      ...marker,
      ...overpaint,
      ...transparency,
      ...emissive,
      ...material,
      ...clipping,
      ...transform,
      padding: ValueCell.create(padding2),
      ...BaseGeometry.createValues(props, counts),
      uSizeFactor: spheres.shaderData.sizeFactor,
      uDoubleSided: ValueCell.create(props.doubleSided),
      dIgnoreLight: ValueCell.create(props.ignoreLight),
      dCelShaded: ValueCell.create(props.celShaded),
      dXrayShaded: ValueCell.create(props.xrayShaded === "inverted" ? "inverted" : props.xrayShaded === true ? "on" : "off"),
      dTransparentBackfaces: ValueCell.create(props.transparentBackfaces),
      dSolidInterior: ValueCell.create(props.solidInterior),
      dClipPrimitive: ValueCell.create(props.clipPrimitive),
      dApproximate: ValueCell.create(props.approximate),
      uAlphaThickness: ValueCell.create(props.alphaThickness),
      uBumpFrequency: ValueCell.create(props.bumpFrequency),
      uBumpAmplitude: ValueCell.create(props.bumpAmplitude),
      lodLevels: spheres.shaderData.lodLevels,
      centerBuffer: spheres.centerBuffer,
      groupBuffer: spheres.groupBuffer
    };
  }
  function createValuesSimple(spheres, props, colorValue, sizeValue, transform) {
    const s = BaseGeometry.createSimple(colorValue, sizeValue, transform);
    const p = { ...ParamDefinition.getDefaultValues(Spheres2.Params), ...props };
    return createValues(spheres, s.transform, s.locationIterator, s.theme, p);
  }
  function updateValues(values2, props) {
    BaseGeometry.updateValues(values2, props);
    ValueCell.updateIfChanged(values2.uSizeFactor, props.sizeFactor);
    ValueCell.updateIfChanged(values2.uDoubleSided, props.doubleSided);
    ValueCell.updateIfChanged(values2.dIgnoreLight, props.ignoreLight);
    ValueCell.updateIfChanged(values2.dCelShaded, props.celShaded);
    ValueCell.updateIfChanged(values2.dXrayShaded, props.xrayShaded === "inverted" ? "inverted" : props.xrayShaded === true ? "on" : "off");
    ValueCell.updateIfChanged(values2.dTransparentBackfaces, props.transparentBackfaces);
    ValueCell.updateIfChanged(values2.dSolidInterior, props.solidInterior);
    ValueCell.updateIfChanged(values2.dClipPrimitive, props.clipPrimitive);
    ValueCell.updateIfChanged(values2.dApproximate, props.approximate);
    ValueCell.updateIfChanged(values2.uAlphaThickness, props.alphaThickness);
    ValueCell.updateIfChanged(values2.uBumpFrequency, props.bumpFrequency);
    ValueCell.updateIfChanged(values2.uBumpAmplitude, props.bumpAmplitude);
    const lodLevels = getLodLevels(values2.lodLevels.ref.value);
    if (!areLodLevelsEqual(props.lodLevels, lodLevels)) {
      const count3 = values2.uVertexCount.ref.value / 6;
      const strides = getStrides(props.lodLevels, props.sizeFactor);
      const offsets = getStrideOffsetsAndSetPositionGroup(values2.tPositionGroup.ref.value, values2.centerBuffer.ref.value, values2.groupBuffer.ref.value, count3, strides);
      const lodLevels2 = offsets ? getLodLevelsValue(props.lodLevels, props.sizeFactor, offsets, count3) : [];
      ValueCell.update(values2.tPositionGroup, values2.tPositionGroup.ref.value);
      ValueCell.update(values2.lodLevels, lodLevels2);
    }
  }
  function updateBoundingSphere(values2, spheres) {
    const padding2 = spheres.boundingSphere.radius ? getMaxSize(values2) * values2.uSizeFactor.ref.value : 0;
    const invariantBoundingSphere = Sphere3D.expand(Sphere3D(), spheres.boundingSphere, padding2);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values2.aTransform.ref.value, values2.instanceCount.ref.value, 0);
    if (!Sphere3D.equals(boundingSphere, values2.boundingSphere.ref.value)) {
      ValueCell.update(values2.boundingSphere, boundingSphere);
    }
    if (!Sphere3D.equals(invariantBoundingSphere, values2.invariantBoundingSphere.ref.value)) {
      ValueCell.update(values2.invariantBoundingSphere, invariantBoundingSphere);
      ValueCell.update(values2.uInvariantBoundingSphere, Vec4.fromSphere(values2.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));
    }
    ValueCell.update(values2.padding, padding2);
  }
  function createRenderableState(props) {
    const state = BaseGeometry.createRenderableState(props);
    updateRenderableState(state, props);
    return state;
  }
  function updateRenderableState(state, props) {
    BaseGeometry.updateRenderableState(state, props);
    state.opaque = state.opaque && !props.xrayShaded;
    state.writeDepth = state.opaque;
  }
})(Spheres || (Spheres = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/texture-mesh/texture-mesh.js
var TextureMesh;
(function(TextureMesh2) {
  class DoubleBuffer {
    constructor() {
      this.index = 0;
      this.textures = [];
    }
    get() {
      return this.textures[this.index];
    }
    set(vertex, group, normal) {
      this.textures[this.index] = Object.assign(this.textures[this.index] || {}, {
        vertex,
        group,
        normal
      });
      this.index = (this.index + 1) % 2;
    }
    destroy() {
      for (const buffer2 of this.textures) {
        buffer2.vertex.destroy();
        buffer2.group.destroy();
        buffer2.normal.destroy();
      }
    }
  }
  TextureMesh2.DoubleBuffer = DoubleBuffer;
  function create(vertexCount, groupCount, vertexTexture, groupTexture, normalTexture, boundingSphere, textureMesh) {
    const width = vertexTexture.getWidth();
    const height = vertexTexture.getHeight();
    if (textureMesh) {
      textureMesh.vertexCount = vertexCount;
      textureMesh.groupCount = groupCount;
      ValueCell.update(textureMesh.geoTextureDim, Vec2.set(textureMesh.geoTextureDim.ref.value, width, height));
      ValueCell.update(textureMesh.vertexTexture, vertexTexture);
      ValueCell.update(textureMesh.groupTexture, groupTexture);
      ValueCell.update(textureMesh.normalTexture, normalTexture);
      textureMesh.doubleBuffer.set(vertexTexture, groupTexture, normalTexture);
      Sphere3D.copy(textureMesh.boundingSphere, boundingSphere);
      return textureMesh;
    } else {
      return {
        kind: "texture-mesh",
        vertexCount,
        groupCount,
        geoTextureDim: ValueCell.create(Vec2.create(width, height)),
        vertexTexture: ValueCell.create(vertexTexture),
        groupTexture: ValueCell.create(groupTexture),
        normalTexture: ValueCell.create(normalTexture),
        varyingGroup: ValueCell.create(false),
        doubleBuffer: new DoubleBuffer(),
        boundingSphere: Sphere3D.clone(boundingSphere),
        meta: {}
      };
    }
  }
  TextureMesh2.create = create;
  function createEmpty(textureMesh) {
    const vt = textureMesh ? textureMesh.vertexTexture.ref.value : createNullTexture();
    const gt = textureMesh ? textureMesh.groupTexture.ref.value : createNullTexture();
    const nt = textureMesh ? textureMesh.normalTexture.ref.value : createNullTexture();
    const bs = textureMesh ? textureMesh.boundingSphere : Sphere3D();
    return create(0, 0, vt, gt, nt, bs, textureMesh);
  }
  TextureMesh2.createEmpty = createEmpty;
  TextureMesh2.Params = {
    ...BaseGeometry.Params,
    doubleSided: ParamDefinition.Boolean(false, BaseGeometry.CustomQualityParamInfo),
    flipSided: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    flatShaded: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    ignoreLight: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    celShaded: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    xrayShaded: ParamDefinition.Select(false, [[false, "Off"], [true, "On"], ["inverted", "Inverted"]], BaseGeometry.ShadingCategory),
    transparentBackfaces: ParamDefinition.Select("off", ParamDefinition.arrayToOptions(["off", "on", "opaque"]), BaseGeometry.ShadingCategory),
    bumpFrequency: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
    bumpAmplitude: ParamDefinition.Numeric(1, { min: 0, max: 5, step: 0.1 }, BaseGeometry.ShadingCategory)
  };
  TextureMesh2.Utils = {
    Params: TextureMesh2.Params,
    createEmpty,
    createValues,
    createValuesSimple,
    updateValues,
    updateBoundingSphere,
    createRenderableState,
    updateRenderableState,
    createPositionIterator
  };
  const TextureMeshName = "texture-mesh";
  function createPositionIterator(textureMesh, transform) {
    const webgl = textureMesh.meta.webgl;
    if (!webgl)
      return LocationIterator(1, 1, 1, () => NullLocation);
    if (!webgl.namedFramebuffers[TextureMeshName]) {
      webgl.namedFramebuffers[TextureMeshName] = webgl.resources.framebuffer();
    }
    const framebuffer = webgl.namedFramebuffers[TextureMeshName];
    const [width, height] = textureMesh.geoTextureDim.ref.value;
    const vertices2 = new Float32Array(width * height * 4);
    framebuffer.bind();
    textureMesh.vertexTexture.ref.value.attachFramebuffer(framebuffer, 0);
    webgl.readPixels(0, 0, width, height, vertices2);
    const normals = new Float32Array(width * height * 4);
    framebuffer.bind();
    textureMesh.normalTexture.ref.value.attachFramebuffer(framebuffer, 0);
    webgl.readPixels(0, 0, width, height, normals);
    const groupCount = textureMesh.vertexCount;
    const instanceCount = transform.instanceCount.ref.value;
    const location = PositionLocation();
    const p = location.position;
    const n = location.normal;
    const m = transform.aTransform.ref.value;
    const getLocation = (groupIndex, instanceIndex) => {
      if (instanceIndex < 0) {
        Vec3.fromArray(p, vertices2, groupIndex * 4);
        Vec3.fromArray(n, normals, groupIndex * 4);
      } else {
        Vec3.transformMat4Offset(p, vertices2, m, 0, groupIndex * 4, instanceIndex * 16);
        Vec3.transformDirectionOffset(n, normals, m, 0, groupIndex * 4, instanceIndex * 16);
      }
      return location;
    };
    return LocationIterator(groupCount, instanceCount, 1, getLocation);
  }
  function createValues(textureMesh, transform, locationIt, theme, props) {
    const { instanceCount, groupCount } = locationIt;
    const positionIt = TextureMesh2.Utils.createPositionIterator(textureMesh, transform);
    const color = createColors(locationIt, positionIt, theme.color);
    const marker = props.instanceGranularity ? createMarkers(instanceCount, "instance") : createMarkers(instanceCount * groupCount, "groupInstance");
    const overpaint = createEmptyOverpaint();
    const transparency = createEmptyTransparency();
    const emissive = createEmptyEmissive();
    const substance = createEmptySubstance();
    const clipping = createEmptyClipping();
    const counts = { drawCount: textureMesh.vertexCount, vertexCount: textureMesh.vertexCount, groupCount, instanceCount };
    const invariantBoundingSphere = Sphere3D.clone(textureMesh.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount, 0);
    return {
      dGeometryType: ValueCell.create("textureMesh"),
      uGeoTexDim: textureMesh.geoTextureDim,
      tPosition: textureMesh.vertexTexture,
      tGroup: textureMesh.groupTexture,
      tNormal: textureMesh.normalTexture,
      dVaryingGroup: textureMesh.varyingGroup,
      boundingSphere: ValueCell.create(boundingSphere),
      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),
      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)),
      ...color,
      ...marker,
      ...overpaint,
      ...transparency,
      ...emissive,
      ...substance,
      ...clipping,
      ...transform,
      ...BaseGeometry.createValues(props, counts),
      uDoubleSided: ValueCell.create(props.doubleSided),
      dFlatShaded: ValueCell.create(props.flatShaded),
      dFlipSided: ValueCell.create(props.flipSided),
      dIgnoreLight: ValueCell.create(props.ignoreLight),
      dCelShaded: ValueCell.create(props.celShaded),
      dXrayShaded: ValueCell.create(props.xrayShaded === "inverted" ? "inverted" : props.xrayShaded === true ? "on" : "off"),
      dTransparentBackfaces: ValueCell.create(props.transparentBackfaces),
      uBumpFrequency: ValueCell.create(props.bumpFrequency),
      uBumpAmplitude: ValueCell.create(props.bumpAmplitude),
      meta: ValueCell.create(textureMesh.meta)
    };
  }
  function createValuesSimple(textureMesh, props, colorValue, sizeValue, transform) {
    const s = BaseGeometry.createSimple(colorValue, sizeValue, transform);
    const p = { ...ParamDefinition.getDefaultValues(TextureMesh2.Params), ...props };
    return createValues(textureMesh, s.transform, s.locationIterator, s.theme, p);
  }
  function updateValues(values2, props) {
    BaseGeometry.updateValues(values2, props);
    ValueCell.updateIfChanged(values2.uDoubleSided, props.doubleSided);
    ValueCell.updateIfChanged(values2.dFlatShaded, props.flatShaded);
    ValueCell.updateIfChanged(values2.dFlipSided, props.flipSided);
    ValueCell.updateIfChanged(values2.dIgnoreLight, props.ignoreLight);
    ValueCell.updateIfChanged(values2.dCelShaded, props.celShaded);
    ValueCell.updateIfChanged(values2.dXrayShaded, props.xrayShaded === "inverted" ? "inverted" : props.xrayShaded === true ? "on" : "off");
    ValueCell.updateIfChanged(values2.dTransparentBackfaces, props.transparentBackfaces);
    ValueCell.updateIfChanged(values2.uBumpFrequency, props.bumpFrequency);
    ValueCell.updateIfChanged(values2.uBumpAmplitude, props.bumpAmplitude);
  }
  function updateBoundingSphere(values2, textureMesh) {
    const invariantBoundingSphere = Sphere3D.clone(textureMesh.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values2.aTransform.ref.value, values2.instanceCount.ref.value, 0);
    if (!Sphere3D.equals(boundingSphere, values2.boundingSphere.ref.value)) {
      ValueCell.update(values2.boundingSphere, boundingSphere);
    }
    if (!Sphere3D.equals(invariantBoundingSphere, values2.invariantBoundingSphere.ref.value)) {
      ValueCell.update(values2.invariantBoundingSphere, invariantBoundingSphere);
      ValueCell.update(values2.uInvariantBoundingSphere, Vec4.fromSphere(values2.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));
    }
  }
  function createRenderableState(props) {
    const state = BaseGeometry.createRenderableState(props);
    updateRenderableState(state, props);
    return state;
  }
  function updateRenderableState(state, props) {
    BaseGeometry.updateRenderableState(state, props);
    state.opaque = state.opaque && !props.xrayShaded;
    state.writeDepth = state.opaque;
  }
})(TextureMesh || (TextureMesh = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable/schema.js
function splitValues(schema, values2) {
  const attributeValues = {};
  const defineValues = {};
  const textureValues = {};
  const materialTextureValues = {};
  const uniformValues = {};
  const materialUniformValues = {};
  const bufferedUniformValues = {};
  Object.keys(schema).forEach((k) => {
    const spec = schema[k];
    if (spec.type === "attribute")
      attributeValues[k] = values2[k];
    if (spec.type === "define")
      defineValues[k] = values2[k];
    if (spec.type === "texture" && values2[k] !== void 0) {
      if (spec.variant === "material")
        materialTextureValues[k] = values2[k];
      else
        textureValues[k] = values2[k];
    }
    if (spec.type === "uniform" && values2[k] !== void 0) {
      if (spec.variant === "material")
        materialUniformValues[k] = values2[k];
      else if (spec.variant === "buffered")
        bufferedUniformValues[k] = values2[k];
      else
        uniformValues[k] = values2[k];
    }
  });
  return { attributeValues, defineValues, textureValues, materialTextureValues, uniformValues, materialUniformValues, bufferedUniformValues };
}
function getValueVersions(values2) {
  const versions = {};
  Object.keys(values2).forEach((k) => {
    versions[k] = values2[k].ref.version;
  });
  return versions;
}
function AttributeSpec(kind, itemSize, divisor) {
  return { type: "attribute", kind, itemSize, divisor };
}
function UniformSpec(kind, variant) {
  return { type: "uniform", kind, variant };
}
function TextureSpec(kind, format, dataType, filter4, variant) {
  return { type: "texture", kind, format, dataType, filter: filter4, variant };
}
function ElementsSpec(kind) {
  return { type: "elements", kind };
}
function DefineSpec(kind, options) {
  return { type: "define", kind, options };
}
function ValueSpec(kind) {
  return { type: "value", kind };
}
var GlobalUniformSchema = {
  uDrawId: UniformSpec("i"),
  uModel: UniformSpec("m4"),
  uView: UniformSpec("m4"),
  uInvView: UniformSpec("m4"),
  uModelView: UniformSpec("m4"),
  uInvModelView: UniformSpec("m4"),
  uProjection: UniformSpec("m4"),
  uInvProjection: UniformSpec("m4"),
  uModelViewProjection: UniformSpec("m4"),
  uInvModelViewProjection: UniformSpec("m4"),
  uIsOrtho: UniformSpec("f"),
  uPixelRatio: UniformSpec("f"),
  uViewport: UniformSpec("v4"),
  uViewOffset: UniformSpec("v2"),
  uDrawingBufferSize: UniformSpec("v2"),
  uCameraPosition: UniformSpec("v3"),
  uCameraDir: UniformSpec("v3"),
  uCameraPlane: UniformSpec("v4"),
  uNear: UniformSpec("f"),
  uFar: UniformSpec("f"),
  uFog: UniformSpec("b"),
  uFogNear: UniformSpec("f"),
  uFogFar: UniformSpec("f"),
  uFogColor: UniformSpec("v3"),
  uTransparentBackground: UniformSpec("b"),
  uLightDirection: UniformSpec("v3[]"),
  uLightColor: UniformSpec("v3[]"),
  uAmbientColor: UniformSpec("v3"),
  uPickingAlphaThreshold: UniformSpec("f"),
  uInteriorDarkening: UniformSpec("f"),
  uInteriorColorFlag: UniformSpec("b"),
  uInteriorColor: UniformSpec("v3"),
  uHighlightColor: UniformSpec("v3"),
  uSelectColor: UniformSpec("v3"),
  uDimColor: UniformSpec("v3"),
  uHighlightStrength: UniformSpec("f"),
  uSelectStrength: UniformSpec("f"),
  uDimStrength: UniformSpec("f"),
  uMarkerPriority: UniformSpec("i"),
  uMarkerAverage: UniformSpec("f"),
  uXrayEdgeFalloff: UniformSpec("f"),
  uCelSteps: UniformSpec("f"),
  uExposure: UniformSpec("f"),
  uRenderMask: UniformSpec("i"),
  uMarkingDepthTest: UniformSpec("b"),
  uMarkingType: UniformSpec("i"),
  uPickType: UniformSpec("i")
};
var GlobalTextureSchema = {
  tDepth: TextureSpec("texture", "depth", "ushort", "nearest"),
  // dpoit
  tDpoitDepth: TextureSpec("texture", "rg", "float", "nearest"),
  tDpoitFrontColor: TextureSpec("texture", "rgba", "float", "nearest"),
  tDpoitBackColor: TextureSpec("texture", "rgba", "float", "nearest")
};
var InternalSchema = {
  uObjectId: UniformSpec("i")
};
var ColorSchema = {
  // aColor: AttributeSpec('float32', 3, 0), // TODO
  uColor: UniformSpec("v3", "material"),
  uColorTexDim: UniformSpec("v2"),
  uColorGridDim: UniformSpec("v3"),
  uColorGridTransform: UniformSpec("v4"),
  uPaletteDomain: UniformSpec("v2"),
  uPaletteDefault: UniformSpec("v3"),
  tColor: TextureSpec("image-uint8", "rgb", "ubyte", "nearest"),
  tPalette: TextureSpec("image-uint8", "rgb", "ubyte", "nearest"),
  tColorGrid: TextureSpec("texture", "rgb", "ubyte", "linear"),
  dColorType: DefineSpec("string", ["uniform", "attribute", "instance", "group", "groupInstance", "vertex", "vertexInstance", "volume", "volumeInstance", "direct"]),
  dUsePalette: DefineSpec("boolean")
};
var SizeSchema = {
  // aSize: AttributeSpec('float32', 1, 0), // TODO
  uSize: UniformSpec("f", "material"),
  uSizeTexDim: UniformSpec("v2"),
  tSize: TextureSpec("image-uint8", "rgb", "ubyte", "nearest"),
  dSizeType: DefineSpec("string", ["uniform", "attribute", "instance", "group", "groupInstance"]),
  uSizeFactor: UniformSpec("f", "material")
};
var MarkerSchema = {
  uMarker: UniformSpec("f"),
  uMarkerTexDim: UniformSpec("v2"),
  tMarker: TextureSpec("image-uint8", "alpha", "ubyte", "nearest"),
  markerAverage: ValueSpec("number"),
  markerStatus: ValueSpec("number"),
  dMarkerType: DefineSpec("string", ["instance", "groupInstance"])
};
var OverpaintSchema = {
  uOverpaintTexDim: UniformSpec("v2"),
  tOverpaint: TextureSpec("image-uint8", "rgba", "ubyte", "nearest"),
  dOverpaint: DefineSpec("boolean"),
  uOverpaintGridDim: UniformSpec("v3"),
  uOverpaintGridTransform: UniformSpec("v4"),
  tOverpaintGrid: TextureSpec("texture", "rgba", "ubyte", "linear"),
  dOverpaintType: DefineSpec("string", ["instance", "groupInstance", "volumeInstance"]),
  uOverpaintStrength: UniformSpec("f", "material")
};
var TransparencySchema = {
  uTransparencyTexDim: UniformSpec("v2"),
  tTransparency: TextureSpec("image-uint8", "alpha", "ubyte", "nearest"),
  dTransparency: DefineSpec("boolean"),
  transparencyAverage: ValueSpec("number"),
  transparencyMin: ValueSpec("number"),
  uTransparencyGridDim: UniformSpec("v3"),
  uTransparencyGridTransform: UniformSpec("v4"),
  tTransparencyGrid: TextureSpec("texture", "alpha", "ubyte", "linear"),
  dTransparencyType: DefineSpec("string", ["instance", "groupInstance", "volumeInstance"]),
  uTransparencyStrength: UniformSpec("f", "material")
};
var EmissiveSchema = {
  uEmissiveTexDim: UniformSpec("v2"),
  tEmissive: TextureSpec("image-uint8", "alpha", "ubyte", "nearest"),
  dEmissive: DefineSpec("boolean"),
  emissiveAverage: ValueSpec("number"),
  uEmissiveGridDim: UniformSpec("v3"),
  uEmissiveGridTransform: UniformSpec("v4"),
  tEmissiveGrid: TextureSpec("texture", "alpha", "ubyte", "linear"),
  dEmissiveType: DefineSpec("string", ["instance", "groupInstance", "volumeInstance"]),
  uEmissiveStrength: UniformSpec("f", "material")
};
var SubstanceSchema = {
  uSubstanceTexDim: UniformSpec("v2"),
  tSubstance: TextureSpec("image-uint8", "rgba", "ubyte", "nearest"),
  dSubstance: DefineSpec("boolean"),
  uSubstanceGridDim: UniformSpec("v3"),
  uSubstanceGridTransform: UniformSpec("v4"),
  tSubstanceGrid: TextureSpec("texture", "rgba", "ubyte", "linear"),
  dSubstanceType: DefineSpec("string", ["instance", "groupInstance", "volumeInstance"]),
  uSubstanceStrength: UniformSpec("f", "material")
};
var ClippingSchema = {
  uClippingTexDim: UniformSpec("v2"),
  tClipping: TextureSpec("image-uint8", "alpha", "ubyte", "nearest"),
  dClipping: DefineSpec("boolean"),
  dClippingType: DefineSpec("string", ["instance", "groupInstance"])
};
var BaseSchema = {
  dGeometryType: DefineSpec("string", ["cylinders", "directVolume", "image", "lines", "mesh", "points", "spheres", "text", "textureMesh"]),
  ...ColorSchema,
  ...MarkerSchema,
  ...OverpaintSchema,
  ...TransparencySchema,
  ...EmissiveSchema,
  ...SubstanceSchema,
  ...ClippingSchema,
  dLightCount: DefineSpec("number"),
  dColorMarker: DefineSpec("boolean"),
  dClipObjectCount: DefineSpec("number"),
  dClipVariant: DefineSpec("string", ["instance", "pixel"]),
  uClipObjectType: UniformSpec("i[]", "material"),
  uClipObjectInvert: UniformSpec("b[]", "material"),
  uClipObjectPosition: UniformSpec("v3[]", "material"),
  uClipObjectRotation: UniformSpec("v4[]", "material"),
  uClipObjectScale: UniformSpec("v3[]", "material"),
  uClipObjectTransform: UniformSpec("m4[]", "material"),
  aInstance: AttributeSpec("float32", 1, 1),
  /**
   * final per-instance transform calculated for instance `i` as
   * `aTransform[i] = matrix * transform[i] * extraTransform[i]`
   */
  aTransform: AttributeSpec("float32", 16, 1),
  /**
   * final alpha, calculated as `values.alpha * state.alpha`
   */
  uAlpha: UniformSpec("f", "material"),
  uMetalness: UniformSpec("f", "material"),
  uRoughness: UniformSpec("f", "material"),
  uBumpiness: UniformSpec("f", "material"),
  uEmissive: UniformSpec("f", "material"),
  /** density value to estimate object thickness */
  uDensity: UniformSpec("f", "material"),
  uVertexCount: UniformSpec("i"),
  uInstanceCount: UniformSpec("i"),
  uGroupCount: UniformSpec("i"),
  uInvariantBoundingSphere: UniformSpec("v4"),
  uLod: UniformSpec("v4"),
  drawCount: ValueSpec("number"),
  instanceCount: ValueSpec("number"),
  /** base alpha, see uAlpha  */
  alpha: ValueSpec("number"),
  /** global transform, see aTransform */
  matrix: ValueSpec("m4"),
  /** base per-instance transform, see aTransform */
  transform: ValueSpec("float32"),
  /** additional per-instance transform, see aTransform */
  extraTransform: ValueSpec("float32"),
  /** denotes reflection in transform */
  hasReflection: ValueSpec("boolean"),
  /** use instance granularity for marker, transparency, clipping, overpaint, substance */
  instanceGranularity: ValueSpec("boolean"),
  /** bounding sphere taking aTransform into account and encompases all instances */
  boundingSphere: ValueSpec("sphere"),
  /** bounding sphere NOT taking aTransform into account */
  invariantBoundingSphere: ValueSpec("sphere"),
  instanceGrid: ValueSpec("instanceGrid")
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/copy.frag.js
var copy_frag = `
precision highp float;
precision highp sampler2D;

uniform sampler2D tColor;
uniform vec2 uTexSize;

void main() {
    vec2 coords = gl_FragCoord.xy / uTexSize;
    gl_FragColor = texture2D(tColor, coords);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/quad.vert.js
var quad_vert = `
precision highp float;

attribute vec2 aPosition;
uniform vec2 uQuadScale;

void main(void) {
    vec2 position = aPosition * uQuadScale - vec2(1.0, 1.0) + uQuadScale;
    gl_Position = vec4(position, 0.0, 1.0);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/webgl/render-item.js
var MaxDrawCount = 3e7;
var getNextRenderItemId = idFactory();
function getDrawMode(ctx, drawMode) {
  const { gl } = ctx;
  switch (drawMode) {
    case "points":
      return gl.POINTS;
    case "lines":
      return gl.LINES;
    case "line-strip":
      return gl.LINE_STRIP;
    case "line-loop":
      return gl.LINE_LOOP;
    case "triangles":
      return gl.TRIANGLES;
    case "triangle-strip":
      return gl.TRIANGLE_STRIP;
    case "triangle-fan":
      return gl.TRIANGLE_FAN;
  }
}
var GraphicsRenderVariant = { color: "", pick: "", depth: "", marking: "", emissive: "", tracing: "" };
var GraphicsRenderVariants = Object.keys(GraphicsRenderVariant);
var ComputeRenderVariant = { compute: "" };
var ComputeRenderVariants = Object.keys(ComputeRenderVariant);
function createProgramVariant(ctx, variant, defineValues, shaderCode, schema) {
  defineValues = { ...defineValues, dRenderVariant: ValueCell.create(variant) };
  if (schema.dRenderVariant === void 0) {
    Object.defineProperty(schema, "dRenderVariant", { value: DefineSpec("string") });
  }
  return ctx.resources.program(defineValues, shaderCode, schema);
}
function createValueChanges() {
  return {
    attributes: false,
    defines: false,
    elements: false,
    textures: false
  };
}
function resetValueChanges(valueChanges) {
  valueChanges.attributes = false;
  valueChanges.defines = false;
  valueChanges.elements = false;
  valueChanges.textures = false;
}
function getRenderVariant(variant, transparency) {
  if (variant === "color") {
    switch (transparency) {
      case "blended":
        return "colorBlended";
      case "wboit":
        return "colorWboit";
      case "dpoit":
        return "colorDpoit";
    }
  }
  return variant;
}
function createGraphicsRenderItem(ctx, drawMode, shaderCode, schema, values2, materialId, transparency) {
  return createRenderItem(ctx, drawMode, shaderCode, schema, values2, materialId, GraphicsRenderVariants, transparency);
}
function createComputeRenderItem(ctx, drawMode, shaderCode, schema, values2, materialId = -1) {
  return createRenderItem(ctx, drawMode, shaderCode, schema, values2, materialId, ComputeRenderVariants, void 0);
}
function createRenderItem(ctx, drawMode, shaderCode, schema, values2, materialId, renderVariants, transparency) {
  const id = getNextRenderItemId();
  const { stats, state, resources } = ctx;
  const { instancedArrays, vertexArrayObject, multiDrawInstancedBaseVertexBaseInstance, drawInstancedBaseVertexBaseInstance } = ctx.extensions;
  renderVariants = renderVariants.filter((v3) => {
    if (v3 === "tracing")
      return !!ctx.extensions.drawBuffers;
    return true;
  });
  if (values2.uVertexCount && !ctx.extensions.noNonInstancedActiveAttribs) {
    const vertexCount = values2.uVertexCount.ref.value;
    values2.aVertex = ValueCell.create(fillSerial(new Float32Array(vertexCount)));
    schema.aVertex = AttributeSpec("float32", 1, 0);
  }
  const { attributeValues, defineValues, textureValues, materialTextureValues, uniformValues, materialUniformValues, bufferedUniformValues } = splitValues(schema, values2);
  const uniformValueEntries = Object.entries(uniformValues);
  const materialUniformValueEntries = Object.entries(materialUniformValues);
  const backBufferUniformValueEntries = Object.entries(bufferedUniformValues);
  const frontBufferUniformValueEntries = Object.entries(cloneUniformValues(bufferedUniformValues));
  const defineValueEntries = Object.entries(defineValues);
  const versions = getValueVersions(values2);
  const glDrawMode = getDrawMode(ctx, drawMode);
  const programs = {};
  for (const rv of renderVariants) {
    programs[rv] = createProgramVariant(ctx, getRenderVariant(rv, transparency), defineValues, shaderCode, schema);
  }
  const textures = createTextures(ctx, schema, textureValues);
  const materialTextures = createTextures(ctx, schema, materialTextureValues);
  const attributeBuffers = createAttributeBuffers(ctx, schema, attributeValues);
  const instanceBuffers = [];
  for (let i = 0, il = attributeBuffers.length; i < il; ++i) {
    const ab2 = attributeBuffers[i];
    if (ab2[1].divisor === 1)
      instanceBuffers.push(ab2);
  }
  let elementsBuffer;
  const elements = values2.elements;
  if (elements && elements.ref.value) {
    elementsBuffer = resources.elements(elements.ref.value);
  }
  const vertexArrays = {};
  for (const k of renderVariants) {
    vertexArrays[k] = vertexArrayObject ? resources.vertexArray(programs[k], attributeBuffers, elementsBuffer) : null;
  }
  let drawCount = values2.drawCount.ref.value;
  let instanceCount = values2.instanceCount.ref.value;
  stats.drawCount += drawCount;
  stats.instanceCount += instanceCount;
  stats.instancedDrawCount += instanceCount * drawCount;
  const valueChanges = createValueChanges();
  let destroyed = false;
  let currentProgramId = -1;
  return {
    id,
    materialId,
    getProgram: (variant) => programs[variant],
    setTransparency: (value) => {
      if (value === transparency)
        return;
      transparency = value;
      for (const rv of renderVariants) {
        programs[rv].destroy();
        programs[rv] = createProgramVariant(ctx, getRenderVariant(rv, transparency), defineValues, shaderCode, schema);
      }
    },
    render: (variant, sharedTexturesCount, mdbDataList) => {
      if (drawCount === 0 || instanceCount === 0)
        return;
      const program = programs[variant];
      if (program.id === currentProgramId && state.currentRenderItemId === id) {
        program.setUniforms(uniformValueEntries);
        program.bindTextures(textures, sharedTexturesCount);
      } else {
        const vertexArray = vertexArrays[variant];
        if (program.id !== state.currentProgramId || program.id !== currentProgramId || materialId === -1 || materialId !== state.currentMaterialId) {
          if (program.id !== state.currentProgramId)
            program.use();
          program.setUniforms(materialUniformValueEntries);
          program.bindTextures(materialTextures, sharedTexturesCount + textures.length);
          state.currentMaterialId = materialId;
          currentProgramId = program.id;
        }
        program.setUniforms(uniformValueEntries);
        program.setUniforms(frontBufferUniformValueEntries);
        program.bindTextures(textures, sharedTexturesCount);
        if (vertexArray) {
          vertexArray.bind();
          if (elementsBuffer)
            elementsBuffer.bind();
        } else {
          if (elementsBuffer)
            elementsBuffer.bind();
          program.bindAttributes(attributeBuffers);
        }
        state.currentRenderItemId = id;
      }
      if (isDebugMode) {
        try {
          checkFramebufferStatus(ctx.gl);
        } catch (e) {
          throw new Error(`Framebuffer error rendering item id ${id}: '${e}'`);
        }
      }
      if (mdbDataList) {
        for (const mdbData of mdbDataList) {
          if (mdbData.count === 0)
            continue;
          program.setUniforms(mdbData.uniforms);
          if (multiDrawInstancedBaseVertexBaseInstance) {
            if (elementsBuffer) {
              multiDrawInstancedBaseVertexBaseInstance.multiDrawElementsInstancedBaseVertexBaseInstance(glDrawMode, mdbData.counts, 0, elementsBuffer._dataType, mdbData.offsets, 0, mdbData.instanceCounts, 0, mdbData.baseVertices, 0, mdbData.baseInstances, 0, mdbData.count);
            } else {
              multiDrawInstancedBaseVertexBaseInstance.multiDrawArraysInstancedBaseInstance(glDrawMode, mdbData.firsts, 0, mdbData.counts, 0, mdbData.instanceCounts, 0, mdbData.baseInstances, 0, mdbData.count);
            }
          } else if (drawInstancedBaseVertexBaseInstance) {
            if (elementsBuffer) {
              for (let i = 0; i < mdbData.count; ++i) {
                if (mdbData.counts[i] > 0) {
                  program.uniform("uDrawId", i);
                  drawInstancedBaseVertexBaseInstance.drawElementsInstancedBaseVertexBaseInstance(glDrawMode, mdbData.counts[i], elementsBuffer._dataType, mdbData.offsets[i], mdbData.instanceCounts[i], mdbData.baseVertices[i], mdbData.baseInstances[i]);
                }
              }
            } else {
              for (let i = 0; i < mdbData.count; ++i) {
                if (mdbData.counts[i] > 0) {
                  program.uniform("uDrawId", i);
                  drawInstancedBaseVertexBaseInstance.drawArraysInstancedBaseInstance(glDrawMode, mdbData.firsts[i], mdbData.counts[i], mdbData.instanceCounts[i], mdbData.baseInstances[i]);
                }
              }
            }
          } else {
            if (elementsBuffer) {
              for (let i = 0; i < mdbData.count; ++i) {
                if (mdbData.counts[i] > 0) {
                  program.uniform("uDrawId", i);
                  program.offsetAttributes(instanceBuffers, mdbData.baseInstances[i]);
                  instancedArrays.drawElementsInstanced(glDrawMode, mdbData.counts[i], elementsBuffer._dataType, mdbData.offsets[i], mdbData.instanceCounts[i]);
                }
              }
            } else {
              for (let i = 0; i < mdbData.count; ++i) {
                if (mdbData.counts[i] > 0) {
                  program.uniform("uDrawId", i);
                  program.offsetAttributes(instanceBuffers, mdbData.baseInstances[i]);
                  instancedArrays.drawArraysInstanced(glDrawMode, 0, mdbData.counts[i], mdbData.instanceCounts[i]);
                }
              }
            }
          }
          if (isTimingMode) {
            if (multiDrawInstancedBaseVertexBaseInstance) {
              stats.calls.multiDrawInstancedBase += 1;
            } else if (drawInstancedBaseVertexBaseInstance) {
              stats.calls.drawInstancedBase += mdbData.count;
            } else {
              stats.calls.drawInstanced += mdbData.count;
            }
            for (let i = 0; i < mdbData.count; ++i) {
              stats.calls.counts += mdbData.instanceCounts[i];
            }
          }
        }
      } else {
        let offset = 0;
        while (true) {
          const count3 = Math.min(drawCount - offset, MaxDrawCount);
          if (elementsBuffer) {
            instancedArrays.drawElementsInstanced(glDrawMode, count3, elementsBuffer._dataType, offset * elementsBuffer._bpe, instanceCount);
          } else {
            instancedArrays.drawArraysInstanced(glDrawMode, offset, count3, instanceCount);
          }
          offset += count3;
          if (offset >= drawCount)
            break;
        }
        if (isTimingMode) {
          stats.calls.drawInstanced += 1;
          stats.calls.counts += instanceCount;
        }
      }
      if (isDebugMode) {
        try {
          checkError(ctx.gl);
        } catch (e) {
          throw new Error(`Draw error rendering item id ${id}: '${e}'`);
        }
      }
    },
    update: () => {
      resetValueChanges(valueChanges);
      if (values2.aVertex) {
        const vertexCount = values2.uVertexCount.ref.value;
        if (values2.aVertex.ref.value.length < vertexCount) {
          ValueCell.update(values2.aVertex, fillSerial(new Float32Array(vertexCount)));
        }
      }
      for (let i = 0, il = defineValueEntries.length; i < il; ++i) {
        const [k, value] = defineValueEntries[i];
        if (value.ref.version !== versions[k]) {
          valueChanges.defines = true;
          versions[k] = value.ref.version;
        }
      }
      if (valueChanges.defines) {
        for (const rv of renderVariants) {
          programs[rv].destroy();
          programs[rv] = createProgramVariant(ctx, getRenderVariant(rv, transparency), defineValues, shaderCode, schema);
        }
      }
      if (values2.drawCount.ref.version !== versions.drawCount) {
        stats.drawCount += values2.drawCount.ref.value - drawCount;
        stats.instancedDrawCount += instanceCount * values2.drawCount.ref.value - instanceCount * drawCount;
        drawCount = values2.drawCount.ref.value;
        versions.drawCount = values2.drawCount.ref.version;
      }
      if (values2.instanceCount.ref.version !== versions.instanceCount) {
        stats.instanceCount += values2.instanceCount.ref.value - instanceCount;
        stats.instancedDrawCount += values2.instanceCount.ref.value * drawCount - instanceCount * drawCount;
        instanceCount = values2.instanceCount.ref.value;
        versions.instanceCount = values2.instanceCount.ref.version;
      }
      for (let i = 0, il = attributeBuffers.length; i < il; ++i) {
        const [k, buffer2] = attributeBuffers[i];
        const value = attributeValues[k];
        if (value.ref.version !== versions[k]) {
          if (buffer2.length >= value.ref.value.length) {
            buffer2.updateSubData(value.ref.value, 0, buffer2.length);
          } else {
            buffer2.destroy();
            const { itemSize, divisor } = schema[k];
            attributeBuffers[i][1] = resources.attribute(value.ref.value, itemSize, divisor);
            valueChanges.attributes = true;
          }
          versions[k] = value.ref.version;
        }
      }
      if (elementsBuffer && values2.elements.ref.version !== versions.elements) {
        if (elementsBuffer.length >= values2.elements.ref.value.length) {
          elementsBuffer.updateSubData(values2.elements.ref.value, 0, elementsBuffer.length);
        } else {
          elementsBuffer.destroy();
          elementsBuffer = resources.elements(values2.elements.ref.value);
          valueChanges.elements = true;
        }
        versions.elements = values2.elements.ref.version;
      }
      if (valueChanges.attributes || valueChanges.defines || valueChanges.elements) {
        for (const k of renderVariants) {
          const vertexArray = vertexArrays[k];
          if (vertexArray)
            vertexArray.destroy();
          vertexArrays[k] = vertexArrayObject ? resources.vertexArray(programs[k], attributeBuffers, elementsBuffer) : null;
        }
      }
      for (let i = 0, il = textures.length; i < il; ++i) {
        const [k, texture] = textures[i];
        const value = textureValues[k];
        if (value.ref.version !== versions[k]) {
          if (schema[k].kind !== "texture") {
            texture.load(value.ref.value);
            valueChanges.textures = true;
          } else {
            textures[i][1] = value.ref.value;
          }
          versions[k] = value.ref.version;
        }
      }
      for (let i = 0, il = materialTextures.length; i < il; ++i) {
        const [k, texture] = materialTextures[i];
        const value = materialTextureValues[k];
        if (value.ref.version !== versions[k]) {
          if (schema[k].kind !== "texture") {
            texture.load(value.ref.value);
            valueChanges.textures = true;
          } else {
            materialTextures[i][1] = value.ref.value;
          }
          versions[k] = value.ref.version;
        }
      }
      for (let i = 0, il = backBufferUniformValueEntries.length; i < il; ++i) {
        const [k, uniform] = backBufferUniformValueEntries[i];
        if (uniform.ref.version !== versions[k]) {
          ValueCell.update(frontBufferUniformValueEntries[i][1], deepClone(uniform.ref.value));
          versions[k] = uniform.ref.version;
        }
      }
    },
    destroy: () => {
      if (!destroyed) {
        for (const k of renderVariants) {
          programs[k].destroy();
          const vertexArray = vertexArrays[k];
          if (vertexArray)
            vertexArray.destroy();
        }
        textures.forEach(([k, texture]) => {
          if (schema[k].kind !== "texture")
            texture.destroy();
        });
        materialTextures.forEach(([k, texture]) => {
          if (schema[k].kind !== "texture")
            texture.destroy();
        });
        attributeBuffers.forEach(([_, buffer2]) => buffer2.destroy());
        if (elementsBuffer)
          elementsBuffer.destroy();
        stats.drawCount -= drawCount;
        stats.instanceCount -= instanceCount;
        stats.instancedDrawCount -= instanceCount * drawCount;
        destroyed = true;
      }
    }
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/primitives/plane3d.js
function Plane3D() {
  return Plane3D.create(Vec3.create(1, 0, 0), 0);
}
(function(Plane3D2) {
  function create(normal, constant) {
    return { normal, constant };
  }
  Plane3D2.create = create;
  function copy(out, p) {
    Vec3.copy(out.normal, p.normal);
    out.constant = p.constant;
    return out;
  }
  Plane3D2.copy = copy;
  function clone(p) {
    return copy(Plane3D2(), p);
  }
  Plane3D2.clone = clone;
  function normalize2(out, p) {
    const inverseNormalLength = 1 / Vec3.magnitude(p.normal);
    Vec3.scale(out.normal, p.normal, inverseNormalLength);
    out.constant = p.constant * inverseNormalLength;
    return out;
  }
  Plane3D2.normalize = normalize2;
  function negate(out, p) {
    Vec3.negate(out.normal, p.normal);
    out.constant = -p.constant;
    return out;
  }
  Plane3D2.negate = negate;
  function toArray3(p, out, offset) {
    Vec3.toArray(p.normal, out, offset);
    out[offset + 3] = p.constant;
    return out;
  }
  Plane3D2.toArray = toArray3;
  function fromArray(out, array, offset) {
    Vec3.fromArray(out.normal, array, offset);
    out.constant = array[offset + 3];
    return out;
  }
  Plane3D2.fromArray = fromArray;
  function fromNormalAndCoplanarPoint(out, normal, point) {
    Vec3.copy(out.normal, normal);
    out.constant = -Vec3.dot(out.normal, point);
    return out;
  }
  Plane3D2.fromNormalAndCoplanarPoint = fromNormalAndCoplanarPoint;
  function fromCoplanarPoints(out, a5, b5, c5) {
    const normal = Vec3.triangleNormal(Vec3(), a5, b5, c5);
    fromNormalAndCoplanarPoint(out, normal, a5);
    return out;
  }
  Plane3D2.fromCoplanarPoints = fromCoplanarPoints;
  const unnormTmpV = Vec3();
  function setUnnormalized(out, nx, ny, nz, constant) {
    Vec3.set(unnormTmpV, nx, ny, nz);
    const inverseNormalLength = 1 / Vec3.magnitude(unnormTmpV);
    Vec3.scale(out.normal, unnormTmpV, inverseNormalLength);
    out.constant = constant * inverseNormalLength;
    return out;
  }
  Plane3D2.setUnnormalized = setUnnormalized;
  function distanceToPoint(plane2, point) {
    return Vec3.dot(plane2.normal, point) + plane2.constant;
  }
  Plane3D2.distanceToPoint = distanceToPoint;
  function distanceToSpher3D(plane2, sphere) {
    return distanceToPoint(plane2, sphere.center) - sphere.radius;
  }
  Plane3D2.distanceToSpher3D = distanceToSpher3D;
  function projectPoint(out, plane2, point) {
    return Vec3.scaleAndAdd(out, point, plane2.normal, -distanceToPoint(plane2, point));
  }
  Plane3D2.projectPoint = projectPoint;
})(Plane3D || (Plane3D = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/primitives/frustum3d.js
function Frustum3D() {
  return Frustum3D.create(Plane3D(), Plane3D(), Plane3D(), Plane3D(), Plane3D(), Plane3D());
}
(function(Frustum3D2) {
  let PlaneIndex;
  (function(PlaneIndex2) {
    PlaneIndex2[PlaneIndex2["Right"] = 0] = "Right";
    PlaneIndex2[PlaneIndex2["Left"] = 1] = "Left";
    PlaneIndex2[PlaneIndex2["Bottom"] = 2] = "Bottom";
    PlaneIndex2[PlaneIndex2["Top"] = 3] = "Top";
    PlaneIndex2[PlaneIndex2["Far"] = 4] = "Far";
    PlaneIndex2[PlaneIndex2["Near"] = 5] = "Near";
  })(PlaneIndex = Frustum3D2.PlaneIndex || (Frustum3D2.PlaneIndex = {}));
  ;
  function create(right, left, bottom, top, far, near) {
    return [right, left, bottom, top, far, near];
  }
  Frustum3D2.create = create;
  function copy(out, f) {
    for (let i = 0; i < 6; ++i)
      Plane3D.copy(out[i], f[i]);
    return out;
  }
  Frustum3D2.copy = copy;
  function clone(f) {
    return copy(Frustum3D2(), f);
  }
  Frustum3D2.clone = clone;
  function fromProjectionMatrix(out, m) {
    const a00 = m[0], a01 = m[1], a02 = m[2], a03 = m[3];
    const a10 = m[4], a11 = m[5], a12 = m[6], a13 = m[7];
    const a20 = m[8], a21 = m[9], a22 = m[10], a23 = m[11];
    const a30 = m[12], a31 = m[13], a32 = m[14], a33 = m[15];
    Plane3D.setUnnormalized(out[0], a03 - a00, a13 - a10, a23 - a20, a33 - a30);
    Plane3D.setUnnormalized(out[1], a03 + a00, a13 + a10, a23 + a20, a33 + a30);
    Plane3D.setUnnormalized(out[2], a03 + a01, a13 + a11, a23 + a21, a33 + a31);
    Plane3D.setUnnormalized(out[3], a03 - a01, a13 - a11, a23 - a21, a33 - a31);
    Plane3D.setUnnormalized(out[4], a03 - a02, a13 - a12, a23 - a22, a33 - a32);
    Plane3D.setUnnormalized(out[5], a03 + a02, a13 + a12, a23 + a22, a33 + a32);
    return out;
  }
  Frustum3D2.fromProjectionMatrix = fromProjectionMatrix;
  function intersectsSphere3D(frustum, sphere) {
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; ++i) {
      const distance = Plane3D.distanceToPoint(frustum[i], center);
      if (distance < negRadius)
        return false;
    }
    return true;
  }
  Frustum3D2.intersectsSphere3D = intersectsSphere3D;
  const boxTmpV = Vec3();
  function intersectsBox3D(frustum, box2) {
    for (let i = 0; i < 6; ++i) {
      const plane2 = frustum[i];
      boxTmpV[0] = plane2.normal[0] > 0 ? box2.max[0] : box2.min[0];
      boxTmpV[1] = plane2.normal[1] > 0 ? box2.max[1] : box2.min[1];
      boxTmpV[2] = plane2.normal[2] > 0 ? box2.max[2] : box2.min[2];
      if (Plane3D.distanceToPoint(plane2, boxTmpV) < 0) {
        return false;
      }
    }
    return true;
  }
  Frustum3D2.intersectsBox3D = intersectsBox3D;
  function containsPoint(frustum, point) {
    for (let i = 0; i < 6; ++i) {
      if (Plane3D.distanceToPoint(frustum[i], point) < 0) {
        return false;
      }
    }
    return true;
  }
  Frustum3D2.containsPoint = containsPoint;
})(Frustum3D || (Frustum3D = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable.js
var p3distanceToPoint = Plane3D.distanceToPoint;
var f3intersectsSphere3D = Frustum3D.intersectsSphere3D;
var s3fromArray = Sphere3D.fromArray;
var getNextRenderableId = idFactory();
function getMdbData(cellCount, mdbData) {
  if (mdbData && mdbData.instanceCounts.length >= cellCount) {
    return mdbData;
  } else {
    return {
      firsts: new Int32Array(cellCount),
      counts: new Int32Array(cellCount),
      offsets: new Int32Array(cellCount),
      instanceCounts: new Int32Array(cellCount),
      baseVertices: new Int32Array(cellCount),
      baseInstances: new Uint32Array(cellCount),
      count: 0,
      uniforms: []
    };
  }
}
function createRenderable(renderItem, values2, state) {
  const id = getNextRenderableId();
  let mdbData = getMdbData(0);
  const mdbDataList = [];
  let cullEnabled = false;
  let lodLevelsVersion = -1;
  const s = Sphere3D();
  const updateLodLevels = () => {
    var _a;
    const lodLevels = (_a = values2.lodLevels) === null || _a === void 0 ? void 0 : _a.ref.value;
    if (lodLevels && lodLevels.length > 0) {
      const { cellCount } = values2.instanceGrid.ref.value;
      mdbDataList.length = lodLevels.length;
      for (let i = 0, il = lodLevels.length; i < il; ++i) {
        mdbDataList[i] = getMdbData(cellCount, mdbDataList[i]);
        mdbDataList[i].count = 0;
      }
      if (values2.lodLevels.ref.version !== lodLevelsVersion) {
        for (let i = 0, il = lodLevels.length; i < il; ++i) {
          if (mdbDataList[i].uniforms.length !== 1) {
            mdbDataList[i].uniforms.length = 1;
            mdbDataList[i].uniforms[0] = ["uLod", ValueCell.create(Vec4())];
          }
          ValueCell.update(mdbDataList[i].uniforms[0][1], Vec4.set(mdbDataList[i].uniforms[0][1].ref.value, lodLevels[i][0], lodLevels[i][1], lodLevels[i][2], lodLevels[i][4]));
        }
        lodLevelsVersion = values2.lodLevels.ref.version;
      }
    }
  };
  updateLodLevels();
  return {
    id,
    materialId: renderItem.materialId,
    values: values2,
    state,
    cull: (cameraPlane, frustum, isOccluded, stats) => {
      var _a, _b;
      cullEnabled = false;
      if (values2.drawCount.ref.value === 0)
        return;
      if (values2.instanceCount.ref.value === 0)
        return;
      if (values2.instanceGrid.ref.value.cellSize <= 1)
        return;
      const { cellOffsets, cellSpheres, cellCount, batchOffsets, batchSpheres, batchCount, batchCell, batchSize } = values2.instanceGrid.ref.value;
      const [minDistance, maxDistance] = values2.uLod.ref.value;
      const hasLod = minDistance !== 0 || maxDistance !== 0;
      const checkCellOccludedDistance = 2 * batchSize;
      const lodLevels = (_a = values2.lodLevels) === null || _a === void 0 ? void 0 : _a.ref.value;
      if (lodLevels && lodLevels.length > 0) {
        if (((_b = values2.lodLevels) === null || _b === void 0 ? void 0 : _b.ref.version) !== lodLevelsVersion) {
          updateLodLevels();
        } else {
          for (let i = 0, il = lodLevels.length; i < il; ++i) {
            mdbDataList[i].count = 0;
          }
        }
        for (let k = 0; k < batchCount; ++k) {
          const cBegin = batchOffsets[k];
          const cEnd = batchOffsets[k + 1];
          const cCount = cEnd - cBegin;
          if (cCount === 0)
            continue;
          s3fromArray(s, batchSpheres, k * 4);
          const d3 = p3distanceToPoint(cameraPlane, s.center);
          if (hasLod) {
            if (d3 + s.radius < minDistance || d3 - s.radius > maxDistance) {
              if (isTimingMode) {
                stats.culled.lod += cellOffsets[batchCell[cEnd - 1] + 1] - cellOffsets[batchCell[cBegin]];
              }
              continue;
            }
          }
          if (!f3intersectsSphere3D(frustum, s)) {
            if (isTimingMode) {
              stats.culled.frustum += cellOffsets[batchCell[cEnd - 1] + 1] - cellOffsets[batchCell[cBegin]];
            }
            continue;
          }
          if (isOccluded !== null && isOccluded(s)) {
            if (isTimingMode) {
              stats.culled.occlusion += cellOffsets[batchCell[cEnd - 1] + 1] - cellOffsets[batchCell[cBegin]];
            }
            continue;
          }
          for (let q = cBegin; q < cEnd; ++q) {
            const i = batchCell[q];
            const begin = cellOffsets[i];
            const end = cellOffsets[i + 1];
            const count3 = end - begin;
            if (count3 === 0)
              continue;
            s3fromArray(s, cellSpheres, i * 4);
            const d4 = p3distanceToPoint(cameraPlane, s.center);
            if (hasLod) {
              if (d4 + s.radius < minDistance || d4 - s.radius > maxDistance) {
                if (isTimingMode) {
                  stats.culled.lod += count3;
                }
                continue;
              }
            }
            if (!f3intersectsSphere3D(frustum, s)) {
              if (isTimingMode) {
                stats.culled.frustum += count3;
              }
              continue;
            }
            if (isOccluded !== null && d4 - s.radius < checkCellOccludedDistance && isOccluded(s)) {
              if (isTimingMode) {
                stats.culled.occlusion += count3;
              }
              continue;
            }
            for (let j = 0, jl = lodLevels.length; j < jl; ++j) {
              if (d4 + s.radius < lodLevels[j][0] || d4 - s.radius > lodLevels[j][1])
                continue;
              const l = mdbDataList[j];
              const o = l.count;
              if (o > 0 && l.baseInstances[o - 1] + l.instanceCounts[o - 1] === begin && l.counts[o - 1] === lodLevels[j][3]) {
                l.instanceCounts[o - 1] += count3;
              } else {
                l.counts[o] = lodLevels[j][3];
                l.instanceCounts[o] = count3;
                l.baseInstances[o] = begin;
                l.count += 1;
              }
            }
          }
        }
      } else {
        mdbData = getMdbData(cellCount, mdbData);
        const { baseInstances, instanceCounts, counts } = mdbData;
        let o = 0;
        for (let k = 0; k < batchCount; ++k) {
          const cBegin = batchOffsets[k];
          const cEnd = batchOffsets[k + 1];
          const cCount = cEnd - cBegin;
          if (cCount === 0)
            continue;
          s3fromArray(s, batchSpheres, k * 4);
          if (hasLod) {
            const d3 = p3distanceToPoint(cameraPlane, s.center);
            if (d3 + s.radius < minDistance || d3 - s.radius > maxDistance) {
              if (isTimingMode) {
                stats.culled.lod += cellOffsets[batchCell[cEnd - 1] + 1] - cellOffsets[batchCell[cBegin]];
              }
              continue;
            }
          }
          if (!f3intersectsSphere3D(frustum, s)) {
            if (isTimingMode) {
              stats.culled.frustum += cellOffsets[batchCell[cEnd - 1] + 1] - cellOffsets[batchCell[cBegin]];
            }
            continue;
          }
          if (isOccluded !== null && isOccluded(s)) {
            if (isTimingMode) {
              stats.culled.occlusion += cellOffsets[batchCell[cEnd - 1] + 1] - cellOffsets[batchCell[cBegin]];
            }
            continue;
          }
          for (let q = cBegin; q < cEnd; ++q) {
            const i = batchCell[q];
            const begin = cellOffsets[i];
            const end = cellOffsets[i + 1];
            const count3 = end - begin;
            if (count3 === 0)
              continue;
            s3fromArray(s, cellSpheres, i * 4);
            const d3 = p3distanceToPoint(cameraPlane, s.center);
            if (hasLod) {
              if (d3 + s.radius < minDistance || d3 - s.radius > maxDistance) {
                if (isTimingMode) {
                  stats.culled.lod += count3;
                }
                continue;
              }
            }
            if (!f3intersectsSphere3D(frustum, s)) {
              if (isTimingMode) {
                stats.culled.frustum += count3;
              }
              continue;
            }
            if (isOccluded !== null && d3 - s.radius < checkCellOccludedDistance && isOccluded(s)) {
              if (isTimingMode) {
                stats.culled.occlusion += count3;
              }
              continue;
            }
            if (o > 0 && baseInstances[o - 1] + instanceCounts[o - 1] === begin) {
              instanceCounts[o - 1] += count3;
            } else {
              counts[o] = values2.drawCount.ref.value;
              instanceCounts[o] = count3;
              baseInstances[o] = begin;
              o += 1;
            }
          }
        }
        mdbData.count = o;
        mdbDataList.length = 1;
        mdbDataList[0] = mdbData;
        mdbDataList[0].uniforms.length = 0;
      }
      cullEnabled = true;
    },
    uncull: () => {
      cullEnabled = false;
    },
    render: (variant, sharedTexturesCount) => {
      if (values2.uAlpha && values2.alpha) {
        ValueCell.updateIfChanged(values2.uAlpha, clamp(values2.alpha.ref.value * state.alphaFactor, 0, 1));
      }
      renderItem.render(variant, sharedTexturesCount, cullEnabled ? mdbDataList : void 0);
    },
    getProgram: (variant) => renderItem.getProgram(variant),
    setTransparency: (transparency) => renderItem.setTransparency(transparency),
    update: () => {
      renderItem.update();
      updateLodLevels();
    },
    dispose: () => renderItem.destroy()
  };
}
function createComputeRenderable(renderItem, values2) {
  return {
    id: getNextRenderableId(),
    values: values2,
    render: () => renderItem.render("compute", 0),
    update: () => renderItem.update(),
    dispose: () => renderItem.destroy()
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/compute/util.js
var QuadPositions = new Float32Array([
  1,
  1,
  -1,
  1,
  -1,
  -1,
  // First triangle
  -1,
  -1,
  1,
  -1,
  1,
  1
  // Second triangle
]);
var QuadSchema = {
  drawCount: ValueSpec("number"),
  instanceCount: ValueSpec("number"),
  aPosition: AttributeSpec("float32", 2, 0),
  uQuadScale: UniformSpec("v2")
};
var QuadValues = {
  drawCount: ValueCell.create(6),
  instanceCount: ValueCell.create(1),
  aPosition: ValueCell.create(QuadPositions),
  uQuadScale: ValueCell.create(Vec2.create(1, 1))
};
var CopySchema = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSize: UniformSpec("v2")
};
var CopyShaderCode = ShaderCode("copy", quad_vert, copy_frag);
function createCopyRenderable(ctx, texture) {
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(texture),
    uTexSize: ValueCell.create(Vec2.create(texture.getWidth(), texture.getHeight()))
  };
  const schema = { ...CopySchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", CopyShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/image/image.js
var QuadIndices = new Uint32Array([
  0,
  1,
  2,
  1,
  3,
  2
]);
var QuadUvs = new Float32Array([
  0,
  1,
  0,
  0,
  1,
  1,
  1,
  0
]);
var InterpolationTypes = {
  "nearest": "Nearest",
  "catmulrom": "Catmulrom (Cubic)",
  "mitchell": "Mitchell (Cubic)",
  "bspline": "B-Spline (Cubic)"
};
var InterpolationTypeNames = Object.keys(InterpolationTypes);
var Image2;
(function(Image3) {
  function createEmptyTrim() {
    return { type: 0, center: Vec3(), rotation: Quat(), scale: Vec3(), transform: Mat4() };
  }
  Image3.createEmptyTrim = createEmptyTrim;
  function create(imageTexture, corners, groupTexture, valueTexture, trim2, isoLevel, image) {
    return image ? update10(imageTexture, corners, groupTexture, valueTexture, trim2, isoLevel, image) : fromData(imageTexture, corners, groupTexture, valueTexture, trim2, isoLevel);
  }
  Image3.create = create;
  function hashCode3(image) {
    return hashFnv32a([
      image.cornerBuffer.ref.version
    ]);
  }
  function fromData(imageTexture, corners, groupTexture, valueTexture, trim2, isoLevel) {
    const boundingSphere = Sphere3D();
    let currentHash = -1;
    const width = imageTexture.width;
    const height = imageTexture.height;
    const image = {
      kind: "image",
      imageTexture: ValueCell.create(imageTexture),
      imageTextureDim: ValueCell.create(Vec2.create(width, height)),
      cornerBuffer: ValueCell.create(corners),
      groupTexture: ValueCell.create(groupTexture),
      valueTexture: ValueCell.create(valueTexture),
      trimType: ValueCell.create(trim2.type),
      trimCenter: ValueCell.create(trim2.center),
      trimRotation: ValueCell.create(trim2.rotation),
      trimScale: ValueCell.create(trim2.scale),
      trimTransform: ValueCell.create(trim2.transform),
      isoLevel: ValueCell.create(isoLevel),
      get boundingSphere() {
        const newHash = hashCode3(image);
        if (newHash !== currentHash) {
          const b5 = getBoundingSphere2(image.cornerBuffer.ref.value);
          Sphere3D.copy(boundingSphere, b5);
          currentHash = newHash;
        }
        return boundingSphere;
      },
      setBoundingSphere(sphere) {
        Sphere3D.copy(boundingSphere, sphere);
        currentHash = hashCode3(image);
      }
    };
    return image;
  }
  function update10(imageTexture, corners, groupTexture, valueTexture, trim2, isoLevel, image) {
    const width = imageTexture.width;
    const height = imageTexture.height;
    ValueCell.update(image.imageTexture, imageTexture);
    ValueCell.update(image.imageTextureDim, Vec2.set(image.imageTextureDim.ref.value, width, height));
    ValueCell.update(image.cornerBuffer, corners);
    ValueCell.update(image.groupTexture, groupTexture);
    ValueCell.update(image.valueTexture, valueTexture);
    ValueCell.updateIfChanged(image.trimType, trim2.type);
    ValueCell.update(image.trimCenter, Vec3.copy(image.trimCenter.ref.value, trim2.center));
    ValueCell.update(image.trimRotation, Quat.copy(image.trimRotation.ref.value, trim2.rotation));
    ValueCell.update(image.trimScale, Vec3.copy(image.trimScale.ref.value, trim2.scale));
    ValueCell.update(image.trimTransform, Mat4.copy(image.trimTransform.ref.value, trim2.transform));
    ValueCell.updateIfChanged(image.isoLevel, isoLevel);
    return image;
  }
  function createEmpty(image) {
    const imageTexture = createTextureImage(0, 4, Uint8Array);
    const corners = image ? image.cornerBuffer.ref.value : new Float32Array(8 * 3);
    const groupTexture = createTextureImage(0, 4, Uint8Array);
    const valueTexture = createTextureImage(0, 1, Float32Array);
    const trim2 = createEmptyTrim();
    return create(imageTexture, corners, groupTexture, valueTexture, trim2, -1, image);
  }
  Image3.createEmpty = createEmpty;
  Image3.Params = {
    ...BaseGeometry.Params,
    interpolation: ParamDefinition.Select("bspline", ParamDefinition.objectToOptions(InterpolationTypes))
  };
  Image3.Utils = {
    Params: Image3.Params,
    createEmpty,
    createValues,
    createValuesSimple,
    updateValues,
    updateBoundingSphere,
    createRenderableState,
    updateRenderableState,
    createPositionIterator
  };
  function createPositionIterator(_image, _transform) {
    return LocationIterator(1, 1, 1, () => NullLocation);
  }
  function createValues(image, transform, locationIt, theme, props) {
    const { instanceCount, groupCount } = locationIt;
    const positionIt = createPositionIterator(image, transform);
    const color = createColors(locationIt, positionIt, theme.color);
    const marker = props.instanceGranularity ? createMarkers(instanceCount, "instance") : createMarkers(instanceCount * groupCount, "groupInstance");
    const overpaint = createEmptyOverpaint();
    const transparency = createEmptyTransparency();
    const emissive = createEmptyEmissive();
    const material = createEmptySubstance();
    const clipping = createEmptyClipping();
    const counts = { drawCount: QuadIndices.length, vertexCount: QuadPositions.length / 3, groupCount, instanceCount };
    const invariantBoundingSphere = Sphere3D.clone(image.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount, 0);
    return {
      dGeometryType: ValueCell.create("image"),
      ...color,
      ...marker,
      ...overpaint,
      ...transparency,
      ...emissive,
      ...material,
      ...clipping,
      ...transform,
      ...BaseGeometry.createValues(props, counts),
      aPosition: image.cornerBuffer,
      aUv: ValueCell.create(QuadUvs),
      elements: ValueCell.create(QuadIndices),
      // aGroup is used as a vertex index here, group id is in tGroupTex
      aGroup: ValueCell.create(fillSerial(new Float32Array(4))),
      boundingSphere: ValueCell.create(boundingSphere),
      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),
      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)),
      dInterpolation: ValueCell.create(props.interpolation),
      uImageTexDim: image.imageTextureDim,
      tImageTex: image.imageTexture,
      tGroupTex: image.groupTexture,
      tValueTex: image.valueTexture,
      uTrimType: image.trimType,
      uTrimCenter: image.trimCenter,
      uTrimRotation: image.trimRotation,
      uTrimScale: image.trimScale,
      uTrimTransform: image.trimTransform,
      uIsoLevel: image.isoLevel
    };
  }
  function createValuesSimple(image, props, colorValue, sizeValue, transform) {
    const s = BaseGeometry.createSimple(colorValue, sizeValue, transform);
    const p = { ...ParamDefinition.getDefaultValues(Image3.Params), ...props };
    return createValues(image, s.transform, s.locationIterator, s.theme, p);
  }
  function updateValues(values2, props) {
    BaseGeometry.updateValues(values2, props);
    ValueCell.updateIfChanged(values2.dInterpolation, props.interpolation);
  }
  function updateBoundingSphere(values2, image) {
    const invariantBoundingSphere = Sphere3D.clone(image.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values2.aTransform.ref.value, values2.instanceCount.ref.value, 0);
    if (!Sphere3D.equals(boundingSphere, values2.boundingSphere.ref.value)) {
      ValueCell.update(values2.boundingSphere, boundingSphere);
    }
    if (!Sphere3D.equals(invariantBoundingSphere, values2.invariantBoundingSphere.ref.value)) {
      ValueCell.update(values2.invariantBoundingSphere, invariantBoundingSphere);
      ValueCell.update(values2.uInvariantBoundingSphere, Vec4.fromSphere(values2.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));
    }
  }
  function createRenderableState(props) {
    const state = BaseGeometry.createRenderableState(props);
    state.opaque = false;
    return state;
  }
  function updateRenderableState(state, props) {
    BaseGeometry.updateRenderableState(state, props);
    state.opaque = false;
  }
})(Image2 || (Image2 = {}));
function getBoundingSphere2(corners) {
  const center = Vec3();
  const extrema = [];
  for (let i = 0, il = corners.length; i < il; i += 3) {
    const e = Vec3.fromArray(Vec3(), corners, i);
    extrema.push(e);
    Vec3.add(center, center, e);
  }
  Vec3.scale(center, center, 1 / (corners.length / 3));
  let radius = 0;
  for (const e of extrema) {
    const d3 = Vec3.distance(center, e);
    if (d3 > radius)
      radius = d3;
  }
  const sphere = Sphere3D.create(center, radius);
  Sphere3D.setExtrema(sphere, extrema);
  return sphere;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/cylinders/cylinders.js
var Cylinders;
(function(Cylinders2) {
  function create(mappings, indices2, groups, starts, ends, scales, caps, colorModes, cylinderCount, cylinders) {
    return cylinders ? update10(mappings, indices2, groups, starts, ends, scales, caps, colorModes, cylinderCount, cylinders) : fromArrays(mappings, indices2, groups, starts, ends, scales, caps, colorModes, cylinderCount);
  }
  Cylinders2.create = create;
  function createEmpty(cylinders) {
    const mb = cylinders ? cylinders.mappingBuffer.ref.value : new Float32Array(0);
    const ib = cylinders ? cylinders.indexBuffer.ref.value : new Uint32Array(0);
    const gb = cylinders ? cylinders.groupBuffer.ref.value : new Float32Array(0);
    const sb = cylinders ? cylinders.startBuffer.ref.value : new Float32Array(0);
    const eb = cylinders ? cylinders.endBuffer.ref.value : new Float32Array(0);
    const ab2 = cylinders ? cylinders.scaleBuffer.ref.value : new Float32Array(0);
    const cb2 = cylinders ? cylinders.capBuffer.ref.value : new Float32Array(0);
    const cmb = cylinders ? cylinders.colorModeBuffer.ref.value : new Float32Array(0);
    return create(mb, ib, gb, sb, eb, ab2, cb2, cmb, 0, cylinders);
  }
  Cylinders2.createEmpty = createEmpty;
  function hashCode3(cylinders) {
    return hashFnv32a([
      cylinders.cylinderCount,
      cylinders.mappingBuffer.ref.version,
      cylinders.indexBuffer.ref.version,
      cylinders.groupBuffer.ref.version,
      cylinders.startBuffer.ref.version,
      cylinders.endBuffer.ref.version,
      cylinders.scaleBuffer.ref.version,
      cylinders.capBuffer.ref.version,
      cylinders.colorModeBuffer.ref.version
    ]);
  }
  function fromArrays(mappings, indices2, groups, starts, ends, scales, caps, colorModes, cylinderCount) {
    const boundingSphere = Sphere3D();
    let groupMapping;
    let currentHash = -1;
    let currentGroup = -1;
    const cylinders = {
      kind: "cylinders",
      cylinderCount,
      mappingBuffer: ValueCell.create(mappings),
      indexBuffer: ValueCell.create(indices2),
      groupBuffer: ValueCell.create(groups),
      startBuffer: ValueCell.create(starts),
      endBuffer: ValueCell.create(ends),
      scaleBuffer: ValueCell.create(scales),
      capBuffer: ValueCell.create(caps),
      colorModeBuffer: ValueCell.create(colorModes),
      get boundingSphere() {
        const newHash = hashCode3(cylinders);
        if (newHash !== currentHash) {
          const s = calculateInvariantBoundingSphere(cylinders.startBuffer.ref.value, cylinders.cylinderCount * 6, 6);
          const e = calculateInvariantBoundingSphere(cylinders.endBuffer.ref.value, cylinders.cylinderCount * 6, 6);
          Sphere3D.expandBySphere(boundingSphere, s, e);
          currentHash = newHash;
        }
        return boundingSphere;
      },
      get groupMapping() {
        if (cylinders.groupBuffer.ref.version !== currentGroup) {
          groupMapping = createGroupMapping(cylinders.groupBuffer.ref.value, cylinders.cylinderCount, 6);
          currentGroup = cylinders.groupBuffer.ref.version;
        }
        return groupMapping;
      },
      setBoundingSphere(sphere) {
        Sphere3D.copy(boundingSphere, sphere);
        currentHash = hashCode3(cylinders);
      }
    };
    return cylinders;
  }
  function update10(mappings, indices2, groups, starts, ends, scales, caps, colorModes, cylinderCount, cylinders) {
    if (cylinderCount > cylinders.cylinderCount) {
      ValueCell.update(cylinders.mappingBuffer, mappings);
      ValueCell.update(cylinders.indexBuffer, indices2);
    }
    cylinders.cylinderCount = cylinderCount;
    ValueCell.update(cylinders.groupBuffer, groups);
    ValueCell.update(cylinders.startBuffer, starts);
    ValueCell.update(cylinders.endBuffer, ends);
    ValueCell.update(cylinders.scaleBuffer, scales);
    ValueCell.update(cylinders.capBuffer, caps);
    ValueCell.update(cylinders.colorModeBuffer, colorModes);
    return cylinders;
  }
  function transform(cylinders, t2) {
    const start = cylinders.startBuffer.ref.value;
    transformPositionArray(t2, start, 0, cylinders.cylinderCount * 6);
    ValueCell.update(cylinders.startBuffer, start);
    const end = cylinders.endBuffer.ref.value;
    transformPositionArray(t2, end, 0, cylinders.cylinderCount * 6);
    ValueCell.update(cylinders.endBuffer, end);
  }
  Cylinders2.transform = transform;
  Cylinders2.Params = {
    ...BaseGeometry.Params,
    sizeFactor: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }),
    sizeAspectRatio: ParamDefinition.Numeric(1, { min: 0, max: 3, step: 0.01 }),
    doubleSided: ParamDefinition.Boolean(false, BaseGeometry.CustomQualityParamInfo),
    ignoreLight: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    celShaded: ParamDefinition.Boolean(false, BaseGeometry.ShadingCategory),
    xrayShaded: ParamDefinition.Select(false, [[false, "Off"], [true, "On"], ["inverted", "Inverted"]], BaseGeometry.ShadingCategory),
    transparentBackfaces: ParamDefinition.Select("off", ParamDefinition.arrayToOptions(["off", "on", "opaque"]), BaseGeometry.ShadingCategory),
    solidInterior: ParamDefinition.Boolean(true, BaseGeometry.ShadingCategory),
    bumpFrequency: ParamDefinition.Numeric(0, { min: 0, max: 10, step: 0.1 }, BaseGeometry.ShadingCategory),
    bumpAmplitude: ParamDefinition.Numeric(1, { min: 0, max: 5, step: 0.1 }, BaseGeometry.ShadingCategory),
    colorMode: ParamDefinition.Select("default", ParamDefinition.arrayToOptions(["default", "interpolate"]), BaseGeometry.ShadingCategory)
  };
  Cylinders2.Utils = {
    Params: Cylinders2.Params,
    createEmpty,
    createValues,
    createValuesSimple,
    updateValues,
    updateBoundingSphere,
    createRenderableState,
    updateRenderableState,
    createPositionIterator
  };
  function createPositionIterator(cylinders, transform2) {
    const groupCount = cylinders.cylinderCount * 6;
    const instanceCount = transform2.instanceCount.ref.value;
    const location = PositionLocation();
    const p = location.position;
    const s = cylinders.startBuffer.ref.value;
    const e = cylinders.endBuffer.ref.value;
    const m = transform2.aTransform.ref.value;
    const getLocation = (groupIndex, instanceIndex) => {
      const v3 = groupIndex % 6 === 0 ? s : e;
      if (instanceIndex < 0) {
        Vec3.fromArray(p, v3, groupIndex * 3);
      } else {
        Vec3.transformMat4Offset(p, v3, m, 0, groupIndex * 3, instanceIndex * 16);
      }
      return location;
    };
    return LocationIterator(groupCount, instanceCount, 2, getLocation);
  }
  function createValues(cylinders, transform2, locationIt, theme, props) {
    const { instanceCount, groupCount } = locationIt;
    const positionIt = createPositionIterator(cylinders, transform2);
    const color = createColors(locationIt, positionIt, theme.color);
    const size = createSizes(locationIt, theme.size);
    const marker = props.instanceGranularity ? createMarkers(instanceCount, "instance") : createMarkers(instanceCount * groupCount, "groupInstance");
    const overpaint = createEmptyOverpaint();
    const transparency = createEmptyTransparency();
    const emissive = createEmptyEmissive();
    const material = createEmptySubstance();
    const clipping = createEmptyClipping();
    const counts = { drawCount: cylinders.cylinderCount * 4 * 3, vertexCount: cylinders.cylinderCount * 6, groupCount, instanceCount };
    const padding2 = getMaxSize(size) * props.sizeFactor;
    const invariantBoundingSphere = Sphere3D.clone(cylinders.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform2.aTransform.ref.value, instanceCount, 0);
    return {
      dGeometryType: ValueCell.create("cylinders"),
      aMapping: cylinders.mappingBuffer,
      aGroup: cylinders.groupBuffer,
      aStart: cylinders.startBuffer,
      aEnd: cylinders.endBuffer,
      aScale: cylinders.scaleBuffer,
      aCap: cylinders.capBuffer,
      aColorMode: cylinders.colorModeBuffer,
      elements: cylinders.indexBuffer,
      boundingSphere: ValueCell.create(boundingSphere),
      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),
      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)),
      ...color,
      ...size,
      ...marker,
      ...overpaint,
      ...transparency,
      ...emissive,
      ...material,
      ...clipping,
      ...transform2,
      padding: ValueCell.create(padding2),
      ...BaseGeometry.createValues(props, counts),
      uSizeFactor: ValueCell.create(props.sizeFactor * props.sizeAspectRatio),
      uDoubleSided: ValueCell.create(props.doubleSided),
      dIgnoreLight: ValueCell.create(props.ignoreLight),
      dCelShaded: ValueCell.create(props.celShaded),
      dXrayShaded: ValueCell.create(props.xrayShaded === "inverted" ? "inverted" : props.xrayShaded === true ? "on" : "off"),
      dTransparentBackfaces: ValueCell.create(props.transparentBackfaces),
      dSolidInterior: ValueCell.create(props.solidInterior),
      uBumpFrequency: ValueCell.create(props.bumpFrequency),
      uBumpAmplitude: ValueCell.create(props.bumpAmplitude),
      dDualColor: ValueCell.create(props.colorMode === "interpolate")
    };
  }
  function createValuesSimple(cylinders, props, colorValue, sizeValue, transform2) {
    const s = BaseGeometry.createSimple(colorValue, sizeValue, transform2);
    const p = { ...ParamDefinition.getDefaultValues(Cylinders2.Params), ...props };
    return createValues(cylinders, s.transform, s.locationIterator, s.theme, p);
  }
  function updateValues(values2, props) {
    BaseGeometry.updateValues(values2, props);
    ValueCell.updateIfChanged(values2.uSizeFactor, props.sizeFactor * props.sizeAspectRatio);
    ValueCell.updateIfChanged(values2.uDoubleSided, props.doubleSided);
    ValueCell.updateIfChanged(values2.dIgnoreLight, props.ignoreLight);
    ValueCell.updateIfChanged(values2.dCelShaded, props.celShaded);
    ValueCell.updateIfChanged(values2.dXrayShaded, props.xrayShaded === "inverted" ? "inverted" : props.xrayShaded === true ? "on" : "off");
    ValueCell.updateIfChanged(values2.dTransparentBackfaces, props.transparentBackfaces);
    ValueCell.updateIfChanged(values2.dSolidInterior, props.solidInterior);
    ValueCell.updateIfChanged(values2.uBumpFrequency, props.bumpFrequency);
    ValueCell.updateIfChanged(values2.uBumpAmplitude, props.bumpAmplitude);
    ValueCell.updateIfChanged(values2.dDualColor, props.colorMode === "interpolate");
  }
  function updateBoundingSphere(values2, cylinders) {
    const invariantBoundingSphere = Sphere3D.clone(cylinders.boundingSphere);
    const boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values2.aTransform.ref.value, values2.instanceCount.ref.value, 0);
    if (!Sphere3D.equals(boundingSphere, values2.boundingSphere.ref.value)) {
      ValueCell.update(values2.boundingSphere, boundingSphere);
    }
    if (!Sphere3D.equals(invariantBoundingSphere, values2.invariantBoundingSphere.ref.value)) {
      ValueCell.update(values2.invariantBoundingSphere, invariantBoundingSphere);
      ValueCell.update(values2.uInvariantBoundingSphere, Vec4.fromSphere(values2.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));
    }
  }
  function createRenderableState(props) {
    const state = BaseGeometry.createRenderableState(props);
    updateRenderableState(state, props);
    return state;
  }
  function updateRenderableState(state, props) {
    BaseGeometry.updateRenderableState(state, props);
    state.opaque = state.opaque && !props.xrayShaded;
    state.writeDepth = state.opaque;
  }
})(Cylinders || (Cylinders = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/geometry.js
var Geometry;
(function(Geometry2) {
  function getDrawCount(geometry) {
    switch (geometry.kind) {
      case "mesh":
        return geometry.triangleCount * 3;
      case "points":
        return geometry.pointCount;
      case "spheres":
        return geometry.sphereCount * 2 * 3;
      case "cylinders":
        return geometry.cylinderCount * 4 * 3;
      case "text":
        return geometry.charCount * 2 * 3;
      case "lines":
        return geometry.lineCount * 2 * 3;
      case "direct-volume":
        return 12 * 3;
      case "image":
        return 2 * 3;
      case "texture-mesh":
        return geometry.vertexCount;
    }
  }
  Geometry2.getDrawCount = getDrawCount;
  function getVertexCount(geometry) {
    switch (geometry.kind) {
      case "mesh":
        return geometry.vertexCount;
      case "points":
        return geometry.pointCount;
      case "spheres":
        return geometry.sphereCount * 6;
      case "cylinders":
        return geometry.cylinderCount * 6;
      case "text":
        return geometry.charCount * 4;
      case "lines":
        return geometry.lineCount * 4;
      case "direct-volume":
        const [x, y, z] = geometry.gridDimension.ref.value;
        return x * y * z;
      case "image":
        return 4;
      case "texture-mesh":
        return geometry.vertexCount;
    }
  }
  Geometry2.getVertexCount = getVertexCount;
  function getGroupCount(geometry) {
    switch (geometry.kind) {
      case "mesh":
      case "points":
      case "spheres":
      case "cylinders":
      case "text":
      case "lines":
        return getDrawCount(geometry) === 0 ? 0 : arrayMax(geometry.groupBuffer.ref.value) + 1;
      case "direct-volume":
        return 1;
      case "image":
        return arrayMaxPackedIntToRGB(geometry.groupTexture.ref.value.array, 4) + 1;
      case "texture-mesh":
        return geometry.groupCount;
    }
  }
  Geometry2.getGroupCount = getGroupCount;
  function getUtils(geometry) {
    switch (geometry.kind) {
      case "mesh":
        return Mesh.Utils;
      case "points":
        return Points.Utils;
      case "spheres":
        return Spheres.Utils;
      case "cylinders":
        return Cylinders.Utils;
      case "text":
        return Text.Utils;
      case "lines":
        return Lines.Utils;
      case "direct-volume":
        return DirectVolume.Utils;
      case "image":
        return Image2.Utils;
      case "texture-mesh":
        return TextureMesh.Utils;
    }
  }
  Geometry2.getUtils = getUtils;
  function getGranularity(locationIt, granularity) {
    return granularity === "instance" && locationIt.nonInstanceable ? "group" : granularity;
  }
  Geometry2.getGranularity = getGranularity;
})(Geometry || (Geometry = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/size/shape-group.js
var DefaultSize = 1;
var Description3 = "Assigns sizes as defined by the shape object.";
var ShapeGroupSizeThemeParams = {};
function getShapeGroupSizeThemeParams(ctx) {
  return ShapeGroupSizeThemeParams;
}
function ShapeGroupSizeTheme(ctx, props) {
  return {
    factory: ShapeGroupSizeTheme,
    granularity: "groupInstance",
    size: (location) => {
      if (ShapeGroup.isLocation(location)) {
        return location.shape.getSize(location.group, location.instance);
      }
      return DefaultSize;
    },
    props,
    description: Description3
  };
}
var ShapeGroupSizeThemeProvider = {
  name: "shape-group",
  label: "Shape Group",
  category: "",
  factory: ShapeGroupSizeTheme,
  getParams: getShapeGroupSizeThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(ShapeGroupSizeThemeParams),
  isApplicable: (ctx) => !!ctx.shape
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/shape-group.js
var DefaultColor2 = Color(13421772);
var Description4 = "Assigns colors as defined by the shape object.";
var ShapeGroupColorThemeParams = {};
function getShapeGroupColorThemeParams(ctx) {
  return ShapeGroupColorThemeParams;
}
function ShapeGroupColorTheme(ctx, props) {
  return {
    factory: ShapeGroupColorTheme,
    granularity: "groupInstance",
    color: (location) => {
      if (ShapeGroup.isLocation(location)) {
        return location.shape.getColor(location.group, location.instance);
      }
      return DefaultColor2;
    },
    props,
    description: Description4
  };
}
var ShapeGroupColorThemeProvider = {
  name: "shape-group",
  label: "Shape Group",
  category: ColorThemeCategory.Misc,
  factory: ShapeGroupColorTheme,
  getParams: getShapeGroupColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(ShapeGroupColorThemeParams),
  isApplicable: (ctx) => !!ctx.shape
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable/direct-volume.js
var DirectVolumeSchema = {
  ...BaseSchema,
  aPosition: AttributeSpec("float32", 3, 0),
  elements: ElementsSpec("uint32"),
  uBboxMin: UniformSpec("v3"),
  uBboxMax: UniformSpec("v3"),
  uBboxSize: UniformSpec("v3"),
  uMaxSteps: UniformSpec("i"),
  uStepScale: UniformSpec("f"),
  uJumpLength: UniformSpec("f"),
  uTransform: UniformSpec("m4"),
  uGridDim: UniformSpec("v3"),
  tTransferTex: TextureSpec("image-uint8", "alpha", "ubyte", "linear"),
  uTransferScale: UniformSpec("f", "material"),
  dGridTexType: DefineSpec("string", ["2d", "3d"]),
  uGridTexDim: UniformSpec("v3"),
  tGridTex: TextureSpec("texture", "rgba", "ubyte", "linear"),
  uGridStats: UniformSpec("v4"),
  // [min, max, mean, sigma]
  uCellDim: UniformSpec("v3"),
  uCartnToUnit: UniformSpec("m4"),
  uUnitToCartn: UniformSpec("m4"),
  dPackedGroup: DefineSpec("boolean"),
  dAxisOrder: DefineSpec("string", ["012", "021", "102", "120", "201", "210"]),
  dIgnoreLight: DefineSpec("boolean"),
  dCelShaded: DefineSpec("boolean"),
  dXrayShaded: DefineSpec("string", ["off", "on", "inverted"]),
  meta: ValueSpec("unknown")
};
function DirectVolumeRenderable(ctx, id, values2, state, materialId, transparency) {
  const schema = { ...GlobalUniformSchema, ...GlobalTextureSchema, ...InternalSchema, ...DirectVolumeSchema };
  if (!ctx.isWebGL2) {
    schema.uMaxSteps = DefineSpec("number");
  }
  const internalValues = {
    uObjectId: ValueCell.create(id)
  };
  const shaderCode = DirectVolumeShaderCode;
  const renderItem = createGraphicsRenderItem(ctx, "triangles", shaderCode, schema, { ...values2, ...internalValues }, materialId, transparency);
  return createRenderable(renderItem, values2, state);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable/mesh.js
var MeshSchema = {
  ...BaseSchema,
  aGroup: AttributeSpec("float32", 1, 0),
  aPosition: AttributeSpec("float32", 3, 0),
  aNormal: AttributeSpec("float32", 3, 0),
  elements: ElementsSpec("uint32"),
  dVaryingGroup: DefineSpec("boolean"),
  dFlatShaded: DefineSpec("boolean"),
  uDoubleSided: UniformSpec("b", "material"),
  dFlipSided: DefineSpec("boolean"),
  dIgnoreLight: DefineSpec("boolean"),
  dCelShaded: DefineSpec("boolean"),
  dXrayShaded: DefineSpec("string", ["off", "on", "inverted"]),
  dTransparentBackfaces: DefineSpec("string", ["off", "on", "opaque"]),
  uBumpFrequency: UniformSpec("f", "material"),
  uBumpAmplitude: UniformSpec("f", "material"),
  meta: ValueSpec("unknown")
};
function MeshRenderable(ctx, id, values2, state, materialId, transparency) {
  const schema = { ...GlobalUniformSchema, ...GlobalTextureSchema, ...InternalSchema, ...MeshSchema };
  const internalValues = {
    uObjectId: ValueCell.create(id)
  };
  const shaderCode = MeshShaderCode;
  const renderItem = createGraphicsRenderItem(ctx, "triangles", shaderCode, schema, { ...values2, ...internalValues }, materialId, transparency);
  return createRenderable(renderItem, values2, state);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable/points.js
var PointsSchema = {
  ...BaseSchema,
  ...SizeSchema,
  aGroup: AttributeSpec("float32", 1, 0),
  aPosition: AttributeSpec("float32", 3, 0),
  dPointSizeAttenuation: DefineSpec("boolean"),
  dPointStyle: DefineSpec("string", ["square", "circle", "fuzzy"])
};
function PointsRenderable(ctx, id, values2, state, materialId, transparency) {
  const schema = { ...GlobalUniformSchema, ...GlobalTextureSchema, ...InternalSchema, ...PointsSchema };
  const internalValues = {
    uObjectId: ValueCell.create(id)
  };
  const shaderCode = PointsShaderCode;
  const renderItem = createGraphicsRenderItem(ctx, "points", shaderCode, schema, { ...values2, ...internalValues }, materialId, transparency);
  return createRenderable(renderItem, values2, state);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable/lines.js
var LinesSchema = {
  ...BaseSchema,
  ...SizeSchema,
  aGroup: AttributeSpec("float32", 1, 0),
  aMapping: AttributeSpec("float32", 2, 0),
  aStart: AttributeSpec("float32", 3, 0),
  aEnd: AttributeSpec("float32", 3, 0),
  elements: ElementsSpec("uint32"),
  dLineSizeAttenuation: DefineSpec("boolean"),
  uDoubleSided: UniformSpec("b", "material"),
  dFlipSided: DefineSpec("boolean")
};
function LinesRenderable(ctx, id, values2, state, materialId, transparency) {
  const schema = { ...GlobalUniformSchema, ...GlobalTextureSchema, ...InternalSchema, ...LinesSchema };
  const internalValues = {
    uObjectId: ValueCell.create(id)
  };
  const shaderCode = LinesShaderCode;
  const renderItem = createGraphicsRenderItem(ctx, "triangles", shaderCode, schema, { ...values2, ...internalValues }, materialId, transparency);
  return createRenderable(renderItem, values2, state);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable/spheres.js
var SpheresSchema = {
  ...BaseSchema,
  ...SizeSchema,
  uTexDim: UniformSpec("v2"),
  tPositionGroup: TextureSpec("image-float32", "rgba", "float", "nearest"),
  padding: ValueSpec("number"),
  uDoubleSided: UniformSpec("b", "material"),
  dIgnoreLight: DefineSpec("boolean"),
  dCelShaded: DefineSpec("boolean"),
  dXrayShaded: DefineSpec("string", ["off", "on", "inverted"]),
  dTransparentBackfaces: DefineSpec("string", ["off", "on", "opaque"]),
  dSolidInterior: DefineSpec("boolean"),
  dClipPrimitive: DefineSpec("boolean"),
  dApproximate: DefineSpec("boolean"),
  uAlphaThickness: UniformSpec("f"),
  uBumpFrequency: UniformSpec("f", "material"),
  uBumpAmplitude: UniformSpec("f", "material"),
  lodLevels: ValueSpec("unknown"),
  centerBuffer: ValueSpec("float32"),
  groupBuffer: ValueSpec("float32")
};
function SpheresRenderable(ctx, id, values2, state, materialId, transparency) {
  const schema = { ...GlobalUniformSchema, ...GlobalTextureSchema, ...InternalSchema, ...SpheresSchema };
  const internalValues = {
    uObjectId: ValueCell.create(id)
  };
  const shaderCode = SpheresShaderCode;
  const renderItem = createGraphicsRenderItem(ctx, "triangles", shaderCode, schema, { ...values2, ...internalValues }, materialId, transparency);
  return createRenderable(renderItem, values2, state);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable/text.js
var TextSchema = {
  ...BaseSchema,
  ...SizeSchema,
  aGroup: AttributeSpec("float32", 1, 0),
  aPosition: AttributeSpec("float32", 3, 0),
  aMapping: AttributeSpec("float32", 2, 0),
  aDepth: AttributeSpec("float32", 1, 0),
  elements: ElementsSpec("uint32"),
  aTexCoord: AttributeSpec("float32", 2, 0),
  tFont: TextureSpec("image-uint8", "alpha", "ubyte", "linear"),
  padding: ValueSpec("number"),
  uBorderWidth: UniformSpec("f", "material"),
  uBorderColor: UniformSpec("v3", "material"),
  uOffsetX: UniformSpec("f", "material"),
  uOffsetY: UniformSpec("f", "material"),
  uOffsetZ: UniformSpec("f", "material"),
  uBackgroundColor: UniformSpec("v3", "material"),
  uBackgroundOpacity: UniformSpec("f", "material")
};
function TextRenderable(ctx, id, values2, state, materialId, transparency) {
  const schema = { ...GlobalUniformSchema, ...GlobalTextureSchema, ...InternalSchema, ...TextSchema };
  const internalValues = {
    uObjectId: ValueCell.create(id)
  };
  const shaderCode = TextShaderCode;
  const renderItem = createGraphicsRenderItem(ctx, "triangles", shaderCode, schema, { ...values2, ...internalValues }, materialId, transparency);
  return createRenderable(renderItem, values2, state);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable/texture-mesh.js
var TextureMeshSchema = {
  ...BaseSchema,
  uGeoTexDim: UniformSpec("v2", "buffered"),
  tPosition: TextureSpec("texture", "rgb", "float", "nearest"),
  tGroup: TextureSpec("texture", "alpha", "float", "nearest"),
  tNormal: TextureSpec("texture", "rgb", "float", "nearest"),
  dVaryingGroup: DefineSpec("boolean"),
  dFlatShaded: DefineSpec("boolean"),
  uDoubleSided: UniformSpec("b", "material"),
  dFlipSided: DefineSpec("boolean"),
  dIgnoreLight: DefineSpec("boolean"),
  dCelShaded: DefineSpec("boolean"),
  dXrayShaded: DefineSpec("string", ["off", "on", "inverted"]),
  dTransparentBackfaces: DefineSpec("string", ["off", "on", "opaque"]),
  uBumpFrequency: UniformSpec("f", "material"),
  uBumpAmplitude: UniformSpec("f", "material"),
  meta: ValueSpec("unknown")
};
function TextureMeshRenderable(ctx, id, values2, state, materialId, transparency) {
  const schema = { ...GlobalUniformSchema, ...GlobalTextureSchema, ...InternalSchema, ...TextureMeshSchema };
  const internalValues = {
    uObjectId: ValueCell.create(id)
  };
  const shaderCode = MeshShaderCode;
  const renderItem = createGraphicsRenderItem(ctx, "triangles", shaderCode, schema, { ...values2, ...internalValues }, materialId, transparency);
  return createRenderable(renderItem, values2, state);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable/image.js
var ImageSchema = {
  ...BaseSchema,
  aGroup: AttributeSpec("float32", 1, 0),
  aPosition: AttributeSpec("float32", 3, 0),
  aUv: AttributeSpec("float32", 2, 0),
  elements: ElementsSpec("uint32"),
  uImageTexDim: UniformSpec("v2"),
  tImageTex: TextureSpec("image-uint8", "rgba", "ubyte", "nearest"),
  tGroupTex: TextureSpec("image-uint8", "rgba", "ubyte", "nearest"),
  tValueTex: TextureSpec("image-float32", "alpha", "float", "linear"),
  uTrimType: UniformSpec("i"),
  uTrimCenter: UniformSpec("v3"),
  uTrimRotation: UniformSpec("q"),
  uTrimScale: UniformSpec("v3"),
  uTrimTransform: UniformSpec("m4"),
  uIsoLevel: UniformSpec("f"),
  dInterpolation: DefineSpec("string", InterpolationTypeNames)
};
function ImageRenderable(ctx, id, values2, state, materialId, transparency) {
  const schema = { ...GlobalUniformSchema, ...GlobalTextureSchema, ...InternalSchema, ...ImageSchema };
  const internalValues = {
    uObjectId: ValueCell.create(id)
  };
  const shaderCode = ImageShaderCode;
  const renderItem = createGraphicsRenderItem(ctx, "triangles", shaderCode, schema, { ...values2, ...internalValues }, materialId, transparency);
  return createRenderable(renderItem, values2, state);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderable/cylinders.js
var CylindersSchema = {
  ...BaseSchema,
  ...SizeSchema,
  aGroup: AttributeSpec("float32", 1, 0),
  aStart: AttributeSpec("float32", 3, 0),
  aEnd: AttributeSpec("float32", 3, 0),
  aMapping: AttributeSpec("float32", 3, 0),
  aScale: AttributeSpec("float32", 1, 0),
  aCap: AttributeSpec("float32", 1, 0),
  aColorMode: AttributeSpec("float32", 1, 0),
  elements: ElementsSpec("uint32"),
  padding: ValueSpec("number"),
  uDoubleSided: UniformSpec("b", "material"),
  dIgnoreLight: DefineSpec("boolean"),
  dCelShaded: DefineSpec("boolean"),
  dXrayShaded: DefineSpec("string", ["off", "on", "inverted"]),
  dTransparentBackfaces: DefineSpec("string", ["off", "on", "opaque"]),
  dSolidInterior: DefineSpec("boolean"),
  uBumpFrequency: UniformSpec("f", "material"),
  uBumpAmplitude: UniformSpec("f", "material"),
  dDualColor: DefineSpec("boolean")
};
function CylindersRenderable(ctx, id, values2, state, materialId, transparency) {
  const schema = { ...GlobalUniformSchema, ...GlobalTextureSchema, ...InternalSchema, ...CylindersSchema };
  const internalValues = {
    uObjectId: ValueCell.create(id)
  };
  const shaderCode = CylindersShaderCode;
  const renderItem = createGraphicsRenderItem(ctx, "triangles", shaderCode, schema, { ...values2, ...internalValues }, materialId, transparency);
  return createRenderable(renderItem, values2, state);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/render-object.js
var getNextId = idFactory(0, 2147483647);
var getNextMaterialId = idFactory(0, 2147483647);
function createRenderObject(type, values2, state, materialId) {
  return { id: getNextId(), type, values: values2, state, materialId };
}
function createRenderable2(ctx, o, transparency) {
  switch (o.type) {
    case "mesh":
      return MeshRenderable(ctx, o.id, o.values, o.state, o.materialId, transparency);
    case "points":
      return PointsRenderable(ctx, o.id, o.values, o.state, o.materialId, transparency);
    case "spheres":
      return SpheresRenderable(ctx, o.id, o.values, o.state, o.materialId, transparency);
    case "cylinders":
      return CylindersRenderable(ctx, o.id, o.values, o.state, o.materialId, transparency);
    case "text":
      return TextRenderable(ctx, o.id, o.values, o.state, o.materialId, transparency);
    case "lines":
      return LinesRenderable(ctx, o.id, o.values, o.state, o.materialId, transparency);
    case "direct-volume":
      return DirectVolumeRenderable(ctx, o.id, o.values, o.state, o.materialId, transparency);
    case "image":
      return ImageRenderable(ctx, o.id, o.values, o.state, o.materialId, transparency);
    case "texture-mesh":
      return TextureMeshRenderable(ctx, o.id, o.values, o.state, o.materialId, transparency);
  }
  throw new Error("unsupported type");
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/shape/shape.js
var Shape;
(function(Shape2) {
  function create(name, sourceData, geometry, getColor, getSize, getLabel, transforms) {
    return {
      id: UUID.create22(),
      name,
      sourceData,
      geometry,
      transforms: transforms || [Mat4.identity()],
      get groupCount() {
        return Geometry.getGroupCount(geometry);
      },
      getColor,
      getSize,
      getLabel
    };
  }
  Shape2.create = create;
  function getTheme(shape) {
    return {
      color: ShapeGroupColorTheme({ shape }, {}),
      size: ShapeGroupSizeTheme({ shape }, {})
    };
  }
  Shape2.getTheme = getTheme;
  function groupIterator(shape) {
    const instanceCount = shape.transforms.length;
    const location = ShapeGroup.Location(shape);
    const getLocation = (groupIndex, instanceIndex) => {
      location.group = groupIndex;
      location.instance = instanceIndex;
      return location;
    };
    return LocationIterator(shape.groupCount, instanceCount, 1, getLocation);
  }
  Shape2.groupIterator = groupIterator;
  function createTransform2(transforms, invariantBoundingSphere, cellSize, batchSize, transformData) {
    const transformArray = transformData && transformData.aTransform.ref.value.length >= transforms.length * 16 ? transformData.aTransform.ref.value : new Float32Array(transforms.length * 16);
    for (let i = 0, il = transforms.length; i < il; ++i) {
      Mat4.toArray(transforms[i], transformArray, i * 16);
    }
    return createTransform(transformArray, transforms.length, invariantBoundingSphere, cellSize, batchSize, transformData);
  }
  Shape2.createTransform = createTransform2;
  function createRenderObject2(shape, props) {
    props;
    const theme = getTheme(shape);
    const utils = Geometry.getUtils(shape.geometry);
    const materialId = getNextMaterialId();
    const locationIt = groupIterator(shape);
    const transform = createTransform2(shape.transforms, shape.geometry.boundingSphere, props.cellSize, props.batchSize);
    const values2 = utils.createValues(shape.geometry, transform, locationIt, theme, props);
    const state = utils.createRenderableState(props);
    return createRenderObject(shape.geometry.kind, values2, state, materialId);
  }
  Shape2.createRenderObject = createRenderObject2;
  function Loci2(shape) {
    return { kind: "shape-loci", shape };
  }
  Shape2.Loci = Loci2;
  function isLoci(x) {
    return !!x && x.kind === "shape-loci";
  }
  Shape2.isLoci = isLoci;
  function areLociEqual(a5, b5) {
    return a5.shape === b5.shape;
  }
  Shape2.areLociEqual = areLociEqual;
  function isLociEmpty(loci) {
    return loci.shape.groupCount === 0;
  }
  Shape2.isLociEmpty = isLociEmpty;
})(Shape || (Shape = {}));
var ShapeGroup;
(function(ShapeGroup2) {
  function Location(shape, group = 0, instance = 0) {
    return { kind: "group-location", shape, group, instance };
  }
  ShapeGroup2.Location = Location;
  function isLocation(x) {
    return !!x && x.kind === "group-location";
  }
  ShapeGroup2.isLocation = isLocation;
  function Loci2(shape, groups) {
    return { kind: "group-loci", shape, groups };
  }
  ShapeGroup2.Loci = Loci2;
  function isLoci(x) {
    return !!x && x.kind === "group-loci";
  }
  ShapeGroup2.isLoci = isLoci;
  function areLociEqual(a5, b5) {
    if (a5.shape !== b5.shape)
      return false;
    if (a5.groups.length !== b5.groups.length)
      return false;
    for (let i = 0, il = a5.groups.length; i < il; ++i) {
      const { ids: idsA, instance: instanceA } = a5.groups[i];
      const { ids: idsB, instance: instanceB } = b5.groups[i];
      if (instanceA !== instanceB)
        return false;
      if (!OrderedSet.areEqual(idsA, idsB))
        return false;
    }
    return true;
  }
  ShapeGroup2.areLociEqual = areLociEqual;
  function isLociEmpty(loci) {
    return size(loci) === 0 ? true : false;
  }
  ShapeGroup2.isLociEmpty = isLociEmpty;
  function size(loci) {
    let size2 = 0;
    for (const group of loci.groups) {
      size2 += OrderedSet.size(group.ids);
    }
    return size2;
  }
  ShapeGroup2.size = size;
  const sphereHelper = new CentroidHelper(), tmpPos2 = Vec3.zero();
  function sphereHelperInclude(groups, mapping, positions, transforms) {
    const { indices: indices2, offsets } = mapping;
    for (const { ids, instance } of groups) {
      OrderedSet.forEach(ids, (v3) => {
        for (let i = offsets[v3], il = offsets[v3 + 1]; i < il; ++i) {
          Vec3.fromArray(tmpPos2, positions, indices2[i] * 3);
          Vec3.transformMat4(tmpPos2, tmpPos2, transforms[instance]);
          sphereHelper.includeStep(tmpPos2);
        }
      });
    }
  }
  function sphereHelperRadius(groups, mapping, positions, transforms) {
    const { indices: indices2, offsets } = mapping;
    for (const { ids, instance } of groups) {
      OrderedSet.forEach(ids, (v3) => {
        for (let i = offsets[v3], il = offsets[v3 + 1]; i < il; ++i) {
          Vec3.fromArray(tmpPos2, positions, indices2[i] * 3);
          Vec3.transformMat4(tmpPos2, tmpPos2, transforms[instance]);
          sphereHelper.radiusStep(tmpPos2);
        }
      });
    }
  }
  function getBoundingSphere3(loci, boundingSphere) {
    if (!boundingSphere)
      boundingSphere = Sphere3D();
    sphereHelper.reset();
    let padding2 = 0;
    const { geometry, transforms } = loci.shape;
    if (geometry.kind === "mesh" || geometry.kind === "points") {
      const positions = geometry.kind === "mesh" ? geometry.vertexBuffer.ref.value : geometry.centerBuffer.ref.value;
      sphereHelperInclude(loci.groups, geometry.groupMapping, positions, transforms);
      sphereHelper.finishedIncludeStep();
      sphereHelperRadius(loci.groups, geometry.groupMapping, positions, transforms);
    } else if (geometry.kind === "lines") {
      const start = geometry.startBuffer.ref.value;
      const end = geometry.endBuffer.ref.value;
      sphereHelperInclude(loci.groups, geometry.groupMapping, start, transforms);
      sphereHelperInclude(loci.groups, geometry.groupMapping, end, transforms);
      sphereHelper.finishedIncludeStep();
      sphereHelperRadius(loci.groups, geometry.groupMapping, start, transforms);
      sphereHelperRadius(loci.groups, geometry.groupMapping, end, transforms);
    } else if (geometry.kind === "spheres" || geometry.kind === "text") {
      const positions = geometry.centerBuffer.ref.value;
      sphereHelperInclude(loci.groups, geometry.groupMapping, positions, transforms);
      sphereHelper.finishedIncludeStep();
      sphereHelperRadius(loci.groups, geometry.groupMapping, positions, transforms);
      for (const { ids, instance } of loci.groups) {
        OrderedSet.forEach(ids, (v3) => {
          const value = loci.shape.getSize(v3, instance);
          if (padding2 < value)
            padding2 = value;
        });
      }
    } else {
      return Sphere3D.copy(boundingSphere, geometry.boundingSphere);
    }
    Vec3.copy(boundingSphere.center, sphereHelper.center);
    boundingSphere.radius = Math.sqrt(sphereHelper.radiusSq);
    Sphere3D.expand(boundingSphere, boundingSphere, padding2);
    return boundingSphere;
  }
  ShapeGroup2.getBoundingSphere = getBoundingSphere3;
})(ShapeGroup || (ShapeGroup = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/shape/ply.js
function createPlyShapeParams(plyFile) {
  const vertex = plyFile && plyFile.getElement("vertex");
  const material = plyFile && plyFile.getElement("material");
  const defaultValues = { group: "", vRed: "", vGreen: "", vBlue: "", mRed: "", mGreen: "", mBlue: "" };
  const groupOptions = [["", ""]];
  const colorOptions = [["", ""]];
  if (vertex) {
    for (let i = 0, il = vertex.propertyNames.length; i < il; ++i) {
      const name = vertex.propertyNames[i];
      const type = vertex.propertyTypes[i];
      if (type === "uchar" || type === "uint8" || type === "ushort" || type === "uint16" || type === "uint" || type === "uint32" || type === "int")
        groupOptions.push([name, name]);
      if (type === "uchar" || type === "uint8")
        colorOptions.push([name, name]);
    }
    if (vertex.propertyNames.includes("atomid"))
      defaultValues.group = "atomid";
    else if (vertex.propertyNames.includes("material_index"))
      defaultValues.group = "material_index";
    if (vertex.propertyNames.includes("red"))
      defaultValues.vRed = "red";
    if (vertex.propertyNames.includes("green"))
      defaultValues.vGreen = "green";
    if (vertex.propertyNames.includes("blue"))
      defaultValues.vBlue = "blue";
  }
  const materialOptions = [["", ""]];
  if (material) {
    for (let i = 0, il = material.propertyNames.length; i < il; ++i) {
      const name = material.propertyNames[i];
      const type = material.propertyTypes[i];
      if (type === "uchar" || type === "uint8")
        materialOptions.push([name, name]);
    }
    if (material.propertyNames.includes("red"))
      defaultValues.mRed = "red";
    if (material.propertyNames.includes("green"))
      defaultValues.mGreen = "green";
    if (material.propertyNames.includes("blue"))
      defaultValues.mBlue = "blue";
  }
  const defaultColoring = defaultValues.vRed && defaultValues.vGreen && defaultValues.vBlue ? "vertex" : defaultValues.mRed && defaultValues.mGreen && defaultValues.mBlue ? "material" : "uniform";
  return {
    ...Mesh.Params,
    coloring: ParamDefinition.MappedStatic(defaultColoring, {
      vertex: ParamDefinition.Group({
        red: ParamDefinition.Select(defaultValues.vRed, colorOptions, { label: "Red Property" }),
        green: ParamDefinition.Select(defaultValues.vGreen, colorOptions, { label: "Green Property" }),
        blue: ParamDefinition.Select(defaultValues.vBlue, colorOptions, { label: "Blue Property" })
      }, { isFlat: true }),
      material: ParamDefinition.Group({
        red: ParamDefinition.Select(defaultValues.mRed, materialOptions, { label: "Red Property" }),
        green: ParamDefinition.Select(defaultValues.mGreen, materialOptions, { label: "Green Property" }),
        blue: ParamDefinition.Select(defaultValues.mBlue, materialOptions, { label: "Blue Property" })
      }, { isFlat: true }),
      uniform: ParamDefinition.Group({
        color: ParamDefinition.Color(ColorNames.grey),
        saturation: ParamDefinition.Numeric(0, { min: -6, max: 6, step: 0.1 }),
        lightness: ParamDefinition.Numeric(0, { min: -6, max: 6, step: 0.1 })
      }, { isFlat: true })
    }),
    grouping: ParamDefinition.MappedStatic(defaultValues.group ? "vertex" : "none", {
      vertex: ParamDefinition.Group({
        group: ParamDefinition.Select(defaultValues.group, groupOptions, { label: "Group Property" })
      }, { isFlat: true }),
      none: ParamDefinition.Group({})
    })
  };
}
var PlyShapeParams = createPlyShapeParams();
function addVerticesRange(begI, endI, state, vertex, groupIds) {
  const { vertices: vertices2, normals, groups } = state;
  const x = vertex.getProperty("x");
  const y = vertex.getProperty("y");
  const z = vertex.getProperty("z");
  if (!x || !y || !z)
    throw new Error("missing coordinate properties");
  const nx = vertex.getProperty("nx");
  const ny = vertex.getProperty("ny");
  const nz = vertex.getProperty("nz");
  const hasNormals = !!nx && !!ny && !!nz;
  for (let i = begI; i < endI; ++i) {
    ChunkedArray.add3(vertices2, x.value(i), y.value(i), z.value(i));
    if (hasNormals)
      ChunkedArray.add3(normals, nx.value(i), ny.value(i), nz.value(i));
    ChunkedArray.add(groups, groupIds[i]);
  }
}
function addFacesRange(begI, endI, state, face) {
  const { indices: indices2 } = state;
  for (let i = begI; i < endI; ++i) {
    const { entries: entries3, count: count3 } = face.value(i);
    if (count3 === 3) {
      ChunkedArray.add3(indices2, entries3[0], entries3[1], entries3[2]);
    } else if (count3 === 4) {
      ChunkedArray.add3(indices2, entries3[2], entries3[1], entries3[0]);
      ChunkedArray.add3(indices2, entries3[2], entries3[0], entries3[3]);
    }
  }
}
async function getMesh(ctx, vertex, face, groupIds, mesh) {
  const builderState = MeshBuilder.createState(vertex.rowCount, vertex.rowCount / 4, mesh);
  const x = vertex.getProperty("x");
  const y = vertex.getProperty("y");
  const z = vertex.getProperty("z");
  if (!x || !y || !z)
    throw new Error("missing coordinate properties");
  const nx = vertex.getProperty("nx");
  const ny = vertex.getProperty("ny");
  const nz = vertex.getProperty("nz");
  const hasNormals = !!nx && !!ny && !!nz;
  const updateChunk = 1e5;
  for (let i = 0, il = vertex.rowCount; i < il; i += updateChunk) {
    addVerticesRange(i, Math.min(i + updateChunk, il), builderState, vertex, groupIds);
    if (ctx.shouldUpdate) {
      await ctx.update({ message: "adding ply mesh vertices", current: i, max: il });
    }
  }
  for (let i = 0, il = face.rowCount; i < il; i += updateChunk) {
    addFacesRange(i, Math.min(i + updateChunk, il), builderState, face);
    if (ctx.shouldUpdate) {
      await ctx.update({ message: "adding ply mesh faces", current: i, max: il });
    }
  }
  const m = MeshBuilder.getMesh(builderState);
  if (!hasNormals)
    Mesh.computeNormals(m);
  ValueCell.updateIfChanged(m.varyingGroup, true);
  return m;
}
var int = Column.Schema.int;
function getGrouping(vertex, props) {
  const { grouping } = props;
  const { rowCount } = vertex;
  const column = grouping.name === "vertex" ? vertex.getProperty(grouping.params.group) : void 0;
  const label2 = grouping.name === "vertex" ? stringToWords(grouping.params.group) : "Vertex";
  const ids = column ? column.toArray({ array: Uint32Array }) : fillSerial(new Uint32Array(rowCount));
  const maxId = column ? arrayMax(ids) : rowCount - 1;
  const map3 = new Uint32Array(maxId + 1);
  for (let i = 0, il = ids.length; i < il; ++i)
    map3[ids[i]] = i;
  return { ids, map: map3, label: label2 };
}
function getColoring(vertex, material, props) {
  const { coloring } = props;
  const { rowCount } = vertex;
  let red, green, blue;
  if (coloring.name === "vertex") {
    red = vertex.getProperty(coloring.params.red) || Column.ofConst(127, rowCount, int);
    green = vertex.getProperty(coloring.params.green) || Column.ofConst(127, rowCount, int);
    blue = vertex.getProperty(coloring.params.blue) || Column.ofConst(127, rowCount, int);
  } else if (coloring.name === "material") {
    red = material && material.getProperty(coloring.params.red) || Column.ofConst(127, rowCount, int);
    green = material && material.getProperty(coloring.params.green) || Column.ofConst(127, rowCount, int);
    blue = material && material.getProperty(coloring.params.blue) || Column.ofConst(127, rowCount, int);
  } else {
    let color = coloring.params.color;
    color = Color.saturate(color, coloring.params.saturation);
    color = Color.lighten(color, coloring.params.lightness);
    const [r, g, b5] = Color.toRgb(color);
    red = Column.ofConst(r, rowCount, int);
    green = Column.ofConst(g, rowCount, int);
    blue = Column.ofConst(b5, rowCount, int);
  }
  return { kind: coloring.name, red, green, blue };
}
function createShape(plyData, mesh, coloring, grouping) {
  const { kind, red, green, blue } = coloring;
  const { ids, map: map3, label: label2 } = grouping;
  const { source, transforms } = plyData;
  return Shape.create(
    "ply-mesh",
    source,
    mesh,
    (groupId) => {
      const idx = kind === "material" ? groupId : map3[groupId];
      return Color.fromRgb(red.value(idx), green.value(idx), blue.value(idx));
    },
    () => 1,
    // size: constant
    (groupId) => {
      return `${label2} ${ids[groupId]}`;
    },
    transforms
  );
}
function makeShapeGetter() {
  let _plyData;
  let _props;
  let _shape;
  let _mesh;
  let _coloring;
  let _grouping;
  const getShape = async (ctx, plyData, props, shape) => {
    const vertex = plyData.source.getElement("vertex");
    if (!vertex)
      throw new Error("missing vertex element");
    const face = plyData.source.getElement("face");
    if (!face)
      throw new Error("missing face element");
    const material = plyData.source.getElement("material");
    let newMesh = false;
    let newColor = false;
    if (!_plyData || _plyData !== _plyData) {
      newMesh = true;
    }
    if (!_props || !ParamDefinition.isParamEqual(PlyShapeParams.grouping, _props.grouping, props.grouping)) {
      newMesh = true;
    }
    if (!_props || !ParamDefinition.isParamEqual(PlyShapeParams.coloring, _props.coloring, props.coloring)) {
      newColor = true;
    }
    if (newMesh) {
      _coloring = getColoring(vertex, material, props);
      _grouping = getGrouping(vertex, props);
      _mesh = await getMesh(ctx, vertex, face, _grouping.ids, shape && shape.geometry);
      _shape = createShape(plyData, _mesh, _coloring, _grouping);
    } else if (newColor) {
      _coloring = getColoring(vertex, material, props);
      _shape = createShape(plyData, _mesh, _coloring, _grouping);
    }
    _plyData = plyData;
    _props = deepClone(props);
    return _shape;
  };
  return getShape;
}
function shapeFromPly(source, params) {
  return Task.create("Shape Provider", async (ctx) => {
    return {
      label: "Mesh",
      data: { source, transforms: params === null || params === void 0 ? void 0 : params.transforms },
      params: createPlyShapeParams(source),
      getShape: makeShapeGetter(),
      geometryUtils: Mesh.Utils
    };
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/geometry/spacegroup/cell.js
function Cell() {
  return Cell.empty();
}
(function(Cell2) {
  function create(size, anglesInRadians) {
    return { size, anglesInRadians };
  }
  Cell2.create = create;
  function empty2() {
    return create(Vec3(), Vec3());
  }
  Cell2.empty = empty2;
  function fromBasis(x, y, z) {
    const a5 = Vec3.magnitude(x);
    const b5 = Vec3.magnitude(y);
    const c5 = Vec3.magnitude(z);
    const alpha = Math.acos(Vec3.dot(y, z) / (b5 * c5));
    const beta2 = Math.acos(Vec3.dot(x, z) / (a5 * c5));
    const gamma = Math.acos(Vec3.dot(x, y) / (a5 * b5));
    if (a5 <= 0 || b5 <= 0 || c5 <= 0 || alpha >= Math.PI || beta2 >= Math.PI || gamma >= Math.PI) {
      return empty2();
    } else {
      return create(Vec3.create(a5, b5, c5), Vec3.create(alpha, beta2, gamma));
    }
  }
  Cell2.fromBasis = fromBasis;
})(Cell || (Cell = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/dcd.js
var charmmTimeUnitFactor = 20.45482949774598;
function coordinatesFromDcd(dcdFile) {
  return Task.create("Parse DCD", async (ctx) => {
    await ctx.update("Converting to coordinates");
    const { header: header2 } = dcdFile;
    const deltaTime = header2.DELTA ? Time(header2.DELTA * charmmTimeUnitFactor, "ps") : Time(1, "step");
    const offsetTime = header2.ISTART >= 1 ? Time((header2.ISTART - 1) * deltaTime.value, deltaTime.unit) : Time(0, deltaTime.unit);
    const frames = [];
    for (let i = 0, il = dcdFile.frames.length; i < il; ++i) {
      const dcdFrame = dcdFile.frames[i];
      const frame = {
        elementCount: dcdFrame.elementCount,
        time: Time(offsetTime.value + deltaTime.value * i, deltaTime.unit),
        x: dcdFrame.x,
        y: dcdFrame.y,
        z: dcdFrame.z,
        xyzOrdering: { isIdentity: true }
      };
      if (dcdFrame.cell) {
        const c5 = dcdFrame.cell;
        if (c5[1] >= -1 && c5[1] <= 1 && c5[3] >= -1 && c5[3] <= 1 && c5[4] >= -1 && c5[4] <= 1) {
          frame.cell = Cell.create(Vec3.create(c5[0], c5[2], c5[5]), Vec3.create(degToRad(90 - Math.asin(c5[1]) * 90 / halfPI), degToRad(90 - Math.asin(c5[3]) * 90 / halfPI), degToRad(90 - Math.asin(c5[4]) * 90 / halfPI)));
        } else if (c5[0] < 0 || c5[1] < 0 || c5[2] < 0 || c5[3] < 0 || c5[4] < 0 || c5[5] < 0 || c5[3] > 180 || c5[4] > 180 || c5[5] > 180) {
          frame.cell = Cell.fromBasis(Vec3.create(c5[0], c5[1], c5[3]), Vec3.create(c5[1], c5[2], c5[4]), Vec3.create(c5[3], c5[4], c5[5]));
        } else {
          frame.cell = Cell.create(
            Vec3.create(c5[0], c5[2], c5[5]),
            // interpret angles very close to 0 as 90 deg
            Vec3.create(degToRad(equalEps(c5[1], 0, EPSILON) ? 90 : c5[1]), degToRad(equalEps(c5[3], 0, EPSILON) ? 90 : c5[3]), degToRad(equalEps(c5[4], 0, EPSILON) ? 90 : c5[4]))
          );
        }
      }
      frames.push(frame);
    }
    return Coordinates.create(frames, deltaTime, offsetTime);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/util.js
function guessElementSymbolTokens(tokens, str3, start, end) {
  let s = start, e = end - 1;
  let c5 = str3.charCodeAt(s);
  while ((c5 === 32 || c5 >= 48 && c5 <= 57) && s <= e)
    c5 = str3.charCodeAt(++s);
  c5 = str3.charCodeAt(e);
  while ((c5 === 32 || c5 >= 48 && c5 <= 57) && e >= s)
    c5 = str3.charCodeAt(--e);
  ++e;
  if (s === e)
    return TokenBuilder.add(tokens, s, e);
  if (s + 1 === e)
    return TokenBuilder.add(tokens, s, e);
  c5 = str3.charCodeAt(s);
  if (s + 2 === e) {
    const c22 = str3.charCodeAt(s + 1);
    if ((c5 === 78 || c5 === 110) && (c22 === 65 || c22 === 97) || // NA na Na nA
    (c5 === 67 || c5 === 99) && (c22 === 76 || c22 === 108) || // CL
    (c5 === 70 || c5 === 102) && (c22 === 69 || c22 === 101) || // FE
    (c5 === 83 || c5 === 115) && (c22 === 73 || c22 === 105) || // SI
    (c5 === 66 || c5 === 98) && (c22 === 82 || c22 === 114) || // BR
    (c5 === 65 || c5 === 97) && (c22 === 83 || c22 === 115))
      return TokenBuilder.add(tokens, s, s + 2);
  }
  if (c5 === 67 || c5 === 99 || // C c
  c5 === 72 || c5 === 104 || // H h
  c5 === 78 || c5 === 110 || // N n
  c5 === 79 || c5 === 111 || // O o
  c5 === 80 || c5 === 112 || // P p
  c5 === 83 || c5 === 115)
    return TokenBuilder.add(tokens, s, s + 1);
  TokenBuilder.add(tokens, s, s);
}
var TwoCharElementNames = /* @__PURE__ */ new Set(["NA", "CL", "FE", "SI", "BR", "AS", "LI"]);
var OneCharElementNames = /* @__PURE__ */ new Set(["C", "H", "N", "O", "P", "S", "F", "B"]);
var reTrimSpacesAndNumbers = /^[\s\d]+|[\s\d]+$/g;
function guessElementSymbolString(atomId2, compId2) {
  atomId2 = atomId2.replace(reTrimSpacesAndNumbers, "").toUpperCase();
  const l = atomId2.length;
  if (l === 0)
    return atomId2;
  if (l === 1)
    return atomId2;
  if (TwoCharElementNames.has(atomId2))
    return atomId2;
  if (l === 3 && compId2 === atomId2) {
    if (atomId2 === "SOD")
      return "NA";
    if (atomId2 === "POT")
      return "K";
    if (atomId2 === "CES")
      return "CS";
    if (atomId2 === "CAL")
      return "CA";
    if (atomId2 === "CLA")
      return "CL";
  }
  if (OneCharElementNames.has(atomId2[0]))
    return atomId2[0];
  return "";
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/common/util.js
var ChainIdAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
function _getChainId(index) {
  const n = ChainIdAlphabet.length;
  let j = index;
  let k = 0;
  let chainId = ChainIdAlphabet[j % n];
  while (j >= n) {
    j = Math.floor(j / n);
    chainId += ChainIdAlphabet[j % n];
    k += 1;
  }
  if (k >= 5) {
    console.warn("getChainId overflow");
  }
  return chainId;
}
var getChainId = memoize1(_getChainId);

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/gro.js
function getBasic(atoms, modelNum) {
  const auth_atom_id = atoms.atomName;
  const auth_comp_id = atoms.residueName;
  const entityIds = new Array(atoms.count);
  const asymIds = new Array(atoms.count);
  const seqIds = new Uint32Array(atoms.count);
  const ids = new Uint32Array(atoms.count);
  const typeSymbol2 = new Array(atoms.count);
  const entityBuilder = new EntityBuilder();
  const componentBuilder = new ComponentBuilder(atoms.residueNumber, atoms.atomName);
  let currentEntityId = "";
  let currentAsymIndex = 0;
  let currentAsymId = "";
  let currentSeqId = 0;
  let prevMoleculeType = MoleculeType.Unknown;
  let prevResidueNumber = -1;
  for (let i = 0, il = atoms.count; i < il; ++i) {
    const residueNumber = atoms.residueNumber.value(i);
    if (residueNumber !== prevResidueNumber) {
      const compId2 = atoms.residueName.value(i);
      const moleculeType = getMoleculeType(componentBuilder.add(compId2, i).type, compId2);
      if (moleculeType !== prevMoleculeType || residueNumber !== prevResidueNumber + 1 && !// gro format allows only for 5 character residueNumbers, handle overflow here
      (prevResidueNumber === 99999 && residueNumber === 0)) {
        currentAsymId = getChainId(currentAsymIndex);
        currentAsymIndex += 1;
        currentSeqId = 0;
      }
      currentEntityId = entityBuilder.getEntityId(compId2, moleculeType, currentAsymId);
      currentSeqId += 1;
      prevResidueNumber = residueNumber;
      prevMoleculeType = moleculeType;
    }
    entityIds[i] = currentEntityId;
    asymIds[i] = currentAsymId;
    seqIds[i] = currentSeqId;
    ids[i] = i;
    typeSymbol2[i] = guessElementSymbolString(atoms.atomName.value(i), atoms.residueName.value(i));
  }
  const auth_asym_id = Column.ofStringArray(asymIds);
  const atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
    auth_asym_id,
    auth_atom_id,
    auth_comp_id,
    auth_seq_id: atoms.residueNumber,
    Cartn_x: Column.ofFloatArray(Column.mapToArray(atoms.x, (x) => x * 10, Float32Array)),
    Cartn_y: Column.ofFloatArray(Column.mapToArray(atoms.y, (y) => y * 10, Float32Array)),
    Cartn_z: Column.ofFloatArray(Column.mapToArray(atoms.z, (z) => z * 10, Float32Array)),
    id: Column.ofIntArray(ids),
    label_asym_id: auth_asym_id,
    label_atom_id: auth_atom_id,
    label_comp_id: auth_comp_id,
    label_seq_id: Column.ofIntArray(seqIds),
    label_entity_id: Column.ofStringArray(entityIds),
    occupancy: Column.ofConst(1, atoms.count, Column.Schema.float),
    type_symbol: Column.ofStringArray(typeSymbol2),
    pdbx_PDB_model_num: Column.ofConst(modelNum, atoms.count, Column.Schema.int)
  }, atoms.count);
  return createBasic({
    entity: entityBuilder.getEntityTable(),
    chem_comp: componentBuilder.getChemCompTable(),
    atom_site
  });
}
var GroFormat;
(function(GroFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "gro";
  }
  GroFormat2.is = is3;
  function fromGro(gro) {
    return { kind: "gro", name: gro.structures[0].header.title, data: gro };
  }
  GroFormat2.fromGro = fromGro;
})(GroFormat || (GroFormat = {}));
function trajectoryFromGRO(gro) {
  return Task.create("Parse GRO", async (ctx) => {
    const format = GroFormat.fromGro(gro);
    const models = [];
    for (let i = 0, il = gro.structures.length; i < il; ++i) {
      const basic = getBasic(gro.structures[i].atoms, i + 1);
      const m = await createModels(basic, format, ctx);
      if (m.frameCount === 1) {
        models.push(m.representative);
      }
    }
    return new ArrayTrajectory(models);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/pdb/assembly.js
function parseCryst1(id, record2) {
  const get11 = (s, l) => (record2.substr(s, l) || "").trim();
  const cell = {
    entry_id: CifField.ofString(id),
    length_a: CifField.ofString(get11(6, 9)),
    length_b: CifField.ofString(get11(15, 9)),
    length_c: CifField.ofString(get11(24, 9)),
    angle_alpha: CifField.ofString(get11(33, 7)),
    angle_beta: CifField.ofString(get11(40, 7)),
    angle_gamma: CifField.ofString(get11(47, 7)),
    Z_PDB: CifField.ofString(get11(66, 4)),
    pdbx_unique_axis: CifField.ofString("?")
  };
  const symmetry = {
    entry_id: CifField.ofString(id),
    "space_group_name_H-M": CifField.ofString(get11(55, 11)),
    Int_Tables_number: CifField.ofString("?"),
    cell_setting: CifField.ofString("?"),
    space_group_name_Hall: CifField.ofString("?")
  };
  return [CifCategory.ofFields("cell", cell), CifCategory.ofFields("symmetry", symmetry)];
}
function PdbAssembly(id, details) {
  return { id, details, groups: [] };
}
function parseRemark350(lines, lineStart, lineEnd) {
  const assemblies = [];
  let current3, group, matrix, operId = 1, asmId = 1;
  const getLine = (n) => lines.data.substring(lines.indices[2 * n], lines.indices[2 * n + 1]);
  for (let i = lineStart; i < lineEnd; i++) {
    let line = getLine(i);
    if (line.substr(11, 12) === "BIOMOLECULE:") {
      const id = line.substr(23).trim();
      let details = `Biomolecule ${id}`;
      line = getLine(i + 1);
      if (line.substr(11, 30) !== "APPLY THE FOLLOWING TO CHAINS:") {
        i++;
        details = line.substr(11).trim();
      }
      current3 = PdbAssembly(id, details);
      assemblies.push(current3);
    } else if (line.substr(13, 5) === "BIOMT") {
      const biomt = line.split(/\s+/);
      const row = parseInt(line[18]) - 1;
      if (row === 0) {
        matrix = Mat4.identity();
        group.operators.push({ id: operId++, matrix });
      }
      Mat4.setValue(matrix, row, 0, parseFloat(biomt[4]));
      Mat4.setValue(matrix, row, 1, parseFloat(biomt[5]));
      Mat4.setValue(matrix, row, 2, parseFloat(biomt[6]));
      Mat4.setValue(matrix, row, 3, parseFloat(biomt[7]));
    } else if (line.substr(11, 30) === "APPLY THE FOLLOWING TO CHAINS:" || line.substr(11, 30) === "                   AND CHAINS:") {
      if (line.substr(11, 5) === "APPLY") {
        group = { chains: [], operators: [] };
        current3.groups.push(group);
      }
      const chainList = line.substr(41, 30).split(",");
      for (let j = 0, jl = chainList.length; j < jl; ++j) {
        const c5 = chainList[j].trim();
        if (c5)
          group.chains.push(c5);
      }
    } else if (line.substr(11, 33) === "APPLYING THE FOLLOWING TO CHAINS:") {
      current3 = PdbAssembly(`${asmId}`, `Biomolecule ${asmId}`);
      assemblies.push(current3);
      asmId += 1;
      group = { chains: [], operators: [] };
      current3.groups.push(group);
      i++;
      line = getLine(i);
      const chainList = line.substr(11, 69).split(",");
      for (let j = 0, jl = chainList.length; j < jl; ++j) {
        const c5 = chainList[j].trim();
        if (c5)
          group.chains.push(c5);
      }
    }
  }
  if (assemblies.length === 0)
    return [];
  const pdbx_struct_assembly = {
    id: CifField.ofStrings(assemblies.map((a5) => a5.id)),
    details: CifField.ofStrings(assemblies.map((a5) => a5.details))
  };
  const pdbx_struct_assembly_gen_rows = [];
  for (const asm of assemblies) {
    for (const group2 of asm.groups) {
      pdbx_struct_assembly_gen_rows.push({
        assembly_id: asm.id,
        oper_expression: group2.operators.map((o) => o.id).join(","),
        asym_id_list: group2.chains.join(",")
      });
    }
  }
  const pdbx_struct_assembly_gen = {
    assembly_id: CifField.ofStrings(pdbx_struct_assembly_gen_rows.map((r) => r.assembly_id)),
    oper_expression: CifField.ofStrings(pdbx_struct_assembly_gen_rows.map((r) => r.oper_expression)),
    asym_id_list: CifField.ofStrings(pdbx_struct_assembly_gen_rows.map((r) => r.asym_id_list))
  };
  const pdbx_struct_oper_list_rows = [];
  for (const asm of assemblies) {
    for (const group2 of asm.groups) {
      for (const oper of group2.operators) {
        const row = {
          id: "" + oper.id,
          type: "?",
          name: "?",
          symmetry_operation: "?"
        };
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            row[`matrix[${i + 1}][${j + 1}]`] = "" + Mat4.getValue(oper.matrix, i, j);
          }
          row[`vector[${i + 1}]`] = "" + Mat4.getValue(oper.matrix, i, 3);
        }
        pdbx_struct_oper_list_rows.push(row);
      }
    }
  }
  const pdbx_struct_oper_list = {
    id: CifField.ofStrings(pdbx_struct_oper_list_rows.map((r) => r.id)),
    type: CifField.ofStrings(pdbx_struct_oper_list_rows.map((r) => r.type)),
    name: CifField.ofStrings(pdbx_struct_oper_list_rows.map((r) => r.name)),
    symmetry_operation: CifField.ofStrings(pdbx_struct_oper_list_rows.map((r) => r.symmetry_operation))
  };
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      const k2 = `matrix[${i + 1}][${j + 1}]`;
      pdbx_struct_oper_list[k2] = CifField.ofStrings(pdbx_struct_oper_list_rows.map((r) => r[k2]));
    }
    const k = `vector[${i + 1}]`;
    pdbx_struct_oper_list[k] = CifField.ofStrings(pdbx_struct_oper_list_rows.map((r) => r[k]));
  }
  return [
    CifCategory.ofFields("pdbx_struct_assembly", pdbx_struct_assembly),
    CifCategory.ofFields("pdbx_struct_assembly_gen", pdbx_struct_assembly_gen),
    CifCategory.ofFields("pdbx_struct_oper_list", pdbx_struct_oper_list)
  ];
}
function parseMtrix(lines, lineStart, lineEnd) {
  const matrices = [];
  let matrix;
  const getLine = (n) => lines.data.substring(lines.indices[2 * n], lines.indices[2 * n + 1]);
  for (let i = lineStart; i < lineEnd; i++) {
    const line = getLine(i);
    const ncs = line.split(/\s+/);
    const row = parseInt(line[5]) - 1;
    if (row === 0) {
      matrix = Mat4.identity();
      matrices.push(matrix);
    }
    Mat4.setValue(matrix, row, 0, parseFloat(ncs[2]));
    Mat4.setValue(matrix, row, 1, parseFloat(ncs[3]));
    Mat4.setValue(matrix, row, 2, parseFloat(ncs[4]));
    Mat4.setValue(matrix, row, 3, parseFloat(ncs[5]));
  }
  if (matrices.length === 0)
    return [];
  const struct_ncs_oper_rows = [];
  let id = 1;
  for (const oper of matrices) {
    const row = {
      id: "ncsop" + id++,
      code: ".",
      details: "."
    };
    for (let i = 0; i < 3; i++) {
      for (let j = 0; j < 3; j++) {
        row[`matrix[${i + 1}][${j + 1}]`] = "" + Mat4.getValue(oper, i, j);
      }
      row[`vector[${i + 1}]`] = "" + Mat4.getValue(oper, i, 3);
    }
    struct_ncs_oper_rows.push(row);
  }
  const struct_ncs_oper = {
    id: CifField.ofStrings(struct_ncs_oper_rows.map((r) => r.id)),
    code: CifField.ofStrings(struct_ncs_oper_rows.map((r) => r.code)),
    details: CifField.ofStrings(struct_ncs_oper_rows.map((r) => r.details))
  };
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      const k2 = `matrix[${i + 1}][${j + 1}]`;
      struct_ncs_oper[k2] = CifField.ofStrings(struct_ncs_oper_rows.map((r) => r[k2]));
    }
    const k = `vector[${i + 1}]`;
    struct_ncs_oper[k] = CifField.ofStrings(struct_ncs_oper_rows.map((r) => r[k]));
  }
  return [CifCategory.ofFields("struct_ncs_oper", struct_ncs_oper)];
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/pdb/secondary-structure.js
var HelixTypes = {
  // CLASS NUMBER
  // TYPE OF  HELIX                     (COLUMNS 39 - 40)
  // --------------------------------------------------------------
  // Right-handed alpha (default)                1
  // Right-handed omega                          2
  // Right-handed pi                             3
  // Right-handed gamma                          4
  // Right-handed 3 - 10                         5
  // Left-handed alpha                           6
  // Left-handed omega                           7
  // Left-handed gamma                           8
  // 2 - 7 ribbon/helix                          9
  // Polyproline                                10
  1: "helx_rh_al_p",
  2: "helx_rh_om_p",
  3: "helx_rh_pi_p",
  4: "helx_rh_ga_p",
  5: "helx_rh_3t_p",
  6: "helx_lh_al_p",
  7: "helx_lh_om_p",
  8: "helx_lh_ga_p",
  9: "helx_rh_27_p",
  // TODO or left-handed???
  10: "helx_rh_pp_p"
  // TODO or left-handed???
};
function getStructConfTypeId(type) {
  return HelixTypes[type] || "helx_p";
}
function parseHelix(lines, lineStart, lineEnd) {
  const helices = [];
  const getLine = (n) => lines.data.substring(lines.indices[2 * n], lines.indices[2 * n + 1]);
  for (let i = lineStart; i < lineEnd; i++) {
    const line = getLine(i);
    helices.push({
      serNum: line.substr(7, 3).trim(),
      helixID: line.substr(11, 3).trim(),
      initResName: line.substr(15, 3).trim(),
      initChainID: line.substr(19, 1).trim(),
      initSeqNum: line.substr(21, 4).trim(),
      initICode: line.substr(25, 1).trim(),
      endResName: line.substr(27, 3).trim(),
      endChainID: line.substr(31, 3).trim(),
      endSeqNum: line.substr(33, 4).trim(),
      endICode: line.substr(37, 1).trim(),
      helixClass: line.substr(38, 2).trim(),
      comment: line.substr(40, 30).trim(),
      length: line.substr(71, 5).trim()
    });
  }
  const beg_auth_asym_id = CifField.ofStrings(helices.map((h) => h.initChainID));
  const beg_auth_comp_id = CifField.ofStrings(helices.map((h) => h.initResName));
  const end_auth_asym_id = CifField.ofStrings(helices.map((h) => h.endChainID));
  const end_auth_comp_id = CifField.ofStrings(helices.map((h) => h.endResName));
  const struct_conf = {
    beg_label_asym_id: beg_auth_asym_id,
    beg_label_comp_id: beg_auth_comp_id,
    beg_label_seq_id: CifField.ofUndefined(helices.length, Column.Schema.int),
    beg_auth_asym_id,
    beg_auth_comp_id,
    beg_auth_seq_id: CifField.ofStrings(helices.map((h) => h.initSeqNum)),
    conf_type_id: CifField.ofStrings(helices.map((h) => getStructConfTypeId(h.helixClass))),
    details: CifField.ofStrings(helices.map((h) => h.comment)),
    end_label_asym_id: end_auth_asym_id,
    end_label_comp_id: end_auth_comp_id,
    end_label_seq_id: CifField.ofUndefined(helices.length, Column.Schema.int),
    end_auth_asym_id,
    end_auth_comp_id,
    end_auth_seq_id: CifField.ofStrings(helices.map((h) => h.endSeqNum)),
    id: CifField.ofStrings(helices.map((h) => h.serNum)),
    pdbx_beg_PDB_ins_code: CifField.ofStrings(helices.map((h) => h.initICode)),
    pdbx_end_PDB_ins_code: CifField.ofStrings(helices.map((h) => h.endICode)),
    pdbx_PDB_helix_class: CifField.ofStrings(helices.map((h) => h.helixClass)),
    pdbx_PDB_helix_length: CifField.ofStrings(helices.map((h) => h.length)),
    pdbx_PDB_helix_id: CifField.ofStrings(helices.map((h) => h.helixID))
  };
  return CifCategory.ofFields("struct_conf", struct_conf);
}
function parseSheet(lines, lineStart, lineEnd) {
  const sheets = [];
  const getLine = (n) => lines.data.substring(lines.indices[2 * n], lines.indices[2 * n + 1]);
  for (let i = lineStart; i < lineEnd; i++) {
    const line = getLine(i);
    sheets.push({
      strand: line.substr(7, 3).trim(),
      sheetID: line.substr(11, 3).trim(),
      numStrands: line.substr(14, 2).trim(),
      initResName: line.substr(17, 3).trim(),
      initChainID: line.substr(21, 1).trim(),
      initSeqNum: line.substr(22, 4).trim(),
      initICode: line.substr(26, 1).trim(),
      endResName: line.substr(28, 3).trim(),
      endChainID: line.substr(32, 1).trim(),
      endSeqNum: line.substr(33, 4).trim(),
      endICode: line.substr(37, 1).trim(),
      sense: line.substr(38, 2).trim(),
      curAtom: line.substr(41, 4).trim(),
      curResName: line.substr(45, 3).trim(),
      curChainId: line.substr(49, 1).trim(),
      curResSeq: line.substr(50, 4).trim(),
      curICode: line.substr(54, 1).trim(),
      prevAtom: line.substr(56, 4).trim(),
      prevResName: line.substr(60, 3).trim(),
      prevChainId: line.substr(64, 1).trim(),
      prevResSeq: line.substr(65, 4).trim(),
      prevICode: line.substr(69, 1).trim()
    });
  }
  const beg_auth_asym_id = CifField.ofStrings(sheets.map((s) => s.initChainID));
  const beg_auth_comp_id = CifField.ofStrings(sheets.map((s) => s.initResName));
  const beg_auth_seq_id = CifField.ofStrings(sheets.map((s) => s.initSeqNum));
  const end_auth_asym_id = CifField.ofStrings(sheets.map((s) => s.endChainID));
  const end_auth_comp_id = CifField.ofStrings(sheets.map((s) => s.endResName));
  const end_auth_seq_id = CifField.ofStrings(sheets.map((s) => s.endSeqNum));
  const struct_sheet_range = {
    beg_label_asym_id: beg_auth_asym_id,
    beg_label_comp_id: beg_auth_comp_id,
    beg_label_seq_id: beg_auth_seq_id,
    beg_auth_asym_id,
    beg_auth_comp_id,
    beg_auth_seq_id,
    end_label_asym_id: end_auth_asym_id,
    end_label_comp_id: end_auth_asym_id,
    end_label_seq_id: end_auth_seq_id,
    end_auth_asym_id,
    end_auth_comp_id,
    end_auth_seq_id,
    id: CifField.ofStrings(sheets.map((s) => s.strand)),
    sheet_id: CifField.ofStrings(sheets.map((s) => s.sheetID)),
    // TODO wrong, needs to point to _struct_sheet.id
    pdbx_beg_PDB_ins_code: CifField.ofStrings(sheets.map((s) => s.initICode)),
    pdbx_end_PDB_ins_code: CifField.ofStrings(sheets.map((s) => s.endICode))
  };
  return CifCategory.ofFields("struct_sheet_range", struct_sheet_range);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/pdb/entity.js
var Spec = {
  "MOL_ID": "",
  "MOLECULE": "",
  "CHAIN": "",
  "FRAGMENT": "",
  "SYNONYM": "",
  "EC": "",
  "ENGINEERED": "",
  "MUTATION": "",
  "OTHER_DETAILS": ""
};
function parseCmpnd(lines, lineStart, lineEnd) {
  const getLine = (n) => lines.data.substring(lines.indices[2 * n], lines.indices[2 * n + 1]);
  let currentSpec;
  let currentCompound = { chains: [], description: "" };
  const compounds = [];
  for (let i = lineStart; i < lineEnd; i++) {
    const line = getLine(i);
    const cmpnd = line.substr(10, 70).trim();
    const cmpndSpecEnd = cmpnd.indexOf(":");
    const cmpndSpec = cmpnd.substring(0, cmpndSpecEnd);
    let value;
    if (cmpndSpec in Spec) {
      currentSpec = cmpndSpec;
      value = cmpnd.substring(cmpndSpecEnd + 2);
    } else {
      value = cmpnd;
    }
    value = value.replace(/;$/, "");
    if (currentSpec === "MOL_ID") {
      currentCompound = {
        chains: [],
        description: ""
      };
      compounds.push(currentCompound);
    } else if (currentSpec === "MOLECULE") {
      if (currentCompound.description)
        currentCompound.description += " ";
      currentCompound.description += value;
    } else if (currentSpec === "CHAIN") {
      Array.prototype.push.apply(currentCompound.chains, value.split(/\s*,\s*/));
    }
  }
  const singletons = [];
  for (const comp of compounds) {
    for (const chain of comp.chains) {
      singletons.push({
        description: comp.description,
        chains: [chain]
      });
    }
  }
  return singletons;
}
function parseHetnam(lines, lineStart, lineEnd) {
  const getLine = (n) => lines.data.substring(lines.indices[2 * n], lines.indices[2 * n + 1]);
  const hetnams = /* @__PURE__ */ new Map();
  for (let i = lineStart; i < lineEnd; i++) {
    const line = getLine(i);
    const het = line.substr(11, 3).trim();
    const name = line.substr(15).trim();
    if (hetnams.has(het)) {
      hetnams.set(het, `${hetnams.get(het)} ${name}`);
    } else {
      hetnams.set(het, name);
    }
  }
  return hetnams;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/pdb/atom-site.js
function getAtomSiteTemplate(data, count3) {
  const str3 = () => [];
  const ts = () => TokenBuilder.create(data, 2 * count3);
  return {
    index: 0,
    group_PDB: ts(),
    id: str3(),
    auth_atom_id: ts(),
    label_alt_id: ts(),
    auth_comp_id: ts(),
    auth_asym_id: ts(),
    auth_seq_id: ts(),
    pdbx_PDB_ins_code: ts(),
    Cartn_x: ts(),
    Cartn_y: ts(),
    Cartn_z: ts(),
    occupancy: ts(),
    B_iso_or_equiv: ts(),
    type_symbol: ts(),
    pdbx_PDB_model_num: str3(),
    label_entity_id: str3(),
    partial_charge: ts()
  };
}
var LabelAsymIdHelper = class {
  constructor(asymIds, modelNums, terIndices, hasAssemblies) {
    this.asymIds = asymIds;
    this.modelNums = modelNums;
    this.terIndices = terIndices;
    this.hasAssemblies = hasAssemblies;
    this.asymIdCounts = /* @__PURE__ */ new Map();
    this.currModelNum = void 0;
    this.currAsymId = "";
    this.currLabelAsymId = "";
  }
  clear() {
    this.asymIdCounts.clear();
    this.currModelNum = void 0;
  }
  get(i) {
    const asymId = this.asymIds.value(i);
    if (this.hasAssemblies)
      return asymId;
    const modelNum = this.modelNums[i];
    if (modelNum !== this.currModelNum) {
      this.asymIdCounts.clear();
      this.currModelNum = modelNum;
      this.currLabelAsymId = asymId;
    } else if (this.currAsymId !== asymId) {
      this.currAsymId = asymId;
      this.currLabelAsymId = asymId;
    }
    if (this.asymIdCounts.has(asymId)) {
      if (this.terIndices.has(i)) {
        const asymIdCount = this.asymIdCounts.get(asymId) + 1;
        this.asymIdCounts.set(asymId, asymIdCount);
        this.currLabelAsymId = `${asymId}_${asymIdCount}`;
      }
    } else {
      this.asymIdCounts.set(asymId, 0);
    }
    return this.currLabelAsymId;
  }
};
function getAtomSite(sites, labelAsymIdHelper, options) {
  labelAsymIdHelper.clear();
  const pdbx_PDB_model_num = CifField.ofStrings(sites.pdbx_PDB_model_num);
  const auth_asym_id = CifField.ofTokens(sites.auth_asym_id);
  const auth_seq_id = CifField.ofTokens(sites.auth_seq_id);
  const pdbx_PDB_ins_code = CifField.ofTokens(sites.pdbx_PDB_ins_code);
  const auth_atom_id = CifField.ofTokens(sites.auth_atom_id);
  const auth_comp_id = CifField.ofTokens(sites.auth_comp_id);
  const id = CifField.ofStrings(sites.id);
  let currModelNum = pdbx_PDB_model_num.str(0);
  let currAsymId = auth_asym_id.str(0);
  let currSeqId = auth_seq_id.int(0);
  let currInsCode = pdbx_PDB_ins_code.str(0);
  let currLabelSeqId = currSeqId;
  const asymIdCounts = /* @__PURE__ */ new Map();
  const atomIdCounts = /* @__PURE__ */ new Map();
  const labelAsymIds = [];
  const labelAtomIds = [];
  const labelSeqIds = [];
  let hasInsCode = false;
  for (let i = 0, il = id.rowCount; i < il; ++i) {
    if (pdbx_PDB_ins_code.str(i) !== "") {
      hasInsCode = true;
      break;
    }
  }
  for (let i = 0, il = id.rowCount; i < il; ++i) {
    const modelNum = pdbx_PDB_model_num.str(i);
    const asymId = auth_asym_id.str(i);
    const seqId = auth_seq_id.int(i);
    const insCode = pdbx_PDB_ins_code.str(i);
    let atomId2 = auth_atom_id.str(i);
    if (modelNum !== currModelNum) {
      asymIdCounts.clear();
      atomIdCounts.clear();
      currModelNum = modelNum;
      currAsymId = asymId;
      currSeqId = seqId;
      currInsCode = insCode;
      currLabelSeqId = seqId;
    } else if (currAsymId !== asymId) {
      atomIdCounts.clear();
      currAsymId = asymId;
      currSeqId = seqId;
      currInsCode = insCode;
      currLabelSeqId = seqId;
    } else if (currSeqId !== seqId) {
      atomIdCounts.clear();
      if (currSeqId === currLabelSeqId) {
        currLabelSeqId = seqId;
      } else {
        currLabelSeqId += 1;
      }
      currSeqId = seqId;
      currInsCode = insCode;
    } else if (currInsCode !== insCode) {
      atomIdCounts.clear();
      currInsCode = insCode;
      currLabelSeqId += 1;
    }
    labelAsymIds[i] = labelAsymIdHelper.get(i);
    if (atomIdCounts.has(atomId2)) {
      const atomIdCount = atomIdCounts.get(atomId2) + 1;
      atomIdCounts.set(atomId2, atomIdCount);
      atomId2 = `${atomId2}_${atomIdCount}`;
    } else {
      atomIdCounts.set(atomId2, 0);
    }
    labelAtomIds[i] = atomId2;
    if (hasInsCode) {
      labelSeqIds[i] = currLabelSeqId;
    }
  }
  const labelAsymId = Column.ofStringArray(labelAsymIds);
  const labelAtomId = Column.ofStringArray(labelAtomIds);
  const label_seq_id = hasInsCode ? CifField.ofColumn(Column.ofIntArray(labelSeqIds)) : CifField.ofUndefined(sites.index, Column.Schema.int);
  return {
    auth_asym_id,
    auth_atom_id,
    auth_comp_id,
    auth_seq_id,
    B_iso_or_equiv: CifField.ofTokens(sites.B_iso_or_equiv),
    Cartn_x: CifField.ofTokens(sites.Cartn_x),
    Cartn_y: CifField.ofTokens(sites.Cartn_y),
    Cartn_z: CifField.ofTokens(sites.Cartn_z),
    group_PDB: CifField.ofTokens(sites.group_PDB),
    id,
    label_alt_id: CifField.ofTokens(sites.label_alt_id),
    label_asym_id: CifField.ofColumn(labelAsymId),
    label_atom_id: CifField.ofColumn(labelAtomId),
    label_comp_id: auth_comp_id,
    label_seq_id,
    label_entity_id: CifField.ofStrings(sites.label_entity_id),
    occupancy: areTokensEmpty(sites.occupancy) ? CifField.ofUndefined(sites.index, Column.Schema.float) : CifField.ofTokens(sites.occupancy),
    type_symbol: CifField.ofTokens(sites.type_symbol),
    pdbx_PDB_ins_code: CifField.ofTokens(sites.pdbx_PDB_ins_code),
    pdbx_PDB_model_num,
    partial_charge: CifField.ofTokens(sites.partial_charge)
  };
}
function addAtom(sites, model, data, s, e, isPdbqt) {
  const { data: str3 } = data;
  const length = e - s;
  TokenBuilder.addToken(sites.group_PDB, Tokenizer.trim(data, s, s + 6));
  Tokenizer.trim(data, s + 6, s + 11);
  sites.id[sites.index] = data.data.substring(data.tokenStart, data.tokenEnd);
  TokenBuilder.addToken(sites.auth_atom_id, Tokenizer.trim(data, s + 12, s + 16));
  if (str3.charCodeAt(s + 16) === 32) {
    TokenBuilder.add(sites.label_alt_id, 0, 0);
  } else {
    TokenBuilder.add(sites.label_alt_id, s + 16, s + 17);
  }
  TokenBuilder.addToken(sites.auth_comp_id, Tokenizer.trim(data, s + 17, s + 20));
  TokenBuilder.add(sites.auth_asym_id, s + 21, s + 22);
  TokenBuilder.addToken(sites.auth_seq_id, Tokenizer.trim(data, s + 22, s + 26));
  if (str3.charCodeAt(s + 26) === 32) {
    TokenBuilder.add(sites.pdbx_PDB_ins_code, 0, 0);
  } else {
    TokenBuilder.add(sites.pdbx_PDB_ins_code, s + 26, s + 27);
  }
  TokenBuilder.addToken(sites.Cartn_x, Tokenizer.trim(data, s + 30, s + 38));
  TokenBuilder.addToken(sites.Cartn_y, Tokenizer.trim(data, s + 38, s + 46));
  TokenBuilder.addToken(sites.Cartn_z, Tokenizer.trim(data, s + 46, s + 54));
  TokenBuilder.addToken(sites.occupancy, Tokenizer.trim(data, s + 54, s + 60));
  if (length >= 66) {
    TokenBuilder.addToken(sites.B_iso_or_equiv, Tokenizer.trim(data, s + 60, s + 66));
  } else {
    TokenBuilder.add(sites.B_iso_or_equiv, 0, 0);
  }
  if (isPdbqt) {
    TokenBuilder.addToken(sites.partial_charge, Tokenizer.trim(data, s + 70, s + 76));
  } else {
  }
  if (length >= 78 && !isPdbqt) {
    Tokenizer.trim(data, s + 76, s + 78);
    if (data.tokenStart < data.tokenEnd) {
      TokenBuilder.addToken(sites.type_symbol, data);
    } else {
      guessElementSymbolTokens(sites.type_symbol, str3, s + 12, s + 16);
    }
  } else {
    guessElementSymbolTokens(sites.type_symbol, str3, s + 12, s + 16);
  }
  sites.pdbx_PDB_model_num[sites.index] = model;
  sites.index++;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/pdb/anisotropic.js
function getAnisotropicTemplate(data, count3) {
  const str3 = () => [];
  const float = () => new Float32Array(count3);
  const ts = () => TokenBuilder.create(data, 2 * count3);
  return {
    index: 0,
    count: count3,
    id: str3(),
    type_symbol: ts(),
    pdbx_label_atom_id: ts(),
    pdbx_label_alt_id: ts(),
    pdbx_label_comp_id: ts(),
    pdbx_label_asym_id: ts(),
    pdbx_label_seq_id: ts(),
    pdbx_PDB_ins_code: ts(),
    "U[1][1]": float(),
    "U[2][2]": float(),
    "U[3][3]": float(),
    "U[1][2]": float(),
    "U[1][3]": float(),
    "U[2][3]": float(),
    pdbx_auth_seq_id: ts(),
    pdbx_auth_comp_id: ts(),
    pdbx_auth_asym_id: ts(),
    pdbx_auth_atom_id: ts()
  };
}
function getAnisotropic(sites) {
  const pdbx_auth_seq_id = CifField.ofTokens(sites.pdbx_auth_seq_id);
  const pdbx_auth_comp_id = CifField.ofTokens(sites.pdbx_auth_comp_id);
  const pdbx_auth_asym_id = CifField.ofTokens(sites.pdbx_auth_asym_id);
  const pdbx_auth_atom_id = CifField.ofTokens(sites.pdbx_auth_atom_id);
  const fields = {
    id: CifField.ofStrings(sites.id),
    type_symbol: CifField.ofTokens(sites.type_symbol),
    pdbx_label_atom_id: pdbx_auth_atom_id,
    pdbx_label_alt_id: CifField.ofTokens(sites.pdbx_label_alt_id),
    pdbx_label_comp_id: pdbx_auth_comp_id,
    pdbx_label_asym_id: pdbx_auth_asym_id,
    pdbx_label_seq_id: pdbx_auth_seq_id,
    pdbx_PDB_ins_code: CifField.ofTokens(sites.pdbx_PDB_ins_code),
    pdbx_auth_seq_id,
    pdbx_auth_comp_id,
    pdbx_auth_asym_id,
    pdbx_auth_atom_id
  };
  fields["U[1][1]"] = CifField.ofNumbers(sites["U[1][1]"]);
  fields["U[2][2]"] = CifField.ofNumbers(sites["U[2][2]"]);
  fields["U[3][3]"] = CifField.ofNumbers(sites["U[3][3]"]);
  fields["U[1][2]"] = CifField.ofNumbers(sites["U[1][2]"]);
  fields["U[1][3]"] = CifField.ofNumbers(sites["U[1][3]"]);
  fields["U[2][3]"] = CifField.ofNumbers(sites["U[2][3]"]);
  return fields;
}
function addAnisotropic(sites, model, data, s, e) {
  const { data: str3 } = data;
  const length = e - s;
  Tokenizer.trim(data, s + 6, s + 11);
  sites.id[sites.index] = str3.substring(data.tokenStart, data.tokenEnd);
  TokenBuilder.addToken(sites.pdbx_auth_atom_id, Tokenizer.trim(data, s + 12, s + 16));
  if (str3.charCodeAt(s + 16) === 32) {
    TokenBuilder.add(sites.pdbx_label_alt_id, 0, 0);
  } else {
    TokenBuilder.add(sites.pdbx_label_alt_id, s + 16, s + 17);
  }
  TokenBuilder.addToken(sites.pdbx_auth_comp_id, Tokenizer.trim(data, s + 17, s + 20));
  TokenBuilder.add(sites.pdbx_auth_asym_id, s + 21, s + 22);
  TokenBuilder.addToken(sites.pdbx_auth_seq_id, Tokenizer.trim(data, s + 22, s + 26));
  if (str3.charCodeAt(s + 26) === 32) {
    TokenBuilder.add(sites.pdbx_PDB_ins_code, 0, 0);
  } else {
    TokenBuilder.add(sites.pdbx_PDB_ins_code, s + 26, s + 27);
  }
  sites["U[1][1]"][sites.index] = parseIntSkipLeadingWhitespace(str3, s + 28, s + 35) / 1e4;
  sites["U[2][2]"][sites.index] = parseIntSkipLeadingWhitespace(str3, s + 35, s + 42) / 1e4;
  sites["U[3][3]"][sites.index] = parseIntSkipLeadingWhitespace(str3, s + 42, s + 49) / 1e4;
  sites["U[1][2]"][sites.index] = parseIntSkipLeadingWhitespace(str3, s + 49, s + 56) / 1e4;
  sites["U[1][3]"][sites.index] = parseIntSkipLeadingWhitespace(str3, s + 56, s + 63) / 1e4;
  sites["U[2][3]"][sites.index] = parseIntSkipLeadingWhitespace(str3, s + 63, s + 70) / 1e4;
  if (length >= 78) {
    Tokenizer.trim(data, s + 76, s + 78);
    if (data.tokenStart < data.tokenEnd) {
      TokenBuilder.addToken(sites.type_symbol, data);
    } else {
      guessElementSymbolTokens(sites.type_symbol, str3, s + 12, s + 16);
    }
  } else {
    guessElementSymbolTokens(sites.type_symbol, str3, s + 12, s + 16);
  }
  sites.index++;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/pdb/conect.js
function parseConect(lines, lineStart, lineEnd, sites) {
  const idMap = {};
  for (let i = 0, il = sites.id.rowCount; i < il; ++i) {
    idMap[sites.id.str(i)] = i;
  }
  const getLine = (n) => lines.data.substring(lines.indices[2 * n], lines.indices[2 * n + 1]);
  const id = [];
  const conn_type_id = [];
  const ptnr1_label_asym_id = [];
  const ptnr1_label_seq_id = [];
  const ptnr1_auth_seq_id = [];
  const ptnr1_label_atom_id = [];
  const ptnr1_label_alt_id = [];
  const ptnr1_PDB_ins_code = [];
  const ptnr2_label_asym_id = [];
  const ptnr2_label_seq_id = [];
  const ptnr2_auth_seq_id = [];
  const ptnr2_label_atom_id = [];
  const ptnr2_label_alt_id = [];
  const ptnr2_PDB_ins_code = [];
  const pos = [11, 16, 21, 26];
  let k = 1;
  for (let i = lineStart; i < lineEnd; i++) {
    const line = getLine(i);
    const idxA = idMap[parseInt(line.substr(6, 5))];
    const bondIndex = {};
    if (idxA === void 0)
      continue;
    for (let j = 0; j < 4; ++j) {
      const idB = parseInt(line.substr(pos[j], 5));
      if (Number.isNaN(idB))
        continue;
      const idxB = idMap[idB];
      if (idxB === void 0)
        continue;
      if (idxA > idxB)
        continue;
      if (bondIndex[idxB] !== void 0)
        continue;
      id.push(`covale${k}`);
      conn_type_id.push("covale");
      ptnr1_label_asym_id.push(sites.label_asym_id.str(idxA));
      ptnr1_label_seq_id.push(sites.label_seq_id.int(idxA));
      ptnr1_auth_seq_id.push(sites.auth_seq_id.int(idxA));
      ptnr1_label_atom_id.push(sites.label_atom_id.str(idxA));
      ptnr1_label_alt_id.push(sites.label_alt_id.str(idxA));
      ptnr1_PDB_ins_code.push(sites.pdbx_PDB_ins_code.str(idxA));
      ptnr2_label_asym_id.push(sites.label_asym_id.str(idxB));
      ptnr2_label_seq_id.push(sites.label_seq_id.int(idxB));
      ptnr2_auth_seq_id.push(sites.auth_seq_id.int(idxB));
      ptnr2_label_atom_id.push(sites.label_atom_id.str(idxB));
      ptnr2_label_alt_id.push(sites.label_alt_id.str(idxB));
      ptnr2_PDB_ins_code.push(sites.pdbx_PDB_ins_code.str(idxB));
      k += 1;
    }
  }
  const struct_conn = {
    id: CifField.ofStrings(id),
    conn_type_id: CifField.ofStrings(conn_type_id),
    ptnr1_label_asym_id: CifField.ofStrings(ptnr1_label_asym_id),
    ptnr1_label_seq_id: CifField.ofNumbers(ptnr1_label_seq_id),
    ptnr1_auth_seq_id: CifField.ofNumbers(ptnr1_auth_seq_id),
    ptnr1_label_atom_id: CifField.ofStrings(ptnr1_label_atom_id),
    pdbx_ptnr1_label_alt_id: CifField.ofStrings(ptnr1_label_alt_id),
    pdbx_ptnr1_PDB_ins_code: CifField.ofStrings(ptnr1_PDB_ins_code),
    ptnr2_label_asym_id: CifField.ofStrings(ptnr2_label_asym_id),
    ptnr2_label_seq_id: CifField.ofNumbers(ptnr2_label_seq_id),
    ptnr2_auth_seq_id: CifField.ofNumbers(ptnr2_auth_seq_id),
    ptnr2_label_atom_id: CifField.ofStrings(ptnr2_label_atom_id),
    pdbx_ptnr2_label_alt_id: CifField.ofStrings(ptnr2_label_alt_id),
    pdbx_ptnr2_PDB_ins_code: CifField.ofStrings(ptnr2_PDB_ins_code)
  };
  return CifCategory.ofFields("struct_conn", struct_conn);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/pdb/header.js
function addHeader(data, s, e, header2) {
  const line = data.substring(s, e);
  header2.id_code = line.substring(62, 66).trim() || void 0;
  header2.dep_date = line.substring(50, 59).trim() || void 0;
  header2.classification = line.substring(10, 50).trim() || void 0;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/pdb/to-cif.js
async function pdbToMmCif(pdb) {
  const { lines } = pdb;
  const { data, indices: indices2 } = lines;
  const tokenizer = Tokenizer(data);
  const isPdbqt = !!pdb.isPdbqt;
  let atomCount = 0;
  let anisotropicCount = 0;
  for (let i = 0, _i = lines.count; i < _i; i++) {
    const s = indices2[2 * i], e = indices2[2 * i + 1];
    switch (data.charAt(s)) {
      case "A":
        if (substringStartsWith(data, s, e, "ATOM  "))
          atomCount++;
        else if (substringStartsWith(data, s, e, "ANISOU"))
          anisotropicCount++;
        break;
      case "H":
        if (substringStartsWith(data, s, e, "HETATM"))
          atomCount++;
        break;
    }
  }
  const header2 = {};
  const atomSite = getAtomSiteTemplate(data, atomCount);
  const anisotropic = getAnisotropicTemplate(data, anisotropicCount);
  const entityBuilder = new EntityBuilder();
  const helperCategories = [];
  const heteroNames = [];
  let modelNum = 0, modelStr = "";
  let conectRange = void 0;
  let hasAssemblies = false;
  const terIndices = /* @__PURE__ */ new Set();
  for (let i = 0, _i = lines.count; i < _i; i++) {
    let s = indices2[2 * i], e = indices2[2 * i + 1];
    switch (data.charAt(s)) {
      case "A":
        if (substringStartsWith(data, s, e, "ATOM  ")) {
          if (!modelNum) {
            modelNum++;
            modelStr = "" + modelNum;
          }
          addAtom(atomSite, modelStr, tokenizer, s, e, isPdbqt);
        } else if (substringStartsWith(data, s, e, "ANISOU")) {
          addAnisotropic(anisotropic, modelStr, tokenizer, s, e);
        }
        break;
      case "C":
        if (substringStartsWith(data, s, e, "CRYST1")) {
          helperCategories.push(...parseCryst1(pdb.id || "?", data.substring(s, e)));
        } else if (substringStartsWith(data, s, e, "CONECT")) {
          let j = i + 1;
          while (true) {
            s = indices2[2 * j];
            e = indices2[2 * j + 1];
            if (!substringStartsWith(data, s, e, "CONECT"))
              break;
            j++;
          }
          if (conectRange) {
            if (isDebugMode) {
              console.log("only single CONECT block allowed, ignoring others");
            }
          } else {
            conectRange = [i, j];
          }
          i = j - 1;
        } else if (substringStartsWith(data, s, e, "COMPND")) {
          let j = i + 1;
          while (true) {
            s = indices2[2 * j];
            e = indices2[2 * j + 1];
            if (!substringStartsWith(data, s, e, "COMPND"))
              break;
            j++;
          }
          entityBuilder.setCompounds(parseCmpnd(lines, i, j));
          i = j - 1;
        }
        break;
      case "H":
        if (substringStartsWith(data, s, e, "HEADER")) {
          addHeader(data, s, e, header2);
        } else if (substringStartsWith(data, s, e, "HETATM")) {
          if (!modelNum) {
            modelNum++;
            modelStr = "" + modelNum;
          }
          addAtom(atomSite, modelStr, tokenizer, s, e, isPdbqt);
        } else if (substringStartsWith(data, s, e, "HELIX")) {
          let j = i + 1;
          while (true) {
            s = indices2[2 * j];
            e = indices2[2 * j + 1];
            if (!substringStartsWith(data, s, e, "HELIX"))
              break;
            j++;
          }
          helperCategories.push(parseHelix(lines, i, j));
          i = j - 1;
        } else if (substringStartsWith(data, s, e, "HETNAM")) {
          let j = i + 1;
          while (true) {
            s = indices2[2 * j];
            e = indices2[2 * j + 1];
            if (!substringStartsWith(data, s, e, "HETNAM"))
              break;
            j++;
          }
          heteroNames.push(...Array.from(parseHetnam(lines, i, j).entries()));
          i = j - 1;
        }
        break;
      case "M":
        if (substringStartsWith(data, s, e, "MODEL ")) {
          modelNum++;
          modelStr = "" + modelNum;
        }
        if (substringStartsWith(data, s, e, "MTRIX")) {
          let j = i + 1;
          while (true) {
            s = indices2[2 * j];
            e = indices2[2 * j + 1];
            if (!substringStartsWith(data, s, e, "MTRIX"))
              break;
            j++;
          }
          helperCategories.push(...parseMtrix(lines, i, j));
          i = j - 1;
        }
        break;
      case "O":
        break;
      case "R":
        if (substringStartsWith(data, s, e, "REMARK 350")) {
          let j = i + 1;
          while (true) {
            s = indices2[2 * j];
            e = indices2[2 * j + 1];
            if (!substringStartsWith(data, s, e, "REMARK 350"))
              break;
            j++;
          }
          helperCategories.push(...parseRemark350(lines, i, j));
          i = j - 1;
          hasAssemblies = true;
        }
        break;
      case "S":
        if (substringStartsWith(data, s, e, "SHEET")) {
          let j = i + 1;
          while (true) {
            s = indices2[2 * j];
            e = indices2[2 * j + 1];
            if (!substringStartsWith(data, s, e, "SHEET"))
              break;
            j++;
          }
          helperCategories.push(parseSheet(lines, i, j));
          i = j - 1;
        }
        break;
      case "T":
        if (substringStartsWith(data, s, e, "TER")) {
          terIndices.add(atomSite.index);
        }
    }
  }
  if (header2.id_code) {
    const entry = {
      id: CifField.ofString(header2.id_code)
    };
    helperCategories.push(CifCategory.ofFields("entry", entry));
  }
  if (header2.classification) {
    const struct_keywords = {
      pdbx_keywords: CifField.ofString(header2.classification)
    };
    helperCategories.push(CifCategory.ofFields("struct_keywords", struct_keywords));
  }
  if (header2.dep_date) {
    const pdbx_database_status = {
      recvd_initial_deposition_date: CifField.ofString(header2.dep_date)
    };
    helperCategories.push(CifCategory.ofFields("pdbx_database_status", pdbx_database_status));
  }
  const seqIds = Column.ofIntTokens(atomSite.auth_seq_id);
  const atomIds = Column.ofStringTokens(atomSite.auth_atom_id);
  const compIds = Column.ofStringTokens(atomSite.auth_comp_id);
  const asymIds = Column.ofStringTokens(atomSite.auth_asym_id);
  const labelAsymIdHelper = new LabelAsymIdHelper(asymIds, atomSite.pdbx_PDB_model_num, terIndices, hasAssemblies);
  const componentBuilder = new ComponentBuilder(seqIds, atomIds);
  componentBuilder.setNames(heteroNames);
  entityBuilder.setNames(heteroNames);
  for (let i = 0, il = compIds.rowCount; i < il; ++i) {
    const compId2 = compIds.value(i);
    const moleculeType = getMoleculeType(componentBuilder.add(compId2, i).type, compId2);
    const asymId = labelAsymIdHelper.get(i);
    atomSite.label_entity_id[i] = entityBuilder.getEntityId(compId2, moleculeType, asymId);
  }
  const atom_site = getAtomSite(atomSite, labelAsymIdHelper, { hasAssemblies });
  if (!isPdbqt)
    delete atom_site.partial_charge;
  if (conectRange) {
    helperCategories.push(parseConect(lines, conectRange[0], conectRange[1], atom_site));
  }
  const categories = {
    entity: CifCategory.ofTable("entity", entityBuilder.getEntityTable()),
    chem_comp: CifCategory.ofTable("chem_comp", componentBuilder.getChemCompTable()),
    atom_site: CifCategory.ofFields("atom_site", atom_site),
    atom_site_anisotrop: CifCategory.ofFields("atom_site_anisotrop", getAnisotropic(anisotropic))
  };
  for (const c5 of helperCategories) {
    categories[c5.name] = c5;
  }
  return {
    header: pdb.id || "PDB",
    categoryNames: Object.keys(categories),
    categories
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/property/partial-charge.js
var AtomPartialCharge;
(function(AtomPartialCharge2) {
  AtomPartialCharge2.Descriptor = {
    name: "atom_partial_charge"
  };
  AtomPartialCharge2.Provider = FormatPropertyProvider.create(AtomPartialCharge2.Descriptor);
})(AtomPartialCharge || (AtomPartialCharge = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/pdb.js
var PdbFormat;
(function(PdbFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "pdb";
  }
  PdbFormat2.is = is3;
  function create(pdb) {
    return { kind: "pdb", name: pdb.id || "", data: pdb };
  }
  PdbFormat2.create = create;
})(PdbFormat || (PdbFormat = {}));
function trajectoryFromPDB(pdb) {
  return Task.create("Parse PDB", async (ctx) => {
    var _a;
    await ctx.update("Converting to mmCIF");
    const cif = await pdbToMmCif(pdb);
    const format = MmcifFormat.fromFrame(cif, void 0, PdbFormat.create(pdb));
    const basic = createBasic(format.data.db, true);
    const models = await createModels(basic, format, ctx);
    const partial_charge = (_a = cif.categories["atom_site"]) === null || _a === void 0 ? void 0 : _a.getField("partial_charge");
    if (partial_charge) {
      if (models.frameCount === 1) {
        const first4 = models.representative;
        const srcIndex = first4.atomicHierarchy.atomSourceIndex;
        const isIdentity = Column.isIdentity(srcIndex);
        const srcIndexArray = isIdentity ? void 0 : srcIndex.toArray({ array: Int32Array });
        const q = partial_charge.toFloatArray();
        const partialCharge = srcIndexArray ? Column.ofFloatArray(Column.mapToArray(srcIndex, (i) => q[i], Float32Array)) : Column.ofFloatArray(q);
        AtomPartialCharge.Provider.set(first4, {
          data: partialCharge,
          type: "GASTEIGER"
          // from PDBQT
        });
      }
    }
    return models;
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/psf.js
function getBasic2(atoms) {
  const entityIds = new Array(atoms.count);
  const asymIds = new Array(atoms.count);
  const seqIds = new Uint32Array(atoms.count);
  const ids = new Uint32Array(atoms.count);
  const typeSymbol2 = new Array(atoms.count);
  const entityBuilder = new EntityBuilder();
  const componentBuilder = new ComponentBuilder(atoms.residueId, atoms.atomName);
  let currentEntityId = "";
  let currentAsymIndex = 0;
  let currentAsymId = "";
  let currentSeqId = 0;
  let currentSegmentName = atoms.segmentName.value(0), segmentChanged = false;
  let prevMoleculeType = MoleculeType.Unknown;
  let prevResidueNumber = -1;
  for (let i = 0, il = atoms.count; i < il; ++i) {
    const residueNumber = atoms.residueId.value(i);
    const segmentName = atoms.segmentName.value(i);
    if (currentSegmentName !== segmentName) {
      currentAsymId = getChainId(currentAsymIndex);
      currentAsymIndex += 1;
      currentSeqId = 0;
      segmentChanged = true;
      currentSegmentName = segmentName;
    } else {
      segmentChanged = false;
    }
    if (segmentChanged || residueNumber !== prevResidueNumber) {
      const compId2 = atoms.residueName.value(i);
      const moleculeType = getMoleculeType(componentBuilder.add(compId2, i).type, compId2);
      if (!segmentChanged && (moleculeType !== prevMoleculeType || residueNumber !== prevResidueNumber + 1)) {
        currentAsymId = getChainId(currentAsymIndex);
        currentAsymIndex += 1;
        currentSeqId = 0;
      }
      currentEntityId = entityBuilder.getEntityId(compId2, moleculeType, currentAsymId);
      currentSeqId += 1;
      prevResidueNumber = residueNumber;
      prevMoleculeType = moleculeType;
    }
    entityIds[i] = currentEntityId;
    asymIds[i] = currentAsymId;
    seqIds[i] = currentSeqId;
    ids[i] = i;
    typeSymbol2[i] = guessElementSymbolString(atoms.atomName.value(i), atoms.residueName.value(i));
  }
  const atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
    auth_asym_id: atoms.segmentName,
    auth_atom_id: atoms.atomName,
    auth_comp_id: atoms.residueName,
    auth_seq_id: atoms.residueId,
    id: Column.ofIntArray(ids),
    label_asym_id: Column.ofStringArray(asymIds),
    label_atom_id: atoms.atomName,
    label_comp_id: atoms.residueName,
    label_seq_id: Column.ofIntArray(seqIds),
    label_entity_id: Column.ofStringArray(entityIds),
    occupancy: Column.ofConst(1, atoms.count, Column.Schema.float),
    type_symbol: Column.ofStringArray(typeSymbol2),
    pdbx_PDB_model_num: Column.ofConst(1, atoms.count, Column.Schema.int)
  }, atoms.count);
  return createBasic({
    entity: entityBuilder.getEntityTable(),
    chem_comp: componentBuilder.getChemCompTable(),
    atom_site
  });
}
var PsfFormat;
(function(PsfFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "psf";
  }
  PsfFormat2.is = is3;
  function fromPsf(psf) {
    return { kind: "psf", name: psf.id, data: psf };
  }
  PsfFormat2.fromPsf = fromPsf;
})(PsfFormat || (PsfFormat = {}));
function topologyFromPsf(psf) {
  return Task.create("Parse PSF", async (ctx) => {
    const format = PsfFormat.fromPsf(psf);
    const basic = getBasic2(psf.atoms);
    const { atomIdA, atomIdB } = psf.bonds;
    const bonds = {
      indexA: Column.ofLambda({
        value: (row) => atomIdA.value(row) - 1,
        rowCount: atomIdA.rowCount,
        schema: atomIdA.schema
      }),
      indexB: Column.ofLambda({
        value: (row) => atomIdB.value(row) - 1,
        rowCount: atomIdB.rowCount,
        schema: atomIdB.schema
      }),
      order: Column.ofConst(1, psf.bonds.count, Column.Schema.int)
    };
    return Topology.create(psf.id, basic, bonds, format);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/script/mol-script/script-macro.js
function getPositionalArgs(args) {
  return Object.keys(args).filter((k) => !isNaN(k)).map((k) => +k).sort((a5, b5) => a5 - b5).map((k) => args[k]);
}
function tryGetArg(args, name, defaultValue) {
  return args && args[name] !== void 0 ? args[name] : defaultValue;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/script/mol-script/symbols.js
function Alias(symbol, ...aliases) {
  return { kind: "alias", aliases, symbol };
}
function Macro(symbol, translate, ...aliases) {
  symbol.info.namespace = "molscript-macro";
  symbol.id = `molscript-macro.${symbol.info.name}`;
  return { kind: "macro", symbol, translate, aliases: [symbol.info.name, ...aliases] };
}
function isMolScriptSymbol(x) {
  return x.kind === "alias" || x.kind === "macro";
}
var SymbolTable = [
  [
    "Core symbols",
    Alias(MolScriptSymbolTable.core.type.bool, "bool"),
    Alias(MolScriptSymbolTable.core.type.num, "num"),
    Alias(MolScriptSymbolTable.core.type.str, "str"),
    Alias(MolScriptSymbolTable.core.type.regex, "regex"),
    Alias(MolScriptSymbolTable.core.type.list, "list"),
    Alias(MolScriptSymbolTable.core.type.set, "set"),
    Alias(MolScriptSymbolTable.core.type.compositeKey, "composite-key"),
    Alias(MolScriptSymbolTable.core.logic.not, "not"),
    Alias(MolScriptSymbolTable.core.logic.and, "and"),
    Alias(MolScriptSymbolTable.core.logic.or, "or"),
    Alias(MolScriptSymbolTable.core.ctrl.if, "if"),
    Alias(MolScriptSymbolTable.core.ctrl.fn, "fn"),
    Alias(MolScriptSymbolTable.core.ctrl.eval, "eval"),
    Alias(MolScriptSymbolTable.core.math.add, "add", "+"),
    Alias(MolScriptSymbolTable.core.math.sub, "sub", "-"),
    Alias(MolScriptSymbolTable.core.math.mult, "mult", "*"),
    Alias(MolScriptSymbolTable.core.math.div, "div", "/"),
    Alias(MolScriptSymbolTable.core.math.pow, "pow", "**"),
    Alias(MolScriptSymbolTable.core.math.mod, "mod"),
    Alias(MolScriptSymbolTable.core.math.min, "min"),
    Alias(MolScriptSymbolTable.core.math.max, "max"),
    Alias(MolScriptSymbolTable.core.math.cantorPairing, "cantor-pairing"),
    Alias(MolScriptSymbolTable.core.math.sortedCantorPairing, "sorted-cantor-pairing"),
    Alias(MolScriptSymbolTable.core.math.invertCantorPairing, "invert-cantor-pairing"),
    Alias(MolScriptSymbolTable.core.math.floor, "floor"),
    Alias(MolScriptSymbolTable.core.math.ceil, "ceil"),
    Alias(MolScriptSymbolTable.core.math.roundInt, "round"),
    Alias(MolScriptSymbolTable.core.math.trunc, "trunc"),
    Alias(MolScriptSymbolTable.core.math.abs, "abs"),
    Alias(MolScriptSymbolTable.core.math.sign, "sign"),
    Alias(MolScriptSymbolTable.core.math.sqrt, "sqrt"),
    Alias(MolScriptSymbolTable.core.math.cbrt, "cbrt"),
    Alias(MolScriptSymbolTable.core.math.sin, "sin"),
    Alias(MolScriptSymbolTable.core.math.cos, "cos"),
    Alias(MolScriptSymbolTable.core.math.tan, "tan"),
    Alias(MolScriptSymbolTable.core.math.asin, "asin"),
    Alias(MolScriptSymbolTable.core.math.acos, "acos"),
    Alias(MolScriptSymbolTable.core.math.atan, "atan"),
    Alias(MolScriptSymbolTable.core.math.sinh, "sinh"),
    Alias(MolScriptSymbolTable.core.math.cosh, "cosh"),
    Alias(MolScriptSymbolTable.core.math.tanh, "tanh"),
    Alias(MolScriptSymbolTable.core.math.exp, "exp"),
    Alias(MolScriptSymbolTable.core.math.log, "log"),
    Alias(MolScriptSymbolTable.core.math.log10, "log10"),
    Alias(MolScriptSymbolTable.core.math.atan2, "atan2"),
    Alias(MolScriptSymbolTable.core.rel.eq, "eq", "="),
    Alias(MolScriptSymbolTable.core.rel.neq, "neq", "!="),
    Alias(MolScriptSymbolTable.core.rel.lt, "lt", "<"),
    Alias(MolScriptSymbolTable.core.rel.lte, "lte", "<="),
    Alias(MolScriptSymbolTable.core.rel.gr, "gr", ">"),
    Alias(MolScriptSymbolTable.core.rel.gre, "gre", ">="),
    Alias(MolScriptSymbolTable.core.rel.inRange, "in-range"),
    Alias(MolScriptSymbolTable.core.str.concat, "concat"),
    Alias(MolScriptSymbolTable.core.str.match, "regex.match"),
    Alias(MolScriptSymbolTable.core.list.getAt, "list.get"),
    Alias(MolScriptSymbolTable.core.set.has, "set.has"),
    Alias(MolScriptSymbolTable.core.set.isSubset, "set.subset")
  ],
  [
    "Structure",
    [
      "Types",
      Alias(MolScriptSymbolTable.structureQuery.type.entityType, "ent-type"),
      Alias(MolScriptSymbolTable.structureQuery.type.authResidueId, "auth-resid"),
      Alias(MolScriptSymbolTable.structureQuery.type.labelResidueId, "label-resid"),
      Alias(MolScriptSymbolTable.structureQuery.type.ringFingerprint, "ringfp"),
      Alias(MolScriptSymbolTable.structureQuery.type.bondFlags, "bond-flags")
    ],
    [
      "Slots",
      Alias(MolScriptSymbolTable.structureQuery.slot.elementSetReduce, "atom.set.reduce.value")
    ],
    [
      "Generators",
      Alias(MolScriptSymbolTable.structureQuery.generator.atomGroups, "sel.atom.atom-groups"),
      Alias(MolScriptSymbolTable.structureQuery.generator.queryInSelection, "sel.atom.query-in-selection"),
      Alias(MolScriptSymbolTable.structureQuery.generator.rings, "sel.atom.rings"),
      Alias(MolScriptSymbolTable.structureQuery.generator.empty, "sel.atom.empty"),
      Alias(MolScriptSymbolTable.structureQuery.generator.all, "sel.atom.all"),
      Alias(MolScriptSymbolTable.structureQuery.generator.bondedAtomicPairs, "sel.atom.bonded-pairs"),
      Macro(MSymbol("sel.atom.atoms", Arguments.Dictionary({
        0: Argument(Type.Bool, { isOptional: true, defaultValue: true, description: "Test applied to each atom." })
      }), Types.ElementSelection, "A selection of singleton atom sets."), (args) => MolScriptBuilder.struct.generator.atomGroups({ "atom-test": tryGetArg(args, 0, true) })),
      Macro(MSymbol("sel.atom.res", Arguments.Dictionary({
        0: Argument(Type.Bool, { isOptional: true, defaultValue: true, description: "Test applied to the 1st atom of each residue." })
      }), Types.ElementSelection, "A selection of atom sets grouped by residue."), (args) => MolScriptBuilder.struct.generator.atomGroups({
        "residue-test": tryGetArg(args, 0, true),
        "group-by": MolScriptBuilder.ammp("residueKey")
      })),
      Macro(MSymbol("sel.atom.chains", Arguments.Dictionary({
        0: Argument(Type.Bool, { isOptional: true, defaultValue: true, description: "Test applied to the 1st atom of each chain." })
      }), Types.ElementSelection, "A selection of atom sets grouped by chain."), (args) => MolScriptBuilder.struct.generator.atomGroups({
        "chain-test": tryGetArg(args, 0, true),
        "group-by": MolScriptBuilder.ammp("chainKey")
      }))
    ],
    [
      "Modifiers",
      Alias(MolScriptSymbolTable.structureQuery.modifier.queryEach, "sel.atom.query-each"),
      Alias(MolScriptSymbolTable.structureQuery.modifier.intersectBy, "sel.atom.intersect-by"),
      Alias(MolScriptSymbolTable.structureQuery.modifier.exceptBy, "sel.atom.except-by"),
      Alias(MolScriptSymbolTable.structureQuery.modifier.unionBy, "sel.atom.union-by"),
      Alias(MolScriptSymbolTable.structureQuery.modifier.union, "sel.atom.union"),
      Alias(MolScriptSymbolTable.structureQuery.modifier.cluster, "sel.atom.cluster"),
      Alias(MolScriptSymbolTable.structureQuery.modifier.includeSurroundings, "sel.atom.include-surroundings"),
      Alias(MolScriptSymbolTable.structureQuery.modifier.surroundingLigands, "sel.atom.surrounding-ligands"),
      Alias(MolScriptSymbolTable.structureQuery.modifier.includeConnected, "sel.atom.include-connected"),
      Alias(MolScriptSymbolTable.structureQuery.modifier.expandProperty, "sel.atom.expand-property")
      // Macro(MSymbol('sel.atom.around', Arguments.Dictionary({
      //     0: Argument(Type.Bool, { isOptional: true, defaultValue: true, description: 'Test applied to the 1st atom of each chain.' })
      // }), Struct.Types.ElementSelection, 'A selection of singleton atom sets with centers within "radius" of the center of any atom in the given selection.'),
      // args => B.struct.modifier.exceptBy({
      //     '0': B.struct.filter.within({
      //         '0': B.struct.generator.atomGroups(), target: M.tryGetArg(args, 0), 'max-radius': M.tryGetArg(args, 'radius')
      //     }),
      //     by: M.tryGetArg(args, 0)
      // }))
    ],
    [
      "Filters",
      Alias(MolScriptSymbolTable.structureQuery.filter.pick, "sel.atom.pick"),
      Alias(MolScriptSymbolTable.structureQuery.filter.first, "sel.atom.first"),
      Alias(MolScriptSymbolTable.structureQuery.filter.withSameAtomProperties, "sel.atom.with-same-atom-properties"),
      Alias(MolScriptSymbolTable.structureQuery.filter.intersectedBy, "sel.atom.intersected-by"),
      Alias(MolScriptSymbolTable.structureQuery.filter.within, "sel.atom.within"),
      Alias(MolScriptSymbolTable.structureQuery.filter.isConnectedTo, "sel.atom.is-connected-to")
    ],
    [
      "Combinators",
      Alias(MolScriptSymbolTable.structureQuery.combinator.intersect, "sel.atom.intersect"),
      Alias(MolScriptSymbolTable.structureQuery.combinator.merge, "sel.atom.merge"),
      Alias(MolScriptSymbolTable.structureQuery.combinator.distanceCluster, "sel.atom.dist-cluster")
    ],
    [
      "Atom Set Properties",
      Alias(MolScriptSymbolTable.structureQuery.atomSet.atomCount, "atom.set.atom-count"),
      Alias(MolScriptSymbolTable.structureQuery.atomSet.countQuery, "atom.set.count-query"),
      Alias(MolScriptSymbolTable.structureQuery.atomSet.reduce, "atom.set.reduce"),
      Alias(MolScriptSymbolTable.structureQuery.atomSet.propertySet, "atom.set.property")
      // Macro(MSymbol('atom.set.max', Arguments.Dictionary({
      //     0: Argument(Type.Num, { description: 'Numeric atom property.'})
      // }), Type.Num, 'Maximum of the given property in the current atom set.'),
      // args => M.aggregate(M.tryGetArg(args, 0), B.core.math.max)),
      // Macro(MSymbol('atom.set.sum', Arguments.Dictionary({
      //     0: Argument(Type.Num, { description: 'Numeric atom property.'})
      // }), Type.Num, 'Sum of the given property in the current atom set.'),
      // args => M.aggregate(M.tryGetArg(args, 0), B.core.math.add, 0)),
      // Macro(MSymbol('atom.set.avg', Arguments.Dictionary({
      //     0: Argument(Type.Num, { description: 'Numeric atom property.'})
      // }), Type.Num, 'Average of the given property in the current atom set.'),
      // args => B.core.math.div([ M.aggregate(M.tryGetArg(args, 0), B.core.math.add, 0), B.struct.atomSet.atomCount() ])),
      // Macro(MSymbol('atom.set.min', Arguments.Dictionary({
      //     0: Argument(Type.Num, { description: 'Numeric atom property.'})
      // }), Type.Num, 'Minimum of the given property in the current atom set.'),
      // args => M.aggregate(M.tryGetArg(args, 0), B.core.math.min))
    ],
    [
      "Atom Properties",
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.elementSymbol, "atom.el"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.vdw, "atom.vdw"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.mass, "atom.mass"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.atomicNumber, "atom.atomic-number"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.x, "atom.x"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.y, "atom.y"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.z, "atom.z"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.sourceIndex, "atom.src-index"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.operatorName, "atom.op-name"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.operatorKey, "atom.op-key"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.modelIndex, "atom.model-index"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.modelLabel, "atom.model-label"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.atomKey, "atom.key"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.core.bondCount, "atom.bond-count"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.topology.connectedComponentKey, "atom.key.molecule"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.authResidueId, "atom.auth-resid"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.labelResidueId, "atom.label-resid"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.residueKey, "atom.key.res"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.chainKey, "atom.key.chain"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.entityKey, "atom.key.entity"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.isHet, "atom.is-het"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.id, "atom.id"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_atom_id, "atom.label_atom_id"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_alt_id, "atom.label_alt_id", "atom.altloc"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_comp_id, "atom.label_comp_id"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_asym_id, "atom.label_asym_id"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_entity_id, "atom.label_entity_id"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_seq_id, "atom.label_seq_id"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.auth_atom_id, "atom.auth_atom_id", "atom.name"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.auth_comp_id, "atom.auth_comp_id", "atom.resname"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.auth_asym_id, "atom.auth_asym_id", "atom.chain"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.auth_seq_id, "atom.auth_seq_id", "atom.resno"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.pdbx_PDB_ins_code, "atom.pdbx_PDB_ins_code", "atom.inscode"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.pdbx_formal_charge, "atom.pdbx_formal_charge"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.occupancy, "atom.occupancy"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.B_iso_or_equiv, "atom.B_iso_or_equiv", "atom.bfactor"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.entityType, "atom.entity-type"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.entitySubtype, "atom.entity-subtype"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.entityPrdId, "atom.entity-prd-id"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.entityDescription, "atom.entity-description"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.objectPrimitive, "atom.object-primitive"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.chemCompType, "atom.chem-comp-type"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.secondaryStructureKey, "atom.key.sec-struct"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.isModified, "atom.is-modified"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.modifiedParentName, "atom.modified-parent"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.ihm.hasSeqId, "atom.ihm.has-seq-id"),
      Alias(MolScriptSymbolTable.structureQuery.atomProperty.ihm.overlapsSeqIdRange, "atom.ihm.overlaps-seq-id-range")
      // Macro(MSymbol('atom.sec-struct.is', Arguments.List(Struct.Types.SecondaryStructureFlag), Type.Bool,
      //     `Test if the current atom is part of an secondary structure. Optionally specify allowed sec. struct. types: ${Type.oneOfValues(Struct.Types.SecondaryStructureFlag).join(', ')}`),
      // args => B.core.flags.hasAny([B.struct.atomProperty.macromolecular.secondaryStructureFlags(), B.struct.type.secondaryStructureFlags(args)])),
    ],
    [
      "Bond Properties",
      Alias(MolScriptSymbolTable.structureQuery.bondProperty.order, "bond.order"),
      Alias(MolScriptSymbolTable.structureQuery.bondProperty.length, "bond.length"),
      Alias(MolScriptSymbolTable.structureQuery.bondProperty.key, "bond.key"),
      Alias(MolScriptSymbolTable.structureQuery.bondProperty.atomA, "bond.atom-a"),
      Alias(MolScriptSymbolTable.structureQuery.bondProperty.atomB, "bond.atom-b"),
      Macro(MSymbol("bond.is", Arguments.List(Types.BondFlag), Type.Bool, `Test if the current bond has at least one (or all if partial = false) of the specified flags: ${Type.oneOfValues(Types.BondFlag).join(", ")}`), (args) => MolScriptBuilder.core.flags.hasAny([MolScriptBuilder.struct.bondProperty.flags(), MolScriptBuilder.struct.type.bondFlags(getPositionalArgs(args))]))
    ]
  ]
];
var list = [];
function makeList2(xs) {
  for (const x of xs) {
    if (isMolScriptSymbol(x))
      list.push(x);
    else if (x instanceof Array)
      makeList2(x);
  }
}
makeList2(SymbolTable);
var normalized = function() {
  const symbolList = [];
  const symbolMap2 = /* @__PURE__ */ Object.create(null);
  const namedArgs = UniqueArray.create();
  const constants = UniqueArray.create();
  for (const s of list) {
    for (const a5 of s.aliases) {
      symbolList.push([a5, s]);
      if (symbolMap2[a5])
        throw new Error(`Alias '${a5}' already in use.`);
      symbolMap2[a5] = s;
    }
    const args = s.symbol.args;
    if (args.kind !== "dictionary") {
      if (args.type.kind === "oneof") {
        Type.oneOfValues(args.type).forEach((v3) => UniqueArray.add(constants, v3, v3));
      }
      continue;
    }
    for (const a5 of Object.keys(args.map)) {
      if (isNaN(a5))
        UniqueArray.add(namedArgs, a5, a5);
      const arg = args.map[a5];
      if (arg.type.kind === "oneof") {
        Type.oneOfValues(arg.type).forEach((v3) => UniqueArray.add(constants, v3, v3));
      }
    }
  }
  return { symbolList, symbolMap: symbolMap2, namedArgs: namedArgs.array, constants: constants.array };
}();
var Constants = normalized.constants;
var NamedArgs = normalized.namedArgs;
var SymbolMap = normalized.symbolMap;
var SymbolList = normalized.symbolList;
function substSymbols(expr) {
  if (Expression.isLiteral(expr)) {
    return expr;
  }
  if (Expression.isSymbol(expr)) {
    if (!SymbolMap[expr.name])
      return expr;
    const s = SymbolMap[expr.name];
    if (s.kind === "alias")
      return Expression.Symbol(SymbolMap[expr.name].symbol.id);
    throw s.translate([]);
  }
  const isMacro = Expression.isSymbol(expr.head) && !!SymbolMap[expr.head.name] && SymbolMap[expr.head.name].kind === "macro";
  const head = isMacro ? expr.head : substSymbols(expr.head);
  const headChanged = head !== expr.head;
  if (!expr.args) {
    if (isMacro)
      return substSymbols(expr.head);
    return headChanged ? Expression.Apply(head) : expr;
  }
  let argsChanged = false;
  let newArgs;
  if (Expression.isArgumentsArray(expr.args)) {
    newArgs = [];
    for (let i = 0, _i = expr.args.length; i < _i; i++) {
      const oldArg = expr.args[i];
      const newArg = substSymbols(oldArg);
      if (oldArg !== newArg)
        argsChanged = true;
      newArgs[newArgs.length] = newArg;
    }
    if (!argsChanged)
      newArgs = expr.args;
    if (!isMacro && !headChanged && !argsChanged)
      return expr;
  } else {
    newArgs = {};
    for (const key2 of Object.keys(expr.args)) {
      const oldArg = expr.args[key2];
      const newArg = substSymbols(oldArg);
      if (oldArg !== newArg)
        argsChanged = true;
      newArgs[key2] = newArg;
    }
    if (!isMacro && !headChanged && !argsChanged)
      return expr;
    if (!argsChanged)
      newArgs = expr.args;
  }
  if (isMacro) {
    const macro = SymbolMap[expr.head.name];
    if (macro.kind !== "macro")
      return Expression.Apply(head, newArgs);
    const ret = macro.translate(newArgs);
    return ret;
  }
  return Expression.Apply(head, newArgs);
}
function transpileMolScript(expr) {
  return substSymbols(expr);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/monadic-parser.js
var MonadicParser = class _MonadicParser {
  constructor(_) {
    this._ = _;
  }
  parse(input) {
    const result = this.skip(_MonadicParser.eof)._(input, 0);
    if (result.status) {
      return { success: true, value: result.value };
    }
    return { success: false, index: makeLineColumnIndex(input, result.furthest), expected: result.expected };
  }
  tryParse(str3) {
    const result = this.parse(str3);
    if (result.success) {
      return result.value;
    } else {
      const msg = formatError(str3, result);
      const err = new Error(msg);
      throw err;
    }
  }
  or(alternative) {
    return _MonadicParser.alt(this, alternative);
  }
  trim(parser) {
    return this.wrap(parser, parser);
  }
  wrap(leftParser, rightParser) {
    return seqPick(1, typeof leftParser === "string" ? _MonadicParser.string(leftParser) : leftParser, this, typeof rightParser === "string" ? _MonadicParser.string(rightParser) : rightParser);
  }
  thru(wrapper) {
    return wrapper(this);
  }
  then(next) {
    return seqPick(1, this, next);
  }
  many() {
    return new _MonadicParser((input, i) => {
      const accum = [];
      let result = void 0;
      while (true) {
        result = mergeReplies(this._(input, i), result);
        if (result.status) {
          if (i === result.index) {
            throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
          }
          i = result.index;
          accum.push(result.value);
        } else {
          return mergeReplies(makeSuccess(i, accum), result);
        }
      }
    });
  }
  times(min3, _max) {
    const max3 = typeof _max === "undefined" ? min3 : _max;
    return new _MonadicParser((input, i) => {
      const accum = [];
      let result = void 0;
      let prevResult = void 0;
      let times;
      for (times = 0; times < min3; times++) {
        result = this._(input, i);
        prevResult = mergeReplies(result, prevResult);
        if (result.status) {
          i = result.index;
          accum.push(result.value);
        } else {
          return prevResult;
        }
      }
      for (; times < max3; times += 1) {
        result = this._(input, i);
        prevResult = mergeReplies(result, prevResult);
        if (result.status) {
          i = result.index;
          accum.push(result.value);
        } else {
          break;
        }
      }
      return mergeReplies(makeSuccess(i, accum), prevResult);
    });
  }
  result(res) {
    return this.map(() => res);
  }
  atMost(n) {
    return this.times(0, n);
  }
  atLeast(n) {
    return _MonadicParser.seq(this.times(n), this.many()).map((r) => [...r[0], ...r[1]]);
  }
  map(f) {
    return new _MonadicParser((input, i) => {
      const result = this._(input, i);
      if (!result.status) {
        return result;
      }
      return mergeReplies(makeSuccess(result.index, f(result.value)), result);
    });
  }
  skip(next) {
    return seqPick(0, this, next);
  }
  mark() {
    return _MonadicParser.seq(_MonadicParser.index, this, _MonadicParser.index).map((r) => ({ start: r[0], value: r[1], end: r[2] }));
  }
  node(name) {
    return _MonadicParser.seq(_MonadicParser.index, this, _MonadicParser.index).map((r) => ({ name, start: r[0], value: r[1], end: r[2] }));
  }
  sepBy(separator) {
    return _MonadicParser.sepBy(this, separator);
  }
  sepBy1(separator) {
    return _MonadicParser.sepBy1(this, separator);
  }
  lookahead(x) {
    return this.skip(_MonadicParser.lookahead(x));
  }
  notFollowedBy(x) {
    return this.skip(_MonadicParser.notFollowedBy(x));
  }
  desc(expected) {
    return new _MonadicParser((input, i) => {
      const reply = this._(input, i);
      if (!reply.status) {
        reply.expected = [expected];
      }
      return reply;
    });
  }
  fallback(result) {
    return this.or(_MonadicParser.succeed(result));
  }
  ap(other) {
    return _MonadicParser.seq(other, this).map(([f, x]) => f(x));
  }
  chain(f) {
    return new _MonadicParser((input, i) => {
      const result = this._(input, i);
      if (!result.status) {
        return result;
      }
      const nextParser = f(result.value);
      return mergeReplies(nextParser._(input, result.index), result);
    });
  }
};
(function(MonadicParser2) {
  function seqMap(a5, b5, c5) {
    const args = [].slice.call(arguments);
    if (args.length === 0) {
      throw new Error("seqMap needs at least one argument");
    }
    const mapper = args.pop();
    assertFunction(mapper);
    return seq.apply(null, args).map(function(results) {
      return mapper.apply(null, results);
    });
  }
  MonadicParser2.seqMap = seqMap;
  function createLanguage(parsers) {
    const language = {};
    for (const key2 of Object.keys(parsers)) {
      (function(key3) {
        language[key3] = lazy(() => parsers[key3](language));
      })(key2);
    }
    return language;
  }
  MonadicParser2.createLanguage = createLanguage;
  function seq(...parsers) {
    const numParsers = parsers.length;
    return new MonadicParser2((input, index) => {
      let result;
      const accum = new Array(numParsers);
      let i = index;
      for (let j = 0; j < numParsers; j++) {
        result = mergeReplies(parsers[j]._(input, i), result);
        if (!result.status) {
          return result;
        }
        accum[j] = result.value;
        i = result.index;
      }
      return mergeReplies(makeSuccess(i, accum), result);
    });
  }
  MonadicParser2.seq = seq;
  function alt(...parsers) {
    const numParsers = parsers.length;
    if (numParsers === 0) {
      return fail("zero alternates");
    }
    return new MonadicParser2((input, i) => {
      let result;
      for (let j = 0; j < parsers.length; j++) {
        result = mergeReplies(parsers[j]._(input, i), result);
        if (result.status) {
          return result;
        }
      }
      return result;
    });
  }
  MonadicParser2.alt = alt;
  function sepBy(parser, separator) {
    return sepBy1(parser, separator).or(succeed([]));
  }
  MonadicParser2.sepBy = sepBy;
  function sepBy1(parser, separator) {
    const pairs2 = separator.then(parser).many();
    return seq(parser, pairs2).map((r) => [r[0], ...r[1]]);
  }
  MonadicParser2.sepBy1 = sepBy1;
  function string(str3) {
    const expected = `'${str3}'`;
    if (str3.length === 1) {
      const code = str3.charCodeAt(0);
      return new MonadicParser2((input, i) => input.charCodeAt(i) === code ? makeSuccess(i + 1, str3) : makeFailure(i, expected));
    }
    return new MonadicParser2((input, i) => {
      const j = i + str3.length;
      if (input.slice(i, j) === str3)
        return makeSuccess(j, str3);
      else
        return makeFailure(i, expected);
    });
  }
  MonadicParser2.string = string;
  function flags(re) {
    const s = "" + re;
    return s.slice(s.lastIndexOf("/") + 1);
  }
  function anchoredRegexp(re) {
    return RegExp("^(?:" + re.source + ")", flags(re));
  }
  function regexp(re, group = 0) {
    const anchored = anchoredRegexp(re);
    const expected = "" + re;
    return new MonadicParser2((input, i) => {
      const match = anchored.exec(input.slice(i));
      if (match) {
        if (0 <= group && group <= match.length) {
          const fullMatch = match[0];
          const groupMatch = match[group];
          return makeSuccess(i + fullMatch.length, groupMatch);
        }
        const message = `invalid match group (0 to ${match.length}) in ${expected}`;
        return makeFailure(i, message);
      }
      return makeFailure(i, expected);
    });
  }
  MonadicParser2.regexp = regexp;
  function succeed(value) {
    return new MonadicParser2((input, i) => makeSuccess(i, value));
  }
  MonadicParser2.succeed = succeed;
  function fail(expected) {
    return new MonadicParser2((input, i) => makeFailure(i, expected));
  }
  MonadicParser2.fail = fail;
  function lookahead(x) {
    if (isParser(x)) {
      return new MonadicParser2((input, i) => {
        const result = x._(input, i);
        if (result.status) {
          result.index = i;
          result.value = null;
        }
        return result;
      });
    } else if (typeof x === "string") {
      return lookahead(string(x));
    } else if (x instanceof RegExp) {
      return lookahead(regexp(x));
    }
    throw new Error("not a string, regexp, or parser: " + x);
  }
  MonadicParser2.lookahead = lookahead;
  function notFollowedBy(parser) {
    return new MonadicParser2((input, i) => {
      const result = parser._(input, i);
      return result.status ? makeFailure(i, 'not "' + input.slice(i, result.index) + '"') : makeSuccess(i, null);
    });
  }
  MonadicParser2.notFollowedBy = notFollowedBy;
  function test(predicate) {
    return new MonadicParser2((input, i) => {
      const char = input.charAt(i);
      if (i < input.length && predicate(char)) {
        return makeSuccess(i + 1, char);
      } else {
        return makeFailure(i, "a character " + predicate);
      }
    });
  }
  MonadicParser2.test = test;
  function oneOf(str3) {
    return test((ch) => str3.indexOf(ch) >= 0);
  }
  MonadicParser2.oneOf = oneOf;
  function noneOf(str3) {
    return test((ch) => str3.indexOf(ch) < 0);
  }
  MonadicParser2.noneOf = noneOf;
  function range2(begin, end) {
    return test((ch) => begin <= ch && ch <= end).desc(begin + "-" + end);
  }
  MonadicParser2.range = range2;
  function takeWhile3(predicate) {
    return new MonadicParser2((input, i) => {
      let j = i;
      while (j < input.length && predicate(input.charAt(j))) {
        j++;
      }
      return makeSuccess(j, input.slice(i, j));
    });
  }
  MonadicParser2.takeWhile = takeWhile3;
  function lazy(f) {
    const parser = new MonadicParser2((input, i) => {
      const a5 = f()._;
      parser._ = a5;
      return a5(input, i);
    });
    return parser;
  }
  MonadicParser2.lazy = lazy;
  function empty2() {
    return fail("empty");
  }
  MonadicParser2.empty = empty2;
  MonadicParser2.index = new MonadicParser2(function(input, i) {
    return makeSuccess(i, makeLineColumnIndex(input, i));
  });
  MonadicParser2.anyChar = new MonadicParser2((input, i) => {
    if (i >= input.length) {
      return makeFailure(i, "any character");
    }
    return makeSuccess(i + 1, input.charAt(i));
  });
  MonadicParser2.all = new MonadicParser2(function(input, i) {
    return makeSuccess(input.length, input.slice(i));
  });
  MonadicParser2.eof = new MonadicParser2(function(input, i) {
    if (i < input.length) {
      return makeFailure(i, "EOF");
    }
    return makeSuccess(i, null);
  });
  MonadicParser2.digit = regexp(/[0-9]/).desc("a digit");
  MonadicParser2.digits = regexp(/[0-9]*/).desc("optional digits");
  MonadicParser2.letter = regexp(/[a-z]/i).desc("a letter");
  MonadicParser2.letters = regexp(/[a-z]*/i).desc("optional letters");
  MonadicParser2.optWhitespace = regexp(/\s*/).desc("optional whitespace");
  MonadicParser2.whitespace = regexp(/\s+/).desc("whitespace");
  MonadicParser2.cr = string("\r");
  MonadicParser2.lf = string("\n");
  MonadicParser2.crlf = string("\r\n");
  MonadicParser2.newline = alt(MonadicParser2.crlf, MonadicParser2.lf, MonadicParser2.cr).desc("newline");
  MonadicParser2.end = alt(MonadicParser2.newline, MonadicParser2.eof);
  function of2(value) {
    return succeed(value);
  }
  MonadicParser2.of = of2;
  function regex(re) {
    return regexp(re);
  }
  MonadicParser2.regex = regex;
})(MonadicParser || (MonadicParser = {}));
function seqPick(idx, ...parsers) {
  const numParsers = parsers.length;
  return new MonadicParser((input, index) => {
    let result;
    let picked;
    let i = index;
    for (let j = 0; j < numParsers; j++) {
      result = mergeReplies(parsers[j]._(input, i), result);
      if (!result.status) {
        return result;
      }
      if (idx === j)
        picked = result.value;
      i = result.index;
    }
    return mergeReplies(makeSuccess(i, picked), result);
  });
}
function makeSuccess(index, value) {
  return { status: true, index, value };
}
function makeFailure(index, expected) {
  return { status: false, furthest: index, expected: [expected] };
}
function mergeReplies(result, last5) {
  if (!last5 || result.status || last5.status || result.furthest > last5.furthest) {
    return result;
  }
  const expected = result.furthest === last5.furthest ? unsafeUnion(result.expected, last5.expected) : last5.expected;
  return { status: result.status, furthest: last5.furthest, expected };
}
function makeLineColumnIndex(input, i) {
  const lines = input.slice(0, i).split("\n");
  const lineWeAreUpTo = lines.length;
  const columnWeAreUpTo = lines[lines.length - 1].length + 1;
  return { offset: i, line: lineWeAreUpTo, column: columnWeAreUpTo };
}
function formatExpected(expected) {
  if (expected.length === 1) {
    return expected[0];
  }
  return "one of " + expected.join(", ");
}
function formatGot(input, error) {
  const index = error.index;
  const i = index.offset;
  if (i === input.length) {
    return ", got the end of the input";
  }
  const prefix2 = i > 0 ? "'..." : "'";
  const suffix = input.length - i > 12 ? "...'" : "'";
  return ` at line ${index.line} column ${index.column}, got ${prefix2}${input.slice(i, i + 12)}${suffix}`;
}
function formatError(input, error) {
  return `expected ${formatExpected(error.expected)}${formatGot(input, error)}`;
}
function unsafeUnion(xs, ys) {
  const xn = xs.length;
  const yn = ys.length;
  if (xn === 0)
    return ys;
  else if (yn === 0)
    return xs;
  const set4 = /* @__PURE__ */ new Set();
  const ret = [];
  for (let i = 0; i < xn; i++) {
    if (!set4.has(xs[i])) {
      ret[ret.length] = xs[i];
      set4.add(xs[i]);
    }
  }
  for (let i = 0; i < yn; i++) {
    if (!set4.has(ys[i])) {
      ret[ret.length] = ys[i];
      set4.add(ys[i]);
    }
  }
  ret.sort();
  return ret;
}
function isParser(obj) {
  return obj instanceof MonadicParser;
}
function assertFunction(x) {
  if (typeof x !== "function") {
    throw new Error("not a function: " + x);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/language/parser.js
function parseMolScript(input) {
  return Language.parse(input);
}
var Language;
(function(Language2) {
  let ASTNode;
  (function(ASTNode2) {
    function str3(value) {
      return { kind: "string", value };
    }
    ASTNode2.str = str3;
    function symb(value) {
      return { kind: "symbol", value };
    }
    ASTNode2.symb = symb;
    function list2(bracket, nodes) {
      return { kind: "list", bracket, nodes };
    }
    ASTNode2.list = list2;
    function comment(value) {
      return { kind: "comment", value };
    }
    ASTNode2.comment = comment;
  })(ASTNode || (ASTNode = {}));
  const ws = MonadicParser.regexp(/[\n\r\s]*/);
  const Expr = MonadicParser.lazy(() => MonadicParser.alt(Str, List4, Symb, Comment).trim(ws));
  const Str = MonadicParser.takeWhile((c5) => c5 !== "`").trim("`").map(ASTNode.str);
  const Symb = MonadicParser.regexp(/[^()\[\]{};`,\n\r\s]+/).map(ASTNode.symb);
  const Comment = MonadicParser.regexp(/\s*;+([^\n\r]*)\n/, 1).map(ASTNode.comment);
  const Args = Expr.many();
  const List1 = Args.wrap("(", ")").map((args) => ASTNode.list("(", args));
  const List2 = Args.wrap("[", "]").map((args) => ASTNode.list("[", args));
  const List3 = Args.wrap("{", "}").map((args) => ASTNode.list("{", args));
  const List4 = MonadicParser.alt(List1, List2, List3);
  const Expressions = Expr.many();
  function getAST(input) {
    return Expressions.tryParse(input);
  }
  function visitExpr(expr) {
    switch (expr.kind) {
      case "string":
        return expr.value;
      case "symbol": {
        const value = expr.value;
        if (value.length > 1) {
          const fst = value.charAt(0);
          switch (fst) {
            case ".":
              return MolScriptBuilder.atomName(value.substr(1));
            case "_":
              return MolScriptBuilder.struct.type.elementSymbol([value.substr(1)]);
          }
        }
        if (value === "true")
          return true;
        if (value === "false")
          return false;
        if (isNumber(value))
          return +value;
        return Expression.Symbol(value);
      }
      case "list": {
        switch (expr.bracket) {
          case "[":
            return MolScriptBuilder.core.type.list(withoutComments(expr.nodes).map(visitExpr));
          case "{":
            return MolScriptBuilder.core.type.set(withoutComments(expr.nodes).map(visitExpr));
          case "(": {
            if (expr.nodes[0].kind === "comment")
              throw new Error("Invalid expression");
            const head = visitExpr(expr.nodes[0]);
            return Expression.Apply(head, getArgs(expr.nodes));
          }
          default:
            assertUnreachable(expr.bracket);
        }
      }
      default:
        assertUnreachable(expr);
    }
  }
  function getArgs(nodes) {
    if (nodes.length <= 1)
      return void 0;
    if (!hasNamedArgs(nodes)) {
      const args2 = [];
      for (let i = 1, _i = nodes.length; i < _i; i++) {
        const n = nodes[i];
        if (n.kind === "comment")
          continue;
        args2[args2.length] = visitExpr(n);
      }
      return args2;
    }
    const args = {};
    let allNumeric = true;
    let pos = 0;
    for (let i = 1, _i = nodes.length; i < _i; i++) {
      const n = nodes[i];
      if (n.kind === "comment")
        continue;
      if (n.kind === "symbol" && n.value.length > 1 && n.value.charAt(0) === ":") {
        const name = n.value.substr(1);
        ++i;
        while (i < _i && nodes[i].kind === "comment") {
          i++;
        }
        if (i >= _i)
          throw new Error(`There must be a value foolowed a named arg ':${name}'.`);
        if (nodes[i].kind === "comment")
          throw new Error("Invalid expression");
        args[name] = visitExpr(nodes[i]);
        if (isNaN(+name))
          allNumeric = false;
      } else {
        args[pos++] = visitExpr(n);
      }
    }
    if (allNumeric) {
      const keys2 = Object.keys(args).map((a5) => +a5).sort((a5, b5) => a5 - b5);
      let isArray4 = true;
      for (let i = 0, _i = keys2.length; i < _i; i++) {
        if (keys2[i] !== i) {
          isArray4 = false;
          break;
        }
      }
      if (isArray4) {
        const arrayArgs = [];
        for (let i = 0, _i = keys2.length; i < _i; i++) {
          arrayArgs[i] = args[i];
        }
        return arrayArgs;
      }
    }
    return args;
  }
  function hasNamedArgs(nodes) {
    for (let i = 1, _i = nodes.length; i < _i; i++) {
      const n = nodes[i];
      if (n.kind === "symbol" && n.value.length > 1 && n.value.charAt(0) === ":")
        return true;
    }
    return false;
  }
  function withoutComments(nodes) {
    let hasComment = false;
    for (let i = 0, _i = nodes.length; i < _i; i++) {
      if (nodes[i].kind === "comment") {
        hasComment = true;
        break;
      }
    }
    if (!hasComment)
      return nodes;
    return nodes.filter((n) => n.kind !== "comment");
  }
  function isNumber(value) {
    return /-?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?/.test(value) && !isNaN(+value);
  }
  function parse4(input) {
    const ast = getAST(input);
    const ret = [];
    for (const expr of ast) {
      if (expr.kind === "comment")
        continue;
      ret[ret.length] = visitExpr(expr);
    }
    return ret;
  }
  Language2.parse = parse4;
})(Language || (Language = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/helper.js
var B = MolScriptBuilder;
function prefix(opParser, nextParser, mapFn) {
  const parser = MonadicParser.lazy(() => {
    return MonadicParser.seq(opParser, parser).map((x) => mapFn(...x)).or(nextParser);
  });
  return parser;
}
function postfix(opParser, nextParser, mapFn) {
  return MonadicParser.seqMap(nextParser, opParser.many(), (x, suffixes) => suffixes.reduce((acc, x2) => {
    return mapFn(x2, acc);
  }, x));
}
function binaryLeft(opParser, nextParser, mapFn) {
  return MonadicParser.seqMap(nextParser, MonadicParser.seq(opParser, nextParser).many(), (first4, rest2) => {
    return rest2.reduce((acc, ch) => {
      const [op2, another] = ch;
      return mapFn(op2, acc, another);
    }, first4);
  });
}
function combineOperators(opList, rule) {
  const x = opList.reduce((acc, level) => {
    const map3 = level.isUnsupported ? makeError(`operator '${level.name}' not supported`) : level.map;
    return level.type(level.rule, acc, map3);
  }, rule);
  return x;
}
function infixOp(re, group = 0) {
  return MonadicParser.optWhitespace.then(MonadicParser.regexp(re, group).skip(MonadicParser.optWhitespace));
}
function prefixOp(re, group = 0) {
  return MonadicParser.regexp(re, group).skip(MonadicParser.optWhitespace);
}
function postfixOp(re, group = 0) {
  return MonadicParser.optWhitespace.then(MonadicParser.regexp(re, group));
}
function ofOp(name, short) {
  const op2 = short ? `${name}|${escapeRegExp(short)}` : name;
  const re = RegExp(`(${op2})\\s+([-+]?[0-9]*\\.?[0-9]+)\\s+OF`, "i");
  return infixOp(re, 2).map(parseFloat);
}
function makeError(msg) {
  return function() {
    throw new Error(msg);
  };
}
function andExpr(selections) {
  if (selections.length === 1) {
    return selections[0];
  } else if (selections.length > 1) {
    return B.core.logic.and(selections);
  } else {
    return void 0;
  }
}
function orExpr(selections) {
  if (selections.length === 1) {
    return selections[0];
  } else if (selections.length > 1) {
    return B.core.logic.or(selections);
  } else {
    return void 0;
  }
}
function testExpr(property, args) {
  if (args && args.op !== void 0 && args.val !== void 0) {
    const opArgs = [property, args.val];
    switch (args.op) {
      case "=":
        return B.core.rel.eq(opArgs);
      case "!=":
        return B.core.rel.neq(opArgs);
      case ">":
        return B.core.rel.gr(opArgs);
      case "<":
        return B.core.rel.lt(opArgs);
      case ">=":
        return B.core.rel.gre(opArgs);
      case "<=":
        return B.core.rel.lte(opArgs);
      default:
        throw new Error(`operator '${args.op}' not supported`);
    }
  } else if (args && args.flags !== void 0) {
    return B.core.flags.hasAny([property, args.flags]);
  } else if (args && args.min !== void 0 && args.max !== void 0) {
    return B.core.rel.inRange([property, args.min, args.max]);
  } else if (!Array.isArray(args)) {
    return B.core.rel.eq([property, args]);
  } else if (args.length > 1) {
    return B.core.set.has([B.core.type.set(args), property]);
  } else {
    return B.core.rel.eq([property, args[0]]);
  }
}
function invertExpr(selection) {
  return B.struct.generator.queryInSelection({
    0: selection,
    query: B.struct.generator.all(),
    "in-complement": true
  });
}
function strLenSortFn(a5, b5) {
  return a5.length < b5.length ? 1 : -1;
}
function getNamesRegex(name, abbr) {
  const names = (abbr ? [name].concat(abbr) : [name]).sort(strLenSortFn).map(escapeRegExp).join("|");
  return RegExp(`${names}`, "i");
}
function getPropertyRules(properties4) {
  const propertiesDict2 = {};
  Object.keys(properties4).sort(strLenSortFn).forEach((name) => {
    const ps = properties4[name];
    const errorFn = makeError(`property '${name}' not supported`);
    const rule = MonadicParser.regexp(ps.regex).map((x) => {
      if (ps.isUnsupported)
        errorFn();
      return testExpr(ps.property, ps.map(x));
    });
    if (!ps.isNumeric) {
      propertiesDict2[name] = rule;
    }
  });
  return propertiesDict2;
}
function getNamedPropertyRules(properties4) {
  const namedPropertiesList = [];
  Object.keys(properties4).sort(strLenSortFn).forEach((name) => {
    const ps = properties4[name];
    const errorFn = makeError(`property '${name}' not supported`);
    const rule = MonadicParser.regexp(ps.regex).map((x) => {
      if (ps.isUnsupported)
        errorFn();
      return testExpr(ps.property, ps.map(x));
    });
    const nameRule = MonadicParser.regexp(getNamesRegex(name, ps.abbr)).trim(MonadicParser.optWhitespace);
    const groupMap = (x) => B.struct.generator.atomGroups({ [ps.level]: x });
    if (ps.isNumeric) {
      namedPropertiesList.push(nameRule.then(MonadicParser.seq(MonadicParser.regexp(/>=|<=|=|!=|>|</).trim(MonadicParser.optWhitespace), MonadicParser.regexp(ps.regex).map(ps.map))).map((x) => {
        if (ps.isUnsupported)
          errorFn();
        return testExpr(ps.property, { op: x[0], val: x[1] });
      }).map(groupMap));
    } else {
      namedPropertiesList.push(nameRule.then(rule).map(groupMap));
    }
  });
  return namedPropertiesList;
}
function getKeywordRules(keywords4) {
  const keywordsList = [];
  Object.keys(keywords4).sort(strLenSortFn).forEach((name) => {
    const ks = keywords4[name];
    const mapFn = ks.map ? ks.map : makeError(`keyword '${name}' not supported`);
    const rule = MonadicParser.regexp(getNamesRegex(name, ks.abbr)).map(mapFn);
    keywordsList.push(rule);
  });
  return keywordsList;
}
function getFunctionRules(functions2, argRule) {
  const functionsList = [];
  const begRule = MonadicParser.regexp(/\(\s*/);
  const endRule = MonadicParser.regexp(/\s*\)/);
  Object.keys(functions2).sort(strLenSortFn).forEach((name) => {
    const fs = functions2[name];
    const mapFn = fs.map ? fs.map : makeError(`function '${name}' not supported`);
    const rule = MonadicParser.regexp(new RegExp(name, "i")).skip(begRule).then(argRule).skip(endRule).map(mapFn);
    functionsList.push(rule);
  });
  return functionsList;
}
function getPropertyNameRules(properties4, lookahead) {
  const list2 = [];
  Object.keys(properties4).sort(strLenSortFn).forEach((name) => {
    const ps = properties4[name];
    const errorFn = makeError(`property '${name}' not supported`);
    const rule = MonadicParser.regexp(getNamesRegex(name, ps.abbr)).lookahead(lookahead).map(() => {
      if (ps.isUnsupported)
        errorFn();
      return ps.property;
    });
    list2.push(rule);
  });
  return list2;
}
function getReservedWords(properties4, keywords4, operators4, functions2) {
  const w = [];
  for (const name in properties4) {
    w.push(name);
    if (properties4[name].abbr)
      w.push(...properties4[name].abbr);
  }
  for (const name in keywords4) {
    w.push(name);
    if (keywords4[name].abbr)
      w.push(...keywords4[name].abbr);
  }
  operators4.forEach((o) => {
    w.push(o.name);
    if (o.abbr)
      w.push(...o.abbr);
  });
  return w;
}
function atomNameSet(ids) {
  return B.core.type.set(ids.map(B.atomName));
}
function asAtoms(e) {
  return B.struct.generator.queryInSelection({
    0: e,
    query: B.struct.generator.all()
  });
}
function wrapValue(property, value, sstrucDict3) {
  switch (property.head.name) {
    case "structure-query.atom-property.macromolecular.label_atom_id":
      return B.atomName(value);
    case "structure-query.atom-property.core.element-symbol":
      return B.es(value);
    case "structure-query.atom-property.macromolecular.secondary-structure-flags":
      if (sstrucDict3) {
        value = [sstrucDict3[value.toUpperCase()] || "none"];
      }
      return B.struct.type.secondaryStructureFlags([value]);
    default:
      return value;
  }
}
var propPrefix = "structure-query.atom-property.macromolecular.";
var entityProps = ["entityKey", "label_entity_id", "entityType"];
var chainProps = ["chainKey", "label_asym_id", "label_entity_id", "auth_asym_id", "entityType"];
var residueProps = ["residueKey", "label_comp_id", "label_seq_id", "auth_comp_id", "auth_seq_id", "pdbx_formal_charge", "secondaryStructureKey", "secondaryStructureFlags", "isModified", "modifiedParentName"];
function testLevel(property) {
  if (property.head.name.startsWith(propPrefix)) {
    const name = property.head.name.substr(propPrefix.length);
    if (entityProps.includes(name))
      return "entity-test";
    if (chainProps.includes(name))
      return "chain-test";
    if (residueProps.includes(name))
      return "residue-test";
  }
  return "atom-test";
}
var flagProps = [
  "structure-query.atom-property.macromolecular.secondary-structure-flags"
];
function valuesTest(property, values2) {
  if (flagProps.includes(property.head.name)) {
    const name = values2[0].head;
    const flags = [];
    values2.forEach((v3) => flags.push(...v3.args[0]));
    return B.core.flags.hasAny([property, { head: name, args: flags }]);
  } else {
    if (values2.length === 1) {
      return B.core.rel.eq([property, values2[0]]);
    } else if (values2.length > 1) {
      return B.core.set.has([B.core.type.set(values2), property]);
    }
  }
}
function resnameExpr(resnameList) {
  return B.struct.generator.atomGroups({
    "residue-test": B.core.set.has([
      B.core.type.set(resnameList),
      B.ammp("label_comp_id")
    ])
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/jmol/properties.js
var B2 = MolScriptBuilder;
var reFloat = /[-+]?[0-9]*\.?[0-9]+/;
var rePosInt = /[0-9]+/;
function str(x) {
  return x;
}
var structureDict = {
  none: "none",
  turn: "turn",
  sheet: "beta",
  helix: "helix",
  dna: "dna",
  rna: "rna",
  carbohydrate: "carbohydrate",
  helix310: "3-10",
  helixalpha: "alpha",
  helixpi: "pi",
  0: "none",
  1: "turn",
  2: "beta",
  3: "helix",
  4: "dna",
  5: "rna",
  6: "carbohydrate",
  7: "3-10",
  8: "alpha",
  9: "pi"
};
function structureMap(x) {
  if (x.head) {
    if (x.head.name && x.head.name === "core.type.regex")
      x = x.args[0].replace(/^\^|\$$/g, "");
    x = structureDict[x.toString().toLowerCase()] || "none";
    if (["dna", "rna", "carbohydrate"].indexOf(x) !== -1) {
      throw new Error("values 'dna', 'rna', 'carbohydrate' not yet supported for 'structure' property");
    } else {
      return B2.struct.type.secondaryStructureFlags([x]);
    }
  }
}
var properties = {
  adpmax: {
    "@desc": "the maximum anisotropic displacement parameter for the selected atom",
    "@examples": [""],
    isUnsupported: true,
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test"
  },
  adpmin: {
    "@desc": "the minimum anisotropic displacement parameter for the selected atom",
    "@examples": [""],
    isUnsupported: true,
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test"
  },
  altloc: {
    "@desc": "PDB alternate location identifier",
    "@examples": ["altloc = A"],
    regex: /[a-zA-Z0-9]/,
    map: str,
    level: "atom-test",
    property: B2.ammp("label_alt_id")
  },
  altname: {
    "@desc": "an alternative name given to atoms by some file readers (for example, P2N)",
    "@examples": [""],
    isUnsupported: true,
    regex: /[a-zA-Z0-9]/,
    map: str,
    level: "atom-test"
  },
  atomID: {
    "@desc": "special atom IDs for PDB atoms assigned by Jmol",
    "@examples": [""],
    isUnsupported: true,
    regex: rePosInt,
    map: (x) => parseInt(x),
    level: "atom-test"
  },
  atomIndex: {
    "@desc": "atom 0-based index; a unique number for each atom regardless of the number of models loaded",
    "@examples": [""],
    isUnsupported: true,
    regex: rePosInt,
    map: (x) => parseInt(x),
    level: "atom-test"
  },
  atomName: {
    "@desc": "atom name",
    "@examples": ["atomName = CA"],
    regex: /[a-zA-Z0-9]+/,
    map: (v3) => B2.atomName(v3),
    level: "atom-test",
    property: B2.ammp("label_atom_id")
  },
  atomno: {
    "@desc": 'sequential number; you can use "@" instead of "atomno=" -- for example, select @33 or Var x = @33 or @35',
    "@examples": [""],
    isUnsupported: true,
    regex: rePosInt,
    map: (x) => parseInt(x),
    level: "atom-test"
  },
  atomType: {
    "@desc": "atom type (mol2, AMBER files) or atom name (other file types)",
    "@examples": ["atomType = OH"],
    regex: /[a-zA-Z0-9]+/,
    map: (v3) => B2.atomName(v3),
    level: "atom-test",
    property: B2.ammp("label_atom_id")
  },
  atomX: {
    "@desc": "Cartesian X coordinate (or just X)",
    "@examples": ["x = 4.2"],
    abbr: ["X"],
    isNumeric: true,
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B2.acp("x")
  },
  atomY: {
    "@desc": "Cartesian Y coordinate (or just Y)",
    "@examples": ["y < 42"],
    abbr: ["Y"],
    isNumeric: true,
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B2.acp("y")
  },
  atomZ: {
    "@desc": "Cartesian Z coordinate (or just Z)",
    "@examples": ["Z > 10"],
    abbr: ["Z"],
    isNumeric: true,
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B2.acp("z")
  },
  bondcount: {
    "@desc": "covalent bond count",
    "@examples": ["bondcount = 0"],
    isNumeric: true,
    regex: rePosInt,
    map: (x) => parseInt(x),
    level: "atom-test",
    property: B2.acp("bondCount")
  },
  bondingRadius: {
    "@desc": "radius used for auto bonding; synonymous with ionic and ionicRadius",
    "@examples": [""],
    abbr: ["ionic", "ionicRadius"],
    isUnsupported: true,
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test"
  },
  cell: {
    "@desc": 'crystallographic unit cell, expressed either in lattice integer notation (111-999) or as a coordinate in ijk space, where {1 1 1} is the same as 555. ANDing two cells, for example select cell=555 and cell=556, selects the atoms on the common face. (Note: in the specifc case of CELL, only "=" is allowed as a comparator.)',
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  configuration: {
    "@desc": 'Only in the context {configuration=n}, this option selects the set of atoms with either no ALTLOC specified or those atoms having this index into the array of altlocs within its model. So, for example, if the model has altloc "A" and "B", select configuration=1 is equivalent to select altloc="" or altloc="A", and print {configuration=2} is equivalent to print {altloc="" or altloc="B"}. Configuration 0 is "all atoms in a model having configurations", and an invalid configuration number gives no atoms. (Note: in the specifc case of CONFIGURATION, only "=" is allowed as a comparator.)',
    "@examples": [""],
    isUnsupported: true,
    regex: rePosInt,
    map: (x) => parseInt(x),
    level: "atom-test"
  },
  chain: {
    "@desc": 'protein chain. For newer CIF files allowing multicharacter chain specifications, use quotations marks: select chain="AA". For these multicharacter desigations, case is not checked unless the CIF file has lower-case chain designations.',
    "@examples": ["chain = A", 'chain = "AA"'],
    regex: /[a-zA-Z0-9]+/,
    map: str,
    level: "chain-test",
    property: B2.ammp("auth_asym_id")
  },
  chainNo: {
    "@desc": 'chain number; sequentially counted from 1 for each model; chainNo == 0 means"no chain" or PDB chain identifier indicated as a blank (Jmol 14.0).',
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  color: {
    "@desc": "the atom color",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  covalentRadius: {
    "@desc": "covalent bonding radius, synonymous with covalent. Not used by Jmol, but could be used, for example, in {*}.spacefill={*}.covalentRadius.all.",
    "@examples": [""],
    abbr: ["covalent"],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  cs: {
    "@desc": "chemical shift calculated using computational results that include magnetic shielding tensors.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  element: {
    "@desc": 'element symbol. The value of this parameter depends upon the context. Used with select structure=x, x can be either the quoted element symbol, "H", "He", "Li", etc. or atomic number. In all other contexts, the value is the element symbol. When the atom is a specific isotope, the string will contain the isotope number -- "13C", for example.',
    "@examples": ["element=Fe"],
    regex: /[a-zA-Z]+/,
    map: (x) => B2.es(x),
    level: "atom-test",
    property: B2.acp("elementSymbol")
  },
  elemno: {
    "@desc": "atomic element number",
    "@examples": ["elemno=8"],
    regex: /[0-9\s{}-]+/,
    map: (x) => parseInt(x),
    level: "atom-test",
    property: B2.acp("atomicNumber")
  },
  eta: {
    "@desc": `Based on Carlos M. Duarte, Leven M. Wadley, and Anna Marie Pyle, RNA structure comparison, motif search and discovery using a reduced representation of RNA conformational space, Nucleic Acids Research, 2003, Vol. 31, No. 16 4755-4761. The parameter eta is the C4'[i-1]-P[i]-C4'[i]-P[i+1] dihedral angle; theta is the P[i]-C4'[i]-P[i+1]-C4'[i+1] dihedral angle. Both are measured on a 0-360 degree scale because they are commonly near 180 degrees. Using the commands plot PROPERTIES eta theta resno; select visible;wireframe only one can create these authors' "RNA worm" graph.`,
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  theta: {
    "@desc": `Based on Carlos M. Duarte, Leven M. Wadley, and Anna Marie Pyle, RNA structure comparison, motif search and discovery using a reduced representation of RNA conformational space, Nucleic Acids Research, 2003, Vol. 31, No. 16 4755-4761. The parameter eta is the C4'[i-1]-P[i]-C4'[i]-P[i+1] dihedral angle; theta is the P[i]-C4'[i]-P[i+1]-C4'[i+1] dihedral angle. Both are measured on a 0-360 degree scale because they are commonly near 180 degrees. Using the commands plot PROPERTIES eta theta resno; select visible;wireframe only one can create these authors' "RNA worm" graph.`,
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  file: {
    "@desc": "file number containing this atom",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  formalCharge: {
    "@desc": "formal charge",
    "@examples": ["formalCharge=1"],
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B2.ammp("pdbx_formal_charge")
  },
  format: {
    "@desc": "format (label) of the atom.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  fXyz: {
    "@desc": "fractional XYZ coordinates",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  fX: {
    "@desc": "fractional X coordinate",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  fY: {
    "@desc": "fractional Y coordinate",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  fZ: {
    "@desc": "fractional Z coordinate",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  fuxyz: {
    "@desc": "fractional XYZ coordinates in the unitcell coordinate system",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  fux: {
    "@desc": "fractional X coordinate in the unitcell coordinate system",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  fuy: {
    "@desc": "fractional Y coordinate in the unitcell coordinate system",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  fuz: {
    "@desc": "fractional Z coordinate in the unit cell coordinate system",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  group: {
    "@desc": "3-letter residue code",
    "@examples": ["group = ALA"],
    regex: /[a-zA-Z0-9]{1,3}/,
    map: str,
    level: "residue-test",
    property: B2.ammp("label_comp_id")
  },
  group1: {
    "@desc": "single-letter residue code (amino acids only)",
    "@examples": ["group1 = G"],
    regex: /[a-zA-Z]/,
    map: str,
    level: "residue-test",
    property: B2.ammp("label_comp_id")
  },
  groupID: {
    "@desc": "group ID number: A unique ID for each amino acid or nucleic acid residue in a PDB file. 0  noGroup 1-5  ALA, ARG, ASN, ASP, CYS 6-10  GLN, GLU, GLY, HIS, ILE 11-15  LEU, LYS, MET, PHE, PRO 16-20  SER, THR, TRP, TYR, VAL 21-23  ASX, GLX, UNK 24-29  A, +A, G, +G, I, +I 30-35  C, +C, T, +T, U, +U Additional unique numbers are assigned arbitrarily by Jmol and cannot be used reproducibly.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  groupindex: {
    "@desc": "overall group index",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  hydrophobicity: {
    "@desc": "Aminoacid residue scale of hydrophobicity based on Rose, G. D., Geselowitz, A. R., Lesser, G. J., Lee, R. H., and Zehfus, M. H. (1985). Hydrophobicity of amino acid residues in globular proteins, Science, 229(4716):834-838.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  identify: {
    "@desc": "for a PDB/mmCIF file, a label such as [ILE]7^1:A.CD1%A/3 #47, which includes the group ([ILE]), residue number with optional insertion code (7^1), chain (:A), atom name (CD1), alternate location if present (%A), PDB model number (/3, for NMR models when one file is loaded; /file.model such as /2.3 if more than one file is loaded), and atom number (#47). For non-PDB data, the information is shorter -- for example, H15/2.1 #6, indicating atom name (H15), full file.model number (/2.1), and atom number (#6). If only a single model is loaded, %[identify] does not include the model number.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  insertion: {
    "@desc": "protein residue insertion code",
    "@examples": ["insertion=A"],
    regex: /[a-zA-Z0-9]/,
    map: str,
    level: "atom-test",
    property: B2.ammp("pdbx_PDB_ins_code")
  },
  label: {
    "@desc": "current atom label (same as format)",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  mass: {
    "@desc": "atomic mass -- especially useful with appended .max or .sum",
    "@examples": ["mass > 13"],
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B2.acp("mass")
  },
  model: {
    "@desc": "model number",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  modelindex: {
    "@desc": "a unique number for each model, starting with 0 and spanning all models in all files",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  modO: {
    "@desc": "currently calculated occupancy from modulation (0 to 100; NaN if atom has no occupancy modulation)",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  modXYZ: {
    "@desc": "currently calculated displacement modulation (for incommensurately modulated structures). Also modX, modY, modZ for individual components. For atoms without modultion, {xx}.modXYZ is -1 and {xx}.modX is NaN, and in a label %[modXYZ] and %[modX] are blank.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  molecule: {
    "@desc": "molecule number",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  monomer: {
    "@desc": "monomer number (group number) in a polymer (usually a chain), starting with 1, or 0 if not part of a biopolymer -- that is, not a connected carbohydrate, amino acid, or nucleic acid (Jmol 14.3.15)",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  ms: {
    "@desc": "magnetic shielding calculated from file-loaded tensors.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  occupancy: {
    "@desc": 'CIF file site occupancy. In SELECT command comparisons ("select occupancy < 90"), an integer n implies measurement on a 0-100 scale; also, in the context %[occupancy] or %q for a label, the reported number is a percentage. In all other cases, such as when %Q is used in a label or when a decimal number is used in a comparison, the scale is 0.0 - 1.0.',
    "@examples": ["occupancy < 1"],
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B2.ammp("occupancy")
  },
  partialCharge: {
    "@desc": "partial charge",
    "@examples": [""],
    isUnsupported: true,
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test"
  },
  phi: {
    "@desc": "protein group PHI angle for atom's residue",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  polymer: {
    "@desc": "sequential polymer number in a model, starting with 1.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  polymerLength: {
    "@desc": "polymer length",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  property_xx: {
    "@desc": "a property created using the DATA command",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  psi: {
    "@desc": "protein group PSI angle for the atom's residue",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  radius: {
    "@desc": 'currently displayed radius -- In SELECT command comparisons ("select radius=n"), integer n implies Rasmol units 1/250 Angstroms; in all other cases or when a decimal number is used, the units are Angstroms.',
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  resno: {
    "@desc": "PDB residue number, not including insertion code (see also seqcode, below)",
    "@examples": ["resno = 100"],
    regex: /-?[0-9]+/,
    map: (x) => parseInt(x),
    level: "residue-test",
    property: B2.ammp("auth_seq_id")
  },
  selected: {
    "@desc": "1.0 if atom is selected; 0.0 if not",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  sequence: {
    "@desc": 'PDB one-character sequence code, as a string of characters, with "?" indicated where single-character codes are not available',
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  seqcode: {
    "@desc": 'PDB residue number, including insertion code (for example, 234^2; "seqcode" option added in Jmol 14.3.16)',
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  seqid: {
    "@desc": "(mmCIF only) the value from _atom_site.label_seq_id; a pointer to _entity_poly_seq.num in the ENTITY_POLY_SEQ category specifying the sequence of monomers in a polymer. Allowance is made for the possibility of microheterogeneity in a sample by allowing a given sequence number to be correlated with more than one monomer id. (Jmol 14.2.3)",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  shape: {
    "@desc": 'hybridization geometry such as "tetrahedral"',
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  site: {
    "@desc": "crystallographic site number",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  spacefill: {
    "@desc": "currently displayed radius",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  straightness: {
    "@desc": 'quaternion-derived straightness (second derivative of the quaternion describing the orientation of the residue. This quantity will have different values depending upon the setting of quaternionFrame as "A" (alpha-carbon/phosphorus atom only), "C" (alpha-carbon/pyrimidine or purine base based), "P" (carbonyl-carbon peptide plane/phosphorus tetrahedron based), or "N" (amide-nitrogen based). The default is alpha-carbon based, which corresponds closely to the following combination of Ramachandran angles involving three consecutive residues i-1, i, and i+1: -psii-1 - phii + psii + phii+1.',
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  strucno: {
    "@desc": "a unique number for each helix, sheet, or turn in a model, starting with 1.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  structure: {
    "@desc": 'The value of this parameter depends upon the context. Used with select structure=x, x can be either the quoted keyword "none", "turn", "sheet", "helix", "dna", "rna", or "carbohydrate" or a respective number 0-6. In the context {*}.structure, the return value is a number; in the context label %[structure], the return is one of the six keywords.',
    "@examples": ['structure="helix"', "structure=3"],
    regex: /none|turn|sheet|helix|dna|rna|carbohydrate|[0-6]/i,
    map: str,
    level: "residue-test",
    property: "structure"
  },
  substructure: {
    "@desc": 'like structure, the value of this parameter depends upon the context. Used with select substructure=x, x can be either the quoted keyword "none", "turn", "sheet", "helix", "dna", "rna", "carbohydrate", "helix310", "helixalpha", or "helixpi", or the respective number 0-9. In the context {*}.substructure, the return value is a number; in the context label %[substructure], the return is one of the nine keywords.',
    "@examples": ['substructure = "alphahelix"', "substructure =9"],
    regex: /none|turn|sheet|helix|dna|rna|carbohydrate|helix310|helixalpha|helixpi|[0-9]/i,
    map: str,
    level: "residue-test",
    property: "structure"
  },
  surfacedistance: {
    "@desc": "A value related to the distance of an atom to a nominal molecular surface. 0 indicates at the surface. Positive numbers are minimum distances in Angstroms from the given atom to the surface.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  symop: {
    "@desc": 'the first symmetry operation code that generated this atom by Jmol; an integer starting with 1. See also symmetry, below. This operator is only present if the file contains space group information and the file was loaded using the {i, j, k} option so as to generate symmetry-based atoms. To select only the original atoms prior to application of symmetry, you can either use "SYMOP=n", where n is the symmetry operator corresponding to "x,y,z", or you can specify instead simply "NOT symmetry" the way you might specify "NOT hydrogen". Note that atoms in special positions will have multiple operator matches. These atoms can be selected using the keyword SPECIALPOSITION. The special form select SYMOP=nijk selects a specific translation of atoms from the given crystallographic symmetry operation. Comparators <, <=, >, >=, and != can be used and only apply to the ijk part of the designation. The ijk are relative, not absolute. Thus, symop=2555 selects for atoms that have been transformed by symop=2 but not subjected to any further translation. select symop=1555 is identical to select not symmetry. All other ijk are relative to these selections for 555. If the model was loaded using load "filename.cif" {444 666 1}, where the 1 indicates that all symmetry-generated atoms are to be packed within cell 555 and then translated to fill the other 26 specified cells, then select symop=3555 is nearly the same as select symop=3 and cell=555. (The difference being that cell=555 selects for all atoms that are on any edge of the cell, while symop=3555 does not.) However, the situation is different if instead the model was loaded using load "filename.cif" {444 666 0}, where the 0 indicates that symmetry-generated atoms are to be placed exactly where their symmetry operator would put them (x,-y,z being different then from x, 1-y, z). In that case, select symop=3555 is for all atoms that have been generated using symmetry operation 3 but have not had any additional translations applied to the x,y,z expression found in the CIF file. If, for example, symmetry operation 3 is -x,-y,-z, then load "filename.cif" {444 666 0} will place an atom originally at {1/2, 1/2, 1/2} at positions {-1/2, -1/2, -1/2} (symop=3555) and {-3/2, -3/2, -3/2} (symop=3444) and 24 other sites.',
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  symmetry: {
    "@desc": 'as "symmetry" or in a label as lower-case "o" gives list of crystallographic symmetry operators generating this atom with lattice designations,such as 3555; upper-case "%O" in a label gives a list without the lattice designations. See also symop, above.',
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  temperature: {
    "@desc": "yes  yes  temperature factor (B-factor)",
    "@examples": ["temperature >= 20"],
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B2.ammp("B_iso_or_equiv")
  },
  unitXyz: {
    "@desc": "unit cell XYZ coordinates",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  uX: {
    "@desc": "unit cell X coordinate normalized to [0,1)",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  uY: {
    "@desc": "unit cell Y coordinate normalized to [0,1)",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  uZ: {
    "@desc": "unit cell Z coordinate normalized to [0,1)",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  valence: {
    "@desc": "the valence of an atom (sum of bonds, where double bond counts as 2 and triple bond counts as 3",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  vanderwaals: {
    "@desc": "van der Waals radius",
    "@examples": ["vanderwaals >2"],
    regex: reFloat,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B2.acp("vdw")
  },
  vectorScale: {
    "@desc": "vibration vector scale",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  volume: {
    "@desc": "approximate van der Waals volume for this atom. Note, {*}.volume gives an average; use {*}.volume.sum to get total volume.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  vXyz: {
    "@desc": "vibration vector, or individual components as %vx %vy %vz. For atoms without vibration vectors, {xx}.vXyz is -1; in a label, %[vxyz] is blank.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  vX: {
    "@desc": "vibration vector X coordinate; for atoms without vibration vector, {xx}.vX is NaN (same for vY and vZ)",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  vY: {
    "@desc": "vibration vector Y coordinate",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  vZ: {
    "@desc": "vibration vector Z coordinate",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  },
  xyz: {
    "@desc": "Cartesian XYZ coordinates; select xyz > 1.0 selects atoms more than one Angstrom from the origin.",
    "@examples": [""],
    isUnsupported: true,
    regex: /[0-9\s{}-]+/,
    map: str,
    level: "atom-test"
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/jmol/operators.js
var B3 = MolScriptBuilder;
var operators = [
  {
    "@desc": "Selects atoms that are not included in s1.",
    "@examples": ["not ARG"],
    name: "not",
    type: prefix,
    rule: MonadicParser.alt(MonadicParser.regex(/NOT/i).skip(MonadicParser.whitespace), MonadicParser.string("!").skip(MonadicParser.optWhitespace)),
    map: (op2, selection) => invertExpr(selection)
  },
  {
    "@desc": "Selects atoms included in both s1 and s2.",
    "@examples": ["ASP and .CA"],
    name: "and",
    type: binaryLeft,
    rule: infixOp(/AND|&/i),
    map: (op2, selection, by) => B3.struct.modifier.intersectBy({ 0: selection, by })
  },
  {
    "@desc": "Selects atoms included in either s1 or s2.",
    "@examples": ["ASP or GLU"],
    name: "or",
    type: binaryLeft,
    rule: infixOp(/OR|\||,/i),
    map: (op2, s1, s2) => B3.struct.combinator.merge([s1, s2])
  }
];

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/jmol/keywords.js
var B4 = MolScriptBuilder;
var ResDict = {
  acidic: ["ASP", "GLU"],
  aliphatic: ["ALA", "GLY", "ILE", "LEU", "VAL"],
  amino: ["ALA", "ARG", "ASN", "ASP", "CYS", "GLN", "GLU", "GLY", "HIS", "ILE", "LEU", "LYS", "MET", "PHE", "PRO", "SER", "THR", "TRP", "TYR", "VAL", "ASX", "GLX", "UNK"],
  aromatic: ["HIS", "PHE", "TRP", "TYR"],
  basic: ["ARG", "HIS", "LYS"],
  buried: ["ALA", "CYS", "ILE", "LEU", "MET", "PHE", "TRP", "VAL"],
  cg: ["CYT", "C", "GUA", "G"],
  cyclic: ["HIS", "PHE", "PRO", "TRP", "TYR"],
  hydrophobic: ["ALA", "GLY", "ILE", "LEU", "MET", "PHE", "PRO", "TRP", "TYR", "VAL"],
  large: ["ARG", "GLU", "GLN", "HIS", "ILE", "LEU", "LYS", "MET", "PHE", "TRP", "TYR"],
  medium: ["ASN", "ASP", "CYS", "PRO", "THR", "VAL"],
  small: ["ALA", "GLY", "SER"],
  nucleic: ["G", "C", "A", "T", "U", "I", "DG", "DC", "DA", "DT", "DU", "DI", "+G", "+C", "+A", "+T", "+U", "+I"]
};
var Backbone = {
  nucleic: [
    "P",
    "O3'",
    "O5'",
    "C5'",
    "C4'",
    "C3'",
    "OP1",
    "OP2",
    "O3*",
    "O5*",
    "C5*",
    "C4*",
    "C3*",
    "C2'",
    "C1'",
    "O4'",
    "O2'"
  ],
  protein: ["C", "N", "CA"]
};
function nucleicExpr() {
  return B4.struct.combinator.merge([
    B4.struct.generator.atomGroups({
      "residue-test": B4.core.set.has([
        B4.set(...ResDict.nucleic),
        B4.ammp("label_comp_id")
      ])
    }),
    B4.struct.filter.pick({
      0: B4.struct.generator.atomGroups({
        "group-by": B4.ammp("residueKey")
      }),
      test: B4.core.logic.and([
        B4.core.rel.eq([B4.struct.atomSet.atomCount(), 1]),
        B4.core.rel.eq([B4.ammp("label_atom_id"), B4.atomName("P")])
      ])
    }),
    B4.struct.filter.pick({
      0: B4.struct.generator.atomGroups({
        "group-by": B4.ammp("residueKey")
      }),
      test: B4.core.logic.or([
        B4.core.set.isSubset([
          atomNameSet(["C1'", "C2'", "O3'", "C3'", "C4'", "C5'", "O5'"]),
          B4.ammpSet("label_atom_id")
        ]),
        B4.core.set.isSubset([
          atomNameSet(["C1*", "C2*", "O3*", "C3*", "C4*", "C5*", "O5*"]),
          B4.ammpSet("label_atom_id")
        ])
      ])
    })
  ]);
}
function proteinExpr() {
  return B4.struct.generator.atomGroups({
    "residue-test": B4.core.set.has([
      B4.set(...ResDict.amino),
      B4.ammp("label_comp_id")
    ])
  });
}
function backboneExpr() {
  return B4.struct.combinator.merge([
    B4.struct.modifier.intersectBy({
      0: B4.struct.generator.atomGroups({
        "residue-test": B4.core.set.has([
          B4.core.type.set(ResDict.amino),
          B4.ammp("label_comp_id")
        ])
      }),
      by: B4.struct.generator.atomGroups({
        "atom-test": B4.core.set.has([
          B4.core.type.set(Backbone.protein),
          B4.ammp("label_atom_id")
        ])
      })
    }),
    B4.struct.modifier.intersectBy({
      0: B4.struct.generator.atomGroups({
        "residue-test": B4.core.set.has([
          B4.core.type.set(ResDict.nucleic),
          B4.ammp("label_comp_id")
        ])
      }),
      by: B4.struct.generator.atomGroups({
        "atom-test": B4.core.set.has([
          B4.core.type.set(Backbone.nucleic),
          B4.ammp("label_atom_id")
        ])
      })
    })
  ]);
}
var keywords = {
  // general terms
  all: {
    "@desc": "all atoms; same as *",
    abbr: ["*"],
    map: () => B4.struct.generator.all()
  },
  bonded: {
    "@desc": "covalently bonded",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.rel.gr([B4.struct.atomProperty.core.bondCount({
        flags: B4.struct.type.bondFlags(["covalent", "metallic", "sulfide"])
      }), 0])
    })
  },
  clickable: {
    "@desc": "actually visible -- having some visible aspect such as wireframe, spacefill, or a label showing, or the alpha-carbon or phosphorus atom in a biomolecule that is rendered with only cartoon, rocket, or other biomolecule-specific shape."
  },
  connected: {
    "@desc": "bonded in any way, including hydrogen bonds",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.rel.gr([B4.struct.atomProperty.core.bondCount({
        flags: B4.struct.type.bondFlags()
      }), 0])
    })
  },
  displayed: {
    "@desc": "displayed using the display or hide command; not necessarily visible"
  },
  hidden: {
    "@desc": "hidden using the display or hide command"
  },
  none: {
    "@desc": "no atoms",
    map: () => B4.struct.generator.empty()
  },
  selected: {
    "@desc": "atoms that have been selected; defaults to all when a file is first loaded"
  },
  thisModel: {
    "@desc": 'atoms in the current frame set, as defined by frame, model, or animation commands. If more than one model is in this set, "thisModel" refers to all of them, regardless of atom displayed/hidden status.'
  },
  visible: {
    "@desc": "visible in any way, including PDB residue atoms for which a cartoon or other such rendering makes their group visible, even if they themselves are not visible."
  },
  subset: {
    "@desc": "the currently defined subset. Note that if a subset is currently defined, then select/display all is the same as select/display subset, restrict none is the same as restrict not subset. In addition, select not subset selects nothing."
  },
  specialPosition: {
    "@desc": "atoms in crystal structures that are at special positions - that is, for which there is more than one operator that leads to them."
  },
  unitcell: {
    "@desc": "atoms within the current unitcell, which may be offset. This includes atoms on the faces and at the vertices of the unitcell."
  },
  polyhedra: {
    "@desc": "all central atoms for which polyhedra have been created. See also polyhera(n), below. (Jmol 14.4)"
  },
  nonmetal: {
    "@desc": "_H,_He,_B,_C,_N,_O,_F,_Ne,_Si,_P,_S,_Cl,_Ar,_As,_Se,_Br,_Kr,_Te,_I,_Xe,_At,_Rn",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.set.has([
        B4.set(...["H", "He", "B", "C", "N", "O", "F", "Ne", "Si", "P", "S", "Cl", "Ar", "As", "Se", "Br", "Kr", "Te", "I", "Xe", "At", "Rn"].map(B4.es)),
        B4.acp("elementSymbol")
      ])
    })
  },
  metal: {
    "@desc": "!nonmetal",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.logic.not([
        B4.core.set.has([
          B4.set(...["H", "He", "B", "C", "N", "O", "F", "Ne", "Si", "P", "S", "Cl", "Ar", "As", "Se", "Br", "Kr", "Te", "I", "Xe", "At", "Rn"].map(B4.es)),
          B4.acp("elementSymbol")
        ])
      ])
    })
  },
  alkaliMetal: {
    "@desc": "_Li,_Na,_K,_Rb,_Cs,_Fr",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.set.has([
        B4.set(...["Li", "Na", "K", "Rb", "Cs", "Fr"].map(B4.es)),
        B4.acp("elementSymbol")
      ])
    })
  },
  alkalineEarth: {
    "@desc": "_Be,_Mg,_Ca,_Sr,_Ba,_Ra",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.set.has([
        B4.set(...["Be", "Mg", "Ca", "Sr", "Ba", "Ra"].map(B4.es)),
        B4.acp("elementSymbol")
      ])
    })
  },
  nobleGas: {
    "@desc": "_He,_Ne,_Ar,_Kr,_Xe,_Rn",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.set.has([
        B4.set(...["He", "Ne", "Ar", "Kr", "Xe", "Rn"].map(B4.es)),
        B4.acp("elementSymbol")
      ])
    })
  },
  metalloid: {
    "@desc": "_B,_Si,_Ge,_As,_Sb,_Te",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.set.has([
        B4.set(...["B", "Si", "Ge", "As", "Sb", "Te"].map(B4.es)),
        B4.acp("elementSymbol")
      ])
    })
  },
  transitionMetal: {
    "@desc": "(includes La and Ac) elemno>=21 and elemno<=30, elemno=57, elemno=89, elemno>=39 and elemno<=48, elemno>=72 and elemno<=80, elemno>=104 and elemno<=112",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.logic.or([
        B4.core.rel.inRange([B4.acp("atomicNumber"), 21, 30]),
        B4.core.rel.inRange([B4.acp("atomicNumber"), 39, 48]),
        B4.core.rel.inRange([B4.acp("atomicNumber"), 72, 80]),
        B4.core.rel.inRange([B4.acp("atomicNumber"), 104, 112]),
        B4.core.set.has([B4.set(57, 89), B4.acp("atomicNumber")])
      ])
    })
  },
  lanthanide: {
    "@desc": "(does not include La) elemno>57 and elemno<=71",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.rel.inRange([B4.acp("atomicNumber"), 57, 71])
    })
  },
  actinide: {
    "@desc": "(does not include Ac) elemno>89 and elemno<=103",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.rel.inRange([B4.acp("atomicNumber"), 89, 103])
    })
  },
  isaromatic: {
    "@desc": "atoms connected with the AROMATIC, AROMATICSINGLE, or AROMATICDOUBLE bond types",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.rel.gr([
        B4.struct.atomProperty.core.bondCount({
          flags: B4.struct.type.bondFlags(["aromatic"])
        }),
        0
      ])
    })
  },
  carbohydrate: {
    "@desc": ""
  },
  ions: {
    "@desc": '(specifically the PDB designations "PO4" and "SO4")'
  },
  ligand: {
    "@desc": '(originally "hetero and not solvent"; changed to "!(protein,nucleic,water,UREA)" for Jmol 12.2)'
  },
  nucleic: {
    "@desc": `any group that (a) has one of the following group names: G, C, A, T, U, I, DG, DC, DA, DT, DU, DI, +G, +C, +A, +T, +U, +I; or (b) can be identified as a group that is only one atom, with name "P"; or (c) has all of the following atoms (prime, ', can replace * here): C1*, C2*, C3*, O3*, C4*, C5*, and O5*.`,
    map: () => nucleicExpr()
  },
  purine: {
    "@desc": "any nucleic group that (a) has one of the following group names: A, G, I, DA, DG, DI, +A, +G, or +I; or (b) also has atoms N7, C8, and N9.",
    map: () => B4.struct.modifier.intersectBy({
      0: nucleicExpr(),
      by: B4.struct.combinator.merge([
        B4.struct.generator.atomGroups({
          "residue-test": B4.core.set.has([
            B4.set(...["A", "G", "I", "DA", "DG", "DI", "+A", "+G", "+I"]),
            B4.ammp("label_comp_id")
          ])
        }),
        B4.struct.filter.pick({
          0: B4.struct.generator.atomGroups({
            "group-by": B4.ammp("residueKey")
          }),
          test: B4.core.set.isSubset([
            atomNameSet(["N7", "C8", "N9"]),
            B4.ammpSet("label_atom_id")
          ])
        })
      ])
    })
  },
  pyrimidine: {
    "@desc": "any nucleic group that (a) has one of the following group names: C, T, U, DC, DT, DU, +C, +T, +U; or (b) also has atom O2.",
    map: () => B4.struct.modifier.intersectBy({
      0: nucleicExpr(),
      by: B4.struct.combinator.merge([
        B4.struct.generator.atomGroups({
          "residue-test": B4.core.set.has([
            B4.set(...["C", "T", "U", "DC", "DT", "DU", "+C", "+T", "+U"]),
            B4.ammp("label_comp_id")
          ])
        }),
        B4.struct.filter.pick({
          0: B4.struct.generator.atomGroups({
            "group-by": B4.ammp("residueKey")
          }),
          test: B4.core.logic.or([
            B4.core.set.has([
              B4.ammpSet("label_atom_id"),
              B4.atomName("O2*")
            ]),
            B4.core.set.has([
              B4.ammpSet("label_atom_id"),
              B4.atomName("O2'")
            ])
          ])
        })
      ])
    })
  },
  dna: {
    "@desc": "any nucleic group that (a) has one of the following group names: DG, DC, DA, DT, DU, DI, T, +G, +C, +A, +T; or (b) has neither atom O2* or O2'.",
    map: () => B4.struct.modifier.intersectBy({
      0: nucleicExpr(),
      by: B4.struct.combinator.merge([
        B4.struct.generator.atomGroups({
          "residue-test": B4.core.set.has([
            B4.set(...["DG", "DC", "DA", "DT", "DU", "DI", "T", "+G", "+C", "+A", "+T"]),
            B4.ammp("label_comp_id")
          ])
        }),
        B4.struct.filter.pick({
          0: B4.struct.generator.atomGroups({
            "group-by": B4.ammp("residueKey")
          }),
          test: B4.core.logic.not([
            B4.core.logic.or([
              B4.core.set.has([
                B4.ammpSet("label_atom_id"),
                B4.atomName("O2*")
              ]),
              B4.core.set.has([
                B4.ammpSet("label_atom_id"),
                B4.atomName("O2'")
              ])
            ])
          ])
        })
      ])
    })
  },
  rna: {
    "@desc": "any nucleic group that (a) has one of the following group names: G, C, A, U, I, +U, +I; or (b) has atom O2* or O2'.",
    map: () => B4.struct.modifier.intersectBy({
      0: nucleicExpr(),
      by: B4.struct.combinator.merge([
        B4.struct.generator.atomGroups({
          "residue-test": B4.core.set.has([
            B4.set(...["G", "C", "A", "U", "I", "+U", "+I"]),
            B4.ammp("label_comp_id")
          ])
        }),
        B4.struct.filter.pick({
          0: B4.struct.generator.atomGroups({
            "group-by": B4.ammp("residueKey")
          }),
          test: B4.core.logic.or([
            B4.core.set.has([
              B4.ammpSet("label_atom_id"),
              B4.atomName("O2*")
            ]),
            B4.core.set.has([
              B4.ammpSet("label_atom_id"),
              B4.atomName("O2'")
            ])
          ])
        })
      ])
    })
  },
  protein: {
    "@desc": 'defined as a group that (a) has one of the following group names: ALA, ARG, ASN, ASP, CYS, GLN, GLU, GLY, HIS, ILE, LEU, LYS, MET, PHE, PRO, SER, THR, TRP, TYR, VAL, ASX, GLX, or UNK; or (b) contains PDB atom designations [C, O, CA, and N] bonded correctly; or (c) does not contain "O" but contains [C, CA, and N] bonded correctly; or (d) has only one atom, which has name CA and does not have the group name CA (indicating a calcium atom).',
    map: () => proteinExpr()
  },
  acidic: {
    "@desc": "ASP GLU",
    map: () => resnameExpr(ResDict.acidic)
  },
  acyclic: {
    "@desc": "amino and not cyclic",
    map: () => B4.struct.modifier.intersectBy({
      0: resnameExpr(ResDict.amino),
      by: invertExpr(resnameExpr(ResDict.cyclic))
    })
  },
  aliphatic: {
    "@desc": "ALA GLY ILE LEU VAL",
    map: () => resnameExpr(ResDict.aliphatic)
  },
  amino: {
    "@desc": "all twenty standard amino acids, plus ASX, GLX, UNK",
    map: () => resnameExpr(ResDict.amino)
  },
  aromatic: {
    "@desc": 'HIS PHE TRP TYR (see also "isaromatic" for aromatic bonds)',
    map: () => resnameExpr(ResDict.aromatic)
  },
  basic: {
    "@desc": "ARG HIS LYS",
    map: () => resnameExpr(ResDict.basic)
  },
  buried: {
    "@desc": "ALA CYS ILE LEU MET PHE TRP VAL",
    map: () => resnameExpr(ResDict.buried)
  },
  charged: {
    "@desc": "same as acidic or basic -- ASP GLU, ARG HIS LYS",
    map: () => resnameExpr(ResDict.acidic.concat(ResDict.basic))
  },
  cyclic: {
    "@desc": "HIS PHE PRO TRP TYR",
    map: () => resnameExpr(ResDict.cyclic)
  },
  helix: {
    "@desc": "secondary structure-related.",
    map: () => B4.struct.generator.atomGroups({
      "residue-test": B4.core.flags.hasAny([
        B4.struct.type.secondaryStructureFlags(["helix"]),
        B4.ammp("secondaryStructureFlags")
      ])
    })
  },
  helixalpha: {
    "@desc": "secondary structure-related.",
    map: () => B4.struct.generator.atomGroups({
      "residue-test": B4.core.flags.hasAny([
        B4.struct.type.secondaryStructureFlags(["alpha"]),
        B4.ammp("secondaryStructureFlags")
      ])
    })
  },
  helix310: {
    "@desc": "secondary structure-related.",
    map: () => B4.struct.generator.atomGroups({
      "residue-test": B4.core.flags.hasAny([
        B4.struct.type.secondaryStructureFlags(["3-10"]),
        B4.ammp("secondaryStructureFlags")
      ])
    })
  },
  helixpi: {
    "@desc": "secondary structure-related.",
    map: () => B4.struct.generator.atomGroups({
      "residue-test": B4.core.flags.hasAny([
        B4.struct.type.secondaryStructureFlags(["pi"]),
        B4.ammp("secondaryStructureFlags")
      ])
    })
  },
  hetero: {
    "@desc": "PDB atoms designated as HETATM",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.ammp("isHet")
    })
  },
  hydrophobic: {
    "@desc": "ALA GLY ILE LEU MET PHE PRO TRP TYR VAL",
    map: () => resnameExpr(ResDict.hydrophobic)
  },
  large: {
    "@desc": "ARG GLU GLN HIS ILE LEU LYS MET PHE TRP TYR",
    map: () => resnameExpr(ResDict.large)
  },
  medium: {
    "@desc": "ASN ASP CYS PRO THR VAL",
    map: () => resnameExpr(ResDict.medium)
  },
  negative: {
    "@desc": "same as acidic -- ASP GLU",
    map: () => resnameExpr(ResDict.acidic)
  },
  neutral: {
    "@desc": "amino and not (acidic or basic)",
    map: () => B4.struct.modifier.intersectBy({
      0: resnameExpr(ResDict.amino),
      by: invertExpr(resnameExpr(ResDict.acidic.concat(ResDict.basic)))
    })
  },
  polar: {
    "@desc": "amino and not hydrophobic",
    map: () => B4.struct.modifier.intersectBy({
      0: resnameExpr(ResDict.amino),
      by: invertExpr(resnameExpr(ResDict.hydrophobic))
    })
  },
  positive: {
    "@desc": "same as basic -- ARG HIS LYS",
    map: () => resnameExpr(ResDict.basic)
  },
  sheet: {
    "@desc": "secondary structure-related",
    map: () => B4.struct.generator.atomGroups({
      "residue-test": B4.core.flags.hasAny([
        B4.struct.type.secondaryStructureFlags(["sheet"]),
        B4.ammp("secondaryStructureFlags")
      ])
    })
  },
  small: {
    "@desc": "ALA GLY SER",
    map: () => resnameExpr(ResDict.small)
  },
  surface: {
    "@desc": "amino and not buried",
    map: () => B4.struct.modifier.intersectBy({
      0: resnameExpr(ResDict.amino),
      by: invertExpr(resnameExpr(ResDict.buried))
    })
  },
  turn: {
    "@desc": "secondary structure-related",
    map: () => B4.struct.generator.atomGroups({
      "residue-test": B4.core.flags.hasAny([
        B4.struct.type.secondaryStructureFlags(["turn"]),
        B4.ammp("secondaryStructureFlags")
      ])
    })
  },
  alpha: {
    "@desc": "(*.CA)",
    map: () => B4.struct.generator.atomGroups({
      "atom-test": B4.core.rel.eq([
        B4.atomName("CA"),
        B4.ammp("label_atom_id")
      ])
    })
  },
  base: {
    "@desc": "(nucleic bases)"
  },
  backbone: {
    "@desc": "(*.C, *.CA, *.N, and all nucleic other than the bases themselves)",
    abbr: ["mainchain"],
    map: () => backboneExpr()
  },
  sidechain: {
    "@desc": "((protein or nucleic) and not backbone)"
  },
  spine: {
    "@desc": "(*.CA, *.N, *.C for proteins; *.P, *.O3', *.O5', *.C3', *.C4', *.C5 for nucleic acids)"
  },
  leadatom: {
    "@desc": "(*.CA, *.P, and terminal *.O5')"
  },
  solvent: {
    "@desc": 'PDB "HOH", water, also the connected set of H-O-H in any model'
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/jmol/parser.js
var B5 = MolScriptBuilder;
var valueOperators = [
  {
    "@desc": "value comparisons",
    "@examples": [],
    name: "=",
    abbr: ["=="],
    type: binaryLeft,
    rule: MonadicParser.regexp(/\s*(LIKE|>=|<=|=|!=|>|<)\s*/i, 1),
    map: (op2, e1, e2) => {
      let expr;
      if (e1 === "structure") {
        expr = B5.core.flags.hasAny([B5.ammp("secondaryStructureFlags"), structureMap(e2)]);
      } else if (e2 === "structure") {
        expr = B5.core.flags.hasAny([B5.ammp("secondaryStructureFlags"), structureMap(e1)]);
      } else if (e1.head !== void 0) {
        if (e1.head.name === "core.type.regex") {
          expr = B5.core.str.match([e1, B5.core.type.str([e2])]);
        }
      } else if (e2.head !== void 0) {
        if (e2.head.name === "core.type.regex") {
          expr = B5.core.str.match([e2, B5.core.type.str([e1])]);
        }
      } else if (op2.toUpperCase() === "LIKE") {
        if (e1.head) {
          expr = B5.core.str.match([
            B5.core.type.regex([`^${e2}$`, "i"]),
            B5.core.type.str([e1])
          ]);
        } else {
          expr = B5.core.str.match([
            B5.core.type.regex([`^${e1}$`, "i"]),
            B5.core.type.str([e2])
          ]);
        }
      }
      if (!expr) {
        if (e1.head)
          e2 = wrapValue(e1, e2);
        if (e2.head)
          e1 = wrapValue(e2, e1);
        switch (op2) {
          case "=":
            expr = B5.core.rel.eq([e1, e2]);
            break;
          case "!=":
            expr = B5.core.rel.neq([e1, e2]);
            break;
          case ">":
            expr = B5.core.rel.gr([e1, e2]);
            break;
          case "<":
            expr = B5.core.rel.lt([e1, e2]);
            break;
          case ">=":
            expr = B5.core.rel.gre([e1, e2]);
            break;
          case "<=":
            expr = B5.core.rel.lte([e1, e2]);
            break;
          default:
            throw new Error(`value operator '${op2}' not supported`);
        }
      }
      return B5.struct.generator.atomGroups({ "atom-test": expr });
    }
  }
];
function atomExpressionQuery(x) {
  const [resname, resnoRange, resno, inscode, chainname, atomname, altloc] = x[1];
  const tests = {};
  if (chainname) {
    tests["chain-test"] = B5.core.rel.eq([B5.ammp("auth_asym_id"), chainname]);
  }
  const resProps = [];
  if (resname)
    resProps.push(B5.core.rel.eq([B5.ammp("label_comp_id"), resname]));
  if (resnoRange)
    resProps.push(B5.core.logic.and([
      B5.core.rel.gre([B5.ammp("auth_seq_id"), resnoRange[0]]),
      B5.core.rel.lte([B5.ammp("auth_seq_id"), resnoRange[1]])
    ]));
  if (resno)
    resProps.push(B5.core.rel.eq([B5.ammp("auth_seq_id"), resno]));
  if (inscode)
    resProps.push(B5.core.rel.eq([B5.ammp("pdbx_PDB_ins_code"), inscode]));
  if (resProps.length)
    tests["residue-test"] = andExpr(resProps);
  const atomProps = [];
  if (atomname)
    atomProps.push(B5.core.rel.eq([B5.ammp("auth_atom_id"), atomname]));
  if (altloc)
    atomProps.push(B5.core.rel.eq([B5.ammp("label_alt_id"), altloc]));
  if (atomProps.length)
    tests["atom-test"] = andExpr(atomProps);
  return B5.struct.generator.atomGroups(tests);
}
var lang = MonadicParser.createLanguage({
  Integer: () => MonadicParser.regexp(/-?[0-9]+/).map(Number).desc("integer"),
  Parens: function(r) {
    return MonadicParser.alt(r.Parens, r.Operator, r.Expression).wrap(MonadicParser.regexp(/\(\s*/), MonadicParser.regexp(/\s*\)/));
  },
  Expression: function(r) {
    return MonadicParser.alt(r.Keywords, r.AtomExpression.map(atomExpressionQuery), r.Within.map((x) => B5.struct.modifier.includeSurroundings({ 0: x[1], radius: x[0] })), r.ValueQuery, r.Element.map((x) => B5.struct.generator.atomGroups({
      "atom-test": B5.core.rel.eq([B5.acp("elementSymbol"), B5.struct.type.elementSymbol(x)])
    })), r.Resname.map((x) => B5.struct.generator.atomGroups({
      "residue-test": B5.core.rel.eq([B5.ammp("label_comp_id"), x])
    })));
  },
  Operator: function(r) {
    return combineOperators(operators, MonadicParser.alt(r.Parens, r.Expression));
  },
  AtomExpression: function(r) {
    return MonadicParser.seq(MonadicParser.lookahead(r.AtomPrefix), MonadicParser.seq(r.BracketedResname.or(MonadicParser.of(null)), r.ResnoRange.or(MonadicParser.of(null)), r.Resno.or(MonadicParser.of(null)), r.Inscode.or(MonadicParser.of(null)), r.Chainname.or(MonadicParser.of(null)), r.Atomname.or(MonadicParser.of(null)), r.Altloc.or(MonadicParser.of(null)), r.Model.or(MonadicParser.of(null)))).desc("expression");
  },
  AtomPrefix: () => MonadicParser.regexp(/[\[0-9:^%/.-]/).desc("atom-prefix"),
  Chainname: () => MonadicParser.regexp(/:([A-Za-z]{1,3})/, 1).desc("chainname"),
  Model: () => MonadicParser.regexp(/\/([0-9]+)/, 1).map(Number).desc("model"),
  Element: () => MonadicParser.regexp(/_([A-Za-z]{1,3})/, 1).desc("element"),
  Atomname: () => MonadicParser.regexp(/\.([a-zA-Z0-9]{1,4})/, 1).map(B5.atomName).desc("atomname"),
  Resname: () => MonadicParser.regexp(/[a-zA-Z0-9]{1,4}/).desc("resname"),
  Resno: (r) => r.Integer.desc("resno"),
  Altloc: () => MonadicParser.regexp(/%([a-zA-Z0-9])/, 1).desc("altloc"),
  Inscode: () => MonadicParser.regexp(/\^([a-zA-Z0-9])/, 1).desc("inscode"),
  BracketedResname: () => MonadicParser.regexp(/\[([a-zA-Z0-9]{1,4})\]/, 1).desc("bracketed-resname"),
  ResnoRange: (r) => {
    return MonadicParser.seq(r.Integer.skip(MonadicParser.seq(MonadicParser.optWhitespace, MonadicParser.string("-"), MonadicParser.optWhitespace)), r.Integer).desc("resno-range");
  },
  Within: (r) => {
    return MonadicParser.regexp(/within/i).skip(MonadicParser.regexp(/\s*\(\s*/)).then(MonadicParser.seq(r.Integer.skip(MonadicParser.regexp(/\s*,\s*/)), r.Query)).skip(MonadicParser.regexp(/\)/));
  },
  Keywords: () => MonadicParser.alt(...getKeywordRules(keywords)).desc("keyword"),
  Query: function(r) {
    return MonadicParser.alt(r.Operator, r.Parens, r.Expression).trim(MonadicParser.optWhitespace);
  },
  Number: function() {
    return MonadicParser.regexp(/-?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?/).map(Number).desc("number");
  },
  String: function() {
    const w = getReservedWords(properties, keywords, operators).sort(strLenSortFn).map(escapeRegExp).join("|");
    return MonadicParser.alt(MonadicParser.regexp(new RegExp(`(?!(${w}))[A-Z0-9_]+`, "i")), MonadicParser.regexp(/'((?:[^"\\]|\\.)*)'/, 1), MonadicParser.regexp(/"((?:[^"\\]|\\.)*)"/, 1).map((x) => B5.core.type.regex([`^${x}$`, "i"]))).desc("string");
  },
  Value: function(r) {
    return MonadicParser.alt(r.Number, r.String);
  },
  ValueParens: function(r) {
    return MonadicParser.alt(r.ValueParens, r.ValueOperator, r.ValueExpressions).wrap(MonadicParser.string("("), MonadicParser.string(")"));
  },
  ValuePropertyNames: function() {
    return MonadicParser.alt(...getPropertyNameRules(properties, /LIKE|>=|<=|=|!=|>|<|\)|\s/i));
  },
  ValueOperator: function(r) {
    return combineOperators(valueOperators, MonadicParser.alt(r.ValueParens, r.ValueExpressions));
  },
  ValueExpressions: function(r) {
    return MonadicParser.alt(r.Value, r.ValuePropertyNames);
  },
  ValueQuery: function(r) {
    return MonadicParser.alt(r.ValueOperator.map((x) => {
      if (x.head) {
        if (x.head.name.startsWith("structure-query.generator"))
          return x;
      } else {
        if (typeof x === "string" && x.length <= 4) {
          return B5.struct.generator.atomGroups({
            "residue-test": B5.core.rel.eq([B5.ammp("label_comp_id"), x])
          });
        }
      }
      throw new Error(`values must be part of an comparison, value '${x}'`);
    }));
  }
});
var transpiler = (str3) => lang.Query.tryParse(str3);

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/pymol/properties.js
var B6 = MolScriptBuilder;
var reFloat2 = /[-+]?[0-9]*\.?[0-9]+/;
function atomNameListMap(x) {
  return x.split("+").map(B6.atomName);
}
function listMap(x) {
  return x.split("+").map((x2) => x2.replace(/^["']|["']$/g, ""));
}
function listOrRangeMap(x) {
  if (x.includes("-") && x.includes("+")) {
    const pSplit = x.split("+").map((x2) => x2.replace(/^["']|["']$/g, ""));
    const res = [];
    pSplit.forEach((x2) => {
      if (x2.includes("-") && !x2.startsWith("-")) {
        const [min3, max3] = x2.split("-").map((x3) => parseInt(x3));
        for (let i = min3; i <= max3; i++) {
          res.push(i);
        }
      } else if (x2.includes("-") && x2.startsWith("-") && x2.match(/[0-9]+-[-0-9]+/)) {
        const min3 = -parseInt(x2.split("-")[1]);
        let max3;
        if (x2.includes("--")) {
          max3 = -parseInt(x2.split("-")[3]);
        } else {
          max3 = parseInt(x2.split("-")[2]);
        }
        for (let i = min3; i <= max3; i++) {
          res.push(i);
        }
      } else if (x2.includes("-") && x2.startsWith("-") && !x2.match(/[0-9]+-[-0-9]+/)) {
        res.push(parseInt(x2));
      } else {
        res.push(parseInt(x2));
      }
    });
    return res;
  } else if (x.includes("-") && !x.includes("+")) {
    const res = [];
    if (!x.startsWith("-")) {
      const [min3, max3] = x.split("-").map((x2) => parseInt(x2));
      for (let i = min3; i <= max3; i++) {
        res.push(i);
      }
    } else if (x.startsWith("-") && x.match(/[0-9]+-[-0-9]+/)) {
      const min3 = -parseInt(x.split("-")[1]);
      let max3;
      if (x.includes("--")) {
        max3 = -parseInt(x.split("-")[3]);
      } else {
        max3 = parseInt(x.split("-")[2]);
      }
      for (let i = min3; i <= max3; i++) {
        res.push(i);
      }
    } else if (x.startsWith("-") && !x.match(/[0-9]+-[-0-9]+/)) {
      res.push(parseInt(x));
    } else {
      res.push(parseInt(x));
    }
    return res;
  } else if (!x.includes("-") && x.includes("+")) {
    return listMap(x).map((x2) => parseInt(x2));
  } else {
    return [parseInt(x)];
  }
}
function elementListMap(x) {
  return x.split("+").map(B6.struct.type.elementSymbol);
}
var sstrucDict = {
  H: "helix",
  S: "beta",
  L: "none"
};
function sstrucListMap(x) {
  return {
    flags: B6.struct.type.secondaryStructureFlags(x.toUpperCase().split("+").map((ss) => sstrucDict[ss] || "none"))
  };
}
var properties2 = {
  symbol: {
    "@desc": "chemical-symbol-list: list of 1- or 2-letter chemical symbols from the periodic table",
    "@examples": ["symbol O+N"],
    abbr: ["e."],
    regex: /[a-zA-Z'"+]+/,
    map: elementListMap,
    level: "atom-test",
    property: B6.acp("elementSymbol")
  },
  name: {
    "@desc": "atom-name-list: list of up to 4-letter codes for atoms in proteins or nucleic acids",
    "@examples": ["name CA+CB+CG+CD"],
    abbr: ["n."],
    regex: /[a-zA-Z0-9'"+]+/,
    map: atomNameListMap,
    level: "atom-test",
    property: B6.ammp("label_atom_id")
  },
  resn: {
    "@desc": "residue-name-list: list of 3-letter codes for amino acids or list of up to 2-letter codes for nucleic acids",
    "@examples": ["resn ASP+GLU+ASN+GLN", "resn A+G"],
    abbr: ["resname", "r."],
    regex: /[a-zA-Z0-9'"+]+/,
    map: listMap,
    level: "residue-test",
    property: B6.ammp("label_comp_id")
  },
  resi: {
    "@desc": "residue-identifier-list list of up to 4-digit residue numbers or residue-identifier-range",
    "@examples": ["resi 1+10+100+1000", "resi 1-10"],
    abbr: ["resident", "residue", "resid", "i."],
    regex: /[0-9+-]+/,
    map: listOrRangeMap,
    level: "residue-test",
    property: B6.ammp("auth_seq_id")
  },
  alt: {
    "@desc": "alternate-conformation-identifier-list list of single letters",
    "@examples": ["alt A+B", 'alt ""', 'alt ""+A'],
    abbr: [],
    regex: /[a-zA-Z0-9'"+]+/,
    map: listMap,
    level: "atom-test",
    property: B6.ammp("label_alt_id")
  },
  chain: {
    "@desc": "chain-identifier-list list of single letters or sometimes numbers",
    "@examples": ["chain A"],
    abbr: ["c."],
    regex: /[a-zA-Z0-9'"+]+/,
    map: listMap,
    level: "chain-test",
    property: B6.ammp("auth_asym_id")
  },
  segi: {
    "@desc": "segment-identifier-list list of up to 4 letter identifiers",
    "@examples": ["segi lig"],
    abbr: ["segid", "s."],
    regex: /[a-zA-Z0-9'"+]+/,
    map: listMap,
    level: "chain-test",
    property: B6.ammp("label_asym_id")
  },
  flag: {
    "@desc": "flag-number a single integer from 0 to 31",
    "@examples": ["flag 0"],
    isUnsupported: true,
    abbr: ["f."],
    regex: /[0-9]+/,
    map: (x) => parseInt(x),
    level: "atom-test"
  },
  numeric_type: {
    "@desc": "type-number a single integer",
    "@examples": ["nt. 5"],
    isUnsupported: true,
    abbr: ["nt."],
    regex: /[0-9]+/,
    map: (x) => parseInt(x),
    level: "atom-test"
  },
  text_type: {
    "@desc": "type-string a list of up to 4 letter codes",
    "@examples": ["text_type HA+HC"],
    isUnsupported: true,
    abbr: ["tt."],
    regex: /[a-zA-Z0-9'"+]+/,
    map: listMap,
    level: "atom-test"
  },
  id: {
    "@desc": "external-index-number a single integer",
    "@examples": ["id 23"],
    regex: /[0-9+-]+/,
    map: listOrRangeMap,
    level: "atom-test",
    property: B6.ammp("id")
  },
  index: {
    "@desc": "internal-index-number a single integer",
    "@examples": ["index 11"],
    regex: /[0-9+-]+/,
    map: listOrRangeMap,
    level: "atom-test",
    property: B6.ammp("id")
  },
  ss: {
    "@desc": "secondary-structure-type list of single letters. Helical regions should be assigned H and sheet regions S. Loop regions can either be assigned L or be blank.",
    "@examples": ["ss H+S+L", 'ss S+""'],
    abbr: [],
    regex: /[a-zA-Z'"+]+/,
    map: sstrucListMap,
    level: "residue-test",
    property: B6.ammp("secondaryStructureFlags")
  },
  b: {
    "@desc": "comparison-operator b-factor-value a real number",
    "@examples": ["b > 10"],
    isNumeric: true,
    abbr: [],
    regex: reFloat2,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B6.ammp("B_iso_or_equiv")
  },
  q: {
    "@desc": "comparison-operator occupancy-value a real number",
    "@examples": ["q <0.50"],
    isNumeric: true,
    abbr: [],
    regex: reFloat2,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B6.ammp("occupancy")
  },
  formal_charge: {
    "@desc": "comparison-operator formal charge-value an integer",
    "@examples": ["fc. = -1"],
    isNumeric: true,
    abbr: ["fc."],
    regex: reFloat2,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B6.ammp("pdbx_formal_charge")
  },
  partial_charge: {
    "@desc": "comparison-operator partial charge-value a real number",
    "@examples": ["pc. > 1"],
    isUnsupported: true,
    isNumeric: true,
    abbr: ["pc."],
    regex: reFloat2,
    map: (x) => parseFloat(x),
    level: "atom-test"
  },
  elem: {
    "@desc": 'str  atomic element symbol string ("X" if undefined)',
    "@examples": ["elem N"],
    regex: /[a-zA-Z0-9]{1,3}/,
    map: (x) => B6.es(x),
    level: "atom-test",
    property: B6.acp("elementSymbol")
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/pymol/operators.js
var B7 = MolScriptBuilder;
var operators2 = [
  {
    "@desc": "Selects atoms that are not included in s1.",
    "@examples": [
      "NOT resn ALA",
      "not (resi 42 or chain A)",
      "!resi 42 or chain A"
    ],
    name: "not",
    type: prefix,
    rule: MonadicParser.alt(MonadicParser.regexp(/NOT/i).skip(MonadicParser.whitespace), MonadicParser.string("!").skip(MonadicParser.optWhitespace)),
    map: (op2, selection) => invertExpr(selection)
  },
  {
    "@desc": "Selects atoms included in both s1 and s2.",
    "@examples": ["chain A AND name CA"],
    name: "and",
    type: binaryLeft,
    rule: infixOp(/AND|&/i),
    map: (op2, selection, by) => B7.struct.modifier.intersectBy({ 0: selection, by })
  },
  {
    "@desc": "Selects atoms included in either s1 or s2.",
    "@examples": ["chain A OR chain B"],
    name: "or",
    type: binaryLeft,
    rule: infixOp(/OR|\|/i),
    map: (op2, s1, s2) => B7.struct.combinator.merge([s1, s2])
  },
  {
    "@desc": "Selects atoms in s1 whose identifiers name, resi, resn, chain and segi all match atoms in s2.",
    "@examples": ["chain A IN chain B"],
    name: "in",
    type: binaryLeft,
    rule: infixOp(/IN/i),
    map: (op2, selection, source) => {
      return B7.struct.filter.withSameAtomProperties({
        0: selection,
        source,
        property: B7.core.type.compositeKey([
          B7.ammp("label_atom_id"),
          B7.ammp("label_seq_id"),
          B7.ammp("label_comp_id"),
          B7.ammp("auth_asym_id"),
          B7.ammp("label_asym_id")
        ])
      });
    }
  },
  {
    "@desc": "Selects atoms in s1 whose identifiers name and resi match atoms in s2.",
    "@examples": ["chain A LIKE chain B"],
    name: "like",
    type: binaryLeft,
    rule: infixOp(/LIKE|l\./i),
    map: (op2, selection, source) => {
      return B7.struct.filter.withSameAtomProperties({
        0: selection,
        source,
        property: B7.core.type.compositeKey([
          B7.ammp("label_atom_id"),
          B7.ammp("label_seq_id")
        ])
      });
    }
  },
  {
    "@desc": "Selects all atoms whose van der Waals radii are separated from the van der Waals radii of s1 by a minimum of X Angstroms.",
    "@examples": ["solvent GAP 2"],
    name: "gap",
    type: postfix,
    rule: postfixOp(/GAP\s+([-+]?[0-9]*\.?[0-9]+)/i, 1).map((x) => parseFloat(x)),
    map: (distance, target) => {
      return B7.struct.filter.within({
        "0": B7.struct.generator.all(),
        target,
        "atom-radius": B7.acp("vdw"),
        "max-radius": distance,
        invert: true
      });
    }
  },
  {
    "@desc": "Selects atoms with centers within X Angstroms of the center of any atom in s1.",
    "@examples": ["resname LIG AROUND 1"],
    name: "around",
    abbr: ["a."],
    type: postfix,
    rule: postfixOp(/(AROUND|a\.)\s+([-+]?[0-9]*\.?[0-9]+)/i, 2).map((x) => parseFloat(x)),
    map: (radius, target) => {
      return B7.struct.modifier.exceptBy({
        "0": B7.struct.filter.within({
          "0": B7.struct.generator.all(),
          target,
          "max-radius": radius
        }),
        by: target
      });
    }
  },
  {
    "@desc": "Expands s1 by all atoms within X Angstroms of the center of any atom in s1.",
    "@examples": ["chain A EXPAND 3"],
    name: "expand",
    abbr: ["x."],
    type: postfix,
    rule: postfixOp(/(EXPAND|x\.)\s+([-+]?[0-9]*\.?[0-9]+)/i, 2).map((x) => parseFloat(x)),
    map: (radius, selection) => {
      return B7.struct.modifier.includeSurroundings({ 0: selection, radius });
    }
  },
  {
    "@desc": "Selects atoms in s1 that are within X Angstroms of any atom in s2.",
    "@examples": ["chain A WITHIN 3 OF chain B"],
    name: "within",
    abbr: ["w."],
    type: binaryLeft,
    rule: ofOp("WITHIN", "w."),
    map: (radius, selection, target) => {
      return B7.struct.filter.within({
        0: selection,
        target,
        "max-radius": radius
      });
    }
  },
  {
    "@desc": "Same as within, but excludes s2 from the selection (and thus is identical to s1 and s2 around X).",
    "@examples": ["chain A NEAR_TO 3 OF chain B"],
    name: "near_to",
    abbr: ["nto."],
    type: binaryLeft,
    rule: ofOp("NEAR_TO", "nto."),
    map: (radius, selection, target) => {
      return B7.struct.modifier.exceptBy({
        "0": B7.struct.filter.within({
          "0": selection,
          target,
          "max-radius": radius
        }),
        by: target
      });
    }
  },
  {
    "@desc": "Selects atoms in s1 that are at least X Anstroms away from s2.",
    "@examples": ["solvent BEYOND 2 OF chain A"],
    name: "beyond",
    abbr: ["be."],
    type: binaryLeft,
    rule: ofOp("BEYOND", "be."),
    map: (radius, selection, target) => {
      return B7.struct.modifier.exceptBy({
        "0": B7.struct.filter.within({
          "0": selection,
          target,
          "max-radius": radius,
          invert: true
        }),
        by: target
      });
    }
  },
  {
    "@desc": "Expands selection to complete residues.",
    "@examples": ["BYRESIDUE name N"],
    name: "byresidue",
    abbr: ["byresi", "byres", "br."],
    type: prefix,
    rule: prefixOp(/BYRESIDUE|byresi|byres|br\./i),
    map: (op2, selection) => {
      return asAtoms(B7.struct.modifier.expandProperty({
        "0": B7.struct.modifier.union({ 0: selection }),
        property: B7.ammp("residueKey")
      }));
    }
  },
  {
    "@desc": "Completely selects all alpha carbons in all residues covered by a selection.",
    "@examples": ["BYCALPHA chain A"],
    name: "bycalpha",
    abbr: ["bca."],
    type: prefix,
    rule: prefixOp(/BYCALPHA|bca\./i),
    map: (op2, selection) => {
      return B7.struct.generator.queryInSelection({
        "0": B7.struct.modifier.expandProperty({
          "0": B7.struct.modifier.union({ 0: selection }),
          property: B7.ammp("residueKey")
        }),
        query: B7.struct.generator.atomGroups({
          "atom-test": B7.core.rel.eq([
            B7.atomName("CA"),
            B7.ammp("label_atom_id")
          ])
        })
      });
    }
  },
  {
    "@desc": "Expands selection to complete molecules.",
    "@examples": ["BYMOLECULE resi 20-30"],
    name: "bymolecule",
    isUnsupported: true,
    // structure-query.atom-property.topology.connected-component-key' is not implemented
    abbr: ["bymol", "bm."],
    type: prefix,
    rule: prefixOp(/BYMOLECULE|bymol|bm\./i),
    map: (op2, selection) => {
      return asAtoms(B7.struct.modifier.expandProperty({
        "0": B7.struct.modifier.union({ 0: selection }),
        property: B7.atp("connectedComponentKey")
      }));
    }
  },
  {
    "@desc": "Expands selection to complete fragments.",
    "@examples": ["BYFRAGMENT resi 10"],
    name: "byfragment",
    abbr: ["byfrag", "bf."],
    isUnsupported: true,
    type: prefix,
    rule: prefixOp(/BYFRAGMENT|byfrag|bf\./i),
    map: (op2, selection) => [op2, selection]
  },
  {
    "@desc": "Expands selection to complete segments.",
    "@examples": ["BYSEGMENT resn CYS"],
    name: "bysegment",
    abbr: ["bysegi", "byseg", "bs."],
    type: prefix,
    rule: prefixOp(/BYSEGMENT|bysegi|byseg|bs\./i),
    map: (op2, selection) => {
      return asAtoms(B7.struct.modifier.expandProperty({
        "0": B7.struct.modifier.union({ 0: selection }),
        property: B7.ammp("chainKey")
      }));
    }
  },
  {
    "@desc": "Expands selection to complete objects.",
    "@examples": ["BYOBJECT chain A"],
    name: "byobject",
    abbr: ["byobj", "bo."],
    isUnsupported: true,
    type: prefix,
    rule: prefixOp(/BYOBJECT|byobj|bo\./i),
    map: (op2, selection) => [op2, selection]
  },
  {
    "@desc": "Expands selection to unit cell.",
    "@examples": ["BYCELL chain A"],
    name: "bycell",
    isUnsupported: true,
    type: prefix,
    rule: prefixOp(/BYCELL/i),
    map: (op2, selection) => [op2, selection]
  },
  {
    "@desc": "All rings of size  7 which have at least one atom in s1.",
    "@examples": ["BYRING resn HEM"],
    name: "byring",
    // isUnsupported: true, // structure-query.atom-set.atom-count' is not implemented.
    type: prefix,
    rule: prefixOp(/BYRING/i),
    map: (op2, selection) => {
      return asAtoms(B7.struct.modifier.intersectBy({
        "0": B7.struct.filter.pick({
          "0": B7.struct.generator.rings(),
          test: B7.core.logic.and([
            B7.core.rel.lte([B7.struct.atomSet.atomCount(), 7]),
            B7.core.rel.gr([B7.struct.atomSet.countQuery([selection]), 1])
          ])
        }),
        by: selection
      }));
    }
  },
  {
    "@desc": "Selects atoms directly bonded to s1, excludes s1.",
    "@examples": ["NEIGHBOR resn CYS"],
    name: "neighbor",
    type: prefix,
    abbr: ["nbr."],
    rule: prefixOp(/NEIGHBOR|nbr\./i),
    map: (op2, selection) => {
      return B7.struct.modifier.exceptBy({
        "0": asAtoms(B7.struct.modifier.includeConnected({
          "0": B7.struct.modifier.union({ 0: selection }),
          "bond-test": true
        })),
        by: selection
      });
    }
  },
  {
    "@desc": "Selects atoms directly bonded to s1, may include s1.",
    "@examples": ["BOUND_TO name CA"],
    name: "bound_to",
    abbr: ["bto."],
    type: prefix,
    rule: prefixOp(/BOUND_TO|bto\./i),
    map: (op2, selection) => {
      return asAtoms(B7.struct.modifier.includeConnected({
        "0": B7.struct.modifier.union({ 0: selection })
      }));
    }
  },
  {
    "@desc": "Extends s1 by X bonds connected to atoms in s1.",
    "@examples": ["resname LIG EXTEND 3"],
    name: "extend",
    abbr: ["xt."],
    type: postfix,
    rule: postfixOp(/(EXTEND|xt\.)\s+([0-9]+)/i, 2).map((x) => parseInt(x)),
    map: (count3, selection) => {
      return asAtoms(B7.struct.modifier.includeConnected({
        "0": B7.struct.modifier.union({ 0: selection }),
        "bond-test": true,
        "layer-count": count3
      }));
    }
  }
];

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/pymol/keywords.js
var B8 = MolScriptBuilder;
var ResDict2 = {
  nucleic: ["A", "C", "T", "G", "U", "DA", "DC", "DT", "DG", "DU"],
  protein: ["ALA", "ARG", "ASN", "ASP", "CYS", "CYX", "GLN", "GLU", "GLY", "HIS", "HID", "HIE", "HIP", "ILE", "LEU", "LYS", "MET", "MSE", "PHE", "PRO", "SER", "THR", "TRP", "TYR", "VAL"],
  solvent: ["HOH", "WAT", "H20", "TIP", "SOL"]
};
var Backbone2 = {
  nucleic: [
    "P",
    "O3'",
    "O5'",
    "C5'",
    "C4'",
    "C3'",
    "OP1",
    "OP2",
    "O3*",
    "O5*",
    "C5*",
    "C4*",
    "C3*",
    "C2'",
    "C1'",
    "O4'",
    "O2'"
  ],
  protein: ["C", "N", "CA", "O"]
};
function backboneExpr2() {
  return B8.struct.combinator.merge([
    B8.struct.modifier.intersectBy({
      0: B8.struct.generator.atomGroups({
        "residue-test": B8.core.set.has([
          B8.core.type.set(ResDict2.protein),
          B8.ammp("label_comp_id")
        ])
      }),
      by: B8.struct.generator.atomGroups({
        "atom-test": B8.core.set.has([
          B8.core.type.set(Backbone2.protein),
          B8.ammp("label_atom_id")
        ])
      })
    }),
    B8.struct.modifier.intersectBy({
      0: B8.struct.generator.atomGroups({
        "residue-test": B8.core.set.has([
          B8.core.type.set(ResDict2.nucleic),
          B8.ammp("label_comp_id")
        ])
      }),
      by: B8.struct.generator.atomGroups({
        "atom-test": B8.core.set.has([
          B8.core.type.set(Backbone2.nucleic),
          B8.ammp("label_atom_id")
        ])
      })
    })
  ]);
}
var keywords2 = {
  all: {
    "@desc": "All atoms currently loaded into PyMOL",
    abbr: ["*"],
    map: () => B8.struct.generator.all()
  },
  none: {
    "@desc": "No atoms (empty selection)",
    map: () => B8.struct.generator.empty()
  },
  hydrogens: {
    "@desc": "All hydrogen atoms currently loaded into PyMOL",
    abbr: ["hydro", "h."],
    map: () => B8.struct.generator.atomGroups({
      "atom-test": B8.core.rel.eq([
        B8.acp("elementSymbol"),
        B8.es("H")
      ])
    })
  },
  hetatm: {
    "@desc": "All atoms loaded from Protein Data Bank HETATM records",
    abbr: ["het"],
    map: () => B8.struct.generator.atomGroups({
      "atom-test": B8.core.rel.eq([B8.ammp("isHet"), true])
    })
  },
  visible: {
    "@desc": "All atoms in enabled objects with at least one visible representation",
    abbr: ["v."]
  },
  polymer: {
    "@desc": "All atoms on the polymer (not het). Finds atoms with residue identifiers matching a known polymer, such a peptide and DNA.",
    abbr: ["pol."],
    map: () => B8.struct.generator.atomGroups({
      "residue-test": B8.core.set.has([
        B8.core.type.set(ResDict2.nucleic.concat(ResDict2.protein)),
        B8.ammp("label_comp_id")
      ])
    })
  },
  sidechain: {
    "@desc": "Polymer non-backbone atoms (new in PyMOL 1.6.1)",
    abbr: ["sc."],
    map: () => {
      return B8.struct.modifier.exceptBy({
        "0": B8.struct.generator.atomGroups({
          "residue-test": B8.core.set.has([
            B8.core.type.set(ResDict2.nucleic.concat(ResDict2.protein)),
            B8.ammp("label_comp_id")
          ])
        }),
        by: backboneExpr2()
      });
    }
  },
  present: {
    "@desc": "All atoms with defined coordinates in the current state (used in creating movies)",
    abbr: ["pr."]
  },
  center: {
    "@desc": "Pseudo-atom at the center of the scene"
  },
  origin: {
    "@desc": "Pseudo-atom at the origin of rotation"
  },
  enabled: {
    "@desc": "All enabled objects or selections from the object list."
  },
  masked: {
    "@desc": "All masked atoms.",
    abbr: ["msk."]
  },
  protected: {
    "@desc": "All protected atoms.",
    abbr: ["pr."]
  },
  bonded: {
    "@desc": "All bonded atoms",
    map: () => B8.struct.generator.atomGroups({
      "atom-test": B8.core.rel.gr([B8.struct.atomProperty.core.bondCount({
        flags: B8.struct.type.bondFlags(["covalent", "metallic", "sulfide"])
      }), 0])
    })
  },
  donors: {
    "@desc": "All hydrogen bond donor atoms.",
    abbr: ["don."]
  },
  acceptors: {
    "@desc": "All hydrogen bond acceptor atoms.",
    abbr: ["acc."]
  },
  fixed: {
    "@desc": "All fixed atoms.",
    abbr: ["fxd."]
  },
  restrained: {
    "@desc": "All restrained atoms.",
    abbr: ["rst."]
  },
  organic: {
    "@desc": "All atoms in non-polymer organic compounds (e.g. ligands, buffers). Finds carbon-containing molecules that do not match known polymers.",
    abbr: ["org."],
    map: () => asAtoms(B8.struct.modifier.expandProperty({
      "0": B8.struct.modifier.union([
        B8.struct.generator.queryInSelection({
          "0": B8.struct.generator.atomGroups({
            "residue-test": B8.core.logic.not([
              B8.core.set.has([
                B8.core.type.set(ResDict2.nucleic.concat(ResDict2.protein)),
                B8.ammp("label_comp_id")
              ])
            ])
          }),
          query: B8.struct.generator.atomGroups({
            "atom-test": B8.core.rel.eq([
              B8.es("C"),
              B8.acp("elementSymbol")
            ])
          })
        })
      ]),
      property: B8.ammp("residueKey")
    }))
  },
  inorganic: {
    "@desc": "All non-polymer inorganic atoms/ions. Finds atoms in molecules that do not contain carbon and do not match any known solvent residues.",
    abbr: ["ino."],
    map: () => asAtoms(B8.struct.modifier.expandProperty({
      "0": B8.struct.modifier.union([
        B8.struct.filter.pick({
          "0": B8.struct.generator.atomGroups({
            "residue-test": B8.core.logic.not([
              B8.core.set.has([
                B8.core.type.set(ResDict2.nucleic.concat(ResDict2.protein).concat(ResDict2.solvent)),
                B8.ammp("label_comp_id")
              ])
            ]),
            "group-by": B8.ammp("residueKey")
          }),
          test: B8.core.logic.not([
            B8.core.set.has([
              B8.struct.atomSet.propertySet([B8.acp("elementSymbol")]),
              B8.es("C")
            ])
          ])
        })
      ]),
      property: B8.ammp("residueKey")
    }))
  },
  solvent: {
    "@desc": "All water molecules. The hardcoded solvent residue identifiers are currently: HOH, WAT, H20, TIP, SOL.",
    abbr: ["sol."],
    map: () => B8.struct.generator.atomGroups({
      "residue-test": B8.core.set.has([
        B8.core.type.set(ResDict2.solvent),
        B8.ammp("label_comp_id")
      ])
    })
  },
  guide: {
    "@desc": "All protein CA and nucleic acid C4*/C4",
    map: () => B8.struct.combinator.merge([
      B8.struct.generator.atomGroups({
        "atom-test": B8.core.rel.eq([
          B8.atomName("CA"),
          B8.ammp("label_atom_id")
        ]),
        "residue-test": B8.core.set.has([
          B8.core.type.set(ResDict2.protein),
          B8.ammp("label_comp_id")
        ])
      }),
      B8.struct.generator.atomGroups({
        "atom-test": B8.core.set.has([
          atomNameSet(["C4*", "C4'"]),
          B8.ammp("label_atom_id")
        ]),
        "residue-test": B8.core.set.has([
          B8.core.type.set(ResDict2.nucleic),
          B8.ammp("label_comp_id")
        ])
      })
    ])
  },
  metals: {
    "@desc": "All metal atoms (new in PyMOL 1.6.1)"
  },
  backbone: {
    "@desc": "Polymer backbone atoms (new in PyMOL 1.6.1)",
    abbr: ["bb."],
    map: () => backboneExpr2()
  },
  "polymer.protein": {
    "@desc": "Protein (New in PyMOL 2.1)",
    abbr: ["polymer.protein"],
    map: () => B8.struct.generator.atomGroups({
      "residue-test": B8.core.set.has([
        B8.core.type.set(ResDict2.protein),
        B8.ammp("label_comp_id")
      ])
    })
  },
  "polymer.nucleic": {
    "@desc": "Nucleic Acid (New in PyMOL 2.1)",
    abbr: ["polymer.nucleic"],
    map: () => B8.struct.generator.atomGroups({
      "residue-test": B8.core.set.has([
        B8.core.type.set(ResDict2.nucleic),
        B8.ammp("label_comp_id")
      ])
    })
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/pymol/parser.js
var B9 = MolScriptBuilder;
var propertiesDict = getPropertyRules(properties2);
var slash = MonadicParser.string("/");
function orNull(rule) {
  return rule.or(MonadicParser.of(null));
}
function atomSelectionQuery(x) {
  const tests = {};
  const props = {};
  for (const k in x) {
    const ps = properties2[k];
    if (!ps) {
      throw new Error(`property '${k}' not supported, value '${x[k]}'`);
    }
    if (x[k] === null)
      continue;
    if (!props[ps.level])
      props[ps.level] = [];
    props[ps.level].push(x[k]);
  }
  for (const p in props) {
    tests[p] = andExpr(props[p]);
  }
  return B9.struct.generator.atomGroups(tests);
}
var lang2 = MonadicParser.createLanguage({
  Parens: function(r) {
    return MonadicParser.alt(r.Parens, r.Operator, r.Expression).wrap(MonadicParser.string("("), MonadicParser.string(")"));
  },
  Expression: function(r) {
    return MonadicParser.alt(r.Keywords, r.AtomSelectionMacro.map(atomSelectionQuery), r.NamedAtomProperties, r.Pepseq, r.Rep, r.Object);
  },
  AtomSelectionMacro: function(r) {
    return MonadicParser.alt(slash.then(MonadicParser.alt(MonadicParser.seq(orNull(r.ObjectProperty).skip(slash), orNull(propertiesDict.segi).skip(slash), orNull(propertiesDict.chain).skip(slash), orNull(propertiesDict.resi).skip(slash), orNull(propertiesDict.name)).map((x) => {
      return { object: x[0], segi: x[1], chain: x[2], resi: x[3], name: x[4] };
    }), MonadicParser.seq(orNull(r.ObjectProperty).skip(slash), orNull(propertiesDict.segi).skip(slash), orNull(propertiesDict.chain).skip(slash), orNull(propertiesDict.resi)).map((x) => {
      return { object: x[0], segi: x[1], chain: x[2], resi: x[3] };
    }), MonadicParser.seq(orNull(r.ObjectProperty).skip(slash), orNull(propertiesDict.segi).skip(slash), orNull(propertiesDict.chain)).map((x) => {
      return { object: x[0], segi: x[1], chain: x[2] };
    }), MonadicParser.seq(orNull(r.ObjectProperty).skip(slash), orNull(propertiesDict.segi)).map((x) => {
      return { object: x[0], segi: x[1] };
    }), MonadicParser.seq(orNull(r.ObjectProperty)).map((x) => {
      return { object: x[0] };
    }))), MonadicParser.alt(MonadicParser.seq(orNull(r.ObjectProperty).skip(slash), orNull(propertiesDict.segi).skip(slash), orNull(propertiesDict.chain).skip(slash), orNull(propertiesDict.resi).skip(slash), orNull(propertiesDict.name)).map((x) => {
      return { object: x[0], segi: x[1], chain: x[2], resi: x[3], name: x[4] };
    }), MonadicParser.seq(orNull(propertiesDict.segi).skip(slash), orNull(propertiesDict.chain).skip(slash), orNull(propertiesDict.resi).skip(slash), orNull(propertiesDict.name)).map((x) => {
      return { segi: x[0], chain: x[1], resi: x[2], name: x[3] };
    }), MonadicParser.seq(orNull(propertiesDict.chain).skip(slash), orNull(propertiesDict.resi).skip(slash), orNull(propertiesDict.name)).map((x) => {
      return { chain: x[0], resi: x[1], name: x[2] };
    }), MonadicParser.seq(orNull(propertiesDict.resi).skip(slash), orNull(propertiesDict.name)).map((x) => {
      return { resi: x[0], name: x[1] };
    })));
  },
  NamedAtomProperties: function() {
    return MonadicParser.alt(...getNamedPropertyRules(properties2));
  },
  Keywords: () => MonadicParser.alt(...getKeywordRules(keywords2)),
  ObjectProperty: () => {
    const w = getReservedWords(properties2, keywords2, operators2).sort(strLenSortFn).map(escapeRegExp).join("|");
    return MonadicParser.regexp(new RegExp(`(?!(${w}))[A-Z0-9_]+`, "i"));
  },
  Object: (r) => {
    return r.ObjectProperty.notFollowedBy(slash).map((x) => {
      throw new Error(`property 'object' not supported, value '${x}'`);
    });
  },
  // Selects peptide sequence matching upper-case one-letter
  // sequence SEQ (see also FindSeq).
  // PEPSEQ seq
  Pepseq: () => {
    return MonadicParser.regexp(/(PEPSEQ|ps\.)\s+([a-z]+)/i, 2).map(makeError(`operator 'pepseq' not supported`));
  },
  // Selects atoms which show representation rep.
  // REP rep
  Rep: () => {
    return MonadicParser.regexp(/REP\s+(lines|spheres|mesh|ribbon|cartoon|sticks|dots|surface|labels|extent|nonbonded|nb_spheres|slice|extent|slice|dashes|angles|dihedrals|cgo|cell|callback|everything)/i, 1).map(makeError(`operator 'rep' not supported`));
  },
  Operator: function(r) {
    return combineOperators(operators2, MonadicParser.alt(r.Parens, r.Expression, r.Operator));
  },
  Query: function(r) {
    return MonadicParser.alt(r.Operator, r.Parens, r.Expression).trim(MonadicParser.optWhitespace);
  }
});
var transpiler2 = (str3) => lang2.Query.tryParse(str3);

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/vmd/properties.js
var B10 = MolScriptBuilder;
var reFloat3 = /[-+]?[0-9]*\.?[0-9]+/;
var rePosInt2 = /[+]?[0-9]+/;
var reInt = /[-+]?[0-9]+/;
function str2(x) {
  return x;
}
var sstrucDict2 = {
  T: "turn",
  // Turn
  E: "sheet",
  // Extended conformation ($\beta$ sheets)
  B: "strand",
  // Isolated bridge
  H: "alpha",
  // Alpha helix
  G: "3-10",
  // 3-10 helix
  I: "pi",
  // Pi helix
  C: "none"
  // Coil
};
function sstrucMap(x) {
  return B10.struct.type.secondaryStructureFlags([sstrucDict2[x.toUpperCase()] || "none"]);
}
var properties3 = {
  name: {
    "@desc": "str    atom name",
    "@examples": ["name CA"],
    regex: /[a-zA-Z0-9]+/,
    map: B10.atomName,
    level: "atom-test",
    property: B10.ammp("label_atom_id")
  },
  type: {
    "@desc": "str    atom type",
    "@examples": ["type C3"],
    isUnsupported: true,
    regex: /[a-zA-Z0-9]+/,
    map: str2,
    level: "atom-test"
  },
  index: {
    "@desc": "num    the atom number, starting at 0",
    "@examples": ["index 10"],
    isNumeric: true,
    regex: rePosInt2,
    map: (x) => parseInt(x) - 1,
    level: "atom-test",
    property: B10.ammp("id")
  },
  serial: {
    "@desc": "num    the atom number, starting at 1",
    "@examples": ["serial 11"],
    isNumeric: true,
    regex: rePosInt2,
    map: (x) => parseInt(x),
    level: "atom-test",
    property: B10.ammp("id")
  },
  atomicnumber: {
    "@desc": "num    atomic number (0 if undefined)",
    "@examples": ["atomicnumber 13"],
    isNumeric: true,
    regex: rePosInt2,
    map: (x) => parseInt(x),
    level: "atom-test",
    property: B10.acp("atomicNumber")
  },
  element: {
    "@desc": 'str  atomic element symbol string ("X" if undefined)',
    "@examples": ["element N"],
    regex: /[a-zA-Z0-9]{1,3}/,
    map: (x) => B10.es(x),
    level: "atom-test",
    property: B10.acp("elementSymbol")
  },
  altloc: {
    "@desc": "str  alternate location/conformation identifier",
    "@examples": ["altloc C"],
    regex: /[a-zA-Z0-9]+/,
    map: str2,
    level: "atom-test",
    property: B10.ammp("label_alt_id")
  },
  chain: {
    "@desc": "str  the one-character chain identifier",
    "@examples": ["chain A"],
    regex: /[a-zA-Z0-9]+/,
    map: str2,
    level: "residue-test",
    property: B10.ammp("auth_asym_id")
  },
  residue: {
    "@desc": "num  a set of connected atoms with the same residue number",
    "@examples": ["residue < 11", "residue 11"],
    isNumeric: true,
    regex: reInt,
    map: (x) => parseInt(x),
    level: "residue-test",
    property: B10.ammp("auth_seq_id")
  },
  fragment: {
    "@desc": "num  a set of connected residues",
    "@examples": ["fragment 42"],
    isUnsupported: true,
    isNumeric: true,
    regex: reInt,
    map: (x) => parseInt(x),
    level: "residue-test"
  },
  pfrag: {
    "@desc": "num  a set of connected protein residues",
    "@examples": ["pfrag 42"],
    isUnsupported: true,
    isNumeric: true,
    regex: reInt,
    map: (x) => parseInt(x),
    level: "residue-test"
  },
  nfrag: {
    "@desc": "num  a set of connected nucleic residues",
    "@examples": ["nfrag 42"],
    isUnsupported: true,
    isNumeric: true,
    regex: reInt,
    map: (x) => parseInt(x),
    level: "residue-test"
  },
  sequence: {
    "@desc": "str  a sequence given by one letter names",
    "@examples": ["sequence PGATTACA"],
    isUnsupported: true,
    regex: /[a-zA-Z0-9]+/,
    map: str2,
    level: "residue-test"
  },
  numbonds: {
    "@desc": "num  number of bonds",
    "@examples": ["numbonds = 2", "numbonds >= 3"],
    isNumeric: true,
    regex: rePosInt2,
    map: (x) => parseInt(x),
    level: "atom-test",
    property: B10.acp("bondCount")
  },
  resname: {
    "@desc": "str  residue name",
    "@examples": ["resname ALA"],
    regex: /[a-zA-Z0-9]+/,
    map: str2,
    level: "residue-test",
    property: B10.ammp("auth_comp_id")
  },
  resid: {
    "@desc": "num  residue id",
    "@examples": ["resid 42"],
    isNumeric: true,
    regex: reInt,
    map: (x) => parseInt(x),
    level: "residue-test",
    property: B10.ammp("auth_seq_id")
  },
  segname: {
    "@desc": "str  segment name",
    "@examples": ["segname B"],
    regex: /[a-zA-Z0-9]+/,
    map: str2,
    level: "residue-test",
    property: B10.ammp("label_asym_id")
  },
  x: {
    "@desc": "float  x coordinate",
    "@examples": ["x 42"],
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B10.acp("x")
  },
  y: {
    "@desc": "float  y coordinate",
    "@examples": ["y > 1.7"],
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B10.acp("y")
  },
  z: {
    "@desc": "float  z coordinate",
    "@examples": ["z < 11", "z > -21"],
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B10.acp("z")
  },
  radius: {
    "@desc": "float  atomic radius",
    "@examples": ["radius > 1.3"],
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B10.acp("vdw")
  },
  mass: {
    "@desc": "float  atomic mass",
    "@examples": ["mass > 2"],
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B10.acp("mass")
  },
  charge: {
    "@desc": "float  atomic charge",
    "@examples": ["charge > 0", "charge 1"],
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B10.ammp("pdbx_formal_charge")
  },
  beta: {
    "@desc": "float  temperature factor",
    "@examples": ["beta < 20", "beta > 35"],
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B10.ammp("B_iso_or_equiv")
  },
  occupancy: {
    "@desc": "float  occupancy",
    "@examples": ["occupancy 1", "occupancy < 1"],
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseFloat(x),
    level: "atom-test",
    property: B10.ammp("occupancy")
  },
  user: {
    "@desc": "float  time-varying user-specified value",
    "@examples": ["user < 0.1"],
    isUnsupported: true,
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseFloat(x),
    level: "atom-test"
  },
  rasmol: {
    "@desc": "str  translates Rasmol selection string to VMD",
    "@examples": ["rasmol 'all'"],
    isUnsupported: true,
    regex: /[^']*/,
    map: str2,
    level: "atom-test"
  },
  structure: {
    "@desc": "str  single letter name for the secondary structure",
    "@examples": ["structure H", "structure H E"],
    regex: /T|E|B|H|G|I|C/i,
    map: sstrucMap,
    level: "atom-test",
    property: B10.ammp("secondaryStructureFlags")
  },
  phi: {
    "@desc": "float  phi backbone conformational angles",
    "@examples": ["phi < 160"],
    isUnsupported: true,
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseFloat(x),
    level: "residue-test"
  },
  psi: {
    "@desc": "float  psi backbone conformational angles",
    "@examples": ["psi < 160"],
    isUnsupported: true,
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseFloat(x),
    level: "residue-test"
  },
  ufx: {
    "@desc": "num  force to apply in the x coordinate",
    "@examples": ["ufx 1"],
    isUnsupported: true,
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseInt(x),
    level: "atom-test"
  },
  ufy: {
    "@desc": "num  force to apply in the y coordinate",
    "@examples": ["ufy 1"],
    isUnsupported: true,
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseInt(x),
    level: "atom-test"
  },
  ufz: {
    "@desc": "num  force to apply in the z coordinate",
    "@examples": ["ufz 1"],
    isUnsupported: true,
    isNumeric: true,
    regex: reFloat3,
    map: (x) => parseInt(x),
    level: "atom-test"
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/vmd/operators.js
var B11 = MolScriptBuilder;
var propNames = Object.keys(properties3).sort(strLenSortFn).filter((name) => !properties3[name].isUnsupported).join("|");
var operators3 = [
  {
    "@desc": "Selects atoms that are not included in s1.",
    "@examples": ["not protein"],
    name: "not",
    type: prefix,
    rule: MonadicParser.regexp(/NOT/i).skip(MonadicParser.whitespace),
    map: (op2, selection) => invertExpr(selection)
  },
  {
    "@desc": "Selects atoms within a specified distance of a selection",
    "@examples": ["within 5 of name FE"],
    name: "within",
    type: prefix,
    rule: prefixOp(/WITHIN\s+([-+]?[0-9]*\.?[0-9]+)\s+OF/i, 1).map((x) => parseFloat(x)),
    map: (radius, selection) => {
      return B11.struct.modifier.includeSurroundings({ 0: selection, radius });
    }
  },
  {
    "@desc": "Exclusive within, equivalent to (within 3 of X) and not X",
    "@examples": ["exwithin 10 of resname HEM"],
    name: "exwithin",
    type: prefix,
    rule: prefixOp(/EXWITHIN\s+([-+]?[0-9]*\.?[0-9]+)\s+OF/i, 1).map((x) => parseFloat(x)),
    map: (radius, target) => {
      return B11.struct.modifier.exceptBy({
        "0": B11.struct.modifier.includeSurroundings({ 0: target, radius }),
        by: target
      });
    }
  },
  {
    "@desc": "Selects atoms which have the same keyword as the atoms in a given selection",
    "@examples": ["same resid as name FE"],
    name: "same",
    type: prefix,
    rule: prefixOp(new RegExp(`SAME\\s+(${propNames})\\s+AS`, "i"), 1).map((x) => properties3[x].property),
    map: (property, source) => {
      return B11.struct.filter.withSameAtomProperties({
        "0": B11.struct.generator.all(),
        source,
        property
      });
    }
  },
  {
    "@desc": "Selects atoms included in both s1 and s2.",
    "@examples": ["backbone and protein"],
    name: "and",
    type: binaryLeft,
    rule: MonadicParser.alt(infixOp(/AND/i), MonadicParser.whitespace),
    map: (op2, selection, by) => B11.struct.modifier.intersectBy({ 0: selection, by })
  },
  {
    "@desc": "Selects atoms included in either s1 or s2.",
    "@examples": ["water or protein"],
    name: "or",
    type: binaryLeft,
    rule: infixOp(/OR/i),
    map: (op2, s1, s2) => B11.struct.combinator.merge([s1, s2])
  }
];

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/vmd/keywords.js
var B12 = MolScriptBuilder;
function proteinExpr2() {
  return B12.struct.filter.pick({
    0: B12.struct.generator.atomGroups({
      "group-by": B12.ammp("residueKey")
    }),
    test: B12.core.set.isSubset([
      atomNameSet(["C", "N", "CA", "O"]),
      B12.ammpSet("label_atom_id")
    ])
  });
}
function nucleicExpr2() {
  return B12.struct.filter.pick({
    0: B12.struct.generator.atomGroups({
      "group-by": B12.ammp("residueKey")
    }),
    test: B12.core.logic.and([
      B12.core.set.isSubset([
        atomNameSet(["P"]),
        B12.ammpSet("label_atom_id")
      ]),
      B12.core.logic.or([
        B12.core.set.isSubset([
          atomNameSet(["O3'", "C3'", "C4'", "C5'", "O5'"]),
          B12.ammpSet("label_atom_id")
        ]),
        B12.core.set.isSubset([
          atomNameSet(["O3*", "C3*", "C4*", "C5*", "O5*"]),
          B12.ammpSet("label_atom_id")
        ])
      ])
    ])
  });
}
function backboneExpr3() {
  return B12.struct.combinator.merge([
    B12.struct.generator.queryInSelection({
      0: proteinExpr2(),
      query: B12.struct.generator.atomGroups({
        "atom-test": B12.core.set.has([
          atomNameSet(Backbone3.protein),
          B12.ammp("label_atom_id")
        ])
      })
    }),
    B12.struct.generator.queryInSelection({
      0: nucleicExpr2(),
      query: B12.struct.generator.atomGroups({
        "atom-test": B12.core.set.has([
          atomNameSet(Backbone3.nucleic),
          B12.ammp("label_atom_id")
        ])
      })
    })
  ]);
}
function secStrucExpr(flags) {
  return B12.struct.generator.atomGroups({
    "residue-test": B12.core.flags.hasAll([
      B12.ammp("secondaryStructureFlags"),
      B12.struct.type.secondaryStructureFlags(flags)
    ])
  });
}
var Backbone3 = {
  nucleic: ["P", "O3'", "O5'", "C5'", "C4'", "C3'", "OP1", "OP2", "O3*", "O5*", "C5*", "C4*", "C3*"],
  protein: ["C", "N", "CA", "O"]
};
var ResDict3 = {
  acidic: ["ASP", "GLU"],
  aliphatic: ["ALA", "GLY", "ILE", "LEU", "VAL"],
  aromatic: ["HIS", "PHE", "TRP", "TYR"],
  at: ["ADA", "A", "THY", "T"],
  basic: ["ARG", "HIS", "LYS"],
  buried: ["ALA", "LEU", "VAL", "ILE", "PHE", "CYS", "MET", "TRP"],
  cg: ["CYT", "C", "GUA", "G"],
  cyclic: ["HIS", "PHE", "PRO", "TRP", "TYR"],
  hydrophobic: ["ALA", "LEU", "VAL", "ILE", "PRO", "PHE", "MET", "TRP"],
  medium: ["VAL", "THR", "ASP", "ASN", "PRO", "CYS", "ASX", "PCA", "HYP"],
  neutral: ["VAL", "PHE", "GLN", "TYR", "HIS", "CYS", "MET", "TRP", "ASX", "GLX", "PCA", "HYP"],
  purine: ["ADE", "A", "GUA", "G"],
  pyrimidine: ["CYT", "C", "THY", "T", "URI", "U"],
  small: ["ALA", "GLY", "SER"],
  water: ["H2O", "HH0", "OHH", "HOH", "OH2", "SOL", "WAT", "TIP", "TIP2", "TIP3", "TIP4"]
};
var keywords3 = {
  all: {
    "@desc": "everything",
    map: () => B12.struct.generator.all()
  },
  none: {
    "@desc": "nothing",
    map: () => B12.struct.generator.empty()
  },
  protein: {
    "@desc": "a residue with atoms named C, N, CA, and O",
    map: () => proteinExpr2()
  },
  nucleic: {
    "@desc": "a residue with atoms named P, O1P, O2P and either O3', C3', C4', C5', O5' or O3*, C3*, C4*, C5*, O5*. This definition assumes that the base is phosphorylated, an assumption which will be corrected in the future.",
    map: () => nucleicExpr2()
  },
  backbone: {
    "@desc": "the C, N, CA, and O atoms of a protein and the equivalent atoms in a nucleic acid.",
    map: () => backboneExpr3()
  },
  sidechain: {
    "@desc": "non-backbone atoms and bonds",
    // TODO: what does 'bonds' mean here?
    map: () => invertExpr(backboneExpr3())
  },
  water: {
    "@desc": "all atoms with the resname H2O, HH0, OHH, HOH, OH2, SOL, WAT, TIP, TIP2, TIP3 or TIP4",
    abbr: ["waters"],
    map: () => resnameExpr(ResDict3.water)
  },
  at: {
    "@desc": "residues named ADA A THY T",
    map: () => resnameExpr(ResDict3.at)
  },
  acidic: {
    "@desc": "residues named ASP GLU",
    map: () => resnameExpr(ResDict3.acidic)
  },
  acyclic: {
    "@desc": '"protein and not cyclic"',
    map: () => B12.struct.modifier.intersectBy({
      0: proteinExpr2(),
      by: invertExpr(resnameExpr(ResDict3.cyclic))
    })
  },
  aliphatic: {
    "@desc": "residues named ALA GLY ILE LEU VAL",
    map: () => resnameExpr(ResDict3.aliphatic)
  },
  alpha: {
    "@desc": "atom's residue is an alpha helix",
    map: () => secStrucExpr(["alpha"])
  },
  amino: {
    "@desc": "a residue with atoms named C, N, CA, and O",
    map: () => proteinExpr2()
  },
  aromatic: {
    "@desc": "residues named HIS PHE TRP TYR",
    map: () => resnameExpr(ResDict3.aromatic)
  },
  basic: {
    "@desc": "residues named ARG HIS LYS",
    map: () => resnameExpr(ResDict3.basic)
  },
  bonded: {
    "@desc": "atoms for which numbonds > 0",
    map: () => asAtoms(B12.struct.filter.pick({
      "0": B12.struct.modifier.includeConnected({
        "0": B12.struct.generator.all(),
        "bond-test": B12.core.flags.hasAny([
          B12.struct.bondProperty.flags(),
          B12.struct.type.bondFlags(["covalent", "metallic", "sulfide"])
        ])
      }),
      test: B12.core.rel.gr([
        B12.struct.atomSet.atomCount(),
        1
      ])
    }))
  },
  buried: {
    "@desc": "residues named ALA LEU VAL ILE PHE CYS MET TRP",
    map: () => resnameExpr(ResDict3.buried)
  },
  cg: {
    "@desc": "residues named CYT C GUA G",
    map: () => resnameExpr(ResDict3.cg)
  },
  charged: {
    "@desc": '"basic or acidic"',
    map: () => resnameExpr(ResDict3.basic.concat(ResDict3.acidic))
  },
  cyclic: {
    "@desc": "residues named HIS PHE PRO TRP TYR",
    map: () => resnameExpr(ResDict3.cyclic)
  },
  hetero: {
    "@desc": '"not (protein or nucleic)"',
    map: () => invertExpr(B12.struct.combinator.merge([proteinExpr2(), nucleicExpr2()]))
  },
  hydrogen: {
    "@desc": 'name "[0-9]?H.*"',
    map: () => B12.struct.generator.atomGroups({
      "atom-test": B12.core.str.match([
        B12.core.type.regex(["^[0-9]?[H].*$", "i"]),
        B12.core.type.str([B12.ammp("label_atom_id")])
      ])
    })
  },
  large: {
    "@desc": '"protein and not (small or medium)"',
    map: () => B12.struct.modifier.intersectBy({
      0: proteinExpr2(),
      by: invertExpr(resnameExpr(ResDict3.small.concat(ResDict3.medium)))
    })
  },
  medium: {
    "@desc": "residues named VAL THR ASP ASN PRO CYS ASX PCA HYP",
    map: () => resnameExpr(ResDict3.medium)
  },
  neutral: {
    "@desc": "residues named VAL PHE GLN TYR HIS CYS MET TRP ASX GLX PCA HYP",
    map: () => resnameExpr(ResDict3.neutral)
  },
  hydrophobic: {
    "@desc": "hydrophobic resname ALA LEU VAL ILE PRO PHE MET TRP",
    map: () => resnameExpr(ResDict3.hydrophobic)
  },
  polar: {
    "@desc": '"protein and not hydrophobic"',
    map: () => B12.struct.modifier.intersectBy({
      0: proteinExpr2(),
      by: invertExpr(resnameExpr(ResDict3.hydrophobic))
    })
  },
  purine: {
    "@desc": "residues named ADE A GUA G",
    map: () => resnameExpr(ResDict3.purine)
  },
  pyrimidine: {
    "@desc": "residues named CYT C THY T URI U",
    map: () => resnameExpr(ResDict3.pyrimidine)
  },
  small: {
    "@desc": "residues named ALA GLY SER",
    map: () => resnameExpr(ResDict3.small)
  },
  surface: {
    "@desc": '"protein and not buried"',
    map: () => B12.struct.modifier.intersectBy({
      0: proteinExpr2(),
      by: invertExpr(resnameExpr(ResDict3.buried))
    })
  },
  alpha_helix: {
    "@desc": "atom's residue is in an alpha helix",
    map: () => secStrucExpr(["alpha"])
  },
  pi_helix: {
    "@desc": "atom's residue is in a pi helix",
    map: () => secStrucExpr(["pi"])
  },
  helix_3_10: {
    "@desc": "atom's residue is in a 3-10 helix",
    map: () => secStrucExpr(["3-10"])
  },
  helix: {
    "@desc": "atom's residue is in an alpha or pi or 3-10 helix",
    map: () => secStrucExpr(["helix"])
  },
  extended_beta: {
    "@desc": "atom's residue is a beta sheet",
    map: () => secStrucExpr(["sheet"])
  },
  bridge_beta: {
    "@desc": "atom's residue is a beta sheet",
    map: () => secStrucExpr(["strand"])
  },
  sheet: {
    "@desc": "atom's residue is a beta sheet",
    map: () => secStrucExpr(["beta"])
  },
  turn: {
    "@desc": "atom's residue is in a turn conformation",
    map: () => secStrucExpr(["turn"])
  },
  coil: {
    "@desc": "atom's residue is in a coil conformation",
    map: () => B12.struct.modifier.intersectBy({
      0: proteinExpr2(),
      by: secStrucExpr(["none"])
    })
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/vmd/functions.js
var B13 = MolScriptBuilder;
var functions = {
  "sqr": {
    "@desc": "square of x",
    "@examples": ["sqr(2)"],
    map: (x) => B13.core.math.pow([x, 2])
  },
  "sqrt": {
    "@desc": "square root of x",
    "@examples": ["sqrt(2)"],
    map: (x) => B13.core.math.sqrt([x])
  },
  "abs": {
    "@desc": "absolute value of x",
    "@examples": ["abs(2)"],
    map: (x) => B13.core.math.abs([x])
  },
  "floor": {
    "@desc": "largest integer not greater than x",
    "@examples": ["floor(2)"],
    map: (x) => B13.core.math.floor([x])
  },
  "ceil": {
    "@desc": "smallest integer not less than x",
    "@examples": ["ceil(2)"],
    map: (x) => B13.core.math.ceil([x])
  },
  "sin": {
    "@desc": "sine of x",
    "@examples": ["sin(2)"],
    map: (x) => B13.core.math.sin([x])
  },
  "cos": {
    "@desc": "cosine of x",
    "@examples": ["cos(2)"],
    map: (x) => B13.core.math.cos([x])
  },
  "tan": {
    "@desc": "tangent of x",
    "@examples": ["tan(2)"],
    map: (x) => B13.core.math.tan([x])
  },
  "atan": {
    "@desc": "arctangent of x",
    "@examples": ["atan(2)"],
    map: (x) => B13.core.math.atan([x])
  },
  "asin": {
    "@desc": "arcsin of x",
    "@examples": ["asin(2)"],
    map: (x) => B13.core.math.asin([x])
  },
  "acos": {
    "@desc": "arccos of x",
    "@examples": ["acos(2)"],
    map: (x) => B13.core.math.acos([x])
  },
  "sinh": {
    "@desc": "hyperbolic sine of x",
    "@examples": ["sinh(2)"],
    map: (x) => B13.core.math.sinh([x])
  },
  "cosh": {
    "@desc": "hyperbolic cosine of x",
    "@examples": ["cosh(2)"],
    map: (x) => B13.core.math.cosh([x])
  },
  "tanh": {
    "@desc": "hyperbolic tangent of x",
    "@examples": ["tanh(2)"],
    map: (x) => B13.core.math.tanh([x])
  },
  "exp": {
    "@desc": "e to the power x",
    "@examples": ["exp(2)"],
    map: (x) => B13.core.math.exp([x])
  },
  "log": {
    "@desc": "natural log of x",
    "@examples": ["log(2)"],
    map: (x) => B13.core.math.log([x])
  },
  "log10": {
    "@desc": "log base 10 of x",
    "@examples": ["log10(2)"],
    map: (x) => B13.core.math.log10([x])
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/vmd/parser.js
var B14 = MolScriptBuilder;
var valueOperators2 = [
  {
    "@desc": "multiplication, division",
    "@examples": [],
    name: "mul-div",
    type: binaryLeft,
    rule: MonadicParser.regexp(/\s*(\*|\/)\s*/, 1),
    map: (op2, e1, e2) => {
      switch (op2) {
        case "*":
          return B14.core.math.mult([e1, e2]);
        case "/":
          return B14.core.math.div([e1, e2]);
        default:
          throw new Error(`value operator '${op2}' not supported`);
      }
    }
  },
  {
    "@desc": "addition, substraction",
    "@examples": [],
    name: "add-sub",
    type: binaryLeft,
    rule: MonadicParser.regexp(/\s*(-|\+)\s*/, 1),
    map: (op2, e1, e2) => {
      switch (op2) {
        case "-":
          return B14.core.math.sub([e1, e2]);
        case "+":
          return B14.core.math.add([e1, e2]);
        default:
          throw new Error(`value operator '${op2}' not supported`);
      }
    }
  },
  {
    "@desc": "value comparisons",
    "@examples": [],
    name: "comparison",
    type: binaryLeft,
    rule: MonadicParser.alt(MonadicParser.regexp(/\s*(=~|==|>=|<=|=|!=|>|<)\s*/, 1), MonadicParser.whitespace.result("=")),
    map: (op2, e1, e2) => {
      let expr;
      if (e1.head !== void 0) {
        if (e1.head.name === "structure-query.atom-property.macromolecular.secondary-structure-flags") {
          expr = B14.core.flags.hasAny([e1, sstrucMap(e2)]);
        }
        if (e1.head.name === "core.type.regex") {
          expr = B14.core.str.match([e1, B14.core.type.str([e2])]);
        }
      } else if (e2.head !== void 0) {
        if (e2.head.name === "structure-query.atom-property.macromolecular.secondary-structure-flags") {
          expr = B14.core.flags.hasAny([e2, sstrucMap(e1)]);
        }
        if (e2.head.name === "core.type.regex") {
          expr = B14.core.str.match([e2, B14.core.type.str([e1])]);
        }
      } else if (op2 === "=~") {
        if (e1.head) {
          expr = B14.core.str.match([
            B14.core.type.regex([`^${e2}$`, "i"]),
            B14.core.type.str([e1])
          ]);
        } else {
          expr = B14.core.str.match([
            B14.core.type.regex([`^${e1}$`, "i"]),
            B14.core.type.str([e2])
          ]);
        }
      }
      if (!expr) {
        if (e1.head)
          e2 = wrapValue(e1, e2);
        if (e2.head)
          e1 = wrapValue(e2, e1);
        switch (op2) {
          case "=":
          case "==":
            expr = B14.core.rel.eq([e1, e2]);
            break;
          case "!=":
            expr = B14.core.rel.neq([e1, e2]);
            break;
          case ">":
            expr = B14.core.rel.gr([e1, e2]);
            break;
          case "<":
            expr = B14.core.rel.lt([e1, e2]);
            break;
          case ">=":
            expr = B14.core.rel.gre([e1, e2]);
            break;
          case "<=":
            expr = B14.core.rel.lte([e1, e2]);
            break;
          default:
            throw new Error(`value operator '${op2}' not supported`);
        }
      }
      return B14.struct.generator.atomGroups({ "atom-test": expr });
    }
  }
];
var lang3 = MonadicParser.createLanguage({
  Parens: function(r) {
    return MonadicParser.alt(r.Parens, r.Operator, r.Expression).wrap(MonadicParser.string("("), MonadicParser.string(")"));
  },
  Expression: function(r) {
    return MonadicParser.alt(
      r.RangeListProperty,
      //	    r.NamedAtomProperties,
      r.ValueQuery,
      r.Keywords
    );
  },
  NamedAtomProperties: function() {
    return MonadicParser.alt(...getNamedPropertyRules(properties3));
  },
  Keywords: () => MonadicParser.alt(...getKeywordRules(keywords3)),
  ValueRange: function(r) {
    return MonadicParser.seq(r.Value.skip(MonadicParser.regexp(/\s+TO\s+/i)), r.Value).map((x) => ({ range: x }));
  },
  RangeListProperty: function(r) {
    return MonadicParser.seq(MonadicParser.alt(...getPropertyNameRules(properties3, /\s/)).skip(MonadicParser.whitespace), MonadicParser.alt(r.ValueRange, r.Value).sepBy1(MonadicParser.whitespace)).map((x) => {
      const [property, values2] = x;
      const listValues = [];
      const rangeValues = [];
      values2.forEach((v3) => {
        if (v3.range) {
          rangeValues.push(B14.core.rel.inRange([property, v3.range[0], v3.range[1]]));
        } else {
          listValues.push(wrapValue(property, v3, sstrucDict2));
        }
      });
      const rangeTest = orExpr(rangeValues);
      const listTest = valuesTest(property, listValues);
      let test;
      if (rangeTest && listTest) {
        test = B14.core.logic.or([rangeTest, listTest]);
      } else {
        test = rangeTest ? rangeTest : listTest;
      }
      return B14.struct.generator.atomGroups({ [testLevel(property)]: test });
    });
  },
  Operator: function(r) {
    return combineOperators(operators3, MonadicParser.alt(r.Parens, r.Expression, r.ValueQuery));
  },
  Query: function(r) {
    return MonadicParser.alt(r.Operator, r.Parens, r.Expression).trim(MonadicParser.optWhitespace);
  },
  Number: function() {
    return MonadicParser.regexp(/-?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?/).map(Number).desc("number");
  },
  String: function() {
    const w = getReservedWords(properties3, keywords3, operators3).sort(strLenSortFn).map(escapeRegExp).join("|");
    return MonadicParser.alt(MonadicParser.regexp(new RegExp(`(?!(${w}))[A-Z0-9_]+`, "i")), MonadicParser.regexp(/'((?:[^"\\]|\\.)*)'/, 1), MonadicParser.regexp(/"((?:[^"\\]|\\.)*)"/, 1).map((x) => B14.core.type.regex([`^${x}$`, "i"]))).desc("string");
  },
  Value: function(r) {
    return MonadicParser.alt(r.Number, r.String);
  },
  ValueParens: function(r) {
    return MonadicParser.alt(r.ValueParens, r.ValueOperator, r.ValueExpressions).wrap(MonadicParser.string("("), MonadicParser.string(")"));
  },
  ValuePropertyNames: function() {
    return MonadicParser.alt(...getPropertyNameRules(properties3, /=~|==|>=|<=|=|!=|>|<|\)|\s|\+|-|\*|\//i));
  },
  ValueOperator: function(r) {
    return combineOperators(valueOperators2, MonadicParser.alt(r.ValueParens, r.ValueExpressions));
  },
  ValueExpressions: function(r) {
    return MonadicParser.alt(r.ValueFunctions, r.Value, r.ValuePropertyNames);
  },
  ValueFunctions: function(r) {
    return MonadicParser.alt(...getFunctionRules(functions, r.ValueOperator));
  },
  ValueQuery: function(r) {
    return MonadicParser.alt(r.ValueOperator.map((x) => {
      if (!x.head.name || !x.head.name.startsWith("structure-query.generator")) {
        throw new Error(`values must be part of an comparison, value '${x}'`);
      } else {
        return x;
      }
    }));
  }
});
var transpiler3 = (str3) => lang3.Query.tryParse(str3);

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpilers/all.js
var _transpiler = {
  pymol: transpiler2,
  vmd: transpiler3,
  jmol: transpiler
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/transpile.js
var transpiler4 = _transpiler;
function parse3(lang4, str3) {
  try {
    const query = transpiler4[lang4](str3);
    return query;
  } catch (e) {
    console.error(e.message);
    throw e;
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/runtime/query/table.js
var C = QuerySymbolRuntime.Const;
var D = QuerySymbolRuntime.Dynamic;
var symbols = [
  // ============= TYPES =============
  C(MolScriptSymbolTable.core.type.bool, function core_type_bool(ctx, v3) {
    return !!v3[0](ctx);
  }),
  C(MolScriptSymbolTable.core.type.num, function core_type_num(ctx, v3) {
    return +v3[0](ctx);
  }),
  C(MolScriptSymbolTable.core.type.str, function core_type_str(ctx, v3) {
    return "" + v3[0](ctx);
  }),
  C(MolScriptSymbolTable.core.type.list, function core_type_list(ctx, xs) {
    return QueryRuntimeArguments.forEachEval(xs, ctx, (v3, i, list2) => list2[i] = v3, []);
  }),
  C(MolScriptSymbolTable.core.type.set, function core_type_set(ctx, xs) {
    return QueryRuntimeArguments.forEachEval(xs, ctx, function core_type_set_argEval(v3, i, set4) {
      return set4.add(v3);
    }, /* @__PURE__ */ new Set());
  }),
  C(MolScriptSymbolTable.core.type.regex, function core_type_regex(ctx, v3) {
    return new RegExp(v3[0](ctx), v3[1] && v3[1](ctx) || "");
  }),
  C(MolScriptSymbolTable.core.type.bitflags, function core_type_bitflags(ctx, v3) {
    return +v3[0](ctx);
  }),
  C(MolScriptSymbolTable.core.type.compositeKey, function core_type_compositeKey(ctx, xs) {
    return QueryRuntimeArguments.forEachEval(xs, ctx, (v3, i, list2) => list2[i] = "" + v3, []).join("-");
  }),
  // ============= LOGIC ================
  C(MolScriptSymbolTable.core.logic.not, (ctx, v3) => !v3[0](ctx)),
  C(MolScriptSymbolTable.core.logic.and, (ctx, xs) => {
    if (typeof xs.length === "number") {
      for (let i = 0, _i = xs.length; i < _i; i++)
        if (!xs[i](ctx))
          return false;
    } else {
      for (const k of Object.keys(xs))
        if (!xs[k](ctx))
          return false;
    }
    return true;
  }),
  C(MolScriptSymbolTable.core.logic.or, (ctx, xs) => {
    if (typeof xs.length === "number") {
      for (let i = 0, _i = xs.length; i < _i; i++)
        if (xs[i](ctx))
          return true;
    } else {
      for (const k of Object.keys(xs))
        if (xs[k](ctx))
          return true;
    }
    return false;
  }),
  // ============= RELATIONAL ================
  C(MolScriptSymbolTable.core.rel.eq, (ctx, v3) => v3[0](ctx) === v3[1](ctx)),
  C(MolScriptSymbolTable.core.rel.neq, (ctx, v3) => v3[0](ctx) !== v3[1](ctx)),
  C(MolScriptSymbolTable.core.rel.lt, (ctx, v3) => v3[0](ctx) < v3[1](ctx)),
  C(MolScriptSymbolTable.core.rel.lte, (ctx, v3) => v3[0](ctx) <= v3[1](ctx)),
  C(MolScriptSymbolTable.core.rel.gr, (ctx, v3) => v3[0](ctx) > v3[1](ctx)),
  C(MolScriptSymbolTable.core.rel.gre, (ctx, v3) => v3[0](ctx) >= v3[1](ctx)),
  C(MolScriptSymbolTable.core.rel.inRange, (ctx, v3) => {
    const x = v3[0](ctx);
    return x >= v3[1](ctx) && x <= v3[2](ctx);
  }),
  // ============= ARITHMETIC ================
  C(MolScriptSymbolTable.core.math.add, (ctx, xs) => {
    let ret = 0;
    if (typeof xs.length === "number") {
      for (let i = 0, _i = xs.length; i < _i; i++)
        ret += xs[i](ctx);
    } else {
      for (const k of Object.keys(xs))
        ret += xs[k](ctx);
    }
    return ret;
  }),
  C(MolScriptSymbolTable.core.math.sub, (ctx, xs) => {
    let ret = 0;
    if (typeof xs.length === "number") {
      if (xs.length === 1)
        return -xs[0](ctx);
      ret = xs[0](ctx) || 0;
      for (let i = 1, _i = xs.length; i < _i; i++)
        ret -= xs[i](ctx);
    } else {
      const keys2 = Object.keys(xs);
      if (keys2.length === 1)
        return -xs[keys2[0]](ctx);
      ret = xs[keys2[0]](ctx) || 0;
      for (let i = 1, _i = keys2.length; i < _i; i++)
        ret -= xs[keys2[i]](ctx);
    }
    return ret;
  }),
  C(MolScriptSymbolTable.core.math.mult, (ctx, xs) => {
    let ret = 1;
    if (typeof xs.length === "number") {
      for (let i = 0, _i = xs.length; i < _i; i++)
        ret *= xs[i](ctx);
    } else {
      for (const k of Object.keys(xs))
        ret *= xs[k](ctx);
    }
    return ret;
  }),
  C(MolScriptSymbolTable.core.math.div, (ctx, v3) => v3[0](ctx) / v3[1](ctx)),
  C(MolScriptSymbolTable.core.math.pow, (ctx, v3) => Math.pow(v3[0](ctx), v3[1](ctx))),
  C(MolScriptSymbolTable.core.math.mod, (ctx, v3) => v3[0](ctx) % v3[1](ctx)),
  C(MolScriptSymbolTable.core.math.min, (ctx, xs) => {
    let ret = Number.POSITIVE_INFINITY;
    if (typeof xs.length === "number") {
      for (let i = 0, _i = xs.length; i < _i; i++)
        ret = Math.min(xs[i](ctx), ret);
    } else {
      for (const k of Object.keys(xs))
        ret = Math.min(xs[k](ctx), ret);
    }
    return ret;
  }),
  C(MolScriptSymbolTable.core.math.max, (ctx, xs) => {
    let ret = Number.NEGATIVE_INFINITY;
    if (typeof xs.length === "number") {
      for (let i = 0, _i = xs.length; i < _i; i++)
        ret = Math.max(xs[i](ctx), ret);
    } else {
      for (const k of Object.keys(xs))
        ret = Math.max(xs[k](ctx), ret);
    }
    return ret;
  }),
  C(MolScriptSymbolTable.core.math.cantorPairing, (ctx, v3) => cantorPairing(v3[0](ctx), v3[1](ctx))),
  C(MolScriptSymbolTable.core.math.sortedCantorPairing, (ctx, v3) => sortedCantorPairing(v3[0](ctx), v3[1](ctx))),
  C(MolScriptSymbolTable.core.math.invertCantorPairing, (ctx, v3) => invertCantorPairing([0, 0], v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.floor, (ctx, v3) => Math.floor(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.ceil, (ctx, v3) => Math.ceil(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.roundInt, (ctx, v3) => Math.round(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.trunc, (ctx, v3) => Math.trunc(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.abs, (ctx, v3) => Math.abs(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.sign, (ctx, v3) => Math.sign(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.sqrt, (ctx, v3) => Math.sqrt(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.cbrt, (ctx, v3) => Math.cbrt(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.sin, (ctx, v3) => Math.sin(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.cos, (ctx, v3) => Math.cos(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.tan, (ctx, v3) => Math.tan(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.asin, (ctx, v3) => Math.asin(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.acos, (ctx, v3) => Math.acos(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.atan, (ctx, v3) => Math.atan(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.sinh, (ctx, v3) => Math.sinh(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.cosh, (ctx, v3) => Math.cosh(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.tanh, (ctx, v3) => Math.tanh(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.exp, (ctx, v3) => Math.exp(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.log, (ctx, v3) => Math.log(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.log10, (ctx, v3) => Math.log10(v3[0](ctx))),
  C(MolScriptSymbolTable.core.math.atan2, (ctx, v3) => Math.atan2(v3[0](ctx), v3[1](ctx))),
  // ============= STRING ================
  C(MolScriptSymbolTable.core.str.match, (ctx, v3) => v3[0](ctx).test(v3[1](ctx))),
  C(MolScriptSymbolTable.core.str.concat, (ctx, xs) => {
    const ret = [];
    if (typeof xs.length === "number") {
      for (let i = 0, _i = xs.length; i < _i; i++)
        ret.push(xs[i](ctx).toString());
    } else {
      for (const k of Object.keys(xs))
        ret.push(xs[k](ctx).toString());
    }
    return ret.join("");
  }),
  // ============= LIST ================
  C(MolScriptSymbolTable.core.list.getAt, (ctx, v3) => v3[0](ctx)[v3[1](ctx)]),
  C(MolScriptSymbolTable.core.list.equal, (ctx, v3) => arrayEqual(v3[0](ctx), v3[1](ctx))),
  // ============= SET ================
  C(MolScriptSymbolTable.core.set.has, function core_set_has(ctx, v3) {
    return v3[0](ctx).has(v3[1](ctx));
  }),
  C(MolScriptSymbolTable.core.set.isSubset, function core_set_isSubset(ctx, v3) {
    return SetUtils.isSuperset(v3[1](ctx), v3[0](ctx));
  }),
  // ============= FLAGS ================
  C(MolScriptSymbolTable.core.flags.hasAny, (ctx, v3) => {
    const test = v3[1](ctx);
    const tested = v3[0](ctx);
    if (!test)
      return !!tested;
    return (tested & test) !== 0;
  }),
  C(MolScriptSymbolTable.core.flags.hasAll, (ctx, v3) => {
    const test = v3[1](ctx);
    const tested = v3[0](ctx);
    if (!test)
      return !tested;
    return (tested & test) === test;
  }),
  // Structure
  // ============= TYPES ================
  C(MolScriptSymbolTable.structureQuery.type.elementSymbol, (ctx, v3) => ElementSymbol(v3[0](ctx))),
  C(MolScriptSymbolTable.structureQuery.type.atomName, (ctx, v3) => upperCaseAny(v3[0](ctx))),
  C(MolScriptSymbolTable.structureQuery.type.bondFlags, (ctx, xs) => {
    let ret = BondType.Flag.None;
    if (typeof xs.length === "number") {
      for (let i = 0, _i = xs.length; i < _i; i++)
        ret = bondFlag(ret, xs[i](ctx));
    } else {
      for (const k of Object.keys(xs))
        ret = bondFlag(ret, xs[k](ctx));
    }
    return ret;
  }),
  C(MolScriptSymbolTable.structureQuery.type.ringFingerprint, (ctx, xs) => UnitRing.elementFingerprint(getArray(ctx, xs))),
  C(MolScriptSymbolTable.structureQuery.type.secondaryStructureFlags, (ctx, xs) => {
    let ret = SecondaryStructureType.Flag.None;
    if (typeof xs.length === "number") {
      for (let i = 0, _i = xs.length; i < _i; i++)
        ret = secondaryStructureFlag(ret, xs[i](ctx));
    } else {
      for (const k of Object.keys(xs))
        ret = secondaryStructureFlag(ret, xs[k](ctx));
    }
    return ret;
  }),
  // TODO:
  // C(MolScript.structureQuery.type.entityType, (ctx, v) => StructureRuntime.Common.entityType(v[0](ctx))),
  // C(MolScript.structureQuery.type.authResidueId, (ctx, v) => ResidueIdentifier.auth(v[0](ctx), v[1](ctx), v[2] && v[2](ctx))),
  // C(MolScript.structureQuery.type.labelResidueId, (ctx, v) => ResidueIdentifier.label(v[0](ctx), v[1](ctx), v[2](ctx), v[3] && v[3](ctx))),
  // ============= SLOTS ================
  // TODO: slots might not be needed after all: reducer simply pushes/pops current element
  // C(MolScript.structureQuery.slot.element, (ctx, _) => ctx_.element),
  // C(MolScript.structureQuery.slot.elementSetReduce, (ctx, _) => ctx_.element),
  // ============= FILTERS ================
  D(MolScriptSymbolTable.structureQuery.filter.pick, (ctx, xs) => Queries.filters.pick(xs[0], xs["test"])(ctx)),
  D(MolScriptSymbolTable.structureQuery.filter.first, (ctx, xs) => Queries.filters.first(xs[0])(ctx)),
  D(MolScriptSymbolTable.structureQuery.filter.withSameAtomProperties, (ctx, xs) => Queries.filters.withSameAtomProperties(xs[0], xs["source"], xs["property"])(ctx)),
  D(MolScriptSymbolTable.structureQuery.filter.intersectedBy, (ctx, xs) => Queries.filters.areIntersectedBy(xs[0], xs["by"])(ctx)),
  D(MolScriptSymbolTable.structureQuery.filter.within, (ctx, xs) => {
    var _a, _b, _c;
    return Queries.filters.within({
      query: xs[0],
      target: xs["target"],
      minRadius: (_a = xs["min-radius"]) === null || _a === void 0 ? void 0 : _a.call(xs, ctx),
      maxRadius: (_b = xs["max-radius"]) === null || _b === void 0 ? void 0 : _b.call(xs, ctx),
      elementRadius: xs["atom-radius"],
      invert: (_c = xs["invert"]) === null || _c === void 0 ? void 0 : _c.call(xs, ctx)
    })(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.filter.isConnectedTo, (ctx, xs) => {
    var _a, _b;
    return Queries.filters.isConnectedTo({
      query: xs[0],
      target: xs["target"],
      disjunct: (_a = xs["disjunct"]) === null || _a === void 0 ? void 0 : _a.call(xs, ctx),
      invert: (_b = xs["invert"]) === null || _b === void 0 ? void 0 : _b.call(xs, ctx),
      bondTest: xs["bond-test"]
    })(ctx);
  }),
  // ============= GENERATORS ================
  D(MolScriptSymbolTable.structureQuery.generator.atomGroups, function structureQuery_generator_atomGroups(ctx, xs) {
    return Queries.generators.atoms({
      entityTest: xs["entity-test"],
      chainTest: xs["chain-test"],
      residueTest: xs["residue-test"],
      atomTest: xs["atom-test"],
      groupBy: xs["group-by"]
    })(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.generator.all, function structureQuery_generator_all(ctx) {
    return Queries.generators.all(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.generator.empty, function structureQuery_generator_empty(ctx) {
    return Queries.generators.none(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.generator.bondedAtomicPairs, function structureQuery_generator_bondedAtomicPairs(ctx, xs) {
    return Queries.generators.bondedAtomicPairs(xs && xs[0])(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.generator.rings, function structureQuery_generator_rings(ctx, xs) {
    var _a, _b;
    return Queries.generators.rings((_a = xs === null || xs === void 0 ? void 0 : xs["fingerprint"]) === null || _a === void 0 ? void 0 : _a.call(xs, ctx), (_b = xs === null || xs === void 0 ? void 0 : xs["only-aromatic"]) === null || _b === void 0 ? void 0 : _b.call(xs, ctx))(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.generator.queryInSelection, function structureQuery_generator_queryInSelection(ctx, xs) {
    var _a;
    return Queries.generators.querySelection(xs[0], xs["query"], (_a = xs["in-complement"]) === null || _a === void 0 ? void 0 : _a.call(xs, ctx))(ctx);
  }),
  // ============= MODIFIERS ================
  D(MolScriptSymbolTable.structureQuery.modifier.includeSurroundings, function structureQuery_modifier_includeSurroundings(ctx, xs) {
    return Queries.modifiers.includeSurroundings(xs[0], {
      radius: xs["radius"](ctx),
      wholeResidues: !!(xs["as-whole-residues"] && xs["as-whole-residues"](ctx)),
      elementRadius: xs["atom-radius"]
    })(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.modifier.surroundingLigands, function structureQuery_modifier_includeSurroundingLigands(ctx, xs) {
    return Queries.modifiers.surroundingLigands({
      query: xs[0],
      radius: xs["radius"](ctx),
      includeWater: !!(xs["include-water"] && xs["include-water"](ctx))
    })(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.modifier.wholeResidues, function structureQuery_modifier_wholeResidues(ctx, xs) {
    return Queries.modifiers.wholeResidues(xs[0])(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.modifier.union, function structureQuery_modifier_union(ctx, xs) {
    return Queries.modifiers.union(xs[0])(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.modifier.expandProperty, function structureQuery_modifier_expandProperty(ctx, xs) {
    return Queries.modifiers.expandProperty(xs[0], xs["property"])(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.modifier.exceptBy, function structureQuery_modifier_exceptBy(ctx, xs) {
    return Queries.modifiers.exceptBy(xs[0], xs["by"])(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.modifier.includeConnected, function structureQuery_modifier_includeConnected(ctx, xs) {
    var _a, _b;
    return Queries.modifiers.includeConnected({
      query: xs[0],
      bondTest: xs["bond-test"],
      wholeResidues: !!(xs["as-whole-residues"] && xs["as-whole-residues"](ctx)),
      layerCount: xs["layer-count"] && xs["layer-count"](ctx) || 1,
      fixedPoint: (_b = (_a = xs["fixed-point"]) === null || _a === void 0 ? void 0 : _a.call(xs, ctx)) !== null && _b !== void 0 ? _b : false
    })(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.modifier.intersectBy, function structureQuery_modifier_intersectBy(ctx, xs) {
    return Queries.modifiers.intersectBy(xs[0], xs["by"])(ctx);
  }),
  // ============= COMBINATORS ================
  D(MolScriptSymbolTable.structureQuery.combinator.merge, (ctx, xs) => Queries.combinators.merge(xs)(ctx)),
  // ============= ATOM PROPERTIES ================
  // ~~~ CORE ~~~
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.elementSymbol, atomProp(StructureProperties.atom.type_symbol)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.vdw, (ctx, xs) => VdwRadius(StructureProperties.atom.type_symbol(xs && xs[0] && xs[0](ctx) || ctx.element))),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.mass, (ctx, xs) => AtomWeight(StructureProperties.atom.type_symbol(xs && xs[0] && xs[0](ctx) || ctx.element))),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.atomicNumber, (ctx, xs) => AtomNumber(StructureProperties.atom.type_symbol(xs && xs[0] && xs[0](ctx) || ctx.element))),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.x, atomProp(StructureProperties.atom.x)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.y, atomProp(StructureProperties.atom.y)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.z, atomProp(StructureProperties.atom.z)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.sourceIndex, atomProp(StructureProperties.atom.sourceIndex)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.operatorName, atomProp(StructureProperties.unit.operator_name)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.operatorKey, atomProp(StructureProperties.unit.operator_key)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.modelIndex, atomProp(StructureProperties.unit.model_index)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.modelLabel, atomProp(StructureProperties.unit.model_label)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.core.atomKey, (ctx, xs) => {
    const e = xs && xs[0] && xs[0](ctx) || ctx.element;
    return cantorPairing(e.unit.id, e.element);
  }),
  // TODO:
  // D(MolScript.structureQuery.atomProperty.core.bondCount, (ctx, _) => ),
  // ~~~ TOPOLOGY ~~~
  // TODO
  // ~~~ MACROMOLECULAR ~~~
  // TODO:
  // // identifiers
  // labelResidueId: prop((env, v) => ResidueIdentifier.labelOfResidueIndex(env.context.model, getAddress(env, v).residue)),
  // authResidueId: prop((env, v) => ResidueIdentifier.authOfResidueIndex(env.context.model, getAddress(env, v).residue)),
  // keys
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.residueKey, (ctx, xs) => element_exports.residueIndex(xs && xs[0] && xs[0](ctx) || ctx.element)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.chainKey, (ctx, xs) => element_exports.chainIndex(xs && xs[0] && xs[0](ctx) || ctx.element)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.entityKey, (ctx, xs) => element_exports.entityIndex(xs && xs[0] && xs[0](ctx) || ctx.element)),
  // mmCIF
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.id, atomProp(StructureProperties.atom.id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.isHet, (ctx, xs) => StructureProperties.residue.group_PDB(xs && xs[0] && xs[0](ctx) || ctx.element) !== "ATOM"),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_atom_id, atomProp(StructureProperties.atom.label_atom_id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_alt_id, atomProp(StructureProperties.atom.label_alt_id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_comp_id, atomProp(StructureProperties.atom.label_comp_id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_seq_id, atomProp(StructureProperties.residue.label_seq_id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_asym_id, atomProp(StructureProperties.chain.label_asym_id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.label_entity_id, atomProp(StructureProperties.entity.id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.auth_atom_id, atomProp(StructureProperties.atom.auth_atom_id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.auth_comp_id, atomProp(StructureProperties.atom.auth_comp_id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.auth_seq_id, atomProp(StructureProperties.residue.auth_seq_id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.auth_asym_id, atomProp(StructureProperties.chain.auth_asym_id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.pdbx_PDB_ins_code, atomProp(StructureProperties.residue.pdbx_PDB_ins_code)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.pdbx_formal_charge, atomProp(StructureProperties.atom.pdbx_formal_charge)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.occupancy, atomProp(StructureProperties.atom.occupancy)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.B_iso_or_equiv, atomProp(StructureProperties.atom.B_iso_or_equiv)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.entityType, atomProp(StructureProperties.entity.type)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.entitySubtype, atomProp(StructureProperties.entity.subtype)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.entityPrdId, atomProp(StructureProperties.entity.prd_id)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.entityDescription, atomProp(StructureProperties.entity.pdbx_description)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.objectPrimitive, atomProp(StructureProperties.unit.object_primitive)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.isNonStandard, atomProp(StructureProperties.residue.isNonStandard)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.secondaryStructureKey, atomProp(StructureProperties.residue.secondary_structure_key)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.secondaryStructureFlags, atomProp(StructureProperties.residue.secondary_structure_type)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.macromolecular.chemCompType, atomProp(StructureProperties.residue.chem_comp_type)),
  D(MolScriptSymbolTable.structureQuery.atomProperty.ihm.hasSeqId, function structureQuery_atomProperty_ihm_hasSeqId(ctx, xs) {
    const current3 = ctx.element;
    const seqId = xs && xs[0] && xs[0](ctx);
    if (current3.unit.kind === Unit.Kind.Atomic) {
      return seqId === StructureProperties.residue.label_seq_id(current3);
    }
    return seqId >= StructureProperties.coarse.seq_id_begin(current3) && seqId <= StructureProperties.coarse.seq_id_end(current3);
  }),
  D(MolScriptSymbolTable.structureQuery.atomProperty.ihm.overlapsSeqIdRange, function structureQuery_atomProperty_ihm_hasSeqId2(ctx, xs) {
    var _a, _b;
    const current3 = ctx.element;
    const beg = (_a = xs && xs.beg && xs.beg(ctx)) !== null && _a !== void 0 ? _a : -Number.MAX_VALUE;
    const end = (_b = xs && xs.end && xs.end(ctx)) !== null && _b !== void 0 ? _b : Number.MAX_VALUE;
    if (current3.unit.kind === Unit.Kind.Atomic) {
      const value = StructureProperties.residue.label_seq_id(current3);
      return value >= beg && value <= end;
    }
    const a5 = StructureProperties.coarse.seq_id_begin(current3);
    const b5 = StructureProperties.coarse.seq_id_end(current3);
    return a5 >= beg && a5 <= end || b5 >= beg && b5 <= end || a5 <= beg && b5 >= end;
  }),
  // ============= ATOM SET ================
  D(MolScriptSymbolTable.structureQuery.atomSet.atomCount, function structureQuery_atomset_atomCount(ctx, xs) {
    return Queries.atomset.atomCount(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.atomSet.countQuery, function structureQuery_atomset_countQuery(ctx, xs) {
    return Queries.atomset.countQuery(xs[0])(ctx);
  }),
  D(MolScriptSymbolTable.structureQuery.atomSet.propertySet, function structureQuery_atomset_propertySet(ctx, xs) {
    return Queries.atomset.propertySet(xs[0])(ctx);
  }),
  // ============= BOND PROPERTIES ================
  D(MolScriptSymbolTable.structureQuery.bondProperty.order, (ctx, xs) => ctx.atomicBond.order),
  D(MolScriptSymbolTable.structureQuery.bondProperty.flags, (ctx, xs) => ctx.atomicBond.type),
  D(MolScriptSymbolTable.structureQuery.bondProperty.key, (ctx, xs) => ctx.atomicBond.key),
  D(MolScriptSymbolTable.structureQuery.bondProperty.atomA, (ctx, xs) => ctx.atomicBond.a),
  D(MolScriptSymbolTable.structureQuery.bondProperty.atomB, (ctx, xs) => ctx.atomicBond.b),
  D(MolScriptSymbolTable.structureQuery.bondProperty.length, (ctx, xs) => ctx.atomicBond.length),
  // Internal
  D(MolScriptSymbolTable.internal.generator.bundleElement, function internal_generator_bundleElement(ctx, xs) {
    return bundleElementImpl(xs.groupedUnits(ctx), xs.ranges(ctx), xs.set(ctx));
  }),
  D(MolScriptSymbolTable.internal.generator.bundle, function internal_generator_bundle(ctx, xs) {
    return bundleGenerator(xs.elements(ctx))(ctx);
  }),
  D(MolScriptSymbolTable.internal.generator.current, function internal_generator_current(ctx, xs) {
    return ctx.tryGetCurrentSelection();
  })
];
function atomProp(p) {
  return (ctx, xs) => p(xs && xs[0] && xs[0](ctx) || ctx.element);
}
function bondFlag(current3, f) {
  return current3 | (BondType.isName(f) ? BondType.fromName(f) : BondType.Flag.None);
}
function secondaryStructureFlag(current3, f) {
  switch (f.toLowerCase()) {
    case "helix":
      return current3 | SecondaryStructureType.Flag.Helix;
    case "alpha":
      return current3 | SecondaryStructureType.Flag.Helix | SecondaryStructureType.Flag.HelixAlpha;
    case "pi":
      return current3 | SecondaryStructureType.Flag.Helix | SecondaryStructureType.Flag.HelixPi;
    case "310":
      return current3 | SecondaryStructureType.Flag.Helix | SecondaryStructureType.Flag.Helix3Ten;
    case "beta":
      return current3 | SecondaryStructureType.Flag.Beta;
    case "strand":
      return current3 | SecondaryStructureType.Flag.Beta | SecondaryStructureType.Flag.BetaStrand;
    case "sheet":
      return current3 | SecondaryStructureType.Flag.Beta | SecondaryStructureType.Flag.BetaSheet;
    case "turn":
      return current3 | SecondaryStructureType.Flag.Turn;
    case "bend":
      return current3 | SecondaryStructureType.Flag.Bend;
    case "coil":
      return current3 | SecondaryStructureType.Flag.NA;
    default:
      return current3;
  }
}
function getArray(ctx, xs) {
  const ret = [];
  if (!xs)
    return ret;
  if (typeof xs.length === "number") {
    for (let i = 0, _i = xs.length; i < _i; i++)
      ret.push(xs[i](ctx));
  } else {
    const keys2 = Object.keys(xs);
    for (let i = 1, _i = keys2.length; i < _i; i++)
      ret.push(xs[keys2[i]](ctx));
  }
  return ret;
}
(function() {
  for (const s of symbols) {
    DefaultQueryRuntimeTable.addSymbol(s);
  }
})();

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-script/script.js
function Script(expression, language) {
  return { expression, language };
}
(function(Script2) {
  Script2.Info = {
    "mol-script": "Mol-Script",
    "pymol": "PyMOL",
    "vmd": "VMD",
    "jmol": "Jmol"
  };
  function is3(x) {
    return !!x && typeof x.expression === "string" && !!x.language;
  }
  Script2.is = is3;
  function areEqual(a5, b5) {
    return a5.language === b5.language && a5.expression === b5.expression;
  }
  Script2.areEqual = areEqual;
  function toExpression(script) {
    switch (script.language) {
      case "mol-script":
        const parsed = parseMolScript(script.expression);
        if (parsed.length === 0)
          throw new Error("No query");
        return transpileMolScript(parsed[0]);
      case "pymol":
      case "jmol":
      case "vmd":
        return parse3(script.language, script.expression);
      default:
        assertUnreachable(script.language);
    }
  }
  Script2.toExpression = toExpression;
  function toQuery(script) {
    const expression = toExpression(script);
    return compile(expression);
  }
  Script2.toQuery = toQuery;
  function toLoci(script, structure) {
    const query = toQuery(script);
    const result = query(new QueryContext(structure));
    return StructureSelection.toLociWithSourceUnits(result);
  }
  Script2.toLoci = toLoci;
  function getStructureSelection(expr, structure, options) {
    const e = typeof expr === "function" ? expr(MolScriptBuilder) : expr;
    const query = compile(e);
    return query(new QueryContext(structure, options));
  }
  Script2.getStructureSelection = getStructureSelection;
})(Script || (Script = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/helpers/root-structure.js
var CommonStructureParams = {
  dynamicBonds: ParamDefinition.Optional(ParamDefinition.Boolean(false, { description: "Ensure bonds are recalculated upon model changes. Also enables calculation of inter-unit bonds in water molecules and ions." }))
};
var RootStructureDefinition;
(function(RootStructureDefinition2) {
  function getParams(model, defaultValue) {
    const symmetry = model && ModelSymmetry.Provider.get(model);
    const assemblyIds = symmetry ? symmetry.assemblies.map((a5) => [a5.id, `${a5.id}: ${stringToWords(a5.details)}`]) : [];
    const showSymm = !symmetry ? true : !SpacegroupCell.isZero(symmetry.spacegroup.cell);
    const operatorOptions = [];
    if (symmetry) {
      const { operators: operators4 } = symmetry.spacegroup;
      for (let i = 0, il = operators4.length; i < il; i++) {
        operatorOptions.push([i, `${i + 1}: ${Spacegroup.getOperatorXyz(operators4[i])}`]);
      }
    }
    const asymIdsOptions = [];
    if (model) {
      model.properties.structAsymMap.forEach((v3) => {
        const label2 = v3.id === v3.auth_id ? v3.id : `${v3.id} [auth ${v3.auth_id}]`;
        asymIdsOptions.push([v3.id, label2]);
      });
    }
    const modes = {
      auto: ParamDefinition.Group(CommonStructureParams),
      model: ParamDefinition.Group(CommonStructureParams),
      assembly: ParamDefinition.Group({
        id: ParamDefinition.Optional(model ? ParamDefinition.Select(assemblyIds.length ? assemblyIds[0][0] : "", assemblyIds, { label: "Asm Id", description: "Assembly Id" }) : ParamDefinition.Text("", { label: "Asm Id", description: "Assembly Id (use empty for the 1st assembly)" })),
        ...CommonStructureParams
      }, { isFlat: true }),
      "symmetry-mates": ParamDefinition.Group({
        radius: ParamDefinition.Numeric(5, { min: 0, max: 50, step: 1 }),
        ...CommonStructureParams
      }, { isFlat: true }),
      "symmetry": ParamDefinition.Group({
        ijkMin: ParamDefinition.Vec3(Vec3.create(-1, -1, -1), { step: 1 }, { label: "Min IJK", fieldLabels: { x: "I", y: "J", z: "K" } }),
        ijkMax: ParamDefinition.Vec3(Vec3.create(1, 1, 1), { step: 1 }, { label: "Max IJK", fieldLabels: { x: "I", y: "J", z: "K" } }),
        ...CommonStructureParams
      }, { isFlat: true }),
      "symmetry-assembly": ParamDefinition.Group({
        generators: ParamDefinition.ObjectList({
          operators: ParamDefinition.ObjectList({
            index: ParamDefinition.Select(0, operatorOptions),
            shift: ParamDefinition.Vec3(Vec3(), { step: 1 }, { label: "IJK", fieldLabels: { x: "I", y: "J", z: "K" } })
          }, (e) => `${e.index + 1}_${e.shift.map((a5) => a5 + 5).join("")}`, {
            defaultValue: []
          }),
          asymIds: ParamDefinition.MultiSelect([], asymIdsOptions)
        }, (e) => `${e.asymIds.length} asym ids, ${e.operators.length} operators`, {
          defaultValue: []
        }),
        ...CommonStructureParams
      }, { isFlat: true })
    };
    const options = [];
    if (defaultValue === "auto") {
      options.push(["auto", "Auto"]);
    }
    options.push(["model", "Model"]);
    if (assemblyIds.length > 0) {
      options.push(["assembly", "Assembly"]);
    }
    if (showSymm) {
      options.push(["symmetry-mates", "Symmetry Mates"]);
      options.push(["symmetry", "Symmetry (indices)"]);
      options.push(["symmetry-assembly", "Symmetry (assembly)"]);
    }
    return {
      type: ParamDefinition.MappedStatic(defaultValue || "model", modes, { options })
    };
  }
  RootStructureDefinition2.getParams = getParams;
  function canAutoUpdate(oldParams, newParams) {
    if (newParams.name === "symmetry-assembly" || newParams.name === "symmetry" && oldParams.name === "symmetry")
      return false;
    return true;
  }
  RootStructureDefinition2.canAutoUpdate = canAutoUpdate;
  async function buildAssembly(plugin, ctx, model, id, props) {
    let asm = void 0;
    const symmetry = ModelSymmetry.Provider.get(model);
    if (!id && symmetry && symmetry.assemblies.length !== 0) {
      id = symmetry.assemblies[0].id;
    }
    if (!symmetry || symmetry.assemblies.length === 0) {
      plugin.log.warn(`Model '${model.entryId}' has no assembly, returning model structure.`);
    } else {
      asm = Symmetry.findAssembly(model, id || "");
      if (!asm) {
        plugin.log.warn(`Model '${model.entryId}' has no assembly called '${id}', returning model structure.`);
      }
    }
    const base = Structure.ofModel(model, props);
    if (!asm) {
      const label2 = { label: "Model", description: Structure.elementDescription(base) };
      return new PluginStateObject.Molecule.Structure(base, label2);
    }
    id = asm.id;
    const s = await StructureSymmetry.buildAssembly(base, id).runInContext(ctx);
    const objProps = { label: `Assembly ${id}`, description: Structure.elementDescription(s) };
    return new PluginStateObject.Molecule.Structure(s, objProps);
  }
  async function buildSymmetry(ctx, model, ijkMin, ijkMax, props) {
    const base = Structure.ofModel(model, props);
    const s = await StructureSymmetry.buildSymmetryRange(base, ijkMin, ijkMax).runInContext(ctx);
    const objProps = { label: `Symmetry [${ijkMin}] to [${ijkMax}]`, description: Structure.elementDescription(s) };
    return new PluginStateObject.Molecule.Structure(s, objProps);
  }
  async function buildSymmetryMates(ctx, model, radius, props) {
    const base = Structure.ofModel(model, props);
    const s = await StructureSymmetry.builderSymmetryMates(base, radius).runInContext(ctx);
    const objProps = { label: `Symmetry Mates`, description: Structure.elementDescription(s) };
    return new PluginStateObject.Molecule.Structure(s, objProps);
  }
  async function buildSymmetryAssembly(ctx, model, generators, symmetry, props) {
    const base = Structure.ofModel(model, props);
    const s = await StructureSymmetry.buildSymmetryAssembly(base, generators, symmetry).runInContext(ctx);
    const objProps = { label: `Symmetry Assembly`, description: Structure.elementDescription(s) };
    return new PluginStateObject.Molecule.Structure(s, objProps);
  }
  async function create(plugin, ctx, model, params) {
    const props = params === null || params === void 0 ? void 0 : params.params;
    const symmetry = ModelSymmetry.Provider.get(model);
    if (!symmetry || !params || params.name === "model") {
      const s = Structure.ofModel(model, props);
      return new PluginStateObject.Molecule.Structure(s, { label: "Model", description: Structure.elementDescription(s) });
    }
    if (params.name === "auto") {
      if (symmetry.assemblies.length === 0) {
        const s = Structure.ofModel(model, props);
        return new PluginStateObject.Molecule.Structure(s, { label: "Model", description: Structure.elementDescription(s) });
      } else {
        return buildAssembly(plugin, ctx, model, void 0, props);
      }
    }
    if (params.name === "assembly") {
      return buildAssembly(plugin, ctx, model, params.params.id, props);
    }
    if (params.name === "symmetry") {
      return buildSymmetry(ctx, model, params.params.ijkMin, params.params.ijkMax, props);
    }
    if (params.name === "symmetry-mates") {
      return buildSymmetryMates(ctx, model, params.params.radius, props);
    }
    if (params.name === "symmetry-assembly") {
      return buildSymmetryAssembly(ctx, model, params.params.generators, symmetry, props);
    }
    assertUnreachable(params);
  }
  RootStructureDefinition2.create = create;
})(RootStructureDefinition || (RootStructureDefinition = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/helpers/structure-query.js
var StructureQueryHelper;
(function(StructureQueryHelper2) {
  function isUnchanged(entry, query, structure) {
    if (entry.currentStructure !== structure)
      return false;
    if (Script.is(query)) {
      return !!entry.script && Script.areEqual(entry.script, query);
    }
    return entry.expression === query;
  }
  StructureQueryHelper2.isUnchanged = isUnchanged;
  function create(structure, query) {
    const script = Script.is(query) ? query : void 0;
    const expression = Script.is(query) ? Script.toExpression(query) : query;
    const compiled = compile(expression);
    return { script, expression, compiled, originalStructure: structure, currentStructure: structure };
  }
  StructureQueryHelper2.create = create;
  function run(entry, structure) {
    return entry.compiled(new QueryContext(structure));
  }
  StructureQueryHelper2.run = run;
  function createAndRun(structure, query) {
    const entry = create(structure, query);
    return { entry, selection: run(entry, structure) };
  }
  StructureQueryHelper2.createAndRun = createAndRun;
  function updateStructure(entry, structure) {
    entry.currentStructure = structure;
    return entry.compiled(new QueryContext(structure));
  }
  StructureQueryHelper2.updateStructure = updateStructure;
  function updateStructureObject(obj, selection, label2) {
    const s = StructureSelection.unionStructure(selection);
    obj.label = `${label2 || "Selection"}`;
    obj.description = Structure.elementDescription(s);
    obj.data = s;
  }
  StructureQueryHelper2.updateStructureObject = updateStructureObject;
})(StructureQueryHelper || (StructureQueryHelper = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms/misc.js
var misc_exports = {};
__export(misc_exports, {
  CreateGroup: () => CreateGroup
});
var CreateGroup = PluginStateTransform.BuiltIn({
  name: "create-group",
  display: { name: "Group" },
  from: [],
  to: PluginStateObject.Group,
  params: {
    label: ParamDefinition.Text("Group"),
    description: ParamDefinition.Optional(ParamDefinition.Text(""))
  }
})({
  apply({ params }) {
    return new PluginStateObject.Group({}, params);
  },
  update({ oldParams, newParams, b: b5 }) {
    if (shallowEqualObjects(oldParams, newParams))
      return Transformer.UpdateResult.Unchanged;
    b5.label = newParams.label;
    b5.description = newParams.description;
    return Transformer.UpdateResult.Updated;
  }
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms/volume.js
var volume_exports = {};
__export(volume_exports, {
  AssignColorVolume: () => AssignColorVolume,
  VolumeFromCcp4: () => VolumeFromCcp4,
  VolumeFromCube: () => VolumeFromCube,
  VolumeFromDensityServerCif: () => VolumeFromDensityServerCif,
  VolumeFromDsn6: () => VolumeFromDsn6,
  VolumeFromDx: () => VolumeFromDx,
  VolumeFromSegmentationCif: () => VolumeFromSegmentationCif,
  VolumeTransform: () => VolumeTransform
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/volume/ccp4.js
function getCcp4Origin(header2) {
  if (header2.originX === 0 && header2.originY === 0 && header2.originZ === 0) {
    return Vec3.create(header2.NCSTART, header2.NRSTART, header2.NSSTART);
  } else {
    return Vec3.create(header2.originX / (header2.xLength / header2.NX), header2.originY / (header2.yLength / header2.NY), header2.originZ / (header2.zLength / header2.NZ));
  }
}
function getTypedArrayCtor(header2) {
  const valueType = getCcp4ValueType(header2);
  switch (valueType) {
    case TypedArrayValueType.Float32:
      return Float32Array;
    case TypedArrayValueType.Int8:
      return Int8Array;
    case TypedArrayValueType.Int16:
      return Int16Array;
    case TypedArrayValueType.Uint16:
      return Uint16Array;
  }
  throw Error(`${valueType} is not a supported value format.`);
}
function volumeFromCcp4(source, params) {
  return Task.create("Create Volume", async (ctx) => {
    const { header: header2, values: values2 } = source;
    const size = Vec3.create(header2.xLength, header2.yLength, header2.zLength);
    if (params && params.voxelSize)
      Vec3.mul(size, size, params.voxelSize);
    const angles = Vec3.create(degToRad(header2.alpha), degToRad(header2.beta), degToRad(header2.gamma));
    const spacegroup = header2.ISPG > 65536 ? 0 : header2.ISPG;
    const cell = SpacegroupCell.create(spacegroup || "P 1", size, angles);
    const axis_order_fast_to_slow = Vec3.create(header2.MAPC - 1, header2.MAPR - 1, header2.MAPS - 1);
    const normalizeOrder = Tensor.convertToCanonicalAxisIndicesFastToSlow(axis_order_fast_to_slow);
    const grid = [header2.NX, header2.NY, header2.NZ];
    const extent = normalizeOrder([header2.NC, header2.NR, header2.NS]);
    const origin = getCcp4Origin(header2);
    if (params === null || params === void 0 ? void 0 : params.offset)
      Vec3.add(origin, origin, params.offset);
    const gridOrigin = normalizeOrder(origin);
    const origin_frac = Vec3.create(gridOrigin[0] / grid[0], gridOrigin[1] / grid[1], gridOrigin[2] / grid[2]);
    const dimensions_frac = Vec3.create(extent[0] / grid[0], extent[1] / grid[1], extent[2] / grid[2]);
    const space = Tensor.Space(extent, Tensor.invertAxisOrder(axis_order_fast_to_slow), getTypedArrayCtor(header2));
    const data = Tensor.create(space, Tensor.Data1(values2));
    const calcStats = header2.AMIN === 0 && header2.AMAX === 0 && header2.AMEAN === 0 && header2.ARMS === 0;
    return {
      label: params === null || params === void 0 ? void 0 : params.label,
      entryId: params === null || params === void 0 ? void 0 : params.entryId,
      grid: {
        transform: { kind: "spacegroup", cell, fractionalBox: Box3D.create(origin_frac, Vec3.add(Vec3.zero(), origin_frac, dimensions_frac)) },
        cells: data,
        stats: {
          min: isNaN(header2.AMIN) || calcStats ? arrayMin(values2) : header2.AMIN,
          max: isNaN(header2.AMAX) || calcStats ? arrayMax(values2) : header2.AMAX,
          mean: isNaN(header2.AMEAN) || calcStats ? arrayMean(values2) : header2.AMEAN,
          sigma: isNaN(header2.ARMS) || header2.ARMS === 0 ? arrayRms(values2) : header2.ARMS
        }
      },
      sourceData: Ccp4Format.create(source),
      customProperties: new CustomProperties(),
      _propertyData: /* @__PURE__ */ Object.create(null)
    };
  });
}
var Ccp4Format;
(function(Ccp4Format2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "ccp4";
  }
  Ccp4Format2.is = is3;
  function create(ccp4) {
    return { kind: "ccp4", name: ccp4.name, data: ccp4 };
  }
  Ccp4Format2.create = create;
})(Ccp4Format || (Ccp4Format = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/volume/dsn6.js
function volumeFromDsn6(source, params) {
  return Task.create("Create Volume", async (ctx) => {
    const { header: header2, values: values2 } = source;
    const size = Vec3.create(header2.xlen, header2.ylen, header2.zlen);
    if (params && params.voxelSize)
      Vec3.mul(size, size, params.voxelSize);
    const angles = Vec3.create(degToRad(header2.alpha), degToRad(header2.beta), degToRad(header2.gamma));
    const cell = SpacegroupCell.create("P 1", size, angles);
    const grid = [header2.xRate, header2.yRate, header2.zRate];
    const extent = [header2.xExtent, header2.yExtent, header2.zExtent];
    const gridOrigin = [header2.xStart, header2.yStart, header2.zStart];
    const origin_frac = Vec3.create(gridOrigin[0] / grid[0], gridOrigin[1] / grid[1], gridOrigin[2] / grid[2]);
    const dimensions_frac = Vec3.create(extent[0] / grid[0], extent[1] / grid[1], extent[2] / grid[2]);
    const space = Tensor.Space(extent, [0, 1, 2], Float32Array);
    const data = Tensor.create(space, Tensor.Data1(values2));
    return {
      label: params === null || params === void 0 ? void 0 : params.label,
      entryId: params === null || params === void 0 ? void 0 : params.entryId,
      grid: {
        transform: { kind: "spacegroup", cell, fractionalBox: Box3D.create(origin_frac, Vec3.add(Vec3.zero(), origin_frac, dimensions_frac)) },
        cells: data,
        stats: {
          min: arrayMin(values2),
          max: arrayMax(values2),
          mean: arrayMean(values2),
          sigma: header2.sigma !== void 0 ? header2.sigma : arrayRms(values2)
        }
      },
      sourceData: Dsn6Format.create(source),
      customProperties: new CustomProperties(),
      _propertyData: /* @__PURE__ */ Object.create(null)
    };
  });
}
var Dsn6Format;
(function(Dsn6Format2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "dsn6";
  }
  Dsn6Format2.is = is3;
  function create(dsn6) {
    return { kind: "dsn6", name: dsn6.name, data: dsn6 };
  }
  Dsn6Format2.create = create;
})(Dsn6Format || (Dsn6Format = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/volume/dx.js
function volumeFromDx(source, params) {
  return Task.create("Create Volume", async () => {
    const { header: header2, values: values2 } = source;
    const space = Tensor.Space(header2.dim, [0, 1, 2], Float64Array);
    const data = Tensor.create(space, Tensor.Data1(values2));
    const matrix = Mat4.fromTranslation(Mat4(), header2.min);
    const basis = Mat4.fromScaling(Mat4(), header2.h);
    Mat4.mul(matrix, matrix, basis);
    return {
      label: params === null || params === void 0 ? void 0 : params.label,
      entryId: params === null || params === void 0 ? void 0 : params.entryId,
      grid: {
        transform: { kind: "matrix", matrix },
        cells: data,
        stats: {
          min: arrayMin(values2),
          max: arrayMax(values2),
          mean: arrayMean(values2),
          sigma: arrayRms(values2)
        }
      },
      sourceData: DxFormat.create(source),
      customProperties: new CustomProperties(),
      _propertyData: /* @__PURE__ */ Object.create(null)
    };
  });
}
var DxFormat;
(function(DxFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "dx";
  }
  DxFormat2.is = is3;
  function create(dx) {
    return { kind: "dx", name: dx.name, data: dx };
  }
  DxFormat2.create = create;
})(DxFormat || (DxFormat = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/volume/segmentation.js
function volumeFromSegmentationData(source, params) {
  return Task.create("Create Segmentation Volume", async (ctx) => {
    var _a;
    const { volume_data_3d_info: info, segmentation_data_3d: values2 } = source;
    const cell = SpacegroupCell.create(info.spacegroup_number.value(0), Vec3.ofArray(info.spacegroup_cell_size.value(0)), Vec3.scale(Vec3(), Vec3.ofArray(info.spacegroup_cell_angles.value(0)), Math.PI / 180));
    const axis_order_fast_to_slow = info.axis_order.value(0);
    const normalizeOrder = Tensor.convertToCanonicalAxisIndicesFastToSlow(axis_order_fast_to_slow);
    const sample_count = normalizeOrder(info.sample_count.value(0));
    const tensorSpace = Tensor.Space(sample_count, Tensor.invertAxisOrder(axis_order_fast_to_slow), Float32Array);
    const t2 = Tensor.create(tensorSpace, Tensor.Data1(values2.values.toArray({ array: Float32Array })));
    const origin = Vec3.ofArray(normalizeOrder(info.origin.value(0)));
    const dimensions = Vec3.ofArray(normalizeOrder(info.dimensions.value(0)));
    const v3 = {
      label: params === null || params === void 0 ? void 0 : params.label,
      entryId: void 0,
      grid: {
        transform: {
          kind: "spacegroup",
          cell,
          fractionalBox: Box3D.create(origin, Vec3.add(Vec3(), origin, dimensions))
        },
        cells: t2,
        stats: {
          min: 0,
          max: 1,
          mean: 0,
          sigma: 1
        }
      },
      sourceData: SegcifFormat.create(source),
      customProperties: new CustomProperties(),
      _propertyData: { ownerId: params === null || params === void 0 ? void 0 : params.ownerId }
    };
    Volume.PickingGranularity.set(v3, "object");
    const segments = /* @__PURE__ */ new Map();
    const sets = /* @__PURE__ */ new Map();
    const { segment_id, set_id } = source.segmentation_data_table;
    for (let i = 0, il = segment_id.rowCount; i < il; ++i) {
      const segment = segment_id.value(i);
      const set4 = set_id.value(i);
      if (set4 === 0 || segment === 0)
        continue;
      if (!sets.has(set4))
        sets.set(set4, /* @__PURE__ */ new Set());
      sets.get(set4).add(segment);
    }
    sets.forEach((segs, set4) => {
      segs.forEach((seg) => {
        if (!segments.has(seg))
          segments.set(seg, /* @__PURE__ */ new Set());
        segments.get(seg).add(set4);
      });
    });
    const c5 = [0, 0, 0];
    const getCoords = t2.space.getCoords;
    const d3 = t2.data;
    const [xn, yn, zn] = v3.grid.cells.space.dimensions;
    const xn1 = xn - 1;
    const yn1 = yn - 1;
    const zn1 = zn - 1;
    const setBounds = {};
    sets.forEach((v4, k) => {
      setBounds[k] = [xn1, yn1, zn1, -1, -1, -1];
    });
    for (let i = 0, il = d3.length; i < il; ++i) {
      const v4 = d3[i];
      if (v4 === 0)
        continue;
      getCoords(i, c5);
      const b5 = setBounds[v4];
      if (c5[0] < b5[0])
        b5[0] = c5[0];
      if (c5[1] < b5[1])
        b5[1] = c5[1];
      if (c5[2] < b5[2])
        b5[2] = c5[2];
      if (c5[0] > b5[3])
        b5[3] = c5[0];
      if (c5[1] > b5[4])
        b5[4] = c5[1];
      if (c5[2] > b5[5])
        b5[5] = c5[2];
    }
    const bounds = {};
    segments.forEach((v4, k) => {
      bounds[k] = Box3D.create(Vec3.create(xn1, yn1, zn1), Vec3.create(-1, -1, -1));
    });
    objectForEach(setBounds, (b5, s) => {
      sets.get(parseInt(s)).forEach((seg) => {
        const sb = bounds[seg];
        if (b5[0] < sb.min[0])
          sb.min[0] = b5[0];
        if (b5[1] < sb.min[1])
          sb.min[1] = b5[1];
        if (b5[2] < sb.min[2])
          sb.min[2] = b5[2];
        if (b5[3] > sb.max[0])
          sb.max[0] = b5[3];
        if (b5[4] > sb.max[1])
          sb.max[1] = b5[4];
        if (b5[5] > sb.max[2])
          sb.max[2] = b5[5];
      });
    });
    Volume.Segmentation.set(v3, { segments, sets, bounds, labels: (_a = params === null || params === void 0 ? void 0 : params.segmentLabels) !== null && _a !== void 0 ? _a : {} });
    return v3;
  });
}
var SegcifFormat;
(function(SegcifFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "segcif";
  }
  SegcifFormat2.is = is3;
  function create(segcif) {
    return { kind: "segcif", name: segcif._name, data: segcif };
  }
  SegcifFormat2.create = create;
})(SegcifFormat || (SegcifFormat = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms/volume.js
var VolumeFromCcp4 = PluginStateTransform.BuiltIn({
  name: "volume-from-ccp4",
  display: { name: "Volume from CCP4/MRC/MAP", description: "Create Volume from CCP4/MRC/MAP data" },
  from: PluginStateObject.Format.Ccp4,
  to: PluginStateObject.Volume.Data,
  params(a5) {
    return {
      voxelSize: ParamDefinition.Vec3(Vec3.create(1, 1, 1)),
      offset: ParamDefinition.Vec3(Vec3.create(0, 0, 0)),
      entryId: ParamDefinition.Text("")
    };
  }
})({
  apply({ a: a5, params }) {
    return Task.create("Create volume from CCP4/MRC/MAP", async (ctx) => {
      const volume = await volumeFromCcp4(a5.data, { ...params, label: a5.data.name || a5.label }).runInContext(ctx);
      const props = { label: volume.label || "Volume", description: `Volume ${a5.data.header.NX}${a5.data.header.NX}${a5.data.header.NX}` };
      return new PluginStateObject.Volume.Data(volume, props);
    });
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customProperties.dispose();
  }
});
var VolumeFromDsn6 = PluginStateTransform.BuiltIn({
  name: "volume-from-dsn6",
  display: { name: "Volume from DSN6/BRIX", description: "Create Volume from DSN6/BRIX data" },
  from: PluginStateObject.Format.Dsn6,
  to: PluginStateObject.Volume.Data,
  params(a5) {
    return {
      voxelSize: ParamDefinition.Vec3(Vec3.create(1, 1, 1)),
      entryId: ParamDefinition.Text("")
    };
  }
})({
  apply({ a: a5, params }) {
    return Task.create("Create volume from DSN6/BRIX", async (ctx) => {
      const volume = await volumeFromDsn6(a5.data, { ...params, label: a5.data.name || a5.label }).runInContext(ctx);
      const props = { label: volume.label || "Volume", description: `Volume ${a5.data.header.xExtent}${a5.data.header.yExtent}${a5.data.header.zExtent}` };
      return new PluginStateObject.Volume.Data(volume, props);
    });
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customProperties.dispose();
  }
});
var VolumeFromCube = PluginStateTransform.BuiltIn({
  name: "volume-from-cube",
  display: { name: "Volume from Cube", description: "Create Volume from Cube data" },
  from: PluginStateObject.Format.Cube,
  to: PluginStateObject.Volume.Data,
  params(a5) {
    const dataIndex = a5 ? ParamDefinition.Select(0, a5.data.header.dataSetIds.map((id, i) => [i, `${id}`])) : ParamDefinition.Numeric(0);
    return {
      dataIndex,
      entryId: ParamDefinition.Text("")
    };
  }
})({
  apply({ a: a5, params }) {
    return Task.create("Create volume from Cube", async (ctx) => {
      const volume = await volumeFromCube(a5.data, { ...params, label: a5.data.name || a5.label }).runInContext(ctx);
      const props = { label: volume.label || "Volume", description: `Volume ${a5.data.header.dim[0]}${a5.data.header.dim[1]}${a5.data.header.dim[2]}` };
      return new PluginStateObject.Volume.Data(volume, props);
    });
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customProperties.dispose();
  }
});
var VolumeFromDx = PluginStateTransform.BuiltIn({
  name: "volume-from-dx",
  display: { name: "Parse DX", description: "Create volume from DX data." },
  from: PluginStateObject.Format.Dx,
  to: PluginStateObject.Volume.Data
})({
  apply({ a: a5 }) {
    return Task.create("Parse DX", async (ctx) => {
      const volume = await volumeFromDx(a5.data, { label: a5.data.name || a5.label }).runInContext(ctx);
      const props = { label: volume.label || "Volume", description: `Volume ${a5.data.header.dim[0]}${a5.data.header.dim[1]}${a5.data.header.dim[2]}` };
      return new PluginStateObject.Volume.Data(volume, props);
    });
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customProperties.dispose();
  }
});
var VolumeFromDensityServerCif = PluginStateTransform.BuiltIn({
  name: "volume-from-density-server-cif",
  display: { name: "Volume from density-server CIF", description: "Identify and create all separate models in the specified CIF data block" },
  from: PluginStateObject.Format.Cif,
  to: PluginStateObject.Volume.Data,
  params(a5) {
    if (!a5) {
      return {
        blockHeader: ParamDefinition.Optional(ParamDefinition.Text(void 0, { description: "Header of the block to parse. If none is specifed, the 1st data block in the file is used." })),
        entryId: ParamDefinition.Text("")
      };
    }
    const blocks = a5.data.blocks.slice(1);
    return {
      blockHeader: ParamDefinition.Optional(ParamDefinition.Select(blocks[0] && blocks[0].header, blocks.map((b5) => [b5.header, b5.header]), { description: "Header of the block to parse" })),
      entryId: ParamDefinition.Text("")
    };
  }
})({
  isApplicable: (a5) => a5.data.blocks.length > 0,
  apply({ a: a5, params }) {
    return Task.create("Parse density-server CIF", async (ctx) => {
      var _a;
      const header2 = params.blockHeader || a5.data.blocks[1].header;
      const block = a5.data.blocks.find((b5) => b5.header === header2);
      if (!block)
        throw new Error(`Data block '${[header2]}' not found.`);
      const densityServerCif = CIF.schema.densityServer(block);
      const volume = await volumeFromDensityServerData(densityServerCif, { entryId: params.entryId }).runInContext(ctx);
      const [x, y, z] = volume.grid.cells.space.dimensions;
      const props = { label: (_a = params.entryId) !== null && _a !== void 0 ? _a : densityServerCif.volume_data_3d_info.name.value(0), description: `Volume ${x}${y}${z}` };
      return new PluginStateObject.Volume.Data(volume, props);
    });
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customProperties.dispose();
  }
});
var VolumeFromSegmentationCif = PluginStateTransform.BuiltIn({
  name: "volume-from-segmentation-cif",
  display: { name: "Volume from Segmentation CIF" },
  from: PluginStateObject.Format.Cif,
  to: PluginStateObject.Volume.Data,
  params(a5) {
    const blocks = a5 === null || a5 === void 0 ? void 0 : a5.data.blocks.slice(1);
    const blockHeaderParam = blocks ? ParamDefinition.Optional(ParamDefinition.Select(blocks[0] && blocks[0].header, blocks.map((b5) => [b5.header, b5.header]), { description: "Header of the block to parse" })) : ParamDefinition.Optional(ParamDefinition.Text(void 0, { description: "Header of the block to parse. If none is specifed, the 1st data block in the file is used." }));
    return {
      blockHeader: blockHeaderParam,
      segmentLabels: ParamDefinition.ObjectList({ id: ParamDefinition.Numeric(-1), label: ParamDefinition.Text("") }, (s) => `${s.id} = ${s.label}`, { description: "Mapping of segment IDs to segment labels" }),
      ownerId: ParamDefinition.Text("", { isHidden: true, description: "Reference to the object which manages this volume" })
    };
  }
})({
  isApplicable: (a5) => a5.data.blocks.length > 0,
  apply({ a: a5, params }) {
    return Task.create("Parse segmentation CIF", async (ctx) => {
      const header2 = params.blockHeader || a5.data.blocks[1].header;
      const block = a5.data.blocks.find((b5) => b5.header === header2);
      if (!block)
        throw new Error(`Data block '${[header2]}' not found.`);
      const segmentationCif = CIF.schema.segmentation(block);
      const segmentLabels = {};
      for (const segment of params.segmentLabels)
        segmentLabels[segment.id] = segment.label;
      const volume = await volumeFromSegmentationData(segmentationCif, { segmentLabels, ownerId: params.ownerId }).runInContext(ctx);
      const [x, y, z] = volume.grid.cells.space.dimensions;
      const props = { label: segmentationCif.volume_data_3d_info.name.value(0), description: `Segmentation ${x}${y}${z}` };
      return new PluginStateObject.Volume.Data(volume, props);
    });
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customProperties.dispose();
  }
});
var AssignColorVolume = PluginStateTransform.BuiltIn({
  name: "assign-color-volume",
  display: { name: "Assign Color Volume", description: "Assigns another volume to be available for coloring." },
  from: PluginStateObject.Volume.Data,
  to: PluginStateObject.Volume.Data,
  isDecorator: true,
  params(a5, plugin) {
    if (!a5)
      return { ref: ParamDefinition.Text() };
    const cells = plugin.state.data.select(StateSelection.Generators.root.subtree().ofType(PluginStateObject.Volume.Data).filter((cell) => {
      var _a;
      return !!cell.obj && !((_a = cell.obj) === null || _a === void 0 ? void 0 : _a.data.colorVolume) && cell.obj !== a5;
    }));
    if (cells.length === 0)
      return { ref: ParamDefinition.Text("", { isHidden: true }) };
    return { ref: ParamDefinition.Select(cells[0].transform.ref, cells.map((c5) => [c5.transform.ref, c5.obj.label])) };
  }
})({
  apply({ a: a5, params, dependencies }) {
    return Task.create("Assign Color Volume", async (ctx) => {
      if (!dependencies || !dependencies[params.ref]) {
        throw new Error("Dependency not available.");
      }
      const colorVolume = dependencies[params.ref].data;
      const volume = {
        ...a5.data,
        colorVolume
      };
      const props = { label: a5.label, description: "Volume + Colors" };
      return new PluginStateObject.Volume.Data(volume, props);
    });
  }
});
var VolumeTransform = PluginStateTransform.BuiltIn({
  name: "volume-transform",
  display: { name: "Transform Volume" },
  isDecorator: true,
  from: PluginStateObject.Volume.Data,
  to: PluginStateObject.Volume.Data,
  params: {
    transform: ParamDefinition.MappedStatic(
      "matrix",
      // TODO: support "components" based rotation
      {
        matrix: ParamDefinition.Group({
          data: ParamDefinition.Mat4(Mat4.identity()),
          transpose: ParamDefinition.Boolean(false)
        }, { isFlat: true })
      },
      { label: "Kind" }
    )
  }
})({
  canAutoUpdate({ newParams }) {
    return newParams.transform.name !== "matrix";
  },
  apply({ a: a5, params }) {
    const transform = Mat4();
    let gridTransform = { ...a5.data.grid.transform };
    Mat4.copy(transform, params.transform.params.data);
    if (params.transform.params.transpose)
      Mat4.transpose(transform, transform);
    const origMat = a5.data.grid.transform.kind === "matrix" ? a5.data.grid.transform.matrix : Grid.getGridToCartesianTransform(a5.data.grid);
    gridTransform = {
      kind: "matrix",
      matrix: Mat4.mul(Mat4(), transform, origMat)
    };
    const v3 = {
      ...a5.data,
      grid: {
        ...a5.data.grid,
        transform: gridTransform
      }
    };
    return new PluginStateObject.Volume.Data(v3, {
      label: a5.label,
      description: `${a5.description} [Transformed]`
    });
  }
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms/representation.js
var representation_exports = {};
__export(representation_exports, {
  ClippingStructureRepresentation3DFromBundle: () => ClippingStructureRepresentation3DFromBundle,
  ClippingStructureRepresentation3DFromScript: () => ClippingStructureRepresentation3DFromScript,
  EmissiveStructureRepresentation3DFromBundle: () => EmissiveStructureRepresentation3DFromBundle,
  EmissiveStructureRepresentation3DFromScript: () => EmissiveStructureRepresentation3DFromScript,
  ExplodeStructureRepresentation3D: () => ExplodeStructureRepresentation3D,
  ModelUnitcell3D: () => ModelUnitcell3D,
  OverpaintStructureRepresentation3DFromBundle: () => OverpaintStructureRepresentation3DFromBundle,
  OverpaintStructureRepresentation3DFromScript: () => OverpaintStructureRepresentation3DFromScript,
  ShapeRepresentation3D: () => ShapeRepresentation3D,
  SpinStructureRepresentation3D: () => SpinStructureRepresentation3D,
  StructureBoundingBox3D: () => StructureBoundingBox3D,
  StructureRepresentation3D: () => StructureRepresentation3D,
  StructureSelectionsAngle3D: () => StructureSelectionsAngle3D,
  StructureSelectionsDihedral3D: () => StructureSelectionsDihedral3D,
  StructureSelectionsDistance3D: () => StructureSelectionsDistance3D,
  StructureSelectionsLabel3D: () => StructureSelectionsLabel3D,
  StructureSelectionsOrientation3D: () => StructureSelectionsOrientation3D,
  StructureSelectionsPlane3D: () => StructureSelectionsPlane3D,
  SubstanceStructureRepresentation3DFromBundle: () => SubstanceStructureRepresentation3DFromBundle,
  SubstanceStructureRepresentation3DFromScript: () => SubstanceStructureRepresentation3DFromScript,
  ThemeStrengthRepresentation3D: () => ThemeStrengthRepresentation3D,
  TransparencyStructureRepresentation3DFromBundle: () => TransparencyStructureRepresentation3DFromBundle,
  TransparencyStructureRepresentation3DFromScript: () => TransparencyStructureRepresentation3DFromScript,
  UnwindStructureAssemblyRepresentation3D: () => UnwindStructureAssemblyRepresentation3D,
  VolumeRepresentation3D: () => VolumeRepresentation3D,
  VolumeRepresentation3DHelpers: () => VolumeRepresentation3DHelpers
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/carbohydrate-symbol.js
var DefaultColor3 = Color(13421772);
var Description5 = "Assigns colors according to the Symbol Nomenclature for Glycans (SNFG).";
var CarbohydrateSymbolColorThemeParams = {};
function getCarbohydrateSymbolColorThemeParams(ctx) {
  return CarbohydrateSymbolColorThemeParams;
}
function CarbohydrateSymbolColorTheme(ctx, props) {
  let color;
  if (ctx.structure) {
    const { elements, getElementIndices } = ctx.structure.carbohydrates;
    const getColor = (unit, index) => {
      if (!Unit.isAtomic(unit))
        return DefaultColor3;
      const carbs = getElementIndices(unit, index);
      return carbs.length > 0 ? elements[carbs[0]].component.color : DefaultColor3;
    };
    color = (location, isSecondary) => {
      if (isSecondary) {
        return SaccharideColors.Secondary;
      } else {
        if (element_exports.Location.is(location)) {
          return getColor(location.unit, location.element);
        } else if (Bond.isLocation(location)) {
          return getColor(location.aUnit, location.aUnit.elements[location.aIndex]);
        }
      }
      return DefaultColor3;
    };
  } else {
    color = () => DefaultColor3;
  }
  return {
    factory: CarbohydrateSymbolColorTheme,
    granularity: "group",
    color,
    props,
    description: Description5,
    legend: TableLegend(MonosaccharidesColorTable)
  };
}
var CarbohydrateSymbolColorThemeProvider = {
  name: "carbohydrate-symbol",
  label: "Carbohydrate Symbol",
  category: ColorThemeCategory.Residue,
  factory: CarbohydrateSymbolColorTheme,
  getParams: getCarbohydrateSymbolColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(CarbohydrateSymbolColorThemeParams),
  isApplicable: (ctx) => {
    return !!ctx.structure && ctx.structure.models.some((m) => Model.hasCarbohydrate(m));
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/color/distinct.js
var DistinctColorsParams = {
  hue: ParamDefinition.Interval([1, 360], { min: 0, max: 360, step: 1 }),
  chroma: ParamDefinition.Interval([40, 70], { min: 0, max: 100, step: 1 }),
  luminance: ParamDefinition.Interval([15, 85], { min: 0, max: 100, step: 1 }),
  sort: ParamDefinition.Select("contrast", ParamDefinition.arrayToOptions(["none", "contrast"]), { description: "no sorting leaves colors approximately ordered by hue" }),
  clusteringStepCount: ParamDefinition.Numeric(50, { min: 10, max: 200, step: 1 }, { isHidden: true }),
  minSampleCount: ParamDefinition.Numeric(800, { min: 100, max: 5e3, step: 100 }, { isHidden: true }),
  sampleCountFactor: ParamDefinition.Numeric(5, { min: 1, max: 100, step: 1 }, { isHidden: true })
};
var LabTolerance = 2;
var tmpCheckColorHcl = [0, 0, 0];
var tmpCheckColorLab = [0, 0, 0];
function checkColor(lab, props) {
  Lab.toHcl(tmpCheckColorHcl, lab);
  Lab.fromColor(tmpCheckColorLab, Lab.toColor(lab));
  return tmpCheckColorHcl[0] >= props.hue[0] && tmpCheckColorHcl[0] <= props.hue[1] && tmpCheckColorHcl[1] >= props.chroma[0] && tmpCheckColorHcl[1] <= props.chroma[1] && tmpCheckColorHcl[2] >= props.luminance[0] && tmpCheckColorHcl[2] <= props.luminance[1] && tmpCheckColorLab[0] >= lab[0] - LabTolerance && tmpCheckColorLab[0] <= lab[0] + LabTolerance && tmpCheckColorLab[1] >= lab[1] - LabTolerance && tmpCheckColorLab[1] <= lab[1] + LabTolerance && tmpCheckColorLab[2] >= lab[2] - LabTolerance && tmpCheckColorLab[2] <= lab[2] + LabTolerance;
}
function sortByContrast(colors) {
  const unsortedColors = colors.slice(0);
  const sortedColors = [unsortedColors.shift()];
  while (unsortedColors.length > 0) {
    const lastColor = sortedColors[sortedColors.length - 1];
    let nearest = 0;
    let maxDist = Number.NEGATIVE_INFINITY;
    for (let i = 0; i < unsortedColors.length; ++i) {
      const dist = Lab.distance(lastColor, unsortedColors[i]);
      if (dist > maxDist) {
        maxDist = dist;
        nearest = i;
      }
    }
    sortedColors.push(unsortedColors.splice(nearest, 1)[0]);
  }
  return sortedColors;
}
function getSamples(count3, p) {
  const samples = /* @__PURE__ */ new Map();
  const rangeDivider = Math.ceil(Math.cbrt(count3));
  const hcl = Hcl();
  const hStep = Math.max((p.hue[1] - p.hue[0]) / rangeDivider, 1);
  const cStep = Math.max((p.chroma[1] - p.chroma[0]) / rangeDivider, 1);
  const lStep = Math.max((p.luminance[1] - p.luminance[0]) / rangeDivider, 1);
  for (let h = p.hue[0] + hStep / 2; h <= p.hue[1]; h += hStep) {
    for (let c5 = p.chroma[0] + cStep / 2; c5 <= p.chroma[1]; c5 += cStep) {
      for (let l = p.luminance[0] + lStep / 2; l <= p.luminance[1]; l += lStep) {
        const lab = Lab.fromHcl(Lab(), Hcl.set(hcl, h, c5, l));
        if (checkColor(lab, p))
          samples.set(Lab.toColor(lab), lab);
      }
    }
  }
  return Array.from(samples.values());
}
function getClosestIndex(colors, color) {
  let minDist = Infinity;
  let nearest = 0;
  for (let j = 0; j < colors.length; j++) {
    const dist = Lab.distance(color, colors[j]);
    if (dist < minDist) {
      minDist = dist;
      nearest = j;
    }
  }
  return nearest;
}
function distinctColors(count3, props = {}) {
  const p = { ...ParamDefinition.getDefaultValues(DistinctColorsParams), ...props };
  if (count3 <= 0)
    return [];
  const samples = getSamples(Math.max(p.minSampleCount, count3 * p.sampleCountFactor), p);
  if (samples.length < count3) {
    console.warn("Not enough samples to generate distinct colors, increase sample count.");
    return new Array(count3).fill(ColorNames.lightgrey);
  }
  const colors = [];
  const zonesProto = [];
  const sliceSize = Math.floor(samples.length / count3);
  for (let i = 0; i < samples.length; i += sliceSize) {
    colors.push(samples[i]);
    zonesProto.push([]);
    if (colors.length >= count3)
      break;
  }
  for (let step = 1; step <= p.clusteringStepCount; ++step) {
    const zones = deepClone(zonesProto);
    const sampleList = deepClone(samples);
    for (let i = 0; i < colors.length; ++i) {
      const idx = getClosestIndex(sampleList, colors[i]);
      zones[i].push(samples[idx]);
      sampleList.splice(idx, 1);
    }
    for (let i = 0; i < sampleList.length; ++i) {
      const nearest = getClosestIndex(colors, samples[i]);
      zones[nearest].push(samples[i]);
    }
    const lastColors = deepClone(colors);
    for (let i = 0; i < zones.length; ++i) {
      const zone = zones[i];
      const size = zone.length;
      if (size === 0)
        continue;
      let Ls = 0;
      let As = 0;
      let Bs = 0;
      for (const sample2 of zone) {
        Ls += sample2[0];
        As += sample2[1];
        Bs += sample2[2];
      }
      const lAvg = Ls / size;
      const aAvg = As / size;
      const bAvg = Bs / size;
      colors[i] = [lAvg, aAvg, bAvg];
    }
    if (deepEqual(lastColors, colors))
      break;
  }
  const sorted = p.sort === "contrast" ? sortByContrast(colors) : colors;
  return sorted.map((c5) => Lab.toColor(c5));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/color/palette.js
var DefaultGetPaletteProps = {
  type: "generate",
  colorList: "red-yellow-blue"
};
function getPaletteParams(props = {}) {
  const p = { ...DefaultGetPaletteProps, ...props };
  return {
    palette: ParamDefinition.MappedStatic(p.type, {
      colors: ParamDefinition.Group({
        list: ParamDefinition.ColorList(p.colorList)
      }, { isFlat: true }),
      generate: ParamDefinition.Group({
        ...DistinctColorsParams,
        maxCount: ParamDefinition.Numeric(75, { min: 1, max: 250, step: 1 })
      }, { isFlat: true })
    }, {
      options: [
        ["colors", "Color List"],
        ["generate", "Generate Distinct"]
      ]
    })
  };
}
var DefaultPaletteProps = ParamDefinition.getDefaultValues(getPaletteParams());
var DefaultLabelOptions = {
  valueLabel: (i) => `${i + 1}`,
  minLabel: "Start",
  maxLabel: "End"
};
function getPalette(count3, props, labelOptions = {}) {
  var _a;
  let color;
  let legend;
  if (props.palette.name === "colors" && props.palette.params.list.kind === "interpolate") {
    const { list: list2 } = props.palette.params;
    const domain = [0, count3 - 1];
    const { minLabel, maxLabel } = { ...DefaultLabelOptions, ...labelOptions };
    let colors = list2.colors;
    if (colors.length === 0)
      colors = getColorListFromName(DefaultGetPaletteProps.colorList).list;
    const scale = ColorScale.create({ listOrName: colors, domain, minLabel, maxLabel });
    legend = scale.legend;
    color = scale.color;
  } else {
    let colors;
    if (props.palette.name === "colors") {
      colors = props.palette.params.list.colors.map((c5) => Array.isArray(c5) ? c5[0] : c5);
      if (colors.length === 0)
        colors = getColorListFromName("dark-2").list.map((c5) => Array.isArray(c5) ? c5[0] : c5);
    } else {
      count3 = Math.min(count3, props.palette.params.maxCount);
      colors = distinctColors(count3, props.palette.params);
    }
    const valueLabel = (_a = labelOptions.valueLabel) !== null && _a !== void 0 ? _a : DefaultLabelOptions.valueLabel;
    const colorsLength = colors.length;
    const table = [];
    for (let i = 0; i < count3; ++i) {
      const j = i % colorsLength;
      if (table[j] === void 0) {
        table[j] = [valueLabel(i), colors[j]];
      } else {
        table[j][0] += `, ${valueLabel(i)}`;
      }
    }
    legend = TableLegend(table);
    color = (i) => colors[i % colorsLength];
  }
  return { color, legend };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/chain-id.js
var DefaultList = "many-distinct";
var DefaultColor4 = Color(16448250);
var Description6 = "Gives every chain a color based on its `asym_id` value.";
var ChainIdColorThemeParams = {
  asymId: ParamDefinition.Select("auth", ParamDefinition.arrayToOptions(["auth", "label"])),
  ...getPaletteParams({ type: "colors", colorList: DefaultList })
};
function getChainIdColorThemeParams(ctx) {
  var _a;
  const params = ParamDefinition.clone(ChainIdColorThemeParams);
  if ((_a = ctx.structure) === null || _a === void 0 ? void 0 : _a.models.some((m) => m.coarseHierarchy.isDefined)) {
    params.asymId.defaultValue = "label";
  }
  return params;
}
function getAsymId(unit, type) {
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      return type === "auth" ? StructureProperties.chain.auth_asym_id : StructureProperties.chain.label_asym_id;
    case Unit.Kind.Spheres:
    case Unit.Kind.Gaussians:
      return StructureProperties.coarse.asym_id;
  }
}
function getAsymIdKey(location, type) {
  const asymId = getAsymId(location.unit, type)(location);
  return location.structure.root.models.length > 1 ? getKey(location.unit.model, asymId) : asymId;
}
function getKey(model, asymId) {
  return `${asymId}|${(Model.Index.get(model).value || 0) + 1}`;
}
function getAsymIdSerialMap(structure, type) {
  const map3 = /* @__PURE__ */ new Map();
  for (const m of structure.models) {
    const asymIdOffset = Model.AsymIdOffset.get(m).value;
    const offset = (type === "auth" ? asymIdOffset === null || asymIdOffset === void 0 ? void 0 : asymIdOffset.auth : asymIdOffset === null || asymIdOffset === void 0 ? void 0 : asymIdOffset.label) || 0;
    let count3 = 0;
    m.properties.structAsymMap.forEach(({ auth_id }, label_id) => {
      const asymId = type === "auth" ? auth_id : label_id;
      const k = structure.models.length > 1 ? getKey(m, asymId) : asymId;
      if (!map3.has(k)) {
        map3.set(k, count3 + offset);
        ++count3;
      }
    });
  }
  return map3;
}
function ChainIdColorTheme(ctx, props) {
  let color;
  let legend;
  if (ctx.structure) {
    const l = element_exports.Location.create(ctx.structure.root);
    const asymIdSerialMap = getAsymIdSerialMap(ctx.structure.root, props.asymId);
    const labelTable = Array.from(asymIdSerialMap.keys());
    const valueLabel = (i) => labelTable[i];
    const palette = getPalette(asymIdSerialMap.size, props, { valueLabel });
    legend = palette.legend;
    color = (location) => {
      let serial = void 0;
      if (element_exports.Location.is(location)) {
        const k = getAsymIdKey(location, props.asymId);
        serial = asymIdSerialMap.get(k);
      } else if (Bond.isLocation(location)) {
        l.unit = location.aUnit;
        l.element = location.aUnit.elements[location.aIndex];
        const k = getAsymIdKey(l, props.asymId);
        serial = asymIdSerialMap.get(k);
      }
      return serial === void 0 ? DefaultColor4 : palette.color(serial);
    };
  } else {
    color = () => DefaultColor4;
  }
  return {
    factory: ChainIdColorTheme,
    granularity: "group",
    color,
    props,
    description: Description6,
    legend
  };
}
var ChainIdColorThemeProvider = {
  name: "chain-id",
  label: "Chain Id",
  category: ColorThemeCategory.Chain,
  factory: ChainIdColorTheme,
  getParams: getChainIdColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(ChainIdColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/element-index.js
var DefaultColor5 = Color(13421772);
var Description7 = "Gives every element (atom or coarse sphere/gaussian) a unique color based on the position (index) of the element in the list of elements in the structure.";
var ElementIndexColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: "red-yellow-blue" })
};
function getElementIndexColorThemeParams(ctx) {
  return ElementIndexColorThemeParams;
}
function ElementIndexColorTheme(ctx, props) {
  let color;
  let legend;
  if (ctx.structure) {
    const { units } = ctx.structure.root;
    const unitCount = units.length;
    const cummulativeElementCount = /* @__PURE__ */ new Map();
    const unitIdIndex = /* @__PURE__ */ new Map();
    let elementCount = 0;
    for (let i = 0; i < unitCount; ++i) {
      cummulativeElementCount.set(i, elementCount);
      elementCount += units[i].elements.length;
      unitIdIndex.set(units[i].id, i);
    }
    const palette = getPalette(elementCount, props);
    legend = palette.legend;
    color = (location) => {
      if (element_exports.Location.is(location)) {
        const unitIndex = unitIdIndex.get(location.unit.id);
        const unitElementIndex = OrderedSet.findPredecessorIndex(units[unitIndex].elements, location.element);
        return palette.color(cummulativeElementCount.get(unitIndex) + unitElementIndex);
      } else if (Bond.isLocation(location)) {
        const unitIndex = unitIdIndex.get(location.aUnit.id);
        const unitElementIndex = OrderedSet.findPredecessorIndex(units[unitIndex].elements, location.aUnit.elements[location.aIndex]);
        return palette.color(cummulativeElementCount.get(unitIndex) + unitElementIndex);
      }
      return DefaultColor5;
    };
  } else {
    color = () => DefaultColor5;
  }
  return {
    factory: ElementIndexColorTheme,
    granularity: "groupInstance",
    preferSmoothing: true,
    color,
    props,
    description: Description7,
    legend
  };
}
var ElementIndexColorThemeProvider = {
  name: "element-index",
  label: "Element Index",
  category: ColorThemeCategory.Atom,
  factory: ElementIndexColorTheme,
  getParams: getElementIndexColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(ElementIndexColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/color/params.js
function getColorMapParams(map3) {
  const colors = {};
  objectForEach(map3, (_, k) => {
    colors[k] = ParamDefinition.Color(map3[k]);
  });
  return colors;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/operator-name.js
var DefaultList2 = "many-distinct";
var DefaultColor6 = Color(13421772);
var Description8 = `Assigns a color based on the operator name of a transformed chain.`;
var OperatorNameColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: DefaultList2 })
};
function getOperatorNameColorThemeParams(ctx) {
  const params = ParamDefinition.clone(OperatorNameColorThemeParams);
  return params;
}
function getOperatorNameSerialMap(structure) {
  const map3 = /* @__PURE__ */ new Map();
  for (let i = 0, il = structure.units.length; i < il; ++i) {
    const name = structure.units[i].conformation.operator.name;
    if (!map3.has(name))
      map3.set(name, map3.size);
  }
  return map3;
}
function OperatorNameColorTheme(ctx, props) {
  let color;
  let legend;
  if (ctx.structure) {
    const operatorNameSerialMap = getOperatorNameSerialMap(ctx.structure.root);
    const labelTable = Array.from(operatorNameSerialMap.keys());
    const valueLabel = (i) => labelTable[i];
    const palette = getPalette(operatorNameSerialMap.size, props, { valueLabel });
    legend = palette.legend;
    color = (location) => {
      let serial = void 0;
      if (element_exports.Location.is(location)) {
        const name = location.unit.conformation.operator.name;
        serial = operatorNameSerialMap.get(name);
      } else if (Bond.isLocation(location)) {
        const name = location.aUnit.conformation.operator.name;
        serial = operatorNameSerialMap.get(name);
      }
      return serial === void 0 ? DefaultColor6 : palette.color(serial);
    };
  } else {
    color = () => DefaultColor6;
  }
  return {
    factory: OperatorNameColorTheme,
    granularity: "instance",
    color,
    props,
    description: Description8,
    legend
  };
}
var OperatorNameColorThemeProvider = {
  name: "operator-name",
  label: "Operator Name",
  category: ColorThemeCategory.Symmetry,
  factory: OperatorNameColorTheme,
  getParams: getOperatorNameColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(OperatorNameColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/entity-id.js
var DefaultList3 = "many-distinct";
var DefaultColor7 = Color(16448250);
var DefaultWaterColor = Color(16715021);
var Description9 = "Gives every chain a color based on its `label_entity_id` value.";
var EntityIdColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: DefaultList3 }),
  overrideWater: ParamDefinition.Boolean(false, { description: "Override the color for water molecules." }),
  waterColor: ParamDefinition.Color(DefaultWaterColor, { hideIf: (p) => !p.overrideWater, description: "Color for water molecules (if overrideWater is true)." })
};
function getEntityIdColorThemeParams(ctx) {
  const params = ParamDefinition.clone(EntityIdColorThemeParams);
  return params;
}
function key(entityId, sourceSerial) {
  return `${entityId}|${sourceSerial}`;
}
function getSourceSerialMap(structure) {
  const map3 = /* @__PURE__ */ new WeakMap();
  let count3 = 0;
  for (let i = 0, il = structure.models.length; i < il; ++i) {
    const sd = structure.models[i].sourceData;
    if (!map3.has(sd))
      map3.set(sd, count3++);
  }
  return map3;
}
function getEntityIdSerialMap(structure, sourceMap) {
  var _a;
  const map3 = /* @__PURE__ */ new Map();
  for (let i = 0, il = structure.models.length; i < il; ++i) {
    const sourceSerial = (_a = sourceMap.get(structure.models[i].sourceData)) !== null && _a !== void 0 ? _a : -1;
    const { label_entity_id } = structure.models[i].atomicHierarchy.chains;
    for (let j = 0, jl = label_entity_id.rowCount; j < jl; ++j) {
      const k = key(label_entity_id.value(j), sourceSerial);
      if (!map3.has(k))
        map3.set(k, map3.size);
    }
    const { coarseHierarchy } = structure.models[i];
    if (coarseHierarchy.isDefined) {
      const { entity_id: spheres_entity_id } = coarseHierarchy.spheres;
      for (let j = 0, jl = spheres_entity_id.rowCount; j < jl; ++j) {
        const k = key(spheres_entity_id.value(j), sourceSerial);
        if (!map3.has(k))
          map3.set(k, map3.size);
      }
      const { entity_id: gaussians_entity_id } = coarseHierarchy.gaussians;
      for (let j = 0, jl = gaussians_entity_id.rowCount; j < jl; ++j) {
        const k = key(gaussians_entity_id.value(j), sourceSerial);
        if (!map3.has(k))
          map3.set(k, map3.size);
      }
    }
  }
  return map3;
}
function getEntityId(location) {
  switch (location.unit.kind) {
    case Unit.Kind.Atomic:
      return StructureProperties.chain.label_entity_id(location);
    case Unit.Kind.Spheres:
    case Unit.Kind.Gaussians:
      return StructureProperties.coarse.entity_id(location);
  }
}
function EntityIdColorTheme(ctx, props) {
  let color;
  let legend;
  if (ctx.structure) {
    const l = element_exports.Location.create(ctx.structure.root);
    const sourceSerialMap = getSourceSerialMap(ctx.structure);
    const entityIdSerialMap = getEntityIdSerialMap(ctx.structure.root, sourceSerialMap);
    const labelTable = Array.from(entityIdSerialMap.keys());
    const valueLabel = (i) => labelTable[i];
    const palette = getPalette(entityIdSerialMap.size, props, { valueLabel });
    legend = palette.legend;
    color = (location) => {
      var _a;
      let structElemLoc;
      if (element_exports.Location.is(location)) {
        structElemLoc = location;
      } else if (Bond.isLocation(location)) {
        l.unit = location.aUnit;
        l.element = location.aUnit.elements[location.aIndex];
        structElemLoc = l;
      } else {
        return DefaultColor7;
      }
      const entityId = getEntityId(structElemLoc);
      const sourceSerial = (_a = sourceSerialMap.get(structElemLoc.unit.model.sourceData)) !== null && _a !== void 0 ? _a : -1;
      if (props.overrideWater) {
        const entities = structElemLoc.unit.model.entities;
        const entityType = entities.data.type.value(entities.getEntityIndex(entityId));
        if (entityType === "water")
          return props.waterColor;
      }
      const k = key(entityId, sourceSerial);
      const serial = entityIdSerialMap.get(k);
      return serial === void 0 ? DefaultColor7 : palette.color(serial);
    };
  } else {
    color = () => DefaultColor7;
  }
  return {
    factory: EntityIdColorTheme,
    granularity: "group",
    color,
    props,
    description: Description9,
    legend
  };
}
var EntityIdColorThemeProvider = {
  name: "entity-id",
  label: "Entity Id",
  category: ColorThemeCategory.Chain,
  factory: EntityIdColorTheme,
  getParams: getEntityIdColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(EntityIdColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/entity-source.js
var DefaultList4 = "dark-2";
var DefaultColor8 = Color(16448250);
var Description10 = "Gives ranges of a polymer chain a color based on the entity source it originates from (e.g. gene, plasmid, organism).";
var EntitySourceColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: DefaultList4 })
};
function getEntitySourceColorThemeParams(ctx) {
  const params = ParamDefinition.clone(EntitySourceColorThemeParams);
  if (ctx.structure) {
    if (getMaps(ctx.structure.root.models).srcKeySerialMap.size > ColorLists[DefaultList4].list.length) {
      params.palette.defaultValue.name = "colors";
      params.palette.defaultValue.params = {
        ...params.palette.defaultValue.params,
        list: { kind: "interpolate", colors: getColorListFromName(DefaultList4).list }
      };
    }
  }
  return params;
}
function modelEntityKey(modelIndex, entityId) {
  return `${modelIndex}|${entityId}`;
}
function srcKey(modelIndex, entityId, organism, srcId, plasmid, gene) {
  return `${modelIndex}|${entityId}|${organism}|${gene ? gene : plasmid ? plasmid : srcId}`;
}
function addSrc(seqToSrcByModelEntity, srcKeySerialMap, modelIndex, model, entity_src, scientific_name, plasmid_name, gene_src_gene) {
  const { entity_id, pdbx_src_id, pdbx_beg_seq_num, pdbx_end_seq_num } = entity_src;
  for (let j = 0, jl = entity_src._rowCount; j < jl; ++j) {
    const entityId = entity_id.value(j);
    const mK = modelEntityKey(modelIndex, entityId);
    let seqToSrc;
    if (!seqToSrcByModelEntity.has(mK)) {
      const entityIndex = model.entities.getEntityIndex(entityId);
      const seq = model.sequence.sequences[entityIndex].sequence;
      seqToSrc = new Int16Array(seq.length);
      seqToSrcByModelEntity.set(mK, seqToSrc);
    } else {
      seqToSrc = seqToSrcByModelEntity.get(mK);
    }
    const plasmid = plasmid_name ? plasmid_name.value(j) : "";
    const gene = gene_src_gene ? gene_src_gene.value(j)[0] : "";
    const sK = srcKey(modelIndex, entityId, scientific_name.value(j), pdbx_src_id.value(j), plasmid, gene);
    const beg = pdbx_beg_seq_num.valueKind(j) === Column.ValueKinds.Present ? pdbx_beg_seq_num.value(j) : 1;
    const end = pdbx_end_seq_num.valueKind(j) === Column.ValueKinds.Present ? pdbx_end_seq_num.value(j) : seqToSrc.length;
    let srcIndex;
    if (srcKeySerialMap.has(sK)) {
      srcIndex = srcKeySerialMap.get(sK);
    } else {
      srcIndex = srcKeySerialMap.size + 1;
      srcKeySerialMap.set(sK, srcIndex);
    }
    for (let i = beg, il = end; i <= il; ++i) {
      seqToSrc[i - 1] = srcIndex;
    }
  }
}
function getMaps(models) {
  const seqToSrcByModelEntity = /* @__PURE__ */ new Map();
  const srcKeySerialMap = /* @__PURE__ */ new Map();
  for (let i = 0, il = models.length; i < il; ++i) {
    const m = models[i];
    if (!MmcifFormat.is(m.sourceData))
      continue;
    const { entity_src_gen, entity_src_nat, pdbx_entity_src_syn } = m.sourceData.data.db;
    addSrc(seqToSrcByModelEntity, srcKeySerialMap, i, m, entity_src_gen, entity_src_gen.pdbx_gene_src_scientific_name, entity_src_gen.plasmid_name, entity_src_gen.pdbx_gene_src_gene);
    addSrc(seqToSrcByModelEntity, srcKeySerialMap, i, m, entity_src_nat, entity_src_nat.pdbx_organism_scientific, entity_src_nat.pdbx_plasmid_name);
    addSrc(seqToSrcByModelEntity, srcKeySerialMap, i, m, pdbx_entity_src_syn, pdbx_entity_src_syn.organism_scientific);
  }
  return { seqToSrcByModelEntity, srcKeySerialMap };
}
function getLabelTable(srcKeySerialMap) {
  let unnamedCount = 0;
  return Array.from(srcKeySerialMap.keys()).map((v3) => {
    const vs = v3.split("|");
    const organism = vs[2];
    const name = isInteger(vs[3]) ? `Unnamed ${++unnamedCount}` : vs[3];
    return `${name}${organism ? ` (${organism})` : ""}`;
  });
}
function EntitySourceColorTheme(ctx, props) {
  let color;
  let legend;
  if (ctx.structure) {
    const l = element_exports.Location.create(ctx.structure);
    const { models } = ctx.structure.root;
    const { seqToSrcByModelEntity, srcKeySerialMap } = getMaps(models);
    const labelTable = getLabelTable(srcKeySerialMap);
    const valueLabel = (i) => labelTable[i];
    const palette = getPalette(srcKeySerialMap.size, props, { valueLabel });
    legend = palette.legend;
    const getSrcColor = (location) => {
      const modelIndex = models.indexOf(location.unit.model);
      const entityId = StructureProperties.entity.id(location);
      const mK = modelEntityKey(modelIndex, entityId);
      const seqToSrc = seqToSrcByModelEntity.get(mK);
      if (seqToSrc) {
        const src = seqToSrc[StructureProperties.residue.label_seq_id(location) - 1] - 1;
        return src === -1 ? DefaultColor8 : palette.color(src);
      } else {
        return DefaultColor8;
      }
    };
    color = (location) => {
      if (element_exports.Location.is(location)) {
        return getSrcColor(location);
      } else if (Bond.isLocation(location)) {
        l.unit = location.aUnit;
        l.element = location.aUnit.elements[location.aIndex];
        return getSrcColor(l);
      }
      return DefaultColor8;
    };
  } else {
    color = () => DefaultColor8;
  }
  return {
    factory: EntitySourceColorTheme,
    granularity: "group",
    color,
    props,
    description: Description10,
    legend
  };
}
var EntitySourceColorThemeProvider = {
  name: "entity-source",
  label: "Entity Source",
  category: ColorThemeCategory.Chain,
  factory: EntitySourceColorTheme,
  getParams: getEntitySourceColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(EntitySourceColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/model-index.js
var DefaultColor9 = Color(13421772);
var Description11 = "Gives every model a unique color based on its index.";
var ModelIndexColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: "many-distinct" })
};
function getModelIndexColorThemeParams(ctx) {
  return ParamDefinition.clone(ModelIndexColorThemeParams);
}
function ModelIndexColorTheme(ctx, props) {
  var _a;
  let color;
  let legend;
  let contextHash = -1;
  if (ctx.structure) {
    const size = ((_a = Model.MaxIndex.get(ctx.structure.models[0]).value) !== null && _a !== void 0 ? _a : -1) + 1;
    contextHash = size;
    const palette = getPalette(size, props);
    legend = palette.legend;
    color = (location) => {
      if (element_exports.Location.is(location)) {
        return palette.color(Model.Index.get(location.unit.model).value || 0);
      } else if (Bond.isLocation(location)) {
        return palette.color(Model.Index.get(location.aUnit.model).value || 0);
      }
      return DefaultColor9;
    };
  } else {
    color = () => DefaultColor9;
  }
  return {
    factory: ModelIndexColorTheme,
    granularity: "instance",
    color,
    props,
    contextHash,
    description: Description11,
    legend
  };
}
var ModelIndexColorThemeProvider = {
  name: "model-index",
  label: "Model Index",
  category: ColorThemeCategory.Chain,
  factory: ModelIndexColorTheme,
  getParams: getModelIndexColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(ModelIndexColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure && ctx.structure.elementCount > 0
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/structure-index.js
var DefaultColor10 = Color(13421772);
var Description12 = "Gives every structure a unique color based on its index.";
var StructureIndexColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: "many-distinct" })
};
function getStructureIndexColorThemeParams(ctx) {
  return ParamDefinition.clone(StructureIndexColorThemeParams);
}
function StructureIndexColorTheme(ctx, props) {
  var _a;
  let color;
  let legend;
  let contextHash = -1;
  if (ctx.structure) {
    const size = ((_a = Structure.MaxIndex.get(ctx.structure).value) !== null && _a !== void 0 ? _a : -1) + 1;
    contextHash = size;
    const palette = getPalette(size, props);
    legend = palette.legend;
    color = (location) => {
      if (element_exports.Location.is(location)) {
        return palette.color(Structure.Index.get(location.structure).value || 0);
      } else if (Bond.isLocation(location)) {
        return palette.color(Structure.Index.get(location.aStructure).value || 0);
      }
      return DefaultColor10;
    };
  } else {
    color = () => DefaultColor10;
  }
  return {
    factory: StructureIndexColorTheme,
    granularity: "instance",
    color,
    props,
    contextHash,
    description: Description12,
    legend
  };
}
var StructureIndexColorThemeProvider = {
  name: "structure-index",
  label: "Structure Index",
  category: ColorThemeCategory.Chain,
  factory: StructureIndexColorTheme,
  getParams: getStructureIndexColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(StructureIndexColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure && ctx.structure.elementCount > 0
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/unit-index.js
var DefaultList5 = "dark-2";
var DefaultColor11 = Color(13421772);
var Description13 = "Gives every chain instance (single chain or collection of single elements) a unique color based on the position (index) of the chain in the list of chains in the structure.";
var UnitIndexColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: DefaultList5 })
};
function getUnitIndexColorThemeParams(ctx) {
  const params = ParamDefinition.clone(UnitIndexColorThemeParams);
  if (ctx.structure) {
    if (ctx.structure.root.units.length > ColorLists[DefaultList5].list.length) {
      params.palette.defaultValue.name = "colors";
      params.palette.defaultValue.params = {
        ...params.palette.defaultValue.params,
        list: { kind: "interpolate", colors: getColorListFromName(DefaultList5).list }
      };
    }
  }
  return params;
}
function UnitIndexColorTheme(ctx, props) {
  let color;
  let legend;
  if (ctx.structure) {
    const { units } = ctx.structure.root;
    const palette = getPalette(units.length, props);
    legend = palette.legend;
    const unitIdColor = /* @__PURE__ */ new Map();
    for (let i = 0, il = units.length; i < il; ++i) {
      unitIdColor.set(units[i].id, palette.color(i));
    }
    color = (location) => {
      if (element_exports.Location.is(location)) {
        return unitIdColor.get(location.unit.id);
      } else if (Bond.isLocation(location)) {
        return unitIdColor.get(location.aUnit.id);
      }
      return DefaultColor11;
    };
  } else {
    color = () => DefaultColor11;
  }
  return {
    factory: UnitIndexColorTheme,
    granularity: "instance",
    color,
    props,
    description: Description13,
    legend
  };
}
var UnitIndexColorThemeProvider = {
  name: "unit-index",
  label: "Chain Instance",
  category: ColorThemeCategory.Chain,
  factory: UnitIndexColorTheme,
  getParams: getUnitIndexColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(UnitIndexColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/trajectory-index.js
var DefaultColor12 = Color(13421772);
var Description14 = "Gives every model (frame) a unique color based on the index in its trajectory.";
var TrajectoryIndexColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: "purples" })
};
function getTrajectoryIndexColorThemeParams(ctx) {
  return ParamDefinition.clone(TrajectoryIndexColorThemeParams);
}
function TrajectoryIndexColorTheme(ctx, props) {
  var _a, _b;
  let color;
  let legend;
  let contextHash = -1;
  if (ctx.structure) {
    const { models } = ctx.structure.root;
    let size = 0;
    for (const m of models)
      size = Math.max(size, ((_a = Model.TrajectoryInfo.get(m)) === null || _a === void 0 ? void 0 : _a.size) || 0);
    const hash3 = [size];
    const palette = getPalette(size, props);
    legend = palette.legend;
    const modelColor = /* @__PURE__ */ new Map();
    for (let i = 0, il = models.length; i < il; ++i) {
      const idx = ((_b = Model.TrajectoryInfo.get(models[i])) === null || _b === void 0 ? void 0 : _b.index) || 0;
      modelColor.set(idx, palette.color(idx));
      hash3.push(idx);
    }
    contextHash = hashFnv32a(hash3);
    color = (location) => {
      if (element_exports.Location.is(location)) {
        return modelColor.get(Model.TrajectoryInfo.get(location.unit.model).index);
      } else if (Bond.isLocation(location)) {
        return modelColor.get(Model.TrajectoryInfo.get(location.aUnit.model).index);
      }
      return DefaultColor12;
    };
  } else {
    color = () => DefaultColor12;
  }
  return {
    factory: TrajectoryIndexColorTheme,
    granularity: "instance",
    color,
    props,
    contextHash,
    description: Description14,
    legend
  };
}
var TrajectoryIndexColorThemeProvider = {
  name: "trajectory-index",
  label: "Trajectory Index",
  category: ColorThemeCategory.Chain,
  factory: TrajectoryIndexColorTheme,
  getParams: getTrajectoryIndexColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(TrajectoryIndexColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure && ctx.structure.elementCount > 0 && Model.TrajectoryInfo.get(ctx.structure.models[0]).size > 1
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/element-symbol.js
var ElementSymbolColors = ColorMap({
  "H": 16777215,
  "D": 16777152,
  "T": 16777120,
  "HE": 14286847,
  "LI": 13402367,
  "BE": 12779264,
  "B": 16758197,
  "C": 9474192,
  "N": 3166456,
  "O": 16715021,
  "F": 9494608,
  "NE": 11789301,
  "NA": 11230450,
  "MG": 9109248,
  "AL": 12560038,
  "SI": 1578e4,
  "P": 16744448,
  "S": 16777008,
  "CL": 2093087,
  "AR": 8442339,
  "K": 9388244,
  "CA": 4062976,
  "SC": 15132390,
  "TI": 12567239,
  "V": 10921643,
  "CR": 9083335,
  "MN": 10255047,
  "FE": 14706227,
  "CO": 15765664,
  "NI": 5296208,
  "CU": 13140019,
  "ZN": 8224944,
  "GA": 12750735,
  "GE": 6721423,
  "AS": 12419299,
  "SE": 16752896,
  "BR": 10889513,
  "KR": 6076625,
  "RB": 7351984,
  "SR": 65280,
  "Y": 9764863,
  "ZR": 9756896,
  "NB": 7586505,
  "MO": 5551541,
  "TC": 3907230,
  "RU": 2396047,
  "RH": 687500,
  "PD": 27013,
  "AG": 12632256,
  "CD": 16767375,
  "IN": 10909043,
  "SN": 6717568,
  "SB": 10380213,
  "TE": 13924864,
  "I": 9699476,
  "XE": 9699476,
  "CS": 5707663,
  "BA": 51456,
  "LA": 7394559,
  "CE": 16777159,
  "PR": 14286791,
  "ND": 13107143,
  "PM": 10747847,
  "SM": 9437127,
  "EU": 6422471,
  "GD": 4587463,
  "TB": 3211207,
  "DY": 2097095,
  "HO": 65436,
  "ER": 58997,
  "TM": 54354,
  "YB": 48952,
  "LU": 43812,
  "HF": 5096191,
  "TA": 5089023,
  "W": 2200790,
  "RE": 2522539,
  "OS": 2516630,
  "IR": 1528967,
  "PT": 13684960,
  "AU": 16765219,
  "HG": 12105936,
  "TL": 10900557,
  "PB": 5724513,
  "BI": 10375093,
  "PO": 11230208,
  "AT": 7688005,
  "RN": 4358806,
  "FR": 4325478,
  "RA": 32e3,
  "AC": 7384058,
  "TH": 47871,
  "PA": 41471,
  "U": 36863,
  "NP": 33023,
  "PU": 27647,
  "AM": 5528818,
  "CM": 7888099,
  "BK": 9064419,
  "CF": 10565332,
  "ES": 11739092,
  "FM": 11739066,
  "MD": 11734438,
  "NO": 12389767,
  "LR": 13041766,
  "RF": 13369433,
  "DB": 13697103,
  "SG": 14221381,
  "BH": 14680120,
  "HS": 15073326,
  "MT": 15400998,
  "DS": 16777215,
  "RG": 16777215,
  "CN": 16777215,
  "UUT": 16777215,
  "FL": 16777215,
  "UUP": 16777215,
  "LV": 16777215,
  "UUH": 16777215
});
var DefaultElementSymbolColor = Color(16777215);
var Description15 = "Assigns a color to every atom according to its chemical element.";
var ElementSymbolColorThemeParams = {
  carbonColor: ParamDefinition.MappedStatic("chain-id", {
    "chain-id": ParamDefinition.Group(ChainIdColorThemeParams),
    "unit-index": ParamDefinition.Group(UnitIndexColorThemeParams, { label: "Chain Instance" }),
    "entity-id": ParamDefinition.Group(EntityIdColorThemeParams),
    "entity-source": ParamDefinition.Group(EntitySourceColorThemeParams),
    "operator-name": ParamDefinition.Group(OperatorNameColorThemeParams),
    "model-index": ParamDefinition.Group(ModelIndexColorThemeParams),
    "structure-index": ParamDefinition.Group(StructureIndexColorThemeParams),
    "trajectory-index": ParamDefinition.Group(TrajectoryIndexColorThemeParams),
    "uniform": ParamDefinition.Group(UniformColorThemeParams),
    "element-symbol": ParamDefinition.EmptyGroup()
  }, { description: "Use chain-id coloring for carbon atoms." }),
  saturation: ParamDefinition.Numeric(0, { min: -6, max: 6, step: 0.1 }),
  lightness: ParamDefinition.Numeric(0.2, { min: -6, max: 6, step: 0.1 }),
  colors: ParamDefinition.MappedStatic("default", {
    "default": ParamDefinition.EmptyGroup(),
    "custom": ParamDefinition.Group(getColorMapParams(ElementSymbolColors))
  })
};
function getElementSymbolColorThemeParams(ctx) {
  return ParamDefinition.clone(ElementSymbolColorThemeParams);
}
function elementSymbolColor(colorMap, element) {
  const c5 = colorMap[element];
  return c5 === void 0 ? DefaultElementSymbolColor : c5;
}
function getCarbonTheme(ctx, props) {
  switch (props.name) {
    case "chain-id":
      return ChainIdColorTheme(ctx, props.params);
    case "unit-index":
      return UnitIndexColorTheme(ctx, props.params);
    case "entity-id":
      return EntityIdColorTheme(ctx, props.params);
    case "entity-source":
      return EntitySourceColorTheme(ctx, props.params);
    case "operator-name":
      return OperatorNameColorTheme(ctx, props.params);
    case "model-index":
      return ModelIndexColorTheme(ctx, props.params);
    case "structure-index":
      return StructureIndexColorTheme(ctx, props.params);
    case "trajectory-index":
      return TrajectoryIndexColorTheme(ctx, props.params);
    case "uniform":
      return UniformColorTheme(ctx, props.params);
    case "element-symbol":
      return void 0;
    default:
      assertUnreachable(props);
  }
}
function ElementSymbolColorTheme(ctx, props) {
  var _a;
  const colorMap = getAdjustedColorMap(props.colors.name === "default" ? ElementSymbolColors : props.colors.params, props.saturation, props.lightness);
  const carbonTheme = getCarbonTheme(ctx, props.carbonColor);
  const carbonColor = carbonTheme === null || carbonTheme === void 0 ? void 0 : carbonTheme.color;
  const contextHash = (_a = carbonTheme === null || carbonTheme === void 0 ? void 0 : carbonTheme.contextHash) !== null && _a !== void 0 ? _a : -1;
  function elementColor(element, location) {
    return carbonColor && element === "C" ? carbonColor(location, false) : elementSymbolColor(colorMap, element);
  }
  function color(location) {
    if (element_exports.Location.is(location)) {
      if (Unit.isAtomic(location.unit)) {
        const { type_symbol } = location.unit.model.atomicHierarchy.atoms;
        return elementColor(type_symbol.value(location.element), location);
      }
    } else if (Bond.isLocation(location)) {
      if (Unit.isAtomic(location.aUnit)) {
        const { type_symbol } = location.aUnit.model.atomicHierarchy.atoms;
        const element = type_symbol.value(location.aUnit.elements[location.aIndex]);
        return elementColor(element, location);
      }
    }
    return DefaultElementSymbolColor;
  }
  const granularity = props.carbonColor.name === "operator-name" || props.carbonColor.name === "unit-index" ? "groupInstance" : "group";
  return {
    factory: ElementSymbolColorTheme,
    granularity,
    preferSmoothing: true,
    color,
    props,
    contextHash,
    description: Description15,
    legend: TableLegend(Object.keys(colorMap).map((name) => {
      return [name, colorMap[name]];
    }))
  };
}
var ElementSymbolColorThemeProvider = {
  name: "element-symbol",
  label: "Element Symbol",
  category: ColorThemeCategory.Atom,
  factory: ElementSymbolColorTheme,
  getParams: getElementSymbolColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(ElementSymbolColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/molecule-type.js
var MoleculeTypeColors = ColorMap({
  water: 3697840,
  ion: 15729279,
  protein: 12496596,
  RNA: 16629894,
  DNA: 12540695,
  PNA: 4367514,
  saccharide: 8374655
});
var DefaultMoleculeTypeColor = Color(16777113);
var Description16 = "Assigns a color based on the molecule type of a residue.";
var MoleculeTypeColorThemeParams = {
  saturation: ParamDefinition.Numeric(0, { min: -6, max: 6, step: 0.1 }),
  lightness: ParamDefinition.Numeric(0, { min: -6, max: 6, step: 0.1 }),
  colors: ParamDefinition.MappedStatic("default", {
    "default": ParamDefinition.EmptyGroup(),
    "custom": ParamDefinition.Group(getColorMapParams(MoleculeTypeColors))
  })
};
function getMoleculeTypeColorThemeParams(ctx) {
  return MoleculeTypeColorThemeParams;
}
function moleculeTypeColor(colorMap, unit, element) {
  const moleculeType = getElementMoleculeType(unit, element);
  switch (moleculeType) {
    case MoleculeType.Water:
      return colorMap.water;
    case MoleculeType.Ion:
      return colorMap.ion;
    case MoleculeType.Protein:
      return colorMap.protein;
    case MoleculeType.RNA:
      return colorMap.RNA;
    case MoleculeType.DNA:
      return colorMap.DNA;
    case MoleculeType.PNA:
      return colorMap.PNA;
    case MoleculeType.Saccharide:
      return colorMap.saccharide;
  }
  return DefaultMoleculeTypeColor;
}
function MoleculeTypeColorTheme(ctx, props) {
  const colorMap = getAdjustedColorMap(props.colors.name === "default" ? MoleculeTypeColors : props.colors.params, props.saturation, props.lightness);
  function color(location) {
    if (element_exports.Location.is(location)) {
      return moleculeTypeColor(colorMap, location.unit, location.element);
    } else if (Bond.isLocation(location)) {
      return moleculeTypeColor(colorMap, location.aUnit, location.aUnit.elements[location.aIndex]);
    }
    return DefaultMoleculeTypeColor;
  }
  return {
    factory: MoleculeTypeColorTheme,
    granularity: "group",
    color,
    props,
    description: Description16,
    legend: TableLegend(Object.keys(colorMap).map((name) => {
      return [name, colorMap[name]];
    }).concat([["Other/unknown", DefaultMoleculeTypeColor]]))
  };
}
var MoleculeTypeColorThemeProvider = {
  name: "molecule-type",
  label: "Molecule Type",
  category: ColorThemeCategory.Residue,
  factory: MoleculeTypeColorTheme,
  getParams: getMoleculeTypeColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(MoleculeTypeColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/polymer-id.js
var DefaultList6 = "dark-2";
var DefaultColor13 = Color(16448250);
var Description17 = "Gives every polymer chain a color based on its `asym_id` value.";
var PolymerIdColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: DefaultList6 })
};
function getPolymerIdColorThemeParams(ctx) {
  const params = ParamDefinition.clone(PolymerIdColorThemeParams);
  if (ctx.structure) {
    if (getPolymerAsymIdSerialMap(ctx.structure.root).size > ColorLists[DefaultList6].list.length) {
      params.palette.defaultValue.name = "colors";
      params.palette.defaultValue.params = {
        ...params.palette.defaultValue.params,
        list: { kind: "interpolate", colors: getColorListFromName(DefaultList6).list }
      };
    }
  }
  return params;
}
function getAsymId2(unit) {
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      return StructureProperties.chain.label_asym_id;
    case Unit.Kind.Spheres:
    case Unit.Kind.Gaussians:
      return StructureProperties.coarse.asym_id;
  }
}
function getPolymerAsymIdSerialMap(structure) {
  const map3 = /* @__PURE__ */ new Map();
  for (let i = 0, il = structure.unitSymmetryGroups.length; i < il; ++i) {
    const unit = structure.unitSymmetryGroups[i].units[0];
    const { model } = unit;
    if (Unit.isAtomic(unit)) {
      const { chainAtomSegments, chains } = model.atomicHierarchy;
      const chainIt = Segmentation.transientSegments(chainAtomSegments, unit.elements);
      while (chainIt.hasNext) {
        const { index: chainIndex } = chainIt.move();
        const entityId = chains.label_entity_id.value(chainIndex);
        const eI = model.entities.getEntityIndex(entityId);
        if (model.entities.data.type.value(eI) === "polymer") {
          const asymId = chains.label_asym_id.value(chainIndex);
          if (!map3.has(asymId))
            map3.set(asymId, map3.size);
        }
      }
    } else if (Unit.isCoarse(unit)) {
      const { chainElementSegments, asym_id, entity_id } = Unit.isSpheres(unit) ? model.coarseHierarchy.spheres : model.coarseHierarchy.gaussians;
      const chainIt = Segmentation.transientSegments(chainElementSegments, unit.elements);
      while (chainIt.hasNext) {
        const { index: chainIndex } = chainIt.move();
        const elementIndex = chainElementSegments.offsets[chainIndex];
        const entityId = entity_id.value(elementIndex);
        const eI = model.entities.getEntityIndex(entityId);
        if (model.entities.data.type.value(eI) === "polymer") {
          const asymId = asym_id.value(elementIndex);
          if (!map3.has(asymId))
            map3.set(asymId, map3.size);
        }
      }
    }
  }
  return map3;
}
function PolymerIdColorTheme(ctx, props) {
  let color;
  let legend;
  if (ctx.structure) {
    const l = element_exports.Location.create(ctx.structure);
    const polymerAsymIdSerialMap = getPolymerAsymIdSerialMap(ctx.structure.root);
    const labelTable = Array.from(polymerAsymIdSerialMap.keys());
    const valueLabel = (i) => labelTable[i];
    const palette = getPalette(polymerAsymIdSerialMap.size, props, { valueLabel });
    legend = palette.legend;
    color = (location) => {
      let serial = void 0;
      if (element_exports.Location.is(location)) {
        const asym_id = getAsymId2(location.unit);
        serial = polymerAsymIdSerialMap.get(asym_id(location));
      } else if (Bond.isLocation(location)) {
        const asym_id = getAsymId2(location.aUnit);
        l.unit = location.aUnit;
        l.element = location.aUnit.elements[location.aIndex];
        serial = polymerAsymIdSerialMap.get(asym_id(l));
      }
      return serial === void 0 ? DefaultColor13 : palette.color(serial);
    };
  } else {
    color = () => DefaultColor13;
  }
  return {
    factory: PolymerIdColorTheme,
    granularity: "group",
    color,
    props,
    description: Description17,
    legend
  };
}
var PolymerIdColorThemeProvider = {
  name: "polymer-id",
  label: "Polymer Chain Id",
  category: ColorThemeCategory.Chain,
  factory: PolymerIdColorTheme,
  getParams: getPolymerIdColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(PolymerIdColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/polymer-index.js
var DefaultList7 = "dark-2";
var DefaultColor14 = Color(13421772);
var Description18 = "Gives every polymer chain instance a unique color based on the position (index) of the polymer in the list of polymers in the structure.";
var PolymerIndexColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: DefaultList7 })
};
function getPolymerIndexColorThemeParams(ctx) {
  const params = ParamDefinition.clone(PolymerIndexColorThemeParams);
  if (ctx.structure) {
    if (getPolymerChainCount(ctx.structure.root) > ColorLists[DefaultList7].list.length) {
      params.palette.defaultValue.name = "colors";
      params.palette.defaultValue.params = {
        ...params.palette.defaultValue.params,
        list: { kind: "interpolate", colors: getColorListFromName(DefaultList7).list }
      };
    }
  }
  return params;
}
function getPolymerChainCount(structure) {
  let polymerChainCount = 0;
  const { units } = structure;
  for (let i = 0, il = units.length; i < il; ++i) {
    if (units[i].polymerElements.length > 0)
      ++polymerChainCount;
  }
  return polymerChainCount;
}
function PolymerIndexColorTheme(ctx, props) {
  let color;
  let legend;
  if (ctx.structure) {
    const palette = getPalette(getPolymerChainCount(ctx.structure.root), props);
    legend = palette.legend;
    const { units } = ctx.structure.root;
    const unitIdColor = /* @__PURE__ */ new Map();
    for (let i = 0, j = 0, il = units.length; i < il; ++i) {
      if (units[i].polymerElements.length > 0) {
        unitIdColor.set(units[i].id, palette.color(j));
        ++j;
      }
    }
    color = (location) => {
      let color2;
      if (element_exports.Location.is(location)) {
        color2 = unitIdColor.get(location.unit.id);
      } else if (Bond.isLocation(location)) {
        color2 = unitIdColor.get(location.aUnit.id);
      }
      return color2 !== void 0 ? color2 : DefaultColor14;
    };
  } else {
    color = () => DefaultColor14;
  }
  return {
    factory: PolymerIndexColorTheme,
    granularity: "instance",
    color,
    props,
    description: Description18,
    legend
  };
}
var PolymerIndexColorThemeProvider = {
  name: "polymer-index",
  label: "Polymer Chain Instance",
  category: ColorThemeCategory.Chain,
  factory: PolymerIndexColorTheme,
  getParams: getPolymerIndexColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(PolymerIndexColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/residue-name.js
var ResidueNameColors = ColorMap({
  // standard amino acids
  "ALA": 9240460,
  "ARG": 124,
  "ASN": 16743536,
  "ASP": 10485826,
  "CYS": 16777072,
  "GLN": 16731212,
  "GLU": 6684672,
  "GLY": 15658734,
  "HIS": 7368959,
  "ILE": 19456,
  "LEU": 4546117,
  "LYS": 4671416,
  "MET": 12099650,
  "PHE": 5459026,
  "PRO": 5395026,
  "SER": 16740418,
  "THR": 12078080,
  "TRP": 5195264,
  "TYR": 9203788,
  "VAL": 16747775,
  // rna bases
  "A": 14423100,
  // Crimson Red
  "G": 3329330,
  // Lime Green
  "I": 10145074,
  // Yellow Green
  "C": 16766720,
  // Gold Yellow
  "T": 4286945,
  // Royal Blue
  "U": 4251856,
  // Turquoise Cyan
  // dna bases
  "DA": 14423100,
  "DG": 3329330,
  "DI": 10145074,
  "DC": 16766720,
  "DT": 4286945,
  "DU": 4251856,
  // peptide bases
  "APN": 14423100,
  "GPN": 3329330,
  "CPN": 16766720,
  "TPN": 4286945
});
var DefaultResidueNameColor = Color(16711935);
var Description19 = "Assigns a color to every residue according to its name.";
var ResidueNameColorThemeParams = {
  saturation: ParamDefinition.Numeric(0, { min: -6, max: 6, step: 0.1 }),
  lightness: ParamDefinition.Numeric(1, { min: -6, max: 6, step: 0.1 }),
  colors: ParamDefinition.MappedStatic("default", {
    "default": ParamDefinition.EmptyGroup(),
    "custom": ParamDefinition.Group(getColorMapParams(ResidueNameColors))
  })
};
function getResidueNameColorThemeParams(ctx) {
  return ResidueNameColorThemeParams;
}
function getAtomicCompId(unit, element) {
  return unit.model.atomicHierarchy.atoms.label_comp_id.value(element);
}
function getCoarseCompId(unit, element) {
  const seqIdBegin = unit.coarseElements.seq_id_begin.value(element);
  const seqIdEnd = unit.coarseElements.seq_id_end.value(element);
  if (seqIdBegin === seqIdEnd) {
    const entityKey = unit.coarseElements.entityKey[element];
    const seq = unit.model.sequence.byEntityKey[entityKey].sequence;
    return seq.compId.value(seqIdBegin - 1);
  }
}
function residueNameColor(colorMap, residueName) {
  const c5 = colorMap[residueName];
  return c5 === void 0 ? DefaultResidueNameColor : c5;
}
function ResidueNameColorTheme(ctx, props) {
  const colorMap = getAdjustedColorMap(props.colors.name === "default" ? ResidueNameColors : props.colors.params, props.saturation, props.lightness);
  function color(location) {
    if (element_exports.Location.is(location)) {
      if (Unit.isAtomic(location.unit)) {
        const compId2 = getAtomicCompId(location.unit, location.element);
        return residueNameColor(colorMap, compId2);
      } else {
        const compId2 = getCoarseCompId(location.unit, location.element);
        if (compId2)
          return residueNameColor(colorMap, compId2);
      }
    } else if (Bond.isLocation(location)) {
      if (Unit.isAtomic(location.aUnit)) {
        const compId2 = getAtomicCompId(location.aUnit, location.aUnit.elements[location.aIndex]);
        return residueNameColor(colorMap, compId2);
      } else {
        const compId2 = getCoarseCompId(location.aUnit, location.aUnit.elements[location.aIndex]);
        if (compId2)
          return residueNameColor(colorMap, compId2);
      }
    }
    return DefaultResidueNameColor;
  }
  return {
    factory: ResidueNameColorTheme,
    granularity: "group",
    preferSmoothing: true,
    color,
    props,
    description: Description19,
    legend: TableLegend(Object.keys(colorMap).map((name) => {
      return [name, colorMap[name]];
    }).concat([["Unknown", DefaultResidueNameColor]]))
  };
}
var ResidueNameColorThemeProvider = {
  name: "residue-name",
  label: "Residue Name",
  category: ColorThemeCategory.Residue,
  factory: ResidueNameColorTheme,
  getParams: getResidueNameColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(ResidueNameColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/secondary-structure.js
var SecondaryStructureColors = ColorMap({
  "alphaHelix": 16711808,
  "threeTenHelix": 10485888,
  "piHelix": 6291584,
  "betaTurn": 6324479,
  "betaStrand": 16762880,
  "coil": 16777215,
  "bend": 6740169,
  "turn": 45670,
  "dna": 11403518,
  "rna": 16580962,
  "carbohydrate": 10921722
});
var DefaultSecondaryStructureColor = Color(8421504);
var Description20 = "Assigns a color based on the type of secondary structure and basic molecule type.";
var SecondaryStructureColorThemeParams = {
  saturation: ParamDefinition.Numeric(-1, { min: -6, max: 6, step: 0.1 }),
  lightness: ParamDefinition.Numeric(0, { min: -6, max: 6, step: 0.1 }),
  colors: ParamDefinition.MappedStatic("default", {
    "default": ParamDefinition.EmptyGroup(),
    "custom": ParamDefinition.Group(getColorMapParams(SecondaryStructureColors))
  })
};
function getSecondaryStructureColorThemeParams(ctx) {
  return SecondaryStructureColorThemeParams;
}
function secondaryStructureColor(colorMap, unit, element, computedSecondaryStructure) {
  let secStrucType = SecondaryStructureType.create(SecondaryStructureType.Flag.None);
  if (computedSecondaryStructure && Unit.isAtomic(unit)) {
    const secondaryStructure = computedSecondaryStructure.get(unit.invariantId);
    if (secondaryStructure)
      secStrucType = secondaryStructure.type[secondaryStructure.getIndex(unit.residueIndex[element])];
  }
  if (SecondaryStructureType.is(secStrucType, SecondaryStructureType.Flag.Helix)) {
    if (SecondaryStructureType.is(secStrucType, SecondaryStructureType.Flag.Helix3Ten)) {
      return colorMap.threeTenHelix;
    } else if (SecondaryStructureType.is(secStrucType, SecondaryStructureType.Flag.HelixPi)) {
      return colorMap.piHelix;
    }
    return colorMap.alphaHelix;
  } else if (SecondaryStructureType.is(secStrucType, SecondaryStructureType.Flag.Beta)) {
    return colorMap.betaStrand;
  } else if (SecondaryStructureType.is(secStrucType, SecondaryStructureType.Flag.Bend)) {
    return colorMap.bend;
  } else if (SecondaryStructureType.is(secStrucType, SecondaryStructureType.Flag.Turn)) {
    return colorMap.turn;
  } else {
    const moleculeType = getElementMoleculeType(unit, element);
    if (moleculeType === MoleculeType.DNA) {
      return colorMap.dna;
    } else if (moleculeType === MoleculeType.RNA) {
      return colorMap.rna;
    } else if (moleculeType === MoleculeType.Saccharide) {
      return colorMap.carbohydrate;
    } else if (moleculeType === MoleculeType.Protein) {
      return colorMap.coil;
    }
  }
  return DefaultSecondaryStructureColor;
}
function SecondaryStructureColorTheme(ctx, props) {
  const computedSecondaryStructure = ctx.structure && SecondaryStructureProvider.get(ctx.structure);
  const contextHash = computedSecondaryStructure ? hash2(computedSecondaryStructure.id, computedSecondaryStructure.version) : -1;
  const colorMap = getAdjustedColorMap(props.colors.name === "default" ? SecondaryStructureColors : props.colors.params, props.saturation, props.lightness);
  function color(location) {
    if (element_exports.Location.is(location)) {
      return secondaryStructureColor(colorMap, location.unit, location.element, computedSecondaryStructure === null || computedSecondaryStructure === void 0 ? void 0 : computedSecondaryStructure.value);
    } else if (Bond.isLocation(location)) {
      return secondaryStructureColor(colorMap, location.aUnit, location.aUnit.elements[location.aIndex], computedSecondaryStructure === null || computedSecondaryStructure === void 0 ? void 0 : computedSecondaryStructure.value);
    }
    return DefaultSecondaryStructureColor;
  }
  return {
    factory: SecondaryStructureColorTheme,
    granularity: "group",
    preferSmoothing: true,
    color,
    props,
    contextHash,
    description: Description20,
    legend: TableLegend(Object.keys(colorMap).map((name) => {
      return [name, colorMap[name]];
    }).concat([["Other", DefaultSecondaryStructureColor]]))
  };
}
var SecondaryStructureColorThemeProvider = {
  name: "secondary-structure",
  label: "Secondary Structure",
  category: ColorThemeCategory.Residue,
  factory: SecondaryStructureColorTheme,
  getParams: getSecondaryStructureColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(SecondaryStructureColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure,
  ensureCustomProperties: {
    attach: (ctx, data) => data.structure ? SecondaryStructureProvider.attach(ctx, data.structure, void 0, true) : Promise.resolve(),
    detach: (data) => data.structure && SecondaryStructureProvider.ref(data.structure, false)
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/sequence-id.js
var DefaultColor15 = Color(13421772);
var Description21 = "Gives every polymer residue a color based on its `seq_id` value.";
var SequenceIdColorThemeParams = {
  list: ParamDefinition.ColorList("turbo", { presetKind: "scale" })
};
function getSequenceIdColorThemeParams(ctx) {
  return SequenceIdColorThemeParams;
}
function getSeqId(unit, element) {
  const { model } = unit;
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      const residueIndex = model.atomicHierarchy.residueAtomSegments.index[element];
      return model.atomicHierarchy.residues.label_seq_id.value(residueIndex);
    case Unit.Kind.Spheres:
      return Math.round((model.coarseHierarchy.spheres.seq_id_begin.value(element) + model.coarseHierarchy.spheres.seq_id_end.value(element)) / 2);
    case Unit.Kind.Gaussians:
      return Math.round((model.coarseHierarchy.gaussians.seq_id_begin.value(element) + model.coarseHierarchy.gaussians.seq_id_end.value(element)) / 2);
  }
}
function getSequenceLength(unit, element) {
  const { model } = unit;
  let entityId = "";
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      const chainIndex = model.atomicHierarchy.chainAtomSegments.index[element];
      entityId = model.atomicHierarchy.chains.label_entity_id.value(chainIndex);
      break;
    case Unit.Kind.Spheres:
      entityId = model.coarseHierarchy.spheres.entity_id.value(element);
      break;
    case Unit.Kind.Gaussians:
      entityId = model.coarseHierarchy.gaussians.entity_id.value(element);
      break;
  }
  if (entityId === "")
    return 0;
  const entityIndex = model.entities.getEntityIndex(entityId);
  if (entityIndex === -1)
    return 0;
  const entity = model.sequence.byEntityKey[entityIndex];
  if (entity === void 0)
    return 0;
  return entity.sequence.length;
}
function SequenceIdColorTheme(ctx, props) {
  const scale = ColorScale.create({
    listOrName: props.list.colors,
    minLabel: "Start",
    maxLabel: "End"
  });
  const color = (location) => {
    if (element_exports.Location.is(location)) {
      const { unit, element } = location;
      const seq_id = getSeqId(unit, element);
      if (seq_id > 0) {
        const seqLen = getSequenceLength(unit, element);
        if (seqLen) {
          scale.setDomain(0, seqLen - 1);
          return scale.color(seq_id);
        }
      }
    } else if (Bond.isLocation(location)) {
      const { aUnit, aIndex } = location;
      const seq_id = getSeqId(aUnit, aUnit.elements[aIndex]);
      if (seq_id > 0) {
        const seqLen = getSequenceLength(aUnit, aUnit.elements[aIndex]);
        if (seqLen) {
          scale.setDomain(0, seqLen - 1);
          return scale.color(seq_id);
        }
      }
    }
    return DefaultColor15;
  };
  return {
    factory: SequenceIdColorTheme,
    granularity: "group",
    preferSmoothing: true,
    color,
    props,
    description: Description21,
    legend: scale ? scale.legend : void 0
  };
}
var SequenceIdColorThemeProvider = {
  name: "sequence-id",
  label: "Sequence Id",
  category: ColorThemeCategory.Residue,
  factory: SequenceIdColorTheme,
  getParams: getSequenceIdColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(SequenceIdColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/uncertainty.js
var DefaultUncertaintyColor = Color(16777113);
var Description22 = `Assigns a color based on the uncertainty or disorder of an element's position, e.g. B-factor or RMSF, depending on the data availability and experimental technique.`;
var UncertaintyColorThemeParams = {
  domain: ParamDefinition.Interval([0, 100]),
  list: ParamDefinition.ColorList("red-white-blue", { presetKind: "scale" })
};
function getUncertaintyColorThemeParams(ctx) {
  return UncertaintyColorThemeParams;
}
function getUncertainty(unit, element) {
  if (Unit.isAtomic(unit)) {
    return unit.model.atomicConformation.B_iso_or_equiv.value(element);
  } else if (Unit.isSpheres(unit)) {
    return unit.model.coarseConformation.spheres.rmsf[element];
  } else {
    return 0;
  }
}
function UncertaintyColorTheme(ctx, props) {
  let scale;
  if (props.list.kind === "set") {
    scale = ColorScale.createDiscrete({
      reverse: true,
      domain: props.domain,
      listOrName: props.list.colors
    });
  } else {
    scale = ColorScale.create({
      reverse: true,
      domain: props.domain,
      listOrName: props.list.colors
    });
  }
  function color(location) {
    if (element_exports.Location.is(location)) {
      return scale.color(getUncertainty(location.unit, location.element));
    } else if (Bond.isLocation(location)) {
      return scale.color(getUncertainty(location.aUnit, location.aUnit.elements[location.aIndex]));
    }
    return DefaultUncertaintyColor;
  }
  return {
    factory: UncertaintyColorTheme,
    granularity: "group",
    preferSmoothing: true,
    color,
    props,
    description: Description22,
    legend: scale ? scale.legend : void 0
  };
}
var UncertaintyColorThemeProvider = {
  name: "uncertainty",
  label: "Uncertainty/Disorder",
  category: ColorThemeCategory.Atom,
  factory: UncertaintyColorTheme,
  getParams: getUncertaintyColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(UncertaintyColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure && ctx.structure.models.some((m) => m.atomicConformation.B_iso_or_equiv.isDefined || m.coarseHierarchy.isDefined)
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/illustrative.js
var DefaultIllustrativeColor = Color(15658734);
var Description23 = `Assigns an illustrative color that gives every chain a color based on the chosen style but with lighter carbons (inspired by David Goodsell's Molecule of the Month style).`;
var IllustrativeColorThemeParams = {
  style: ParamDefinition.MappedStatic("entity-id", {
    uniform: ParamDefinition.Group(UniformColorThemeParams),
    "chain-id": ParamDefinition.Group(ChainIdColorThemeParams),
    "entity-id": ParamDefinition.Group(EntityIdColorThemeParams),
    "entity-source": ParamDefinition.Group(EntitySourceColorThemeParams),
    "molecule-type": ParamDefinition.Group(MoleculeTypeColorThemeParams),
    "model-index": ParamDefinition.Group(ModelIndexColorThemeParams),
    "structure-index": ParamDefinition.Group(StructureIndexColorThemeParams),
    "trajectory-index": ParamDefinition.Group(TrajectoryIndexColorThemeParams)
  }),
  carbonLightness: ParamDefinition.Numeric(0.8, { min: -6, max: 6, step: 0.1 })
};
function getIllustrativeColorThemeParams(ctx) {
  const params = ParamDefinition.clone(IllustrativeColorThemeParams);
  return params;
}
function getStyleTheme(ctx, props) {
  switch (props.name) {
    case "uniform":
      return UniformColorTheme(ctx, props.params);
    case "chain-id":
      return ChainIdColorTheme(ctx, props.params);
    case "entity-id":
      return EntityIdColorTheme(ctx, props.params);
    case "entity-source":
      return EntitySourceColorTheme(ctx, props.params);
    case "molecule-type":
      return MoleculeTypeColorTheme(ctx, props.params);
    case "model-index":
      return ModelIndexColorTheme(ctx, props.params);
    case "structure-index":
      return StructureIndexColorTheme(ctx, props.params);
    case "trajectory-index":
      return TrajectoryIndexColorTheme(ctx, props.params);
    default:
      assertUnreachable(props);
  }
}
function IllustrativeColorTheme(ctx, props) {
  const { color: styleColor, legend, contextHash } = getStyleTheme(ctx, props.style);
  function illustrativeColor(location, typeSymbol2) {
    const baseColor = styleColor(location, false);
    return typeSymbol2 === "C" ? Color.lighten(baseColor, props.carbonLightness) : baseColor;
  }
  function color(location) {
    if (element_exports.Location.is(location) && Unit.isAtomic(location.unit)) {
      const typeSymbol2 = location.unit.model.atomicHierarchy.atoms.type_symbol.value(location.element);
      return illustrativeColor(location, typeSymbol2);
    } else if (Bond.isLocation(location) && Unit.isAtomic(location.aUnit)) {
      const elementIndex = location.aUnit.elements[location.aIndex];
      const typeSymbol2 = location.aUnit.model.atomicHierarchy.atoms.type_symbol.value(elementIndex);
      return illustrativeColor(location, typeSymbol2);
    }
    return DefaultIllustrativeColor;
  }
  return {
    factory: IllustrativeColorTheme,
    granularity: "group",
    preferSmoothing: true,
    color,
    props,
    contextHash,
    description: Description23,
    legend
  };
}
var IllustrativeColorThemeProvider = {
  name: "illustrative",
  label: "Illustrative",
  category: ColorThemeCategory.Misc,
  factory: IllustrativeColorTheme,
  getParams: getIllustrativeColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(IllustrativeColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/hydrophobicity.js
var Description24 = 'Assigns a color to every amino acid according to the "Experimentally determined hydrophobicity scale for proteins at membrane interfaces" by Wimely and White (doi:10.1038/nsb1096-842).';
var HydrophobicityColorThemeParams = {
  list: ParamDefinition.ColorList("red-yellow-green", { presetKind: "scale" }),
  scale: ParamDefinition.Select("DGwif", [["DGwif", "DG water-membrane"], ["DGwoct", "DG water-octanol"], ["Oct-IF", "DG difference"]])
};
function getHydrophobicityColorThemeParams(ctx) {
  return HydrophobicityColorThemeParams;
}
var scaleIndexMap = { "DGwif": 0, "DGwoct": 1, "Oct-IF": 2 };
function hydrophobicity(compId2, scaleIndex) {
  const c5 = ResidueHydrophobicity[compId2];
  return c5 === void 0 ? 0 : c5[scaleIndex];
}
function getAtomicCompId2(unit, element) {
  return unit.model.atomicHierarchy.atoms.label_comp_id.value(element);
}
function getCoarseCompId2(unit, element) {
  const seqIdBegin = unit.coarseElements.seq_id_begin.value(element);
  const seqIdEnd = unit.coarseElements.seq_id_end.value(element);
  if (seqIdBegin === seqIdEnd) {
    const entityKey = unit.coarseElements.entityKey[element];
    const seq = unit.model.sequence.byEntityKey[entityKey].sequence;
    return seq.compId.value(seqIdBegin - 1);
  }
}
function HydrophobicityColorTheme(ctx, props) {
  const scaleIndex = scaleIndexMap[props.scale];
  let min3 = Infinity;
  let max3 = -Infinity;
  for (const name in ResidueHydrophobicity) {
    const val = ResidueHydrophobicity[name][scaleIndex];
    min3 = Math.min(min3, val);
    max3 = Math.max(max3, val);
  }
  const scale = ColorScale.create({
    listOrName: props.list.colors,
    domain: [max3, min3],
    minLabel: "Hydrophilic",
    maxLabel: "Hydrophobic"
  });
  function color(location) {
    let compId2;
    if (element_exports.Location.is(location)) {
      if (Unit.isAtomic(location.unit)) {
        compId2 = getAtomicCompId2(location.unit, location.element);
      } else {
        compId2 = getCoarseCompId2(location.unit, location.element);
      }
    } else if (Bond.isLocation(location)) {
      if (Unit.isAtomic(location.aUnit)) {
        compId2 = getAtomicCompId2(location.aUnit, location.aUnit.elements[location.aIndex]);
      } else {
        compId2 = getCoarseCompId2(location.aUnit, location.aUnit.elements[location.aIndex]);
      }
    }
    return scale.color(compId2 ? hydrophobicity(compId2, scaleIndex) : 0);
  }
  return {
    factory: HydrophobicityColorTheme,
    granularity: "group",
    preferSmoothing: true,
    color,
    props,
    description: Description24,
    legend: scale ? scale.legend : void 0
  };
}
var HydrophobicityColorThemeProvider = {
  name: "hydrophobicity",
  label: "Hydrophobicity",
  category: ColorThemeCategory.Residue,
  factory: HydrophobicityColorTheme,
  getParams: getHydrophobicityColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(HydrophobicityColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/occupancy.js
var DefaultOccupancyColor = Color(13421772);
var Description25 = `Assigns a color based on the occupancy of an atom.`;
var OccupancyColorThemeParams = {
  domain: ParamDefinition.Interval([0, 1]),
  list: ParamDefinition.ColorList("purples", { presetKind: "scale" })
};
function getOccupancyColorThemeParams(ctx) {
  return OccupancyColorThemeParams;
}
function getOccupancy(unit, element) {
  if (Unit.isAtomic(unit)) {
    return unit.model.atomicConformation.occupancy.value(element);
  } else {
    return 0;
  }
}
function OccupancyColorTheme(ctx, props) {
  const scale = ColorScale.create({
    reverse: false,
    domain: props.domain,
    listOrName: props.list.colors
  });
  function color(location) {
    if (element_exports.Location.is(location)) {
      return scale.color(getOccupancy(location.unit, location.element));
    } else if (Bond.isLocation(location)) {
      return scale.color(getOccupancy(location.aUnit, location.aUnit.elements[location.aIndex]));
    }
    return DefaultOccupancyColor;
  }
  return {
    factory: OccupancyColorTheme,
    granularity: "group",
    preferSmoothing: true,
    color,
    props,
    description: Description25,
    legend: scale ? scale.legend : void 0
  };
}
var OccupancyColorThemeProvider = {
  name: "occupancy",
  label: "Occupancy",
  category: ColorThemeCategory.Atom,
  factory: OccupancyColorTheme,
  getParams: getOccupancyColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(OccupancyColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure && ctx.structure.models.some((m) => m.atomicConformation.occupancy.isDefined)
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/operator-hkl.js
var DefaultList8 = "dark-2";
var DefaultColor16 = Color(13421772);
var Description26 = `Assigns a color based on the operator HKL value of a transformed chain.`;
var OperatorHklColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: DefaultList8 })
};
function getOperatorHklColorThemeParams(ctx) {
  const params = ParamDefinition.clone(OperatorHklColorThemeParams);
  if (ctx.structure) {
    if (getOperatorHklSerialMap(ctx.structure.root).map.size > ColorLists[DefaultList8].list.length) {
      params.palette.defaultValue.name = "colors";
      params.palette.defaultValue.params = {
        ...params.palette.defaultValue.params,
        list: { kind: "interpolate", colors: getColorListFromName(DefaultList8).list }
      };
    }
  }
  return params;
}
var hklOffset = 1e4;
function hklKey(hkl) {
  return hkl.map((v3) => `${v3 + hklOffset}`.padStart(5, "0")).join("");
}
function hklKeySplit(key2) {
  const len = integerDigitCount(hklOffset, 0);
  const h = parseInt(key2.substr(0, len));
  const k = parseInt(key2.substr(len, len));
  const l = parseInt(key2.substr(len + len, len));
  return Vec3.create(h - hklOffset, k - hklOffset, l - hklOffset);
}
function formatHkl(hkl) {
  return hkl.map((v3) => v3 + 5).join("");
}
function getOperatorHklSerialMap(structure) {
  const map3 = /* @__PURE__ */ new Map();
  const set4 = /* @__PURE__ */ new Set();
  for (let i = 0, il = structure.units.length; i < il; ++i) {
    const k = hklKey(structure.units[i].conformation.operator.hkl);
    set4.add(k);
  }
  const arr = Array.from(set4.values()).sort();
  arr.forEach((k) => map3.set(k, map3.size));
  const min3 = hklKeySplit(arr[0]);
  const max3 = hklKeySplit(arr[arr.length - 1]);
  return { min: min3, max: max3, map: map3 };
}
function OperatorHklColorTheme(ctx, props) {
  let color;
  let legend;
  if (ctx.structure) {
    const { min: min3, max: max3, map: map3 } = getOperatorHklSerialMap(ctx.structure.root);
    const labelTable = [];
    map3.forEach((v3, k) => {
      const i = v3 % map3.size;
      const label2 = formatHkl(hklKeySplit(k));
      if (labelTable[i] === void 0)
        labelTable[i] = label2;
      else
        labelTable[i] += `, ${label2}`;
    });
    const labelOptions = {
      minLabel: formatHkl(min3),
      maxLabel: formatHkl(max3),
      valueLabel: (i) => labelTable[i]
    };
    const palette = getPalette(map3.size, props, labelOptions);
    legend = palette.legend;
    color = (location) => {
      let serial = void 0;
      if (element_exports.Location.is(location)) {
        const k = hklKey(location.unit.conformation.operator.hkl);
        serial = map3.get(k);
      } else if (Bond.isLocation(location)) {
        const k = hklKey(location.aUnit.conformation.operator.hkl);
        serial = map3.get(k);
      }
      return serial === void 0 ? DefaultColor16 : palette.color(serial);
    };
  } else {
    color = () => DefaultColor16;
  }
  return {
    factory: OperatorHklColorTheme,
    granularity: "instance",
    color,
    props,
    description: Description26,
    legend
  };
}
var OperatorHklColorThemeProvider = {
  name: "operator-hkl",
  label: "Operator HKL",
  category: ColorThemeCategory.Symmetry,
  factory: OperatorHklColorTheme,
  getParams: getOperatorHklColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(OperatorHklColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/partial-charge.js
var DefaultPartialChargeColor = Color(16777113);
var Description27 = `Assigns a color based on the partial charge of an atom.`;
var PartialChargeColorThemeParams = {
  domain: ParamDefinition.Interval([-1, 1]),
  list: ParamDefinition.ColorList("red-white-blue", { presetKind: "scale" })
};
function getPartialChargeColorThemeParams(ctx) {
  return PartialChargeColorThemeParams;
}
function getPartialCharge(unit, element) {
  var _a;
  return (_a = AtomPartialCharge.Provider.get(unit.model)) === null || _a === void 0 ? void 0 : _a.data.value(element);
}
function PartialChargeColorTheme(ctx, props) {
  const scale = ColorScale.create({
    domain: props.domain,
    listOrName: props.list.colors
  });
  function color(location) {
    if (element_exports.Location.is(location)) {
      const q = getPartialCharge(location.unit, location.element);
      return q !== void 0 ? scale.color(q) : DefaultPartialChargeColor;
    } else if (Bond.isLocation(location)) {
      const q = getPartialCharge(location.aUnit, location.aUnit.elements[location.aIndex]);
      return q !== void 0 ? scale.color(q) : DefaultPartialChargeColor;
    }
    return DefaultPartialChargeColor;
  }
  return {
    factory: PartialChargeColorTheme,
    granularity: "group",
    preferSmoothing: true,
    color,
    props,
    description: Description27,
    legend: scale ? scale.legend : void 0
  };
}
var PartialChargeColorThemeProvider = {
  name: "partial-charge",
  label: "Partial Charge",
  category: ColorThemeCategory.Atom,
  factory: PartialChargeColorTheme,
  getParams: getPartialChargeColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(PartialChargeColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure && ctx.structure.models.some((m) => AtomPartialCharge.Provider.get(m) !== void 0)
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/atom-id.js
var DefaultList9 = "many-distinct";
var DefaultColor17 = Color(16448250);
var Description28 = "Gives every atom a color based on its `label_atom_id` value.";
var AtomIdColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: DefaultList9 })
};
function getAtomIdColorThemeParams(ctx) {
  const params = ParamDefinition.clone(AtomIdColorThemeParams);
  return params;
}
function getAtomIdSerialMap(structure) {
  const map3 = /* @__PURE__ */ new Map();
  for (const m of structure.models) {
    const { label_atom_id } = m.atomicHierarchy.atoms;
    for (let i = 0, il = label_atom_id.rowCount; i < il; ++i) {
      const id = label_atom_id.value(i);
      if (!map3.has(id))
        map3.set(id, map3.size);
    }
  }
  return map3;
}
function AtomIdColorTheme(ctx, props) {
  let color;
  let legend;
  if (ctx.structure) {
    const l = element_exports.Location.create(ctx.structure.root);
    const atomIdSerialMap = getAtomIdSerialMap(ctx.structure.root);
    const labelTable = Array.from(atomIdSerialMap.keys());
    const valueLabel = (i) => labelTable[i];
    const palette = getPalette(atomIdSerialMap.size, props, { valueLabel });
    legend = palette.legend;
    color = (location) => {
      let serial = void 0;
      if (element_exports.Location.is(location)) {
        const id = StructureProperties.atom.label_atom_id(location);
        serial = atomIdSerialMap.get(id);
      } else if (Bond.isLocation(location)) {
        l.unit = location.aUnit;
        l.element = location.aUnit.elements[location.aIndex];
        const id = StructureProperties.atom.label_atom_id(l);
        serial = atomIdSerialMap.get(id);
      }
      return serial === void 0 ? DefaultColor17 : palette.color(serial);
    };
  } else {
    color = () => DefaultColor17;
  }
  return {
    factory: AtomIdColorTheme,
    granularity: "group",
    preferSmoothing: true,
    color,
    props,
    description: Description28,
    legend
  };
}
var AtomIdColorThemeProvider = {
  name: "atom-id",
  label: "Atom Id",
  category: ColorThemeCategory.Atom,
  factory: AtomIdColorTheme,
  getParams: getAtomIdColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(AtomIdColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/volume-value.js
var Description29 = "Assign color based on the given value of a volume cell.";
var VolumeValueColorThemeParams = {
  colorList: ParamDefinition.ColorList({
    kind: "interpolate",
    colors: [
      [ColorNames.white, 0],
      [ColorNames.red, 0.25],
      [ColorNames.white, 0.5],
      [ColorNames.blue, 0.75],
      [ColorNames.white, 1]
    ]
  }, { offsets: true, isEssential: true }),
  domain: ParamDefinition.MappedStatic("auto", {
    custom: ParamDefinition.Interval([-1, 1], { step: 1e-3 }),
    auto: ParamDefinition.Group({
      symmetric: ParamDefinition.Boolean(false, { description: "If true the automatic range is determined as [-|max|, |max|]." })
    })
  }),
  isRelative: ParamDefinition.Boolean(false, { description: "If true the value is treated as relative to the volume mean and sigma." }),
  defaultColor: ParamDefinition.Color(Color(13421772))
};
function getVolumeValueColorThemeParams(ctx) {
  return VolumeValueColorThemeParams;
}
function VolumeValueColorTheme(ctx, props) {
  var _a;
  if (ctx.volume) {
    const { min: min3, max: max3, mean, sigma } = ctx.volume.grid.stats;
    const domain = props.domain.name === "custom" ? props.domain.params : [min3, max3];
    const { colorList, defaultColor } = props;
    if (props.domain.name === "auto" && props.isRelative) {
      domain[0] = (domain[0] - mean) / sigma;
      domain[1] = (domain[1] - mean) / sigma;
    }
    if (props.domain.name === "auto" && props.domain.params.symmetric) {
      const max4 = Math.max(Math.abs(domain[0]), Math.abs(domain[1]));
      domain[0] = -max4;
      domain[1] = max4;
    }
    if ((_a = ctx.locationKinds) === null || _a === void 0 ? void 0 : _a.includes("direct-location")) {
      const normalizedDomain = [
        normalize(domain[0], min3, max3),
        normalize(domain[1], min3, max3)
      ];
      const palette = ColorTheme.Palette(colorList.colors, colorList.kind, normalizedDomain, defaultColor);
      return {
        factory: VolumeValueColorTheme,
        granularity: "direct",
        props,
        description: Description29,
        palette
      };
    } else {
      const getTrilinearlyInterpolated2 = Grid.makeGetTrilinearlyInterpolated(ctx.volume.grid, "none");
      const color = (location) => {
        if (!isPositionLocation(location)) {
          return props.defaultColor;
        }
        const value = getTrilinearlyInterpolated2(location.position);
        if (isNaN(value))
          return props.defaultColor;
        return clamp((value - domain[0]) / (domain[1] - domain[0]), 0, 1) * ColorTheme.PaletteScale;
      };
      const palette = ColorTheme.Palette(colorList.colors, colorList.kind, void 0, defaultColor);
      return {
        factory: VolumeValueColorTheme,
        granularity: "vertex",
        preferSmoothing: true,
        color,
        palette,
        props,
        description: Description29
      };
    }
  } else {
    return {
      factory: VolumeValueColorTheme,
      granularity: "uniform",
      color: () => props.defaultColor,
      props,
      description: Description29
    };
  }
}
var VolumeValueColorThemeProvider = {
  name: "volume-value",
  label: "Volume Value",
  category: ColorThemeCategory.Misc,
  factory: VolumeValueColorTheme,
  getParams: getVolumeValueColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(VolumeValueColorThemeParams),
  isApplicable: (ctx) => !!ctx.volume && !Volume.Segmentation.get(ctx.volume)
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/volume-segment.js
var DefaultColor18 = Color(13421772);
var Description30 = "Gives every volume segment a unique color.";
var VolumeSegmentColorThemeParams = {
  ...getPaletteParams({ type: "colors", colorList: "many-distinct" })
};
function getVolumeSegmentColorThemeParams(ctx) {
  return ParamDefinition.clone(VolumeSegmentColorThemeParams);
}
function VolumeSegmentColorTheme(ctx, props) {
  let color;
  let legend;
  const segmentation = ctx.volume && Volume.Segmentation.get(ctx.volume);
  if (segmentation) {
    const size = segmentation.segments.size;
    const segments = Array.from(segmentation.segments.keys());
    const palette = getPalette(size, props);
    legend = palette.legend;
    color = (location) => {
      if (Volume.Segment.isLocation(location)) {
        return palette.color(segments.indexOf(location.segment));
      }
      return DefaultColor18;
    };
  } else {
    color = () => DefaultColor18;
  }
  return {
    factory: VolumeSegmentColorTheme,
    granularity: "instance",
    color,
    props,
    description: Description30,
    legend
  };
}
var VolumeSegmentColorThemeProvider = {
  name: "volume-segment",
  label: "Volume Segment",
  category: ColorThemeCategory.Misc,
  factory: VolumeSegmentColorTheme,
  getParams: getVolumeSegmentColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(VolumeSegmentColorThemeParams),
  isApplicable: (ctx) => !!ctx.volume && !!Volume.Segmentation.get(ctx.volume)
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/external-volume.js
var Description31 = `Assigns a color based on volume value at a given vertex.`;
var ExternalVolumeColorThemeParams = {
  volume: ParamDefinition.ValueRef((ctx) => {
    const volumes = ctx.state.data.selectQ((q) => q.root.subtree().filter((c5) => {
      var _a;
      return Volume.is((_a = c5.obj) === null || _a === void 0 ? void 0 : _a.data);
    }));
    return volumes.map((v3) => {
      var _a, _b;
      return [v3.transform.ref, (_b = (_a = v3.obj) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : "<unknown>"];
    });
  }, (ref, getData) => getData(ref)),
  coloring: ParamDefinition.MappedStatic("absolute-value", {
    "absolute-value": ParamDefinition.Group({
      domain: ParamDefinition.MappedStatic("auto", {
        custom: ParamDefinition.Interval([-1, 1], { step: 1e-3 }),
        auto: ParamDefinition.Group({
          symmetric: ParamDefinition.Boolean(false, { description: "If true the automatic range is determined as [-|max|, |max|]." })
        })
      }),
      list: ParamDefinition.ColorList("red-white-blue", { presetKind: "scale" })
    }),
    "relative-value": ParamDefinition.Group({
      domain: ParamDefinition.MappedStatic("auto", {
        custom: ParamDefinition.Interval([-1, 1], { step: 1e-3 }),
        auto: ParamDefinition.Group({
          symmetric: ParamDefinition.Boolean(false, { description: "If true the automatic range is determined as [-|max|, |max|]." })
        })
      }),
      list: ParamDefinition.ColorList("red-white-blue", { presetKind: "scale" })
    })
  }),
  defaultColor: ParamDefinition.Color(Color(13421772)),
  normalOffset: ParamDefinition.Numeric(0, { min: 0, max: 20, step: 0.1 }, { description: "Offset vertex position along its normal by given amount." }),
  usePalette: ParamDefinition.Boolean(false, { description: "Use a palette to color at the pixel level." })
};
function ExternalVolumeColorTheme(ctx, props) {
  let volume;
  try {
    volume = props.volume.getValue();
  } catch (_a) {
  }
  let color;
  let palette;
  const { normalOffset, defaultColor, usePalette } = props;
  if (volume) {
    const coloring = props.coloring.params;
    const { stats } = volume.grid;
    const domain = coloring.domain.name === "custom" ? coloring.domain.params : [stats.min, stats.max];
    const isRelative = props.coloring.name === "relative-value";
    if (coloring.domain.name === "auto" && isRelative) {
      domain[0] = (domain[0] - stats.mean) / stats.sigma;
      domain[1] = (domain[1] - stats.mean) / stats.sigma;
    }
    if (coloring.domain.name === "auto" && coloring.domain.params.symmetric) {
      const max3 = Math.max(Math.abs(domain[0]), Math.abs(domain[1]));
      domain[0] = -max3;
      domain[1] = max3;
    }
    const scale = ColorScale.create({ domain, listOrName: coloring.list.colors });
    const position = Vec3();
    const getTrilinearlyInterpolated2 = Grid.makeGetTrilinearlyInterpolated(volume.grid, isRelative ? "relative" : "none");
    color = (location) => {
      if (!isPositionLocation(location)) {
        return defaultColor;
      }
      if (normalOffset > 0) {
        Vec3.scaleAndAdd(position, location.position, location.normal, normalOffset);
      } else {
        Vec3.copy(position, location.position);
      }
      const value = getTrilinearlyInterpolated2(position);
      if (isNaN(value))
        return defaultColor;
      if (usePalette) {
        return clamp((value - domain[0]) / (domain[1] - domain[0]), 0, 1) * ColorTheme.PaletteScale;
      } else {
        return scale.color(value);
      }
    };
    palette = usePalette ? {
      colors: coloring.list.colors.map((e) => Array.isArray(e) ? e[0] : e),
      filter: coloring.list.kind === "set" ? "nearest" : "linear"
    } : void 0;
  } else {
    color = () => defaultColor;
  }
  return {
    factory: ExternalVolumeColorTheme,
    granularity: "vertex",
    preferSmoothing: true,
    color,
    palette,
    props,
    description: Description31
    // TODO: figure out how to do legend for this
  };
}
var ExternalVolumeColorThemeProvider = {
  name: "external-volume",
  label: "External Volume",
  category: ColorThemeCategory.Misc,
  factory: ExternalVolumeColorTheme,
  getParams: () => ExternalVolumeColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(ExternalVolumeColorThemeParams),
  isApplicable: (ctx) => true
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/cartoon.js
var Description32 = "Uses separate themes for coloring mainchain and sidechain visuals.";
var CartoonColorThemeParams = {
  mainchain: ParamDefinition.MappedStatic("molecule-type", {
    "uniform": ParamDefinition.Group(UniformColorThemeParams),
    "chain-id": ParamDefinition.Group(ChainIdColorThemeParams),
    "entity-id": ParamDefinition.Group(EntityIdColorThemeParams),
    "entity-source": ParamDefinition.Group(EntitySourceColorThemeParams),
    "molecule-type": ParamDefinition.Group(MoleculeTypeColorThemeParams),
    "model-index": ParamDefinition.Group(ModelIndexColorThemeParams),
    "structure-index": ParamDefinition.Group(StructureIndexColorThemeParams),
    "secondary-structure": ParamDefinition.Group(SecondaryStructureColorThemeParams),
    "trajectory-index": ParamDefinition.Group(TrajectoryIndexColorThemeParams)
  }),
  sidechain: ParamDefinition.MappedStatic("residue-name", {
    "uniform": ParamDefinition.Group(UniformColorThemeParams),
    "residue-name": ParamDefinition.Group(ResidueNameColorThemeParams),
    "element-symbol": ParamDefinition.Group(ElementSymbolColorThemeParams),
    "hydrophobicity": ParamDefinition.Group(HydrophobicityColorThemeParams),
    "uncertainty": ParamDefinition.Group(UncertaintyColorThemeParams),
    "occupancy": ParamDefinition.Group(OccupancyColorThemeParams),
    "sequence-id": ParamDefinition.Group(SequenceIdColorThemeParams),
    "partial-charge": ParamDefinition.Group(PartialChargeColorThemeParams)
  })
};
function getCartoonColorThemeParams(ctx) {
  const params = ParamDefinition.clone(CartoonColorThemeParams);
  return params;
}
function getMainchainTheme(ctx, props) {
  switch (props.name) {
    case "uniform":
      return UniformColorTheme(ctx, props.params);
    case "chain-id":
      return ChainIdColorTheme(ctx, props.params);
    case "entity-id":
      return EntityIdColorTheme(ctx, props.params);
    case "entity-source":
      return EntitySourceColorTheme(ctx, props.params);
    case "molecule-type":
      return MoleculeTypeColorTheme(ctx, props.params);
    case "model-index":
      return ModelIndexColorTheme(ctx, props.params);
    case "structure-index":
      return StructureIndexColorTheme(ctx, props.params);
    case "secondary-structure":
      return SecondaryStructureColorTheme(ctx, props.params);
    case "trajectory-index":
      return TrajectoryIndexColorTheme(ctx, props.params);
    default:
      assertUnreachable(props);
  }
}
function getSidechainTheme(ctx, props) {
  switch (props.name) {
    case "uniform":
      return UniformColorTheme(ctx, props.params);
    case "residue-name":
      return ResidueNameColorTheme(ctx, props.params);
    case "element-symbol":
      return ElementSymbolColorTheme(ctx, props.params);
    case "hydrophobicity":
      return HydrophobicityColorTheme(ctx, props.params);
    case "uncertainty":
      return UncertaintyColorTheme(ctx, props.params);
    case "occupancy":
      return OccupancyColorTheme(ctx, props.params);
    case "sequence-id":
      return SequenceIdColorTheme(ctx, props.params);
    case "partial-charge":
      return PartialChargeColorTheme(ctx, props.params);
    default:
      assertUnreachable(props);
  }
}
function CartoonColorTheme(ctx, props) {
  var _a, _b, _c, _d;
  const mainchain = getMainchainTheme(ctx, props.mainchain);
  const sidechain2 = getSidechainTheme(ctx, props.sidechain);
  const contextHash = hash2((_a = mainchain.contextHash) !== null && _a !== void 0 ? _a : 0, (_b = sidechain2.contextHash) !== null && _b !== void 0 ? _b : 0);
  function color(location, isSecondary) {
    return isSecondary ? mainchain.color(location, false) : sidechain2.color(location, false);
  }
  let legend = mainchain.legend;
  if (((_c = mainchain.legend) === null || _c === void 0 ? void 0 : _c.kind) === "table-legend" && ((_d = sidechain2.legend) === null || _d === void 0 ? void 0 : _d.kind) === "table-legend") {
    legend = {
      kind: "table-legend",
      table: [...mainchain.legend.table, ...sidechain2.legend.table]
    };
  }
  return {
    factory: CartoonColorTheme,
    granularity: "group",
    preferSmoothing: false,
    color,
    props,
    contextHash,
    description: Description32,
    legend
  };
}
var CartoonColorThemeProvider = {
  name: "cartoon",
  label: "Cartoon",
  category: ColorThemeCategory.Misc,
  factory: CartoonColorTheme,
  getParams: getCartoonColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(CartoonColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/formal-charge.js
var DefaultFormalChargeColor = Color(16777113);
var Description33 = `Assigns a color based on the formal charge of an atom.`;
var FormalChargeColorThemeParams = {
  domain: ParamDefinition.Interval([-3, 3]),
  list: ParamDefinition.ColorList({ kind: "set", colors: ColorLists["red-white-blue"].list })
};
function getFormalChargeColorThemeParams(ctx) {
  return FormalChargeColorThemeParams;
}
function getFormalCharge(unit, element) {
  if (Unit.isAtomic(unit)) {
    return unit.model.atomicHierarchy.atoms.pdbx_formal_charge.value(element);
  } else {
    return 0;
  }
}
function FormalChargeColorTheme(ctx, props) {
  const scale = ColorScale.create({
    domain: props.domain,
    listOrName: props.list.colors
  });
  function color(location) {
    if (element_exports.Location.is(location)) {
      const fc = getFormalCharge(location.unit, location.element);
      return fc !== void 0 ? scale.color(fc) : DefaultFormalChargeColor;
    } else if (Bond.isLocation(location)) {
      const fc = getFormalCharge(location.aUnit, location.aUnit.elements[location.aIndex]);
      return fc !== void 0 ? scale.color(fc) : DefaultFormalChargeColor;
    }
    return DefaultFormalChargeColor;
  }
  return {
    factory: FormalChargeColorTheme,
    granularity: "group",
    preferSmoothing: true,
    color,
    props,
    description: Description33,
    legend: scale ? scale.legend : void 0
  };
}
var FormalChargeColorThemeProvider = {
  name: "formal-charge",
  label: "Formal Charge",
  category: ColorThemeCategory.Atom,
  factory: FormalChargeColorTheme,
  getParams: getFormalChargeColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(FormalChargeColorThemeParams),
  isApplicable: (ctx) => !!ctx.structure && ctx.structure.models.some((m) => m.atomicHierarchy.atoms.pdbx_formal_charge.isDefined)
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color/external-structure.js
var Description34 = `Assigns a color based on structure property at a given vertex.`;
var ExternalStructureColorThemeParams = {
  structure: ParamDefinition.ValueRef((ctx) => {
    const structures = ctx.state.data.select(StateSelection.Generators.rootsOfType(PluginStateObject.Molecule.Structure)).filter((c5) => {
      var _a;
      return (_a = c5.obj) === null || _a === void 0 ? void 0 : _a.data;
    });
    return structures.map((v3) => {
      var _a, _b;
      return [v3.transform.ref, (_b = (_a = v3.obj) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : "<unknown>"];
    });
  }, (ref, getData) => getData(ref)),
  style: ParamDefinition.MappedStatic("chain-id", {
    "chain-id": ParamDefinition.Group(ChainIdColorThemeParams),
    "entity-id": ParamDefinition.Group(EntityIdColorThemeParams),
    "entity-source": ParamDefinition.Group(EntitySourceColorThemeParams),
    "molecule-type": ParamDefinition.Group(MoleculeTypeColorThemeParams),
    "model-index": ParamDefinition.Group(ModelIndexColorThemeParams),
    "structure-index": ParamDefinition.Group(StructureIndexColorThemeParams)
  }),
  defaultColor: ParamDefinition.Color(Color(13421772)),
  maxDistance: ParamDefinition.Numeric(8, { min: 0.1, max: 24, step: 0.1 }, { description: "Maximum distance to search for the nearest structure element. This is done only if the approximate search fails." }),
  approxMaxDistance: ParamDefinition.Numeric(4, { min: 0, max: 12, step: 0.1 }, { description: "Maximum distance to search for an approximately nearest structure element. This is done before the extact search." }),
  normalOffset: ParamDefinition.Numeric(0, { min: -10, max: 20, step: 0.1 }, { description: "Offset vertex position along its normal by given amount." }),
  backboneOnly: ParamDefinition.Boolean(false)
};
function getStyleTheme2(ctx, props) {
  switch (props.name) {
    case "chain-id":
      return ChainIdColorTheme(ctx, props.params);
    case "entity-id":
      return EntityIdColorTheme(ctx, props.params);
    case "entity-source":
      return EntitySourceColorTheme(ctx, props.params);
    case "molecule-type":
      return MoleculeTypeColorTheme(ctx, props.params);
    case "model-index":
      return ModelIndexColorTheme(ctx, props.params);
    case "structure-index":
      return StructureIndexColorTheme(ctx, props.params);
    default:
      assertUnreachable(props);
  }
}
function ExternalStructureColorTheme(ctx, props) {
  let structure;
  try {
    structure = props.structure.getValue();
  } catch (_a) {
  }
  let color;
  let contextHash = void 0;
  let legend = void 0;
  const { maxDistance, approxMaxDistance: approxDistance, normalOffset, defaultColor, backboneOnly } = props;
  if (structure) {
    const styleTheme = getStyleTheme2({ ...ctx, structure }, props.style);
    const lookupFirstCtx = StructureLookup3DResultContext();
    const lookupNearestCtx = StructureLookup3DResultContext();
    let s = structure;
    if (backboneOnly) {
      s = StructureSelection.unionStructure(StructureSelectionQueries.backbone.query(new QueryContext(structure)));
    }
    const position = Vec3();
    const l = element_exports.Location.create(s);
    color = (location, isSecondary) => {
      if (!isPositionLocation(location)) {
        return defaultColor;
      }
      if (normalOffset !== 0) {
        Vec3.scaleAndAdd(position, location.position, location.normal, normalOffset);
      } else {
        Vec3.copy(position, location.position);
      }
      const [x, y, z] = position;
      if (approxDistance > 0) {
        const rf = s.lookup3d.approxNearest(x, y, z, approxDistance, lookupFirstCtx);
        if (rf.count > 0) {
          l.unit = rf.units[0];
          l.element = l.unit.elements[rf.indices[0]];
          return styleTheme.color(l, isSecondary);
        }
      }
      const rn = s.lookup3d.find(x, y, z, maxDistance, lookupNearestCtx);
      if (rn.count > 0) {
        let idx = 0;
        let minD = rn.squaredDistances[0];
        for (let i = 1; i < rn.count; ++i) {
          if (rn.squaredDistances[i] < minD) {
            minD = rn.squaredDistances[i];
            idx = i;
          }
        }
        l.unit = rn.units[idx];
        l.element = l.unit.elements[rn.indices[idx]];
        return styleTheme.color(l, isSecondary);
      }
      return defaultColor;
    };
    contextHash = styleTheme.contextHash;
    legend = styleTheme.legend;
  } else {
    color = () => defaultColor;
  }
  return {
    factory: ExternalStructureColorTheme,
    granularity: "vertex",
    preferSmoothing: true,
    color,
    props,
    contextHash,
    description: Description34,
    legend
  };
}
var ExternalStructureColorThemeProvider = {
  name: "external-structure",
  label: "External Structure",
  category: ColorThemeCategory.Misc,
  factory: ExternalStructureColorTheme,
  getParams: () => ExternalStructureColorThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(ExternalStructureColorThemeParams),
  isApplicable: (ctx) => true
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/color.js
var ColorTheme;
(function(ColorTheme2) {
  ColorTheme2.Category = ColorThemeCategory;
  function Palette(list2, kind, domain, defaultColor) {
    const colors = [];
    const hasOffsets = list2.every((c5) => Array.isArray(c5));
    if (hasOffsets) {
      let maxPrecision = 0;
      for (const e of list2) {
        if (Array.isArray(e)) {
          const p = getPrecision(e[1]);
          if (p > maxPrecision)
            maxPrecision = p;
        }
      }
      const count3 = Math.pow(10, maxPrecision);
      const sorted = [...list2];
      sorted.sort((a5, b5) => a5[1] - b5[1]);
      const src = sorted.map((c5) => c5[0]);
      const values2 = SortedArray.ofSortedArray(sorted.map((c5) => c5[1]));
      const _off = [];
      for (let i = 0, il = values2.length - 1; i < il; ++i) {
        _off.push(values2[i] + (values2[i + 1] - values2[i]) / 2);
      }
      _off.push(values2[values2.length - 1]);
      const off = SortedArray.ofSortedArray(_off);
      for (let i = 0, il = Math.max(count3, list2.length); i < il; ++i) {
        const t2 = normalize(i, 0, count3 - 1);
        const j = SortedArray.findPredecessorIndex(off, t2);
        colors[i] = src[j];
      }
    } else {
      for (const e of list2) {
        if (Array.isArray(e))
          colors.push(e[0]);
        else
          colors.push(e);
      }
    }
    return {
      colors,
      filter: kind === "set" ? "nearest" : "linear",
      domain,
      defaultColor
    };
  }
  ColorTheme2.Palette = Palette;
  ColorTheme2.PaletteScale = (1 << 24) - 2;
  ColorTheme2.EmptyFactory = () => ColorTheme2.Empty;
  const EmptyColor = Color(13421772);
  ColorTheme2.Empty = {
    factory: ColorTheme2.EmptyFactory,
    granularity: "uniform",
    color: () => EmptyColor,
    props: {}
  };
  function areEqual(themeA, themeB) {
    return themeA.contextHash === themeB.contextHash && themeA.factory === themeB.factory && deepEqual(themeA.props, themeB.props);
  }
  ColorTheme2.areEqual = areEqual;
  ColorTheme2.EmptyProvider = { name: "", label: "", category: "", factory: ColorTheme2.EmptyFactory, getParams: () => ({}), defaultValues: {}, isApplicable: () => true };
  function createRegistry() {
    return new ThemeRegistry(ColorTheme2.BuiltIn, ColorTheme2.EmptyProvider);
  }
  ColorTheme2.createRegistry = createRegistry;
  ColorTheme2.BuiltIn = {
    "atom-id": AtomIdColorThemeProvider,
    "carbohydrate-symbol": CarbohydrateSymbolColorThemeProvider,
    "cartoon": CartoonColorThemeProvider,
    "chain-id": ChainIdColorThemeProvider,
    "element-index": ElementIndexColorThemeProvider,
    "element-symbol": ElementSymbolColorThemeProvider,
    "entity-id": EntityIdColorThemeProvider,
    "entity-source": EntitySourceColorThemeProvider,
    "external-structure": ExternalStructureColorThemeProvider,
    "external-volume": ExternalVolumeColorThemeProvider,
    "formal-charge": FormalChargeColorThemeProvider,
    "hydrophobicity": HydrophobicityColorThemeProvider,
    "illustrative": IllustrativeColorThemeProvider,
    "model-index": ModelIndexColorThemeProvider,
    "molecule-type": MoleculeTypeColorThemeProvider,
    "occupancy": OccupancyColorThemeProvider,
    "operator-hkl": OperatorHklColorThemeProvider,
    "operator-name": OperatorNameColorThemeProvider,
    "partial-charge": PartialChargeColorThemeProvider,
    "polymer-id": PolymerIdColorThemeProvider,
    "polymer-index": PolymerIndexColorThemeProvider,
    "residue-name": ResidueNameColorThemeProvider,
    "secondary-structure": SecondaryStructureColorThemeProvider,
    "sequence-id": SequenceIdColorThemeProvider,
    "shape-group": ShapeGroupColorThemeProvider,
    "structure-index": StructureIndexColorThemeProvider,
    "trajectory-index": TrajectoryIndexColorThemeProvider,
    "uncertainty": UncertaintyColorThemeProvider,
    "unit-index": UnitIndexColorThemeProvider,
    "uniform": UniformColorThemeProvider,
    "volume-segment": VolumeSegmentColorThemeProvider,
    "volume-value": VolumeValueColorThemeProvider
  };
})(ColorTheme || (ColorTheme = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/size/physical.js
var DefaultSize2 = 1;
var Description35 = "Assigns a physical size, i.e. vdW radius for atoms or given radius for coarse spheres.";
var PhysicalSizeThemeParams = {
  scale: ParamDefinition.Numeric(1, { min: 0.1, max: 5, step: 0.1 })
};
function getPhysicalSizeThemeParams(ctx) {
  return PhysicalSizeThemeParams;
}
function getPhysicalRadius(unit, element) {
  if (Unit.isAtomic(unit)) {
    return VdwRadius(unit.model.atomicHierarchy.atoms.type_symbol.value(element));
  } else if (Unit.isSpheres(unit)) {
    return unit.model.coarseConformation.spheres.radius[element];
  } else {
    return 0;
  }
}
function PhysicalSizeTheme(ctx, props) {
  const scale = props.scale === void 0 ? 1 : props.scale;
  function size(location) {
    let size2;
    if (element_exports.Location.is(location)) {
      size2 = scale * getPhysicalRadius(location.unit, location.element);
    } else if (Bond.isLocation(location)) {
      size2 = scale * Math.min(getPhysicalRadius(location.aUnit, location.aUnit.elements[location.aIndex]), getPhysicalRadius(location.bUnit, location.bUnit.elements[location.bIndex]));
    } else {
      size2 = scale * DefaultSize2;
    }
    return size2;
  }
  return {
    factory: PhysicalSizeTheme,
    granularity: "group",
    size,
    props,
    description: Description35
  };
}
var PhysicalSizeThemeProvider = {
  name: "physical",
  label: "Physical",
  category: "",
  factory: PhysicalSizeTheme,
  getParams: getPhysicalSizeThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(PhysicalSizeThemeParams),
  isApplicable: (ctx) => !!ctx.structure
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/size/uncertainty.js
var Description36 = `Assigns a size reflecting the uncertainty or disorder of an element's position, e.g. B-factor or RMSF, depending on the data availability and experimental technique.`;
var UncertaintySizeThemeParams = {
  bfactorFactor: ParamDefinition.Numeric(0.1, { min: 0, max: 1, step: 0.01 }),
  rmsfFactor: ParamDefinition.Numeric(0.05, { min: 0, max: 1, step: 0.01 }),
  baseSize: ParamDefinition.Numeric(0.2, { min: 0, max: 2, step: 0.1 })
};
function getUncertaintySizeThemeParams(ctx) {
  return UncertaintySizeThemeParams;
}
function getUncertainty2(unit, element, props) {
  if (Unit.isAtomic(unit)) {
    return unit.model.atomicConformation.B_iso_or_equiv.value(element) * props.bfactorFactor;
  } else if (Unit.isSpheres(unit)) {
    return unit.model.coarseConformation.spheres.rmsf[element] * props.rmsfFactor;
  } else {
    return 0;
  }
}
function UncertaintySizeTheme(ctx, props) {
  function size(location) {
    let size2 = props.baseSize;
    if (element_exports.Location.is(location)) {
      size2 += getUncertainty2(location.unit, location.element, props);
    } else if (Bond.isLocation(location)) {
      size2 += getUncertainty2(location.aUnit, location.aUnit.elements[location.aIndex], props);
    }
    return size2;
  }
  return {
    factory: UncertaintySizeTheme,
    granularity: "group",
    size,
    props,
    description: Description36
  };
}
var UncertaintySizeThemeProvider = {
  name: "uncertainty",
  label: "Uncertainty/Disorder",
  category: "",
  factory: UncertaintySizeTheme,
  getParams: getUncertaintySizeThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(UncertaintySizeThemeParams),
  isApplicable: (ctx) => !!ctx.structure && ctx.structure.models.some((m) => m.atomicConformation.B_iso_or_equiv.isDefined || m.coarseHierarchy.isDefined)
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/size/volume-value.js
var Description37 = "Assign size based on the given value of a volume cell.";
var VolumeValueSizeThemeParams = {
  scale: ParamDefinition.Numeric(1, { min: 0.1, max: 5, step: 0.1 })
};
function getVolumeValueSizeThemeParams(ctx) {
  return VolumeValueSizeThemeParams;
}
function VolumeValueSizeTheme(ctx, props) {
  if (ctx.volume) {
    const { data } = ctx.volume.grid.cells;
    const isLocation = Volume.Cell.isLocation;
    const size = (location) => {
      if (isLocation(location)) {
        return data[location.cell] * props.scale;
      } else {
        return 0;
      }
    };
    return {
      factory: VolumeValueSizeTheme,
      granularity: "group",
      size,
      props,
      description: Description37
    };
  } else {
    return {
      factory: VolumeValueSizeTheme,
      granularity: "uniform",
      size: () => props.scale,
      props,
      description: Description37
    };
  }
}
var VolumeValueSizeThemeProvider = {
  name: "volume-value",
  label: "Volume Value",
  category: "",
  factory: VolumeValueSizeTheme,
  getParams: getVolumeValueSizeThemeParams,
  defaultValues: ParamDefinition.getDefaultValues(VolumeValueSizeThemeParams),
  isApplicable: (ctx) => !!ctx.volume && !Volume.Segmentation.get(ctx.volume)
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/size.js
var SizeTheme;
(function(SizeTheme2) {
  SizeTheme2.EmptyFactory = () => SizeTheme2.Empty;
  SizeTheme2.Empty = { factory: SizeTheme2.EmptyFactory, granularity: "uniform", size: () => 1, props: {} };
  function areEqual(themeA, themeB) {
    return themeA.contextHash === themeB.contextHash && themeA.factory === themeB.factory && deepEqual(themeA.props, themeB.props);
  }
  SizeTheme2.areEqual = areEqual;
  SizeTheme2.EmptyProvider = { name: "", label: "", category: "", factory: SizeTheme2.EmptyFactory, getParams: () => ({}), defaultValues: {}, isApplicable: () => true };
  function createRegistry() {
    return new ThemeRegistry(SizeTheme2.BuiltIn, SizeTheme2.EmptyProvider);
  }
  SizeTheme2.createRegistry = createRegistry;
  SizeTheme2.BuiltIn = {
    "physical": PhysicalSizeThemeProvider,
    "shape-group": ShapeGroupSizeThemeProvider,
    "uncertainty": UncertaintySizeThemeProvider,
    "uniform": UniformSizeThemeProvider,
    "volume-value": VolumeValueSizeThemeProvider
  };
})(SizeTheme || (SizeTheme = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/theme.js
var Theme;
(function(Theme2) {
  function create(ctx, data, props, theme) {
    theme = theme || createEmpty();
    const colorProps = props.colorTheme;
    const sizeProps = props.sizeTheme;
    theme.color = ctx.colorThemeRegistry.create(colorProps.name, data, colorProps.params);
    theme.size = ctx.sizeThemeRegistry.create(sizeProps.name, data, sizeProps.params);
    return theme;
  }
  Theme2.create = create;
  function createEmpty() {
    return { color: ColorTheme.Empty, size: SizeTheme.Empty };
  }
  Theme2.createEmpty = createEmpty;
  async function ensureDependencies(ctx, theme, data, props) {
    var _a, _b;
    await ((_a = theme.colorThemeRegistry.get(props.colorTheme.name).ensureCustomProperties) === null || _a === void 0 ? void 0 : _a.attach(ctx, data));
    await ((_b = theme.sizeThemeRegistry.get(props.sizeTheme.name).ensureCustomProperties) === null || _b === void 0 ? void 0 : _b.attach(ctx, data));
  }
  Theme2.ensureDependencies = ensureDependencies;
  function releaseDependencies(theme, data, props) {
    var _a, _b;
    (_a = theme.colorThemeRegistry.get(props.colorTheme.name).ensureCustomProperties) === null || _a === void 0 ? void 0 : _a.detach(data);
    (_b = theme.sizeThemeRegistry.get(props.sizeTheme.name).ensureCustomProperties) === null || _b === void 0 ? void 0 : _b.detach(data);
  }
  Theme2.releaseDependencies = releaseDependencies;
})(Theme || (Theme = {}));
function getTypes(list2) {
  return list2.map((e) => [e.name, e.provider.label, e.provider.category]);
}
var ThemeRegistry = class {
  get default() {
    return this._list[0];
  }
  get list() {
    return this._list;
  }
  get types() {
    return getTypes(this._list);
  }
  constructor(builtInThemes, emptyProvider) {
    this.emptyProvider = emptyProvider;
    this._list = [];
    this._map = /* @__PURE__ */ new Map();
    this._name = /* @__PURE__ */ new Map();
    objectForEach(builtInThemes, (p, k) => {
      if (p.name !== k)
        throw new Error(`Fix build in themes to have matching names. ${p.name} ${k}`);
      this.add(p);
    });
  }
  sort() {
    this._list.sort((a5, b5) => {
      if (a5.provider.category === b5.provider.category) {
        return a5.provider.label < b5.provider.label ? -1 : a5.provider.label > b5.provider.label ? 1 : 0;
      }
      return a5.provider.category < b5.provider.category ? -1 : 1;
    });
  }
  add(provider) {
    if (this._map.has(provider.name)) {
      throw new Error(`${provider.name} already registered.`);
    }
    const name = provider.name;
    this._list.push({ name, provider });
    this._map.set(name, provider);
    this._name.set(provider, name);
    this.sort();
  }
  remove(provider) {
    this._list.splice(this._list.findIndex((e) => e.name === provider.name), 1);
    const p = this._map.get(provider.name);
    if (p) {
      this._map.delete(provider.name);
      this._name.delete(p);
    }
  }
  has(provider) {
    return this._map.has(provider.name);
  }
  get(name) {
    return this._map.get(name) || this.emptyProvider;
  }
  getName(provider) {
    if (!this._name.has(provider))
      throw new Error(`'${provider.label}' is not a registered theme provider.`);
    return this._name.get(provider);
  }
  create(name, ctx, props = {}) {
    const provider = this.get(name);
    return provider.factory(ctx, { ...ParamDefinition.getDefaultValues(provider.getParams(ctx)), ...props });
  }
  getApplicableList(ctx) {
    return this._list.filter((e) => e.provider.isApplicable(ctx));
  }
  getApplicableTypes(ctx) {
    return getTypes(this.getApplicableList(ctx));
  }
  clear() {
    this._list.length = 0;
    this._map.clear();
    this._name.clear();
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/marker-action.js
var MarkerAction;
(function(MarkerAction2) {
  MarkerAction2[MarkerAction2["None"] = 0] = "None";
  MarkerAction2[MarkerAction2["Highlight"] = 1] = "Highlight";
  MarkerAction2[MarkerAction2["RemoveHighlight"] = 2] = "RemoveHighlight";
  MarkerAction2[MarkerAction2["Select"] = 4] = "Select";
  MarkerAction2[MarkerAction2["Deselect"] = 8] = "Deselect";
  MarkerAction2[MarkerAction2["Toggle"] = 16] = "Toggle";
  MarkerAction2[MarkerAction2["Clear"] = 32] = "Clear";
})(MarkerAction || (MarkerAction = {}));
var MarkerActions;
(function(MarkerActions2) {
  MarkerActions2.is = BitFlags.has;
  MarkerActions2.All = MarkerAction.Highlight | MarkerAction.RemoveHighlight | MarkerAction.Select | MarkerAction.Deselect | MarkerAction.Toggle | MarkerAction.Clear;
  MarkerActions2.Highlighting = MarkerAction.Highlight | MarkerAction.RemoveHighlight | MarkerAction.Clear;
  MarkerActions2.Selecting = MarkerAction.Select | MarkerAction.Deselect | MarkerAction.Toggle | MarkerAction.Clear;
  function isReverse(a5, b5) {
    return a5 === MarkerAction.Highlight && b5 === MarkerAction.RemoveHighlight || a5 === MarkerAction.RemoveHighlight && b5 === MarkerAction.Highlight || a5 === MarkerAction.Select && b5 === MarkerAction.Deselect || a5 === MarkerAction.Deselect && b5 === MarkerAction.Select || a5 === MarkerAction.Toggle && b5 === MarkerAction.Toggle;
  }
  MarkerActions2.isReverse = isReverse;
})(MarkerActions || (MarkerActions = {}));
function setMarkerValue(array, status, count3) {
  array.fill(status, 0, count3);
}
function applyMarkerActionAtPosition(array, i, action) {
  switch (action) {
    case MarkerAction.Highlight:
      array[i] |= 1;
      break;
    case MarkerAction.RemoveHighlight:
      array[i] &= ~1;
      break;
    case MarkerAction.Select:
      array[i] |= 2;
      break;
    case MarkerAction.Deselect:
      array[i] &= ~2;
      break;
    case MarkerAction.Toggle:
      array[i] ^= 2;
      break;
    case MarkerAction.Clear:
      array[i] = 0;
      break;
  }
}
function applyMarkerAction(array, set4, action) {
  if (action === MarkerAction.None)
    return false;
  if (Interval.is(set4)) {
    const start = Interval.start(set4);
    const end = Interval.end(set4);
    const viewStart = start + 3 >> 2;
    const viewEnd = viewStart + (end - 4 * viewStart >> 2);
    if (viewEnd <= viewStart) {
      for (let i = start; i < end; ++i) {
        applyMarkerActionAtPosition(array, i, action);
      }
      return true;
    }
    const view = new Uint32Array(array.buffer, 0, array.buffer.byteLength >> 2);
    const frontStart = start;
    const frontEnd = Math.min(4 * viewStart, end);
    const backStart = Math.max(start, 4 * viewEnd);
    const backEnd = end;
    switch (action) {
      case MarkerAction.Highlight:
        for (let i = viewStart; i < viewEnd; ++i)
          view[i] |= 16843009;
        break;
      case MarkerAction.RemoveHighlight:
        for (let i = viewStart; i < viewEnd; ++i)
          view[i] &= ~16843009;
        break;
      case MarkerAction.Select:
        for (let i = viewStart; i < viewEnd; ++i)
          view[i] |= 33686018;
        break;
      case MarkerAction.Deselect:
        for (let i = viewStart; i < viewEnd; ++i)
          view[i] &= ~33686018;
        break;
      case MarkerAction.Toggle:
        for (let i = viewStart; i < viewEnd; ++i)
          view[i] ^= 33686018;
        break;
      case MarkerAction.Clear:
        for (let i = viewStart; i < viewEnd; ++i)
          view[i] = 0;
        break;
      default:
        assertUnreachable(action);
    }
    for (let i = frontStart; i < frontEnd; ++i) {
      applyMarkerActionAtPosition(array, i, action);
    }
    for (let i = backStart; i < backEnd; ++i) {
      applyMarkerActionAtPosition(array, i, action);
    }
  } else {
    switch (action) {
      case MarkerAction.Highlight:
        for (let i = 0, il = set4.length; i < il; ++i)
          array[set4[i]] |= 1;
        break;
      case MarkerAction.RemoveHighlight:
        for (let i = 0, il = set4.length; i < il; ++i)
          array[set4[i]] &= ~1;
        break;
      case MarkerAction.Select:
        for (let i = 0, il = set4.length; i < il; ++i)
          array[set4[i]] |= 2;
        break;
      case MarkerAction.Deselect:
        for (let i = 0, il = set4.length; i < il; ++i)
          array[set4[i]] &= ~2;
        break;
      case MarkerAction.Toggle:
        for (let i = 0, il = set4.length; i < il; ++i)
          array[set4[i]] ^= 2;
        break;
      case MarkerAction.Clear:
        for (let i = 0, il = set4.length; i < il; ++i)
          array[set4[i]] = 0;
        break;
      default:
        assertUnreachable(action);
    }
  }
  return true;
}
function getMarkerInfo(action, currentStatus) {
  let average = -1;
  let status = -1;
  switch (action) {
    case MarkerAction.Highlight:
      if (currentStatus === 0 || currentStatus === 1) {
        average = 1;
        status = 1;
      } else if (currentStatus === 2 || currentStatus === 3) {
        average = 1;
        status = 3;
      } else {
        average = 1;
      }
      break;
    case MarkerAction.RemoveHighlight:
      if (currentStatus === 0 || currentStatus === 1) {
        average = 0;
        status = 0;
      } else if (currentStatus === 2 || currentStatus === 3) {
        average = 1;
        status = 2;
      }
      break;
    case MarkerAction.Select:
      if (currentStatus === 1 || currentStatus === 3) {
        average = 1;
        status = 3;
      } else if (currentStatus === 0 || currentStatus === 2) {
        average = 1;
        status = 2;
      } else {
        average = 1;
      }
      break;
    case MarkerAction.Deselect:
      if (currentStatus === 1 || currentStatus === 3) {
        average = 1;
        status = 1;
      } else if (currentStatus === 0 || currentStatus === 2) {
        average = 0;
        status = 0;
      }
      break;
    case MarkerAction.Toggle:
      if (currentStatus === 1) {
        average = 1;
        status = 3;
      } else if (currentStatus === 2) {
        average = 0;
        status = 0;
      } else if (currentStatus === 3) {
        average = 1;
        status = 1;
      } else if (currentStatus === 0) {
        average = 1;
        status = 2;
      }
      break;
    case MarkerAction.Clear:
      average = 0;
      status = 0;
      break;
  }
  return { average, status };
}
function getPartialMarkerAverage(action, currentStatus) {
  switch (action) {
    case MarkerAction.Highlight:
      return 0.5;
    case MarkerAction.RemoveHighlight:
      if (currentStatus === 0) {
        return 0;
      } else if (currentStatus === 2 || currentStatus === 3) {
        return 0.5;
      } else {
        return -1;
      }
    case MarkerAction.Select:
      return 0.5;
    case MarkerAction.Deselect:
      if (currentStatus === 1 || currentStatus === 3) {
        return 0.5;
      } else if (currentStatus === 0) {
        return 0;
      } else {
        return -1;
      }
    case MarkerAction.Toggle:
      if (currentStatus === -1) {
        return -1;
      } else {
        return 0.5;
      }
    case MarkerAction.Clear:
      if (currentStatus === -1) {
        return -1;
      } else if (currentStatus === 0) {
        return 0;
      } else {
        return 0.5;
      }
    case MarkerAction.None:
      return -1;
    default:
      assertUnreachable(action);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/loci.js
var EveryLoci = { kind: "every-loci" };
function isEveryLoci(x) {
  return !!x && x.kind === "every-loci";
}
var EmptyLoci = { kind: "empty-loci" };
function isEmptyLoci(x) {
  return !!x && x.kind === "empty-loci";
}
function isDataLoci(x) {
  return !!x && x.kind === "data-loci";
}
function areDataLociEqual(a5, b5) {
  if (!shallowEqual(a5.data, b5.data) || a5.tag !== b5.tag)
    return false;
  if (a5.elements.length !== b5.elements.length)
    return false;
  for (let i = 0, il = a5.elements.length; i < il; ++i) {
    if (!shallowEqual(a5.elements[i], b5.elements[i]))
      return false;
  }
  return true;
}
function isDataLociEmpty(loci) {
  return loci.elements.length === 0 ? true : false;
}
function DataLoci(tag, data, elements, getBoundingSphere3, getLabel) {
  return { kind: "data-loci", tag, data, elements, getBoundingSphere: getBoundingSphere3, getLabel };
}
var Loci;
(function(Loci2) {
  const boundaryHelper2 = new BoundaryHelper("98");
  function getBundleBoundingSphere(bundle) {
    const spheres = bundle.loci.map((l) => getBoundingSphere3(l)).filter((s) => !!s);
    boundaryHelper2.reset();
    for (const s of spheres)
      boundaryHelper2.includePositionRadius(s.center, s.radius);
    boundaryHelper2.finishedIncludeStep();
    for (const s of spheres)
      boundaryHelper2.radiusPositionRadius(s.center, s.radius);
    return boundaryHelper2.getSphere();
  }
  Loci2.getBundleBoundingSphere = getBundleBoundingSphere;
  function areEqual(lociA, lociB) {
    if (isEveryLoci(lociA) && isEveryLoci(lociB))
      return true;
    if (isEmptyLoci(lociA) && isEmptyLoci(lociB))
      return true;
    if (isDataLoci(lociA) && isDataLoci(lociB)) {
      return areDataLociEqual(lociA, lociB);
    }
    if (Structure.isLoci(lociA) && Structure.isLoci(lociB)) {
      return Structure.areLociEqual(lociA, lociB);
    }
    if (element_exports.Loci.is(lociA) && element_exports.Loci.is(lociB)) {
      return element_exports.Loci.areEqual(lociA, lociB);
    }
    if (Bond.isLoci(lociA) && Bond.isLoci(lociB)) {
      return Bond.areLociEqual(lociA, lociB);
    }
    if (Shape.isLoci(lociA) && Shape.isLoci(lociB)) {
      return Shape.areLociEqual(lociA, lociB);
    }
    if (ShapeGroup.isLoci(lociA) && ShapeGroup.isLoci(lociB)) {
      return ShapeGroup.areLociEqual(lociA, lociB);
    }
    if (Volume.isLoci(lociA) && Volume.isLoci(lociB)) {
      return Volume.areLociEqual(lociA, lociB);
    }
    if (Volume.Isosurface.isLoci(lociA) && Volume.Isosurface.isLoci(lociB)) {
      return Volume.Isosurface.areLociEqual(lociA, lociB);
    }
    if (Volume.Cell.isLoci(lociA) && Volume.Cell.isLoci(lociB)) {
      return Volume.Cell.areLociEqual(lociA, lociB);
    }
    if (Volume.Segment.isLoci(lociA) && Volume.Segment.isLoci(lociB)) {
      return Volume.Segment.areLociEqual(lociA, lociB);
    }
    return false;
  }
  Loci2.areEqual = areEqual;
  function isEvery(loci) {
    return !!loci && loci.kind === "every-loci";
  }
  Loci2.isEvery = isEvery;
  function isEmpty3(loci) {
    if (isEveryLoci(loci))
      return false;
    if (isEmptyLoci(loci))
      return true;
    if (isDataLoci(loci))
      return isDataLociEmpty(loci);
    if (Structure.isLoci(loci))
      return Structure.isLociEmpty(loci);
    if (element_exports.Loci.is(loci))
      return element_exports.Loci.isEmpty(loci);
    if (Bond.isLoci(loci))
      return Bond.isLociEmpty(loci);
    if (Shape.isLoci(loci))
      return Shape.isLociEmpty(loci);
    if (ShapeGroup.isLoci(loci))
      return ShapeGroup.isLociEmpty(loci);
    if (Volume.isLoci(loci))
      return Volume.isLociEmpty(loci);
    if (Volume.Isosurface.isLoci(loci))
      return Volume.Isosurface.isLociEmpty(loci);
    if (Volume.Cell.isLoci(loci))
      return Volume.Cell.isLociEmpty(loci);
    if (Volume.Segment.isLoci(loci))
      return Volume.Segment.isLociEmpty(loci);
    return false;
  }
  Loci2.isEmpty = isEmpty3;
  function remap(loci, data) {
    if (data instanceof Structure) {
      if (element_exports.Loci.is(loci)) {
        loci = element_exports.Loci.remap(loci, data);
      } else if (Structure.isLoci(loci)) {
        loci = Structure.remapLoci(loci, data);
      } else if (Bond.isLoci(loci)) {
        loci = Bond.remapLoci(loci, data);
      }
    }
    return loci;
  }
  Loci2.remap = remap;
  function getBoundingSphere3(loci, boundingSphere) {
    var _a;
    if (loci.kind === "every-loci" || loci.kind === "empty-loci")
      return void 0;
    if (!boundingSphere)
      boundingSphere = Sphere3D();
    if (loci.kind === "structure-loci") {
      return Sphere3D.copy(boundingSphere, loci.structure.boundary.sphere);
    } else if (loci.kind === "element-loci") {
      return Sphere3D.copy(boundingSphere, element_exports.Loci.getBoundary(loci).sphere);
    } else if (loci.kind === "bond-loci") {
      return Bond.getBoundingSphere(loci, boundingSphere);
    } else if (loci.kind === "shape-loci") {
      return Sphere3D.copy(boundingSphere, loci.shape.geometry.boundingSphere);
    } else if (loci.kind === "group-loci") {
      return ShapeGroup.getBoundingSphere(loci, boundingSphere);
    } else if (loci.kind === "data-loci") {
      return (_a = loci.getBoundingSphere) === null || _a === void 0 ? void 0 : _a.call(loci, boundingSphere);
    } else if (loci.kind === "volume-loci") {
      return Volume.getBoundingSphere(loci.volume, boundingSphere);
    } else if (loci.kind === "isosurface-loci") {
      return Volume.Isosurface.getBoundingSphere(loci.volume, loci.isoValue, boundingSphere);
    } else if (loci.kind === "cell-loci") {
      return Volume.Cell.getBoundingSphere(loci.volume, loci.indices, boundingSphere);
    } else if (loci.kind === "segment-loci") {
      return Volume.Segment.getBoundingSphere(loci.volume, loci.segments, boundingSphere);
    }
  }
  Loci2.getBoundingSphere = getBoundingSphere3;
  const tmpSphere3D = Sphere3D.zero();
  function getCenter(loci, center) {
    const boundingSphere = getBoundingSphere3(loci, tmpSphere3D);
    return boundingSphere ? Vec3.copy(center || Vec3(), boundingSphere.center) : void 0;
  }
  Loci2.getCenter = getCenter;
  function getPrincipalAxes(loci) {
    if (loci.kind === "every-loci" || loci.kind === "empty-loci")
      return void 0;
    if (loci.kind === "structure-loci") {
      return element_exports.Loci.getPrincipalAxes(Structure.toStructureElementLoci(loci.structure));
    } else if (loci.kind === "element-loci") {
      return element_exports.Loci.getPrincipalAxes(loci);
    } else if (loci.kind === "bond-loci") {
      return void 0;
    } else if (loci.kind === "shape-loci") {
      return void 0;
    } else if (loci.kind === "group-loci") {
      return void 0;
    } else if (loci.kind === "data-loci") {
      return void 0;
    } else if (loci.kind === "volume-loci") {
      return void 0;
    } else if (loci.kind === "isosurface-loci") {
      return void 0;
    } else if (loci.kind === "cell-loci") {
      return void 0;
    } else if (loci.kind === "segment-loci") {
      return void 0;
    }
  }
  Loci2.getPrincipalAxes = getPrincipalAxes;
  const Granularity = {
    "element": (loci) => loci,
    "residue": (loci) => {
      return element_exports.Loci.is(loci) ? element_exports.Loci.extendToWholeResidues(loci, true) : loci;
    },
    "chain": (loci) => {
      return element_exports.Loci.is(loci) ? element_exports.Loci.extendToWholeChains(loci) : loci;
    },
    "entity": (loci) => {
      return element_exports.Loci.is(loci) ? element_exports.Loci.extendToWholeEntities(loci) : loci;
    },
    "model": (loci) => {
      return element_exports.Loci.is(loci) ? element_exports.Loci.extendToWholeModels(loci) : loci;
    },
    "operator": (loci) => {
      return element_exports.Loci.is(loci) ? element_exports.Loci.extendToWholeOperators(loci) : loci;
    },
    "structure": (loci) => {
      return element_exports.Loci.is(loci) ? Structure.toStructureElementLoci(loci.structure) : ShapeGroup.isLoci(loci) ? Shape.Loci(loci.shape) : Volume.Cell.isLoci(loci) ? Volume.Loci(loci.volume) : loci;
    },
    "elementInstances": (loci) => {
      return element_exports.Loci.is(loci) ? element_exports.Loci.extendToAllInstances(loci) : loci;
    },
    "residueInstances": (loci) => {
      return element_exports.Loci.is(loci) ? element_exports.Loci.extendToAllInstances(element_exports.Loci.extendToWholeResidues(loci, true)) : loci;
    },
    "chainInstances": (loci) => {
      return element_exports.Loci.is(loci) ? element_exports.Loci.extendToAllInstances(element_exports.Loci.extendToWholeChains(loci)) : loci;
    }
  };
  Loci2.GranularityOptions = ParamDefinition.objectToOptions(Granularity, (k) => {
    switch (k) {
      case "element":
        return "Atom/Coarse Element";
      case "elementInstances":
        return ["Atom/Coarse Element Instances", "With Symmetry"];
      case "structure":
        return "Structure/Shape";
      default:
        return k.indexOf("Instances") ? [stringToWords(k), "With Symmetry"] : stringToWords(k);
    }
  });
  function simpleGranularity(granularity) {
    return granularity.replace("Instances", "");
  }
  Loci2.simpleGranularity = simpleGranularity;
  function applyGranularity(loci, granularity) {
    return Granularity[granularity](loci);
  }
  Loci2.applyGranularity = applyGranularity;
  function normalize2(loci, granularity, alwaysConvertBonds = false) {
    if ((granularity !== "element" || alwaysConvertBonds) && Bond.isLoci(loci)) {
      loci = Bond.toStructureElementLoci(loci);
    }
    if (Structure.isLoci(loci)) {
      loci = Structure.toStructureElementLoci(loci.structure);
    }
    if (element_exports.Loci.is(loci)) {
      loci = element_exports.Loci.remap(loci, loci.structure.root);
    }
    if (granularity) {
      loci = applyGranularity(loci, granularity);
    }
    return loci;
  }
  Loci2.normalize = normalize2;
})(Loci || (Loci = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/overpaint.js
function Overpaint(kind, layers) {
  return { kind, layers };
}
(function(Overpaint2) {
  Overpaint2.Empty = { kind: "empty-loci", layers: [] };
  function areEqual(oA, oB) {
    if (oA.layers.length === 0 && oB.layers.length === 0)
      return true;
    if (oA.layers.length !== oB.layers.length)
      return false;
    for (let i = 0, il = oA.layers.length; i < il; ++i) {
      if (oA.layers[i].clear !== oB.layers[i].clear)
        return false;
      if (oA.layers[i].color !== oB.layers[i].color)
        return false;
      if (!Loci.areEqual(oA.layers[i].loci, oB.layers[i].loci))
        return false;
    }
    return true;
  }
  Overpaint2.areEqual = areEqual;
  function isEmpty3(overpaint) {
    return overpaint.layers.length === 0;
  }
  Overpaint2.isEmpty = isEmpty3;
  function remap(overpaint, structure) {
    if (overpaint.kind === "element-loci") {
      const layers = [];
      for (const layer of overpaint.layers) {
        let { loci, color, clear: clear2 } = layer;
        loci = element_exports.Loci.remap(loci, structure);
        if (!element_exports.Loci.isEmpty(loci)) {
          layers.push({ loci, color, clear: clear2 });
        }
      }
      return { kind: "element-loci", layers };
    } else {
      return overpaint;
    }
  }
  Overpaint2.remap = remap;
  function merge3(overpaint) {
    if (isEmpty3(overpaint))
      return overpaint;
    if (overpaint.kind === "element-loci") {
      const { structure } = overpaint.layers[0].loci;
      const map3 = /* @__PURE__ */ new Map();
      let shadowed = element_exports.Loci.none(structure);
      for (let i = 0, il = overpaint.layers.length; i < il; ++i) {
        let { loci, color, clear: clear2 } = overpaint.layers[il - i - 1];
        loci = element_exports.Loci.subtract(loci, shadowed);
        shadowed = element_exports.Loci.union(loci, shadowed);
        if (!element_exports.Loci.isEmpty(loci)) {
          const colorOrClear = clear2 ? -1 : color;
          if (map3.has(colorOrClear)) {
            loci = element_exports.Loci.union(loci, map3.get(colorOrClear));
          }
          map3.set(colorOrClear, loci);
        }
      }
      const layers = [];
      map3.forEach((loci, colorOrClear) => {
        const clear2 = colorOrClear === -1;
        const color = clear2 ? Color(0) : colorOrClear;
        layers.push({ loci, color, clear: clear2 });
      });
      return { kind: "element-loci", layers };
    } else {
      return overpaint;
    }
  }
  Overpaint2.merge = merge3;
  function filter4(overpaint, filter5) {
    if (isEmpty3(overpaint))
      return overpaint;
    if (overpaint.kind === "element-loci") {
      const { structure } = overpaint.layers[0].loci;
      const layers = [];
      for (const layer of overpaint.layers) {
        let { loci, color, clear: clear2 } = layer;
        const filtered = element_exports.Loci.remap(loci, filter5);
        loci = element_exports.Loci.remap(filtered, structure);
        if (!element_exports.Loci.isEmpty(loci)) {
          layers.push({ loci, color, clear: clear2 });
        }
      }
      return { kind: "element-loci", layers };
    } else {
      return overpaint;
    }
  }
  Overpaint2.filter = filter4;
  function ofScript(scriptLayers, structure) {
    const layers = [];
    for (let i = 0, il = scriptLayers.length; i < il; ++i) {
      const { script, color, clear: clear2 } = scriptLayers[i];
      const loci = Script.toLoci(script, structure);
      if (!element_exports.Loci.isEmpty(loci)) {
        layers.push({ loci, color, clear: clear2 });
      }
    }
    return { kind: "element-loci", layers };
  }
  Overpaint2.ofScript = ofScript;
  function ofBundle(bundleLayers, structure) {
    const layers = [];
    for (let i = 0, il = bundleLayers.length; i < il; ++i) {
      const { bundle, color, clear: clear2 } = bundleLayers[i];
      const loci = element_exports.Bundle.toLoci(bundle, structure.root);
      layers.push({ loci, color, clear: clear2 });
    }
    return { kind: "element-loci", layers };
  }
  Overpaint2.ofBundle = ofBundle;
  function toBundle(overpaint) {
    const layers = [];
    for (let i = 0, il = overpaint.layers.length; i < il; ++i) {
      const { loci, color, clear: clear2 } = overpaint.layers[i];
      const bundle = element_exports.Bundle.fromLoci(loci);
      layers.push({ bundle, color, clear: clear2 });
    }
    return { kind: "element-loci", layers };
  }
  Overpaint2.toBundle = toBundle;
})(Overpaint || (Overpaint = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/transparency.js
function Transparency(kind, layers) {
  return { kind, layers };
}
(function(Transparency2) {
  Transparency2.Empty = { kind: "empty-loci", layers: [] };
  function areEqual(tA, tB) {
    if (tA.layers.length === 0 && tB.layers.length === 0)
      return true;
    if (tA.layers.length !== tB.layers.length)
      return false;
    for (let i = 0, il = tA.layers.length; i < il; ++i) {
      if (tA.layers[i].value !== tB.layers[i].value)
        return false;
      if (!Loci.areEqual(tA.layers[i].loci, tB.layers[i].loci))
        return false;
    }
    return true;
  }
  Transparency2.areEqual = areEqual;
  function isEmpty3(transparency) {
    return transparency.layers.length === 0;
  }
  Transparency2.isEmpty = isEmpty3;
  function remap(transparency, structure) {
    if (transparency.kind === "element-loci") {
      const layers = [];
      for (const layer of transparency.layers) {
        const loci = element_exports.Loci.remap(layer.loci, structure);
        if (!element_exports.Loci.isEmpty(loci)) {
          layers.push({ loci, value: layer.value });
        }
      }
      return { kind: "element-loci", layers };
    } else {
      return transparency;
    }
  }
  Transparency2.remap = remap;
  function merge3(transparency) {
    if (isEmpty3(transparency))
      return transparency;
    if (transparency.kind === "element-loci") {
      const { structure } = transparency.layers[0].loci;
      const map3 = /* @__PURE__ */ new Map();
      let shadowed = element_exports.Loci.none(structure);
      for (let i = 0, il = transparency.layers.length; i < il; ++i) {
        let { loci, value } = transparency.layers[il - i - 1];
        loci = element_exports.Loci.subtract(loci, shadowed);
        shadowed = element_exports.Loci.union(loci, shadowed);
        if (!element_exports.Loci.isEmpty(loci)) {
          if (map3.has(value)) {
            loci = element_exports.Loci.union(loci, map3.get(value));
          }
          map3.set(value, loci);
        }
      }
      const layers = [];
      map3.forEach((loci, value) => {
        layers.push({ loci, value });
      });
      return { kind: "element-loci", layers };
    } else {
      return transparency;
    }
  }
  Transparency2.merge = merge3;
  function filter4(transparency, filter5) {
    if (isEmpty3(transparency))
      return transparency;
    if (transparency.kind === "element-loci") {
      const { structure } = transparency.layers[0].loci;
      const layers = [];
      for (const layer of transparency.layers) {
        let { loci, value } = layer;
        const filtered = element_exports.Loci.remap(loci, filter5);
        loci = element_exports.Loci.remap(filtered, structure);
        if (!element_exports.Loci.isEmpty(loci)) {
          layers.push({ loci, value });
        }
      }
      return { kind: "element-loci", layers };
    } else {
      return transparency;
    }
  }
  Transparency2.filter = filter4;
  function ofScript(scriptLayers, structure) {
    const layers = [];
    for (let i = 0, il = scriptLayers.length; i < il; ++i) {
      const { script, value } = scriptLayers[i];
      const loci = Script.toLoci(script, structure);
      if (!element_exports.Loci.isEmpty(loci)) {
        layers.push({ loci, value });
      }
    }
    return { kind: "element-loci", layers };
  }
  Transparency2.ofScript = ofScript;
  function ofBundle(bundleLayers, structure) {
    const layers = [];
    for (let i = 0, il = bundleLayers.length; i < il; ++i) {
      const { bundle, value } = bundleLayers[i];
      const loci = element_exports.Bundle.toLoci(bundle, structure.root);
      layers.push({ loci, value });
    }
    return { kind: "element-loci", layers };
  }
  Transparency2.ofBundle = ofBundle;
  function toBundle(transparency) {
    const layers = [];
    for (let i = 0, il = transparency.layers.length; i < il; ++i) {
      const { loci, value } = transparency.layers[i];
      const bundle = element_exports.Bundle.fromLoci(loci);
      layers.push({ bundle, value });
    }
    return { kind: "element-loci", layers };
  }
  Transparency2.toBundle = toBundle;
})(Transparency || (Transparency = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/util.js
var VisualUpdateState;
(function(VisualUpdateState2) {
  function create() {
    return {
      updateTransform: false,
      updateMatrix: false,
      updateColor: false,
      updateSize: false,
      createGeometry: false,
      createNew: false,
      info: {}
    };
  }
  VisualUpdateState2.create = create;
  function reset(state) {
    state.updateTransform = false;
    state.updateMatrix = false;
    state.updateColor = false;
    state.updateSize = false;
    state.createGeometry = false;
    state.createNew = false;
  }
  VisualUpdateState2.reset = reset;
})(VisualUpdateState || (VisualUpdateState = {}));
var DefaultQualityThresholds = {
  lowestElementCount: 1e6,
  lowerElementCount: 5e5,
  lowElementCount: 1e5,
  mediumElementCount: 2e4,
  highElementCount: 2e3,
  coarseGrainedFactor: 10,
  elementCountFactor: 1
};
function getStructureQuality(structure, tresholds = {}) {
  const t2 = { ...DefaultQualityThresholds, ...tresholds };
  let score = structure.elementCount * t2.elementCountFactor;
  if (structure.isCoarseGrained || structure.isCoarse)
    score *= t2.coarseGrainedFactor;
  if (score > t2.lowestElementCount) {
    return "lowest";
  } else if (score > t2.lowerElementCount) {
    return "lower";
  } else if (score > t2.lowElementCount) {
    return "low";
  } else if (score > t2.mediumElementCount) {
    return "medium";
  } else if (score > t2.highElementCount) {
    return "high";
  } else {
    return "higher";
  }
}
function getRootVolume(structure) {
  if (structure.root.models.length === 1) {
    const sym = ModelSymmetry.Provider.get(structure.root.model);
    if (sym && sym.spacegroup.name === "P 1" && !SpacegroupCell.isZero(sym.spacegroup.cell)) {
      return sym.spacegroup.cell.volume;
    }
  }
  return Box3D.volume(structure.root.boundary.box);
}
function getQualityProps(props, data) {
  let quality = defaults(props.quality, "auto");
  let detail = defaults(props.detail, 1);
  let radialSegments = defaults(props.radialSegments, 12);
  let linearSegments = defaults(props.linearSegments, 8);
  let resolution = defaults(props.resolution, 2);
  let imageResolution = defaults(props.imageResolution, 1);
  let probePositions = defaults(props.probePositions, 12);
  let doubleSided = defaults(props.doubleSided, true);
  let volume = 0;
  if (quality === "auto") {
    if (data instanceof Structure) {
      quality = getStructureQuality(data.root);
      volume = getRootVolume(data);
    } else if (Volume.is(data)) {
      const [x, y, z] = data.grid.cells.space.dimensions;
      volume = x * y * z;
      quality = volume < 1e7 ? "medium" : "low";
    }
  }
  switch (quality) {
    case "highest":
      detail = 3;
      radialSegments = 36;
      linearSegments = 18;
      resolution = 0.1;
      imageResolution = 0.01;
      probePositions = 72;
      doubleSided = true;
      break;
    case "higher":
      detail = 3;
      radialSegments = 28;
      linearSegments = 14;
      resolution = 0.3;
      imageResolution = 0.05;
      probePositions = 48;
      doubleSided = true;
      break;
    case "high":
      detail = 2;
      radialSegments = 20;
      linearSegments = 10;
      resolution = 0.5;
      imageResolution = 0.1;
      probePositions = 36;
      doubleSided = true;
      break;
    case "medium":
      detail = 1;
      radialSegments = 12;
      linearSegments = 8;
      resolution = 0.8;
      imageResolution = 0.2;
      probePositions = 24;
      doubleSided = true;
      break;
    case "low":
      detail = 0;
      radialSegments = 8;
      linearSegments = 3;
      resolution = 1.3;
      imageResolution = 0.4;
      probePositions = 24;
      doubleSided = false;
      break;
    case "lower":
      detail = 0;
      radialSegments = 4;
      linearSegments = 2;
      resolution = 3;
      imageResolution = 0.7;
      probePositions = 12;
      doubleSided = false;
      break;
    case "lowest":
      detail = 0;
      radialSegments = 2;
      linearSegments = 1;
      resolution = 8;
      imageResolution = 1;
      probePositions = 12;
      doubleSided = false;
      break;
    case "custom":
      break;
  }
  if (volume > 0) {
    resolution = Math.max(resolution, volume / 3e8);
    resolution = Math.min(resolution, 20);
  }
  if (props.transparentBackfaces === "off" && (props.alpha !== void 0 && props.alpha < 1 || !!props.xrayShaded)) {
    doubleSided = false;
  }
  return {
    detail,
    radialSegments,
    linearSegments,
    resolution,
    imageResolution,
    probePositions,
    doubleSided
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/number-conversion.js
var Tables = generateTables();
function generateTables() {
  const buffer2 = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer2);
  const uint32View = new Uint32Array(buffer2);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);
  for (let i = 0; i < 256; ++i) {
    const e = i - 127;
    if (e < -27) {
      baseTable[i] = 0;
      baseTable[i | 256] = 32768;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else if (e < -14) {
      baseTable[i] = 1024 >> -e - 14;
      baseTable[i | 256] = 1024 >> -e - 14 | 32768;
      shiftTable[i] = -e - 1;
      shiftTable[i | 256] = -e - 1;
    } else if (e <= 15) {
      baseTable[i] = e + 15 << 10;
      baseTable[i | 256] = e + 15 << 10 | 32768;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    } else if (e < 128) {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    }
  }
  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);
  for (let i = 1; i < 1024; ++i) {
    let m = i << 13;
    let e = 0;
    while ((m & 8388608) === 0) {
      m <<= 1;
      e -= 8388608;
    }
    m &= ~8388608;
    e += 947912704;
    mantissaTable[i] = m | e;
  }
  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 939524096 + (i - 1024 << 13);
  }
  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23;
  }
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 2147483648 + (i - 32 << 23);
  }
  exponentTable[63] = 3347054592;
  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024;
    }
  }
  return {
    floatView,
    uint32View,
    baseTable,
    shiftTable,
    mantissaTable,
    exponentTable,
    offsetTable
  };
}
function toHalfFloat(val) {
  val = clamp(val, -65504, 65504);
  Tables.floatView[0] = val;
  const f = Tables.uint32View[0];
  const e = f >> 23 & 511;
  return Tables.baseTable[e] + ((f & 8388607) >> Tables.shiftTable[e]);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/volume/util.js
var v3set = Vec3.set;
var v3normalize = Vec3.normalize;
var v3sub = Vec3.sub;
var v3addScalar = Vec3.addScalar;
var v3scale = Vec3.scale;
var v3toArray = Vec3.toArray;
function eachVolumeLoci(loci, volume, props, apply) {
  let changed = false;
  if (Volume.isLoci(loci)) {
    if (!Volume.areEquivalent(loci.volume, volume))
      return false;
    if (apply(Interval.ofLength(volume.grid.cells.data.length)))
      changed = true;
  } else if (Volume.Isosurface.isLoci(loci)) {
    if (!Volume.areEquivalent(loci.volume, volume))
      return false;
    if (props === null || props === void 0 ? void 0 : props.isoValue) {
      if (!Volume.IsoValue.areSame(loci.isoValue, props.isoValue, volume.grid.stats))
        return false;
      if (apply(Interval.ofLength(volume.grid.cells.data.length)))
        changed = true;
    } else {
      const { stats, cells: { data } } = volume.grid;
      const eps = stats.sigma;
      const v3 = Volume.IsoValue.toAbsolute(loci.isoValue, stats).absoluteValue;
      for (let i = 0, il = data.length; i < il; ++i) {
        if (equalEps(v3, data[i], eps)) {
          if (apply(Interval.ofSingleton(i)))
            changed = true;
        }
      }
    }
  } else if (Volume.Cell.isLoci(loci)) {
    if (!Volume.areEquivalent(loci.volume, volume))
      return false;
    if (Interval.is(loci.indices)) {
      if (apply(loci.indices))
        changed = true;
    } else {
      OrderedSet.forEach(loci.indices, (v3) => {
        if (apply(Interval.ofSingleton(v3)))
          changed = true;
      });
    }
  } else if (Volume.Segment.isLoci(loci)) {
    if (!Volume.areEquivalent(loci.volume, volume))
      return false;
    if (props === null || props === void 0 ? void 0 : props.segments) {
      if (!SortedArray.areIntersecting(loci.segments, props.segments))
        return false;
      if (apply(Interval.ofLength(volume.grid.cells.data.length)))
        changed = true;
    } else {
      const segmentation = Volume.Segmentation.get(volume);
      if (segmentation) {
        const set4 = /* @__PURE__ */ new Set();
        for (let i = 0, il = loci.segments.length; i < il; ++i) {
          SetUtils.add(set4, segmentation.segments.get(loci.segments[i]));
        }
        const s = Array.from(set4.values());
        const d3 = volume.grid.cells.data;
        for (let i = 0, il = d3.length; i < il; ++i) {
          if (s.includes(d3[i])) {
            if (apply(Interval.ofSingleton(i)))
              changed = true;
          }
        }
      }
    }
  }
  return changed;
}
function createVolumeCellLocationIterator(volume) {
  const [xn, yn, zn] = volume.grid.cells.space.dimensions;
  const groupCount = xn * yn * zn;
  const instanceCount = 1;
  const location = Volume.Cell.Location(volume);
  const getLocation = (groupIndex, _instanceIndex) => {
    location.cell = groupIndex;
    return location;
  };
  return LocationIterator(groupCount, instanceCount, 1, getLocation);
}
function getVolumeTexture2dLayout(dim, padding2 = 0) {
  const area = dim[0] * dim[1] * dim[2];
  const squareDim = Math.sqrt(area);
  const powerOfTwoSize = Math.pow(2, Math.ceil(Math.log(squareDim) / Math.log(2)));
  let width = dim[0] + padding2;
  let height = dim[1] + padding2;
  let rows = 1;
  let columns = width;
  if (powerOfTwoSize < width * dim[2]) {
    columns = Math.floor(powerOfTwoSize / width);
    rows = Math.ceil(dim[2] / columns);
    width *= columns;
    height *= rows;
  } else {
    width *= dim[2];
  }
  return { width, height, columns, rows, powerOfTwoSize: height < powerOfTwoSize ? powerOfTwoSize : powerOfTwoSize * 2 };
}
function createVolumeTexture2d(volume, variant, padding2 = 0, type = "byte") {
  const { cells: { space, data }, stats: { max: max3, min: min3 } } = volume.grid;
  const dim = space.dimensions;
  const { dataOffset: o } = space;
  const { width, height } = getVolumeTexture2dLayout(dim, padding2);
  const itemSize = variant === "data" ? 1 : 4;
  const array = type === "byte" ? new Uint8Array(width * height * itemSize) : type === "halfFloat" ? new Uint16Array(width * height * itemSize) : new Float32Array(width * height * itemSize);
  const textureImage = { array, width, height };
  const diff = max3 - min3;
  const [xn, yn, zn] = dim;
  const xnp = xn + padding2;
  const ynp = yn + padding2;
  const n0 = Vec3();
  const n1 = Vec3();
  const xn1 = xn - 1;
  const yn1 = yn - 1;
  const zn1 = zn - 1;
  for (let z = 0; z < zn; ++z) {
    for (let y = 0; y < yn; ++y) {
      for (let x = 0; x < xn; ++x) {
        const column = Math.floor(z * xnp % width / xnp);
        const row = Math.floor(z * xnp / width);
        const px = column * xnp + x;
        const index = itemSize * (row * ynp * width + y * width + px);
        const offset = o(x, y, z);
        let value;
        if (type === "byte") {
          value = Math.round((data[offset] - min3) / diff * 255);
        } else if (type === "halfFloat") {
          value = toHalfFloat((data[offset] - min3) / diff);
        } else {
          value = (data[offset] - min3) / diff;
        }
        if (variant === "data") {
          array[index] = value;
        } else {
          if (variant === "groups") {
            if (type === "halfFloat") {
              let group = clamp(Math.round(offset), 0, 16777216 - 1) + 1;
              array[index + 2] = toHalfFloat(group % 256);
              group = Math.floor(group / 256);
              array[index + 1] = toHalfFloat(group % 256);
              group = Math.floor(group / 256);
              array[index] = toHalfFloat(group % 256);
            } else {
              packIntToRGBArray(offset, array, index);
            }
          } else {
            v3set(n0, data[o(Math.max(0, x - 1), y, z)], data[o(x, Math.max(0, y - 1), z)], data[o(x, y, Math.max(0, z - 1))]);
            v3set(n1, data[o(Math.min(xn1, x + 1), y, z)], data[o(x, Math.min(yn1, y + 1), z)], data[o(x, y, Math.min(zn1, z + 1))]);
            v3normalize(n0, v3sub(n0, n0, n1));
            v3addScalar(n0, v3scale(n0, n0, 0.5), 0.5);
            if (type === "byte") {
              v3toArray(v3scale(n0, n0, 255), array, index);
            } else if (type === "halfFloat") {
              array[index] = toHalfFloat(n0[0]);
              array[index + 1] = toHalfFloat(n0[1]);
              array[index + 2] = toHalfFloat(n0[2]);
            } else {
              v3toArray(n0, array, index);
            }
          }
          array[index + 3] = value;
        }
      }
    }
  }
  return textureImage;
}
function createVolumeTexture3d(volume, type = "byte") {
  const { cells: { space, data }, stats: { max: max3, min: min3 } } = volume.grid;
  const [width, height, depth] = space.dimensions;
  const { dataOffset: o } = space;
  const array = type === "byte" ? new Uint8Array(width * height * depth * 4) : type === "halfFloat" ? new Uint16Array(width * height * depth * 4) : new Float32Array(width * height * depth * 4);
  const textureVolume = { array, width, height, depth };
  const diff = max3 - min3;
  const n0 = Vec3();
  const n1 = Vec3();
  const width1 = width - 1;
  const height1 = height - 1;
  const depth1 = depth - 1;
  let i = 0;
  for (let z = 0; z < depth; ++z) {
    for (let y = 0; y < height; ++y) {
      for (let x = 0; x < width; ++x) {
        const offset = o(x, y, z);
        v3set(n0, data[o(Math.max(0, x - 1), y, z)], data[o(x, Math.max(0, y - 1), z)], data[o(x, y, Math.max(0, z - 1))]);
        v3set(n1, data[o(Math.min(width1, x + 1), y, z)], data[o(x, Math.min(height1, y + 1), z)], data[o(x, y, Math.min(depth1, z + 1))]);
        v3normalize(n0, v3sub(n0, n0, n1));
        v3addScalar(n0, v3scale(n0, n0, 0.5), 0.5);
        if (type === "byte") {
          v3toArray(v3scale(n0, n0, 255), array, i);
          array[i + 3] = Math.round((data[offset] - min3) / diff * 255);
        } else if (type === "halfFloat") {
          array[i] = toHalfFloat(n0[0]);
          array[i + 1] = toHalfFloat(n0[1]);
          array[i + 2] = toHalfFloat(n0[2]);
          array[i + 3] = toHalfFloat((data[offset] - min3) / diff);
        } else {
          v3toArray(n0, array, i);
          array[i + 3] = (data[offset] - min3) / diff;
        }
        i += 4;
      }
    }
  }
  return textureVolume;
}
function createSegmentTexture2d(volume, set4, bbox, padding2 = 0) {
  const data = volume.grid.cells.data;
  const dim = Box3D.size(Vec3(), bbox);
  const o = volume.grid.cells.space.dataOffset;
  const { width, height } = getVolumeTexture2dLayout(dim, padding2);
  const itemSize = 1;
  const array = new Uint8Array(width * height * itemSize);
  const textureImage = { array, width, height };
  const [xn, yn, zn] = dim;
  const xn1 = xn - 1;
  const yn1 = yn - 1;
  const zn1 = zn - 1;
  const xnp = xn + padding2;
  const ynp = yn + padding2;
  const [minx, miny, minz] = bbox.min;
  const [maxx, maxy, maxz] = bbox.max;
  for (let z = 0; z < zn; ++z) {
    for (let y = 0; y < yn; ++y) {
      for (let x = 0; x < xn; ++x) {
        const column = Math.floor(z * xnp % width / xnp);
        const row = Math.floor(z * xnp / width);
        const px = column * xnp + x;
        const index = itemSize * (row * ynp * width + y * width + px);
        const v0 = set4.includes(data[o(x + minx, y + miny, z + minz)]) ? 255 : 0;
        const xp = set4.includes(data[o(Math.min(xn1 + maxx, x + 1 + minx), y + miny, z + minz)]) ? 255 : 0;
        const xn2 = set4.includes(data[o(Math.max(0, x - 1 + minx), y + miny, z + minz)]) ? 255 : 0;
        const yp = set4.includes(data[o(x + minx, Math.min(yn1 + maxy, y + 1 + miny), z + minz)]) ? 255 : 0;
        const yn2 = set4.includes(data[o(x + minx, Math.max(0, y - 1 + miny), z + minz)]) ? 255 : 0;
        const zp = set4.includes(data[o(x + minx, y + miny, Math.min(zn1 + maxz, z + 1 + minz))]) ? 255 : 0;
        const zn2 = set4.includes(data[o(x + minx, y + miny, Math.max(0, z - 1 + minz))]) ? 255 : 0;
        array[index] = Math.round((v0 + v0 + xp + xn2 + yp + yn2 + zp + zn2) / 8);
      }
    }
  }
  return textureImage;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/mesh/color-smoothing.js
function calcMeshColorSmoothing(input, resolution, stride, webgl, texture) {
  const { colorType, vertexCount, groupCount, positionBuffer, transformBuffer, groupBuffer, itemSize } = input;
  const isInstanceType = colorType.endsWith("Instance");
  const box2 = Box3D.fromSphere3D(Box3D(), isInstanceType ? input.boundingSphere : input.invariantBoundingSphere);
  const pad = 1 + resolution;
  const expandedBox = Box3D.expand(Box3D(), box2, Vec3.create(pad, pad, pad));
  const scaleFactor = 1 / resolution;
  const scaledBox = Box3D.scale(Box3D(), expandedBox, scaleFactor);
  const gridDim = Box3D.size(Vec3(), scaledBox);
  Vec3.ceil(gridDim, gridDim);
  Vec3.add(gridDim, gridDim, Vec3.create(2, 2, 2));
  const { min: min3 } = expandedBox;
  const [xn, yn] = gridDim;
  const { width, height } = getVolumeTexture2dLayout(gridDim);
  const data = new Float32Array(width * height * itemSize);
  const count3 = new Float32Array(width * height);
  const grid = new Uint8Array(width * height * itemSize);
  const textureImage = { array: grid, width, height, filter: "linear" };
  const instanceCount = isInstanceType ? input.instanceCount : 1;
  const colors = input.colorData.array;
  function getIndex(x, y, z) {
    const column = Math.floor(z * xn % width / xn);
    const row = Math.floor(z * xn / width);
    const px = column * xn + x;
    return itemSize * (row * yn * width + y * width + px);
  }
  const p = 2;
  const [dimX, dimY, dimZ] = gridDim;
  const v3 = Vec3();
  for (let i = 0; i < instanceCount; ++i) {
    for (let j = 0; j < vertexCount; j += stride) {
      Vec3.fromArray(v3, positionBuffer, j * 3);
      if (isInstanceType)
        Vec3.transformMat4Offset(v3, v3, transformBuffer, 0, 0, i * 16);
      Vec3.sub(v3, v3, min3);
      Vec3.scale(v3, v3, scaleFactor);
      const [vx, vy, vz] = v3;
      const x = Math.floor(vx);
      const y = Math.floor(vy);
      const z = Math.floor(vz);
      const ci = (i * groupCount + groupBuffer[j]) * itemSize;
      const begX = Math.max(0, x - p);
      const begY = Math.max(0, y - p);
      const begZ = Math.max(0, z - p);
      const endX = Math.min(dimX, x + p + 2);
      const endY = Math.min(dimY, y + p + 2);
      const endZ = Math.min(dimZ, z + p + 2);
      for (let xi = begX; xi < endX; ++xi) {
        const dx = xi - vx;
        for (let yi = begY; yi < endY; ++yi) {
          const dy = yi - vy;
          for (let zi = begZ; zi < endZ; ++zi) {
            const dz = zi - vz;
            const d3 = Math.sqrt(dx * dx + dy * dy + dz * dz);
            if (d3 > p)
              continue;
            const s = p - d3;
            const index = getIndex(xi, yi, zi);
            for (let k = 0; k < itemSize; ++k) {
              data[index + k] += colors[ci + k] * s;
            }
            count3[index / itemSize] += s;
          }
        }
      }
    }
  }
  for (let i = 0, il = count3.length; i < il; ++i) {
    const is3 = i * itemSize;
    const c5 = count3[i];
    for (let k = 0; k < itemSize; ++k) {
      grid[is3 + k] = Math.round(data[is3 + k] / c5);
    }
  }
  const gridTexDim = Vec2.create(width, height);
  const gridTransform = Vec4.create(min3[0], min3[1], min3[2], scaleFactor);
  const type = isInstanceType ? "volumeInstance" : "volume";
  if (webgl) {
    if (!texture) {
      const format = itemSize === 4 ? "rgba" : itemSize === 3 ? "rgb" : "alpha";
      texture = webgl.resources.texture("image-uint8", format, "ubyte", "linear");
    }
    texture.load(textureImage);
    return { kind: "volume", texture, gridTexDim, gridDim, gridTransform, type };
  } else {
    const interpolated = getTrilinearlyInterpolated({ vertexCount, instanceCount, transformBuffer, positionBuffer, colorType: type, grid, gridDim, gridTexDim, gridTransform, vertexStride: 3, colorStride: itemSize, outputStride: itemSize });
    return {
      kind: "vertex",
      texture: interpolated,
      texDim: Vec2.create(interpolated.width, interpolated.height),
      type: isInstanceType ? "vertexInstance" : "vertex"
    };
  }
}
function getTrilinearlyInterpolated(input) {
  const { vertexCount, positionBuffer, transformBuffer, grid, gridDim, gridTexDim, gridTransform, vertexStride, colorStride } = input;
  const itemOffset = input.itemOffset || 0;
  const outputStride = input.outputStride;
  if (outputStride + itemOffset > colorStride) {
    throw new Error("outputStride + itemOffset must NOT be larger than colorStride");
  }
  const isInstanceType = input.colorType.endsWith("Instance");
  const instanceCount = isInstanceType ? input.instanceCount : 1;
  const image = createTextureImage(Math.max(1, instanceCount * vertexCount), outputStride, Uint8Array);
  const { array } = image;
  const [xn, yn] = gridDim;
  const width = gridTexDim[0];
  const min3 = Vec3.fromArray(Vec3(), gridTransform, 0);
  const scaleFactor = gridTransform[3];
  function getIndex(x, y, z) {
    const column = Math.floor(z * xn % width / xn);
    const row = Math.floor(z * xn / width);
    const px = column * xn + x;
    return colorStride * (row * yn * width + y * width + px);
  }
  const v3 = Vec3();
  const v0 = Vec3();
  const v1 = Vec3();
  const vd = Vec3();
  for (let i = 0; i < instanceCount; ++i) {
    for (let j = 0; j < vertexCount; ++j) {
      Vec3.fromArray(v3, positionBuffer, j * vertexStride);
      if (isInstanceType)
        Vec3.transformMat4Offset(v3, v3, transformBuffer, 0, 0, i * 16);
      Vec3.sub(v3, v3, min3);
      Vec3.scale(v3, v3, scaleFactor);
      Vec3.floor(v0, v3);
      Vec3.ceil(v1, v3);
      Vec3.sub(vd, v3, v0);
      Vec3.sub(v3, v1, v0);
      Vec3.div(vd, vd, v3);
      const [x0, y0, z0] = v0;
      const [x1, y1, z1] = v1;
      const [xd, yd, zd] = vd;
      const i000 = getIndex(x0, y0, z0) + itemOffset;
      const i100 = getIndex(x1, y0, z0) + itemOffset;
      const i001 = getIndex(x0, y0, z1) + itemOffset;
      const i101 = getIndex(x1, y0, z1) + itemOffset;
      const i010 = getIndex(x0, y1, z0) + itemOffset;
      const i110 = getIndex(x1, y1, z0) + itemOffset;
      const i011 = getIndex(x0, y1, z1) + itemOffset;
      const i111 = getIndex(x1, y1, z1) + itemOffset;
      const o = (i * vertexCount + j) * outputStride;
      for (let k = 0; k < outputStride; ++k) {
        const s000 = grid[i000 + k];
        const s100 = grid[i100 + k];
        const s001 = grid[i001 + k];
        const s101 = grid[i101 + k];
        const s010 = grid[i010 + k];
        const s110 = grid[i110 + k];
        const s011 = grid[i011 + k];
        const s111 = grid[i111 + k];
        const s00 = lerp(s000, s100, xd);
        const s01 = lerp(s001, s101, xd);
        const s10 = lerp(s010, s110, xd);
        const s11 = lerp(s011, s111, xd);
        const s0 = lerp(s00, s10, yd);
        const s1 = lerp(s01, s11, yd);
        array[o + k] = lerp(s0, s1, zd);
      }
    }
  }
  return image;
}
function isSupportedColorType(x) {
  return x === "group" || x === "groupInstance";
}
function applyMeshColorSmoothing(values2, resolution, stride, webgl, colorTexture) {
  if (!isSupportedColorType(values2.dColorType.ref.value))
    return;
  const smoothingData = calcMeshColorSmoothing({
    vertexCount: values2.uVertexCount.ref.value,
    instanceCount: values2.uInstanceCount.ref.value,
    groupCount: values2.uGroupCount.ref.value,
    transformBuffer: values2.aTransform.ref.value,
    instanceBuffer: values2.aInstance.ref.value,
    positionBuffer: values2.aPosition.ref.value,
    groupBuffer: values2.aGroup.ref.value,
    colorData: values2.tColor.ref.value,
    colorType: values2.dColorType.ref.value,
    boundingSphere: values2.boundingSphere.ref.value,
    invariantBoundingSphere: values2.invariantBoundingSphere.ref.value,
    itemSize: 3
  }, resolution, stride, webgl, colorTexture);
  if (smoothingData.kind === "volume") {
    ValueCell.updateIfChanged(values2.dColorType, smoothingData.type);
    ValueCell.update(values2.tColorGrid, smoothingData.texture);
    ValueCell.update(values2.uColorTexDim, smoothingData.gridTexDim);
    ValueCell.update(values2.uColorGridDim, smoothingData.gridDim);
    ValueCell.update(values2.uColorGridTransform, smoothingData.gridTransform);
  } else if (smoothingData.kind === "vertex") {
    ValueCell.updateIfChanged(values2.dColorType, smoothingData.type);
    ValueCell.update(values2.tColor, smoothingData.texture);
    ValueCell.update(values2.uColorTexDim, smoothingData.texDim);
  }
}
function isSupportedOverpaintType(x) {
  return x === "groupInstance";
}
function applyMeshOverpaintSmoothing(values2, resolution, stride, webgl, colorTexture) {
  if (!isSupportedOverpaintType(values2.dOverpaintType.ref.value))
    return;
  const smoothingData = calcMeshColorSmoothing({
    vertexCount: values2.uVertexCount.ref.value,
    instanceCount: values2.uInstanceCount.ref.value,
    groupCount: values2.uGroupCount.ref.value,
    transformBuffer: values2.aTransform.ref.value,
    instanceBuffer: values2.aInstance.ref.value,
    positionBuffer: values2.aPosition.ref.value,
    groupBuffer: values2.aGroup.ref.value,
    colorData: values2.tOverpaint.ref.value,
    colorType: values2.dOverpaintType.ref.value,
    boundingSphere: values2.boundingSphere.ref.value,
    invariantBoundingSphere: values2.invariantBoundingSphere.ref.value,
    itemSize: 4
  }, resolution, stride, webgl, colorTexture);
  if (smoothingData.kind === "volume") {
    ValueCell.updateIfChanged(values2.dOverpaintType, smoothingData.type);
    ValueCell.update(values2.tOverpaintGrid, smoothingData.texture);
    ValueCell.update(values2.uOverpaintTexDim, smoothingData.gridTexDim);
    ValueCell.update(values2.uOverpaintGridDim, smoothingData.gridDim);
    ValueCell.update(values2.uOverpaintGridTransform, smoothingData.gridTransform);
  } else if (smoothingData.kind === "vertex") {
    ValueCell.updateIfChanged(values2.dOverpaintType, smoothingData.type);
    ValueCell.update(values2.tOverpaint, smoothingData.texture);
    ValueCell.update(values2.uOverpaintTexDim, smoothingData.texDim);
  }
}
function isSupportedTransparencyType(x) {
  return x === "groupInstance";
}
function applyMeshTransparencySmoothing(values2, resolution, stride, webgl, colorTexture) {
  if (!isSupportedTransparencyType(values2.dTransparencyType.ref.value))
    return;
  const smoothingData = calcMeshColorSmoothing({
    vertexCount: values2.uVertexCount.ref.value,
    instanceCount: values2.uInstanceCount.ref.value,
    groupCount: values2.uGroupCount.ref.value,
    transformBuffer: values2.aTransform.ref.value,
    instanceBuffer: values2.aInstance.ref.value,
    positionBuffer: values2.aPosition.ref.value,
    groupBuffer: values2.aGroup.ref.value,
    colorData: values2.tTransparency.ref.value,
    colorType: values2.dTransparencyType.ref.value,
    boundingSphere: values2.boundingSphere.ref.value,
    invariantBoundingSphere: values2.invariantBoundingSphere.ref.value,
    itemSize: 1
  }, resolution, stride, webgl, colorTexture);
  if (smoothingData.kind === "volume") {
    ValueCell.updateIfChanged(values2.dTransparencyType, smoothingData.type);
    ValueCell.update(values2.tTransparencyGrid, smoothingData.texture);
    ValueCell.update(values2.uTransparencyTexDim, smoothingData.gridTexDim);
    ValueCell.update(values2.uTransparencyGridDim, smoothingData.gridDim);
    ValueCell.update(values2.uTransparencyGridTransform, smoothingData.gridTransform);
  } else if (smoothingData.kind === "vertex") {
    ValueCell.updateIfChanged(values2.dTransparencyType, smoothingData.type);
    ValueCell.update(values2.tTransparency, smoothingData.texture);
    ValueCell.update(values2.uTransparencyTexDim, smoothingData.texDim);
  }
}
function isSupportedEmissiveType(x) {
  return x === "groupInstance";
}
function applyMeshEmissiveSmoothing(values2, resolution, stride, webgl, colorTexture) {
  if (!isSupportedEmissiveType(values2.dEmissiveType.ref.value))
    return;
  const smoothingData = calcMeshColorSmoothing({
    vertexCount: values2.uVertexCount.ref.value,
    instanceCount: values2.uInstanceCount.ref.value,
    groupCount: values2.uGroupCount.ref.value,
    transformBuffer: values2.aTransform.ref.value,
    instanceBuffer: values2.aInstance.ref.value,
    positionBuffer: values2.aPosition.ref.value,
    groupBuffer: values2.aGroup.ref.value,
    colorData: values2.tEmissive.ref.value,
    colorType: values2.dEmissiveType.ref.value,
    boundingSphere: values2.boundingSphere.ref.value,
    invariantBoundingSphere: values2.invariantBoundingSphere.ref.value,
    itemSize: 1
  }, resolution, stride, webgl, colorTexture);
  if (smoothingData.kind === "volume") {
    ValueCell.updateIfChanged(values2.dEmissiveType, smoothingData.type);
    ValueCell.update(values2.tEmissiveGrid, smoothingData.texture);
    ValueCell.update(values2.uEmissiveTexDim, smoothingData.gridTexDim);
    ValueCell.update(values2.uEmissiveGridDim, smoothingData.gridDim);
    ValueCell.update(values2.uEmissiveGridTransform, smoothingData.gridTransform);
  } else if (smoothingData.kind === "vertex") {
    ValueCell.updateIfChanged(values2.dEmissiveType, smoothingData.type);
    ValueCell.update(values2.tEmissive, smoothingData.texture);
    ValueCell.update(values2.uEmissiveTexDim, smoothingData.texDim);
  }
}
function isSupportedSubstanceType(x) {
  return x === "groupInstance";
}
function applyMeshSubstanceSmoothing(values2, resolution, stride, webgl, colorTexture) {
  if (!isSupportedSubstanceType(values2.dSubstanceType.ref.value))
    return;
  const smoothingData = calcMeshColorSmoothing({
    vertexCount: values2.uVertexCount.ref.value,
    instanceCount: values2.uInstanceCount.ref.value,
    groupCount: values2.uGroupCount.ref.value,
    transformBuffer: values2.aTransform.ref.value,
    instanceBuffer: values2.aInstance.ref.value,
    positionBuffer: values2.aPosition.ref.value,
    groupBuffer: values2.aGroup.ref.value,
    colorData: values2.tSubstance.ref.value,
    colorType: values2.dSubstanceType.ref.value,
    boundingSphere: values2.boundingSphere.ref.value,
    invariantBoundingSphere: values2.invariantBoundingSphere.ref.value,
    itemSize: 4
  }, resolution, stride, webgl, colorTexture);
  if (smoothingData.kind === "volume") {
    ValueCell.updateIfChanged(values2.dSubstanceType, smoothingData.type);
    ValueCell.update(values2.tSubstanceGrid, smoothingData.texture);
    ValueCell.update(values2.uSubstanceTexDim, smoothingData.gridTexDim);
    ValueCell.update(values2.uSubstanceGridDim, smoothingData.gridDim);
    ValueCell.update(values2.uSubstanceGridTransform, smoothingData.gridTransform);
  } else if (smoothingData.kind === "vertex") {
    ValueCell.updateIfChanged(values2.dSubstanceType, smoothingData.type);
    ValueCell.update(values2.tSubstance, smoothingData.texture);
    ValueCell.update(values2.uSubstanceTexDim, smoothingData.texDim);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/compute/color-smoothing/normalize.frag.js
var normalize_frag = `
precision highp float;
precision highp sampler2D;

uniform sampler2D tColor;
uniform sampler2D tCount;
uniform vec2 uTexSize;

void main(void) {
    vec2 coords = gl_FragCoord.xy / uTexSize;
    vec4 color = texture2D(tColor, coords);
    float count = texture2D(tCount, coords).r;

    gl_FragColor = color / count;
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/compute/color-smoothing/accumulate.frag.js
var accumulate_frag = `
precision highp float;

varying vec3 vPosition;
varying vec4 vColor;

uniform float uCurrentSlice;
uniform float uCurrentX;
uniform float uCurrentY;
uniform float uResolution;

const float p = 2.0;

void main() {
    vec2 v = gl_FragCoord.xy - vec2(uCurrentX, uCurrentY) - 0.5;
    vec3 fragPos = vec3(v.x, v.y, uCurrentSlice);
    float dist = distance(fragPos, vPosition);
    if (dist > p) discard;

    float f = p - dist;
    gl_FragColor = vColor * f;
    gl_FragData[1] = vec4(f);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/compute/color-smoothing/accumulate.vert.js
var accumulate_vert = `
precision highp float;

#include common
#include read_from_texture

uniform int uGroupCount;

attribute float aSample;
#define SampleID int(aSample)

attribute mat4 aTransform;
attribute float aInstance;

uniform vec2 uGeoTexDim;
uniform sampler2D tPosition;
uniform sampler2D tGroup;

uniform vec2 uColorTexDim;
uniform sampler2D tColor;

varying vec3 vPosition;
varying vec4 vColor;

uniform vec3 uBboxSize;
uniform vec3 uBboxMin;
uniform float uResolution;

void main() {
    vec3 position = readFromTexture(tPosition, SampleID, uGeoTexDim).xyz;
    float group = unpackRGBToInt(readFromTexture(tGroup, SampleID, uGeoTexDim).rgb);

    position = (aTransform * vec4(position, 1.0)).xyz;
    gl_PointSize = 7.0;
    vPosition = (position - uBboxMin) / uResolution;
    gl_Position = vec4(((position - uBboxMin) / uBboxSize) * 2.0 - 1.0, 1.0);

    #if defined(dColorType_group)
        vColor = readFromTexture(tColor, group, uColorTexDim);
    #elif defined(dColorType_groupInstance)
        vColor = readFromTexture(tColor, aInstance * float(uGroupCount) + group, uColorTexDim);
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/texture-mesh/color-smoothing.js
var ColorAccumulateSchema = {
  drawCount: ValueSpec("number"),
  instanceCount: ValueSpec("number"),
  stride: ValueSpec("number"),
  uGroupCount: UniformSpec("i", "material"),
  aTransform: AttributeSpec("float32", 16, 1),
  aInstance: AttributeSpec("float32", 1, 1),
  aSample: AttributeSpec("float32", 1, 0),
  uGeoTexDim: UniformSpec("v2", "material"),
  tPosition: TextureSpec("texture", "rgba", "float", "nearest", "material"),
  tGroup: TextureSpec("texture", "rgba", "float", "nearest", "material"),
  uColorTexDim: UniformSpec("v2", "material"),
  tColor: TextureSpec("texture", "rgba", "ubyte", "nearest", "material"),
  dColorType: DefineSpec("string", ["group", "groupInstance", "vertex", "vertexInstance"]),
  uCurrentSlice: UniformSpec("f"),
  uCurrentX: UniformSpec("f"),
  uCurrentY: UniformSpec("f"),
  uBboxMin: UniformSpec("v3", "material"),
  uBboxSize: UniformSpec("v3", "material"),
  uResolution: UniformSpec("f", "material")
};
var ColorAccumulateName = "color-accumulate";
var ColorCountName = "color-count";
function getSampleBuffer(sampleCount, stride) {
  const sampleBuffer = new Float32Array(sampleCount);
  for (let i = 0; i < sampleCount; ++i) {
    sampleBuffer[i] = i * stride;
  }
  return sampleBuffer;
}
function getAccumulateRenderable(ctx, input, box2, resolution, stride) {
  if (ctx.namedComputeRenderables[ColorAccumulateName]) {
    const extent = Vec3.sub(Vec3(), box2.max, box2.min);
    const v3 = ctx.namedComputeRenderables[ColorAccumulateName].values;
    const sampleCount = Math.round(input.vertexCount / stride);
    if (sampleCount > v3.drawCount.ref.value || stride !== v3.stride.ref.value) {
      ValueCell.update(v3.aSample, getSampleBuffer(sampleCount, stride));
    }
    ValueCell.updateIfChanged(v3.drawCount, sampleCount);
    ValueCell.updateIfChanged(v3.instanceCount, input.instanceCount);
    ValueCell.updateIfChanged(v3.stride, stride);
    ValueCell.updateIfChanged(v3.uGroupCount, input.groupCount);
    ValueCell.update(v3.aTransform, input.transformBuffer);
    ValueCell.update(v3.aInstance, input.instanceBuffer);
    ValueCell.update(v3.uGeoTexDim, Vec2.set(v3.uGeoTexDim.ref.value, input.positionTexture.getWidth(), input.positionTexture.getHeight()));
    ValueCell.update(v3.tPosition, input.positionTexture);
    ValueCell.update(v3.tGroup, input.groupTexture);
    ValueCell.update(v3.uColorTexDim, Vec2.set(v3.uColorTexDim.ref.value, input.colorData.getWidth(), input.colorData.getHeight()));
    ValueCell.update(v3.tColor, input.colorData);
    ValueCell.updateIfChanged(v3.dColorType, input.colorType);
    ValueCell.updateIfChanged(v3.uCurrentSlice, 0);
    ValueCell.updateIfChanged(v3.uCurrentX, 0);
    ValueCell.updateIfChanged(v3.uCurrentY, 0);
    ValueCell.update(v3.uBboxMin, box2.min);
    ValueCell.update(v3.uBboxSize, extent);
    ValueCell.updateIfChanged(v3.uResolution, resolution);
    ctx.namedComputeRenderables[ColorAccumulateName].update();
  } else {
    ctx.namedComputeRenderables[ColorAccumulateName] = createAccumulateRenderable(ctx, input, box2, resolution, stride);
  }
  return ctx.namedComputeRenderables[ColorAccumulateName];
}
function createAccumulateRenderable(ctx, input, box2, resolution, stride) {
  const extent = Vec3.sub(Vec3(), box2.max, box2.min);
  const sampleCount = Math.round(input.vertexCount / stride);
  const values2 = {
    drawCount: ValueCell.create(sampleCount),
    instanceCount: ValueCell.create(input.instanceCount),
    stride: ValueCell.create(stride),
    uGroupCount: ValueCell.create(input.groupCount),
    aTransform: ValueCell.create(input.transformBuffer),
    aInstance: ValueCell.create(input.instanceBuffer),
    aSample: ValueCell.create(getSampleBuffer(sampleCount, stride)),
    uGeoTexDim: ValueCell.create(Vec2.create(input.positionTexture.getWidth(), input.positionTexture.getHeight())),
    tPosition: ValueCell.create(input.positionTexture),
    tGroup: ValueCell.create(input.groupTexture),
    uColorTexDim: ValueCell.create(Vec2.create(input.colorData.getWidth(), input.colorData.getHeight())),
    tColor: ValueCell.create(input.colorData),
    dColorType: ValueCell.create(input.colorType),
    uCurrentSlice: ValueCell.create(0),
    uCurrentX: ValueCell.create(0),
    uCurrentY: ValueCell.create(0),
    uBboxMin: ValueCell.create(box2.min),
    uBboxSize: ValueCell.create(extent),
    uResolution: ValueCell.create(resolution)
  };
  const schema = { ...ColorAccumulateSchema };
  const shaderCode = ShaderCode("accumulate", accumulate_vert, accumulate_frag, { drawBuffers: "required" });
  const renderItem = createComputeRenderItem(ctx, "points", shaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
function setAccumulateDefaults(ctx) {
  const { gl, state } = ctx;
  state.disable(gl.CULL_FACE);
  state.enable(gl.BLEND);
  state.disable(gl.DEPTH_TEST);
  state.enable(gl.SCISSOR_TEST);
  state.depthMask(false);
  state.clearColor(0, 0, 0, 0);
  state.blendFunc(gl.ONE, gl.ONE);
  state.blendEquation(gl.FUNC_ADD);
}
var ColorNormalizeSchema = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "float", "nearest"),
  tCount: TextureSpec("texture", "alpha", "float", "nearest"),
  uTexSize: UniformSpec("v2")
};
var ColorNormalizeName = "color-normalize";
function getNormalizeRenderable(ctx, color, count3) {
  if (ctx.namedComputeRenderables[ColorNormalizeName]) {
    const v3 = ctx.namedComputeRenderables[ColorNormalizeName].values;
    ValueCell.update(v3.tColor, color);
    ValueCell.update(v3.tCount, count3);
    ValueCell.update(v3.uTexSize, Vec2.set(v3.uTexSize.ref.value, color.getWidth(), color.getHeight()));
    ctx.namedComputeRenderables[ColorNormalizeName].update();
  } else {
    ctx.namedComputeRenderables[ColorNormalizeName] = createColorNormalizeRenderable(ctx, color, count3);
  }
  return ctx.namedComputeRenderables[ColorNormalizeName];
}
function createColorNormalizeRenderable(ctx, color, count3) {
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(color),
    tCount: ValueCell.create(count3),
    uTexSize: ValueCell.create(Vec2.create(color.getWidth(), color.getHeight()))
  };
  const schema = { ...ColorNormalizeSchema };
  const shaderCode = ShaderCode("normalize", quad_vert, normalize_frag);
  const renderItem = createComputeRenderItem(ctx, "triangles", shaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
function setNormalizeDefaults(ctx) {
  const { gl, state } = ctx;
  state.disable(gl.CULL_FACE);
  state.enable(gl.BLEND);
  state.disable(gl.DEPTH_TEST);
  state.enable(gl.SCISSOR_TEST);
  state.depthMask(false);
  state.clearColor(0, 0, 0, 0);
  state.blendFunc(gl.ONE, gl.ONE);
  state.blendEquation(gl.FUNC_ADD);
}
function getTexture2dSize(gridDim) {
  const area = gridDim[0] * gridDim[1] * gridDim[2];
  const squareDim = Math.sqrt(area);
  const powerOfTwoSize = Math.pow(2, Math.ceil(Math.log(squareDim) / Math.log(2)));
  let texDimX = 0;
  let texDimY = gridDim[1];
  let texRows = 1;
  let texCols = gridDim[2];
  if (powerOfTwoSize < gridDim[0] * gridDim[2]) {
    texCols = Math.floor(powerOfTwoSize / gridDim[0]);
    texRows = Math.ceil(gridDim[2] / texCols);
    texDimX = texCols * gridDim[0];
    texDimY *= texRows;
  } else {
    texDimX = gridDim[0] * gridDim[2];
  }
  return { texDimX, texDimY, texRows, texCols, powerOfTwoSize: texDimY < powerOfTwoSize ? powerOfTwoSize : powerOfTwoSize * 2 };
}
function calcTextureMeshColorSmoothing(input, resolution, stride, webgl, texture) {
  const { drawBuffers } = webgl.extensions;
  if (!drawBuffers)
    throw new Error("need WebGL draw buffers");
  if (isTimingMode)
    webgl.timer.mark("calcTextureMeshColorSmoothing");
  const { gl, resources, state, extensions: { colorBufferHalfFloat, textureHalfFloat } } = webgl;
  const isInstanceType = input.colorType.endsWith("Instance");
  const box2 = Box3D.fromSphere3D(Box3D(), isInstanceType ? input.boundingSphere : input.invariantBoundingSphere);
  const pad = 1 + resolution;
  const expandedBox = Box3D.expand(Box3D(), box2, Vec3.create(pad, pad, pad));
  const scaleFactor = 1 / resolution;
  const scaledBox = Box3D.scale(Box3D(), expandedBox, scaleFactor);
  const gridDim = Box3D.size(Vec3(), scaledBox);
  Vec3.ceil(gridDim, gridDim);
  Vec3.add(gridDim, gridDim, Vec3.create(2, 2, 2));
  const { min: min3 } = expandedBox;
  const [dx, dy, dz] = gridDim;
  const { texDimX: width, texDimY: height, texCols } = getTexture2dSize(gridDim);
  if (!webgl.namedFramebuffers[ColorAccumulateName]) {
    webgl.namedFramebuffers[ColorAccumulateName] = webgl.resources.framebuffer();
  }
  const framebuffer = webgl.namedFramebuffers[ColorAccumulateName];
  if (isWebGL2(gl)) {
    if (!webgl.namedTextures[ColorAccumulateName]) {
      webgl.namedTextures[ColorAccumulateName] = colorBufferHalfFloat && textureHalfFloat ? resources.texture("image-float16", "rgba", "fp16", "nearest") : resources.texture("image-float32", "rgba", "float", "nearest");
    }
    if (!webgl.namedTextures[ColorCountName]) {
      webgl.namedTextures[ColorCountName] = resources.texture("image-float32", "alpha", "float", "nearest");
    }
  } else {
    if (!webgl.namedTextures[ColorAccumulateName]) {
      webgl.namedTextures[ColorAccumulateName] = resources.texture("image-float32", "rgba", "float", "nearest");
    }
    if (!webgl.namedTextures[ColorCountName]) {
      webgl.namedTextures[ColorCountName] = resources.texture("image-float32", "rgba", "float", "nearest");
    }
  }
  const accumulateTexture = webgl.namedTextures[ColorAccumulateName];
  const countTexture = webgl.namedTextures[ColorCountName];
  accumulateTexture.define(width, height);
  countTexture.define(width, height);
  accumulateTexture.attachFramebuffer(framebuffer, 0);
  countTexture.attachFramebuffer(framebuffer, 1);
  const accumulateRenderable = getAccumulateRenderable(webgl, input, expandedBox, resolution, stride);
  state.currentRenderItemId = -1;
  framebuffer.bind();
  drawBuffers.drawBuffers([
    drawBuffers.COLOR_ATTACHMENT0,
    drawBuffers.COLOR_ATTACHMENT1
  ]);
  const { uCurrentSlice, uCurrentX, uCurrentY } = accumulateRenderable.values;
  if (isTimingMode)
    webgl.timer.mark("ColorAccumulate.render");
  setAccumulateDefaults(webgl);
  state.viewport(0, 0, width, height);
  state.scissor(0, 0, width, height);
  gl.clear(gl.COLOR_BUFFER_BIT);
  ValueCell.update(uCurrentY, 0);
  let currCol = 0;
  let currY = 0;
  let currX = 0;
  for (let i = 0; i < dz; ++i) {
    if (currCol >= texCols) {
      currCol -= texCols;
      currY += dy;
      currX = 0;
      ValueCell.update(uCurrentY, currY);
    }
    ValueCell.update(uCurrentX, currX);
    ValueCell.update(uCurrentSlice, i);
    state.viewport(currX, currY, dx, dy);
    state.scissor(currX, currY, dx, dy);
    accumulateRenderable.render();
    ++currCol;
    currX += dx;
  }
  accumulateTexture.detachFramebuffer(framebuffer, 0);
  countTexture.detachFramebuffer(framebuffer, 1);
  drawBuffers.drawBuffers([gl.COLOR_ATTACHMENT0, gl.NONE]);
  if (isTimingMode)
    webgl.timer.markEnd("ColorAccumulate.render");
  if (isTimingMode)
    webgl.timer.mark("ColorNormalize.render");
  if (!texture || isNullTexture(texture)) {
    texture = resources.texture("image-uint8", "rgba", "ubyte", "linear");
  }
  texture.define(width, height);
  const normalizeRenderable = getNormalizeRenderable(webgl, accumulateTexture, countTexture);
  state.currentRenderItemId = -1;
  setNormalizeDefaults(webgl);
  texture.attachFramebuffer(framebuffer, 0);
  state.viewport(0, 0, width, height);
  state.scissor(0, 0, width, height);
  gl.clear(gl.COLOR_BUFFER_BIT);
  normalizeRenderable.render();
  if (isTimingMode)
    webgl.timer.markEnd("ColorNormalize.render");
  const gridTransform = Vec4.create(min3[0], min3[1], min3[2], scaleFactor);
  const type = isInstanceType ? "volumeInstance" : "volume";
  if (isTimingMode)
    webgl.timer.markEnd("calcTextureMeshColorSmoothing");
  return { texture, gridDim, gridTexDim: Vec2.create(width, height), gridTransform, type };
}
var ColorSmoothingRgbName = "color-smoothing-rgb";
var ColorSmoothingRgbaName = "color-smoothing-rgba";
var ColorSmoothingAlphaName = "color-smoothing-alpha";
function isSupportedColorType2(x) {
  return x === "group" || x === "groupInstance";
}
function applyTextureMeshColorSmoothing(values2, resolution, stride, webgl, colorTexture) {
  if (!isSupportedColorType2(values2.dColorType.ref.value))
    return;
  stride *= 3;
  if (!webgl.namedTextures[ColorSmoothingRgbName]) {
    webgl.namedTextures[ColorSmoothingRgbName] = webgl.resources.texture("image-uint8", "rgb", "ubyte", "nearest");
  }
  const colorData = webgl.namedTextures[ColorSmoothingRgbName];
  colorData.load(values2.tColor.ref.value);
  const smoothingData = calcTextureMeshColorSmoothing({
    vertexCount: values2.uVertexCount.ref.value,
    instanceCount: values2.uInstanceCount.ref.value,
    groupCount: values2.uGroupCount.ref.value,
    transformBuffer: values2.aTransform.ref.value,
    instanceBuffer: values2.aInstance.ref.value,
    positionTexture: values2.tPosition.ref.value,
    groupTexture: values2.tGroup.ref.value,
    colorData,
    colorType: values2.dColorType.ref.value,
    boundingSphere: values2.boundingSphere.ref.value,
    invariantBoundingSphere: values2.invariantBoundingSphere.ref.value
  }, resolution, stride, webgl, colorTexture);
  ValueCell.updateIfChanged(values2.dColorType, smoothingData.type);
  ValueCell.update(values2.tColorGrid, smoothingData.texture);
  ValueCell.update(values2.uColorTexDim, smoothingData.gridTexDim);
  ValueCell.update(values2.uColorGridDim, smoothingData.gridDim);
  ValueCell.update(values2.uColorGridTransform, smoothingData.gridTransform);
}
function isSupportedOverpaintType2(x) {
  return x === "groupInstance";
}
function applyTextureMeshOverpaintSmoothing(values2, resolution, stride, webgl, colorTexture) {
  if (!isSupportedOverpaintType2(values2.dOverpaintType.ref.value))
    return;
  stride *= 3;
  if (!webgl.namedTextures[ColorSmoothingRgbaName]) {
    webgl.namedTextures[ColorSmoothingRgbaName] = webgl.resources.texture("image-uint8", "rgba", "ubyte", "nearest");
  }
  const colorData = webgl.namedTextures[ColorSmoothingRgbaName];
  colorData.load(values2.tOverpaint.ref.value);
  const smoothingData = calcTextureMeshColorSmoothing({
    vertexCount: values2.uVertexCount.ref.value,
    instanceCount: values2.uInstanceCount.ref.value,
    groupCount: values2.uGroupCount.ref.value,
    transformBuffer: values2.aTransform.ref.value,
    instanceBuffer: values2.aInstance.ref.value,
    positionTexture: values2.tPosition.ref.value,
    groupTexture: values2.tGroup.ref.value,
    colorData,
    colorType: values2.dOverpaintType.ref.value,
    boundingSphere: values2.boundingSphere.ref.value,
    invariantBoundingSphere: values2.invariantBoundingSphere.ref.value
  }, resolution, stride, webgl, colorTexture);
  ValueCell.updateIfChanged(values2.dOverpaintType, smoothingData.type);
  ValueCell.update(values2.tOverpaintGrid, smoothingData.texture);
  ValueCell.update(values2.uOverpaintTexDim, smoothingData.gridTexDim);
  ValueCell.update(values2.uOverpaintGridDim, smoothingData.gridDim);
  ValueCell.update(values2.uOverpaintGridTransform, smoothingData.gridTransform);
}
function isSupportedTransparencyType2(x) {
  return x === "groupInstance";
}
function applyTextureMeshTransparencySmoothing(values2, resolution, stride, webgl, colorTexture) {
  if (!isSupportedTransparencyType2(values2.dTransparencyType.ref.value))
    return;
  stride *= 3;
  if (!webgl.namedTextures[ColorSmoothingAlphaName]) {
    webgl.namedTextures[ColorSmoothingAlphaName] = webgl.resources.texture("image-uint8", "alpha", "ubyte", "nearest");
  }
  const colorData = webgl.namedTextures[ColorSmoothingAlphaName];
  colorData.load(values2.tTransparency.ref.value);
  const smoothingData = calcTextureMeshColorSmoothing({
    vertexCount: values2.uVertexCount.ref.value,
    instanceCount: values2.uInstanceCount.ref.value,
    groupCount: values2.uGroupCount.ref.value,
    transformBuffer: values2.aTransform.ref.value,
    instanceBuffer: values2.aInstance.ref.value,
    positionTexture: values2.tPosition.ref.value,
    groupTexture: values2.tGroup.ref.value,
    colorData,
    colorType: values2.dTransparencyType.ref.value,
    boundingSphere: values2.boundingSphere.ref.value,
    invariantBoundingSphere: values2.invariantBoundingSphere.ref.value
  }, resolution, stride, webgl, colorTexture);
  ValueCell.updateIfChanged(values2.dTransparencyType, smoothingData.type);
  ValueCell.update(values2.tTransparencyGrid, smoothingData.texture);
  ValueCell.update(values2.uTransparencyTexDim, smoothingData.gridTexDim);
  ValueCell.update(values2.uTransparencyGridDim, smoothingData.gridDim);
  ValueCell.update(values2.uTransparencyGridTransform, smoothingData.gridTransform);
}
function isSupportedEmissiveType2(x) {
  return x === "groupInstance";
}
function applyTextureMeshEmissiveSmoothing(values2, resolution, stride, webgl, colorTexture) {
  if (!isSupportedEmissiveType2(values2.dEmissiveType.ref.value))
    return;
  stride *= 3;
  if (!webgl.namedTextures[ColorSmoothingAlphaName]) {
    webgl.namedTextures[ColorSmoothingAlphaName] = webgl.resources.texture("image-uint8", "alpha", "ubyte", "nearest");
  }
  const colorData = webgl.namedTextures[ColorSmoothingAlphaName];
  colorData.load(values2.tEmissive.ref.value);
  const smoothingData = calcTextureMeshColorSmoothing({
    vertexCount: values2.uVertexCount.ref.value,
    instanceCount: values2.uInstanceCount.ref.value,
    groupCount: values2.uGroupCount.ref.value,
    transformBuffer: values2.aTransform.ref.value,
    instanceBuffer: values2.aInstance.ref.value,
    positionTexture: values2.tPosition.ref.value,
    groupTexture: values2.tGroup.ref.value,
    colorData,
    colorType: values2.dEmissiveType.ref.value,
    boundingSphere: values2.boundingSphere.ref.value,
    invariantBoundingSphere: values2.invariantBoundingSphere.ref.value
  }, resolution, stride, webgl, colorTexture);
  ValueCell.updateIfChanged(values2.dEmissiveType, smoothingData.type);
  ValueCell.update(values2.tEmissiveGrid, smoothingData.texture);
  ValueCell.update(values2.uEmissiveTexDim, smoothingData.gridTexDim);
  ValueCell.update(values2.uEmissiveGridDim, smoothingData.gridDim);
  ValueCell.update(values2.uEmissiveGridTransform, smoothingData.gridTransform);
}
function isSupportedSubstanceType2(x) {
  return x === "groupInstance";
}
function applyTextureMeshSubstanceSmoothing(values2, resolution, stride, webgl, colorTexture) {
  if (!isSupportedSubstanceType2(values2.dSubstanceType.ref.value))
    return;
  stride *= 3;
  if (!webgl.namedTextures[ColorSmoothingRgbaName]) {
    webgl.namedTextures[ColorSmoothingRgbaName] = webgl.resources.texture("image-uint8", "rgba", "ubyte", "nearest");
  }
  const colorData = webgl.namedTextures[ColorSmoothingRgbaName];
  colorData.load(values2.tSubstance.ref.value);
  const smoothingData = calcTextureMeshColorSmoothing({
    vertexCount: values2.uVertexCount.ref.value,
    instanceCount: values2.uInstanceCount.ref.value,
    groupCount: values2.uGroupCount.ref.value,
    transformBuffer: values2.aTransform.ref.value,
    instanceBuffer: values2.aInstance.ref.value,
    positionTexture: values2.tPosition.ref.value,
    groupTexture: values2.tGroup.ref.value,
    colorData,
    colorType: values2.dSubstanceType.ref.value,
    boundingSphere: values2.boundingSphere.ref.value,
    invariantBoundingSphere: values2.invariantBoundingSphere.ref.value
  }, resolution, stride, webgl, colorTexture);
  ValueCell.updateIfChanged(values2.dSubstanceType, smoothingData.type);
  ValueCell.update(values2.tSubstanceGrid, smoothingData.texture);
  ValueCell.update(values2.uSubstanceTexDim, smoothingData.gridTexDim);
  ValueCell.update(values2.uSubstanceGridDim, smoothingData.gridDim);
  ValueCell.update(values2.uSubstanceGridTransform, smoothingData.gridTransform);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/visual.js
var Visual;
(function(Visual2) {
  function setVisibility(renderObject, visible) {
    if (renderObject)
      renderObject.state.visible = visible;
  }
  Visual2.setVisibility = setVisibility;
  function setAlphaFactor(renderObject, alphaFactor) {
    if (renderObject)
      renderObject.state.alphaFactor = alphaFactor;
  }
  Visual2.setAlphaFactor = setAlphaFactor;
  function setPickable(renderObject, pickable) {
    if (renderObject)
      renderObject.state.pickable = pickable;
  }
  Visual2.setPickable = setPickable;
  function setColorOnly(renderObject, colorOnly) {
    if (renderObject)
      renderObject.state.colorOnly = colorOnly;
  }
  Visual2.setColorOnly = setColorOnly;
  function mark(renderObject, loci, action, lociApply, previous) {
    if (!renderObject || isEmptyLoci(loci))
      return false;
    const { tMarker, uMarker, markerAverage, markerStatus, uGroupCount, instanceCount, instanceGranularity } = renderObject.values;
    const count3 = instanceGranularity.ref.value ? instanceCount.ref.value : uGroupCount.ref.value * instanceCount.ref.value;
    const { array } = tMarker.ref.value;
    const currentStatus = markerStatus.ref.value;
    if (!isEveryLoci(loci)) {
      let intervalSize = 0;
      lociApply(loci, (interval2) => {
        intervalSize += Interval.size(interval2);
        return true;
      }, true);
      if (intervalSize === 0)
        return false;
      if (intervalSize === count3)
        loci = EveryLoci;
    }
    let changed = false;
    let average = -1;
    let status = -1;
    if (isEveryLoci(loci)) {
      const info = getMarkerInfo(action, currentStatus);
      if (info.status !== -1) {
        changed = currentStatus !== info.status;
        if (changed)
          setMarkerValue(array, info.status, count3);
      } else {
        changed = applyMarkerAction(array, Interval.ofLength(count3), action);
      }
      average = info.average;
      status = info.status;
    } else {
      changed = lociApply(loci, (interval2) => applyMarkerAction(array, interval2, action), true);
      if (changed) {
        average = getPartialMarkerAverage(action, currentStatus);
        if (previous && previous.status !== -1 && average === -1 && MarkerActions.isReverse(previous.action, action) && Loci.areEqual(loci, previous.loci)) {
          status = previous.status;
          average = status === 0 ? 0 : 0.5;
        }
      }
    }
    if (changed) {
      if (average === -1) {
        average = getMarkersAverage(array, count3);
        if (average === 0)
          status = 0;
      }
      if (previous) {
        previous.action = action;
        previous.loci = loci;
        previous.status = currentStatus;
      }
      ValueCell.updateIfChanged(uMarker, status);
      if (status === -1)
        ValueCell.update(tMarker, tMarker.ref.value);
      ValueCell.updateIfChanged(markerAverage, average);
      ValueCell.updateIfChanged(markerStatus, status);
    }
    return changed;
  }
  Visual2.mark = mark;
  function setOverpaint(renderObject, overpaint, lociApply, clear2, smoothing) {
    if (!renderObject)
      return;
    const { tOverpaint, dOverpaintType, dOverpaint, uGroupCount, instanceCount, instanceGranularity } = renderObject.values;
    const count3 = instanceGranularity.ref.value ? instanceCount.ref.value : uGroupCount.ref.value * instanceCount.ref.value;
    const type = instanceGranularity.ref.value ? "instance" : "groupInstance";
    createOverpaint(overpaint.layers.length ? count3 : 0, type, renderObject.values);
    const { array } = tOverpaint.ref.value;
    if (clear2)
      clearOverpaint(array, 0, count3);
    for (let i = 0, il = overpaint.layers.length; i < il; ++i) {
      const { loci, color, clear: clear3 } = overpaint.layers[i];
      const apply = (interval2) => {
        const start = Interval.start(interval2);
        const end = Interval.end(interval2);
        return clear3 ? clearOverpaint(array, start, end) : applyOverpaintColor(array, start, end, color);
      };
      lociApply(loci, apply, false);
    }
    ValueCell.update(tOverpaint, tOverpaint.ref.value);
    ValueCell.updateIfChanged(dOverpaintType, type);
    ValueCell.updateIfChanged(dOverpaint, overpaint.layers.length > 0);
    if (overpaint.layers.length === 0)
      return;
    if (type === "instance")
      return;
    if (smoothing && hasColorSmoothingProp(smoothing.props)) {
      const { geometry, props, webgl } = smoothing;
      if (geometry.kind === "mesh") {
        const { resolution, overpaintTexture } = geometry.meta;
        const csp = getColorSmoothingProps(props.smoothColors, true, resolution);
        if (csp) {
          applyMeshOverpaintSmoothing(renderObject.values, csp.resolution, csp.stride, webgl, overpaintTexture);
          geometry.meta.overpaintTexture = renderObject.values.tOverpaintGrid.ref.value;
        }
      } else if (webgl && geometry.kind === "texture-mesh") {
        const { resolution, overpaintTexture } = geometry.meta;
        const csp = getColorSmoothingProps(props.smoothColors, true, resolution);
        if (csp) {
          applyTextureMeshOverpaintSmoothing(renderObject.values, csp.resolution, csp.stride, webgl, overpaintTexture);
          geometry.meta.overpaintTexture = renderObject.values.tOverpaintGrid.ref.value;
        }
      }
    }
  }
  Visual2.setOverpaint = setOverpaint;
  function setTransparency(renderObject, transparency, lociApply, clear2, smoothing) {
    if (!renderObject)
      return;
    const { tTransparency, dTransparencyType, transparencyAverage, transparencyMin, dTransparency, uGroupCount, instanceCount, instanceGranularity } = renderObject.values;
    const count3 = instanceGranularity.ref.value ? instanceCount.ref.value : uGroupCount.ref.value * instanceCount.ref.value;
    const type = instanceGranularity.ref.value ? "instance" : "groupInstance";
    createTransparency(transparency.layers.length ? count3 : 0, type, renderObject.values);
    const { array } = tTransparency.ref.value;
    if (clear2)
      clearTransparency(array, 0, count3);
    for (let i = 0, il = transparency.layers.length; i < il; ++i) {
      const { loci, value } = transparency.layers[i];
      const apply = (interval2) => {
        const start = Interval.start(interval2);
        const end = Interval.end(interval2);
        return applyTransparencyValue(array, start, end, value);
      };
      lociApply(loci, apply, false);
    }
    ValueCell.update(tTransparency, tTransparency.ref.value);
    ValueCell.updateIfChanged(transparencyAverage, getTransparencyAverage(array, count3));
    ValueCell.updateIfChanged(transparencyMin, getTransparencyMin(array, count3));
    ValueCell.updateIfChanged(dTransparencyType, type);
    ValueCell.updateIfChanged(dTransparency, transparency.layers.length > 0);
    if (transparency.layers.length === 0)
      return;
    if (type === "instance")
      return;
    if (smoothing && hasColorSmoothingProp(smoothing.props)) {
      const { geometry, props, webgl } = smoothing;
      if (geometry.kind === "mesh") {
        const { resolution, transparencyTexture } = geometry.meta;
        const csp = getColorSmoothingProps(props.smoothColors, true, resolution);
        if (csp) {
          applyMeshTransparencySmoothing(renderObject.values, csp.resolution, csp.stride, webgl, transparencyTexture);
          geometry.meta.transparencyTexture = renderObject.values.tTransparencyGrid.ref.value;
        }
      } else if (webgl && geometry.kind === "texture-mesh") {
        const { resolution, transparencyTexture } = geometry.meta;
        const csp = getColorSmoothingProps(props.smoothColors, true, resolution);
        if (csp) {
          applyTextureMeshTransparencySmoothing(renderObject.values, csp.resolution, csp.stride, webgl, transparencyTexture);
          geometry.meta.transparencyTexture = renderObject.values.tTransparencyGrid.ref.value;
        }
      }
    }
  }
  Visual2.setTransparency = setTransparency;
  function setEmissive(renderObject, emissive, lociApply, clear2, smoothing) {
    if (!renderObject)
      return;
    const { tEmissive, dEmissiveType, emissiveAverage, dEmissive, uGroupCount, instanceCount, instanceGranularity } = renderObject.values;
    const count3 = instanceGranularity.ref.value ? instanceCount.ref.value : uGroupCount.ref.value * instanceCount.ref.value;
    const type = instanceGranularity.ref.value ? "instance" : "groupInstance";
    createEmissive(emissive.layers.length ? count3 : 0, type, renderObject.values);
    const { array } = tEmissive.ref.value;
    if (clear2)
      clearEmissive(array, 0, count3);
    for (let i = 0, il = emissive.layers.length; i < il; ++i) {
      const { loci, value } = emissive.layers[i];
      const apply = (interval2) => {
        const start = Interval.start(interval2);
        const end = Interval.end(interval2);
        return applyEmissiveValue(array, start, end, value);
      };
      lociApply(loci, apply, false);
    }
    ValueCell.update(tEmissive, tEmissive.ref.value);
    ValueCell.updateIfChanged(emissiveAverage, getEmissiveAverage(array, count3));
    ValueCell.updateIfChanged(dEmissiveType, type);
    ValueCell.updateIfChanged(dEmissive, emissive.layers.length > 0);
    if (emissive.layers.length === 0)
      return;
    if (type === "instance")
      return;
    if (smoothing && hasColorSmoothingProp(smoothing.props)) {
      const { geometry, props, webgl } = smoothing;
      if (geometry.kind === "mesh") {
        const { resolution, emissiveTexture } = geometry.meta;
        const csp = getColorSmoothingProps(props.smoothColors, true, resolution);
        if (csp) {
          applyMeshEmissiveSmoothing(renderObject.values, csp.resolution, csp.stride, webgl, emissiveTexture);
          geometry.meta.emissiveTexture = renderObject.values.tEmissiveGrid.ref.value;
        }
      } else if (webgl && geometry.kind === "texture-mesh") {
        const { resolution, emissiveTexture } = geometry.meta;
        const csp = getColorSmoothingProps(props.smoothColors, true, resolution);
        if (csp) {
          applyTextureMeshEmissiveSmoothing(renderObject.values, csp.resolution, csp.stride, webgl, emissiveTexture);
          geometry.meta.emissiveTexture = renderObject.values.tEmissiveGrid.ref.value;
        }
      }
    }
  }
  Visual2.setEmissive = setEmissive;
  function setSubstance(renderObject, substance, lociApply, clear2, smoothing) {
    if (!renderObject)
      return;
    const { tSubstance, dSubstanceType, dSubstance, uGroupCount, instanceCount, instanceGranularity } = renderObject.values;
    const count3 = instanceGranularity.ref.value ? instanceCount.ref.value : uGroupCount.ref.value * instanceCount.ref.value;
    const type = instanceGranularity.ref.value ? "instance" : "groupInstance";
    createSubstance(substance.layers.length ? count3 : 0, type, renderObject.values);
    const { array } = tSubstance.ref.value;
    if (clear2)
      clearSubstance(array, 0, count3);
    for (let i = 0, il = substance.layers.length; i < il; ++i) {
      const { loci, material, clear: clear3 } = substance.layers[i];
      const apply = (interval2) => {
        const start = Interval.start(interval2);
        const end = Interval.end(interval2);
        return clear3 ? clearSubstance(array, start, end) : applySubstanceMaterial(array, start, end, material);
      };
      lociApply(loci, apply, false);
    }
    ValueCell.update(tSubstance, tSubstance.ref.value);
    ValueCell.updateIfChanged(dSubstanceType, type);
    ValueCell.updateIfChanged(dSubstance, substance.layers.length > 0);
    if (substance.layers.length === 0)
      return;
    if (type === "instance")
      return;
    if (smoothing && hasColorSmoothingProp(smoothing.props)) {
      const { geometry, props, webgl } = smoothing;
      if (geometry.kind === "mesh") {
        const { resolution, substanceTexture } = geometry.meta;
        const csp = getColorSmoothingProps(props.smoothColors, true, resolution);
        if (csp) {
          applyMeshSubstanceSmoothing(renderObject.values, csp.resolution, csp.stride, webgl, substanceTexture);
          geometry.meta.substanceTexture = renderObject.values.tSubstanceGrid.ref.value;
        }
      } else if (webgl && geometry.kind === "texture-mesh") {
        const { resolution, substanceTexture } = geometry.meta;
        const csp = getColorSmoothingProps(props.smoothColors, true, resolution);
        if (csp) {
          applyTextureMeshSubstanceSmoothing(renderObject.values, csp.resolution, csp.stride, webgl, substanceTexture);
          geometry.meta.substanceTexture = renderObject.values.tSubstanceGrid.ref.value;
        }
      }
    }
  }
  Visual2.setSubstance = setSubstance;
  function setClipping(renderObject, clipping, lociApply, clear2) {
    if (!renderObject)
      return;
    const { tClipping, dClippingType, dClipping, uGroupCount, instanceCount, instanceGranularity } = renderObject.values;
    const count3 = instanceGranularity.ref.value ? instanceCount.ref.value : uGroupCount.ref.value * instanceCount.ref.value;
    const { layers } = clipping;
    const type = instanceGranularity.ref.value ? "instance" : "groupInstance";
    createClipping(layers.length ? count3 : 0, type, renderObject.values);
    const { array } = tClipping.ref.value;
    if (clear2)
      clearClipping(array, 0, count3);
    for (let i = 0, il = clipping.layers.length; i < il; ++i) {
      const { loci, groups } = clipping.layers[i];
      const apply = (interval2) => {
        const start = Interval.start(interval2);
        const end = Interval.end(interval2);
        return applyClippingGroups(array, start, end, groups);
      };
      lociApply(loci, apply, false);
    }
    ValueCell.update(tClipping, tClipping.ref.value);
    ValueCell.updateIfChanged(dClippingType, type);
    ValueCell.updateIfChanged(dClipping, clipping.layers.length > 0);
  }
  Visual2.setClipping = setClipping;
  function setThemeStrength(renderObject, strength) {
    if (renderObject) {
      ValueCell.updateIfChanged(renderObject.values.uOverpaintStrength, strength.overpaint);
      ValueCell.updateIfChanged(renderObject.values.uTransparencyStrength, strength.transparency);
      ValueCell.updateIfChanged(renderObject.values.uEmissiveStrength, strength.emissive);
      ValueCell.updateIfChanged(renderObject.values.uSubstanceStrength, strength.substance);
    }
  }
  Visual2.setThemeStrength = setThemeStrength;
  function setTransform(renderObject, transform, instanceTransforms) {
    if (!renderObject || !transform && !instanceTransforms)
      return;
    const { values: values2 } = renderObject;
    if (transform) {
      Mat4.copy(values2.matrix.ref.value, transform);
      ValueCell.update(values2.matrix, values2.matrix.ref.value);
    }
    if (instanceTransforms) {
      values2.extraTransform.ref.value.set(instanceTransforms);
      ValueCell.update(values2.extraTransform, values2.extraTransform.ref.value);
    } else if (instanceTransforms === null) {
      fillIdentityTransform(values2.extraTransform.ref.value, values2.instanceCount.ref.value);
      ValueCell.update(values2.extraTransform, values2.extraTransform.ref.value);
    }
    updateTransformData(values2, values2.invariantBoundingSphere.ref.value, values2.instanceGrid.ref.value.cellSize, values2.instanceGrid.ref.value.batchSize);
    const boundingSphere = calculateTransformBoundingSphere(values2.invariantBoundingSphere.ref.value, values2.transform.ref.value, values2.instanceCount.ref.value, 0);
    ValueCell.update(values2.boundingSphere, boundingSphere);
  }
  Visual2.setTransform = setTransform;
})(Visual || (Visual = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/clipping.js
function Clipping(kind, layers) {
  return { kind, layers };
}
(function(Clipping2) {
  Clipping2.Empty = { kind: "empty-loci", layers: [] };
  let Groups;
  (function(Groups2) {
    Groups2.is = BitFlags.has;
    let Flag;
    (function(Flag2) {
      Flag2[Flag2["None"] = 0] = "None";
      Flag2[Flag2["One"] = 1] = "One";
      Flag2[Flag2["Two"] = 2] = "Two";
      Flag2[Flag2["Three"] = 4] = "Three";
      Flag2[Flag2["Four"] = 8] = "Four";
      Flag2[Flag2["Five"] = 16] = "Five";
      Flag2[Flag2["Six"] = 32] = "Six";
    })(Flag = Groups2.Flag || (Groups2.Flag = {}));
    function create(flags) {
      return BitFlags.create(flags);
    }
    Groups2.create = create;
    Groups2.Names = {
      "one": Flag.One,
      "two": Flag.Two,
      "three": Flag.Three,
      "four": Flag.Four,
      "five": Flag.Five,
      "six": Flag.Six
    };
    function isName(name) {
      return name in Groups2.Names;
    }
    Groups2.isName = isName;
    function fromName(name) {
      switch (name) {
        case "one":
          return Flag.One;
        case "two":
          return Flag.Two;
        case "three":
          return Flag.Three;
        case "four":
          return Flag.Four;
        case "five":
          return Flag.Five;
        case "six":
          return Flag.Six;
      }
    }
    Groups2.fromName = fromName;
    function fromNames(names) {
      let f = Flag.None;
      for (let i = 0, il = names.length; i < il; ++i) {
        f |= fromName(names[i]);
      }
      return f;
    }
    Groups2.fromNames = fromNames;
    function toNames(groups) {
      const names = [];
      if (Groups2.is(groups, Flag.One))
        names.push("one");
      if (Groups2.is(groups, Flag.Two))
        names.push("two");
      if (Groups2.is(groups, Flag.Three))
        names.push("three");
      if (Groups2.is(groups, Flag.Four))
        names.push("four");
      if (Groups2.is(groups, Flag.Five))
        names.push("five");
      if (Groups2.is(groups, Flag.Six))
        names.push("six");
      return names;
    }
    Groups2.toNames = toNames;
  })(Groups = Clipping2.Groups || (Clipping2.Groups = {}));
  function areEqual(cA, cB) {
    if (cA.layers.length !== cB.layers.length)
      return false;
    for (let i = 0, il = cA.layers.length; i < il; ++i) {
      if (cA.layers[i].groups !== cB.layers[i].groups)
        return false;
      if (!Loci.areEqual(cA.layers[i].loci, cB.layers[i].loci))
        return false;
    }
    return true;
  }
  Clipping2.areEqual = areEqual;
  function isEmpty3(clipping) {
    return clipping.layers.length === 0;
  }
  Clipping2.isEmpty = isEmpty3;
  function remap(clipping, structure) {
    if (clipping.kind === "element-loci") {
      const layers = [];
      for (const layer of clipping.layers) {
        let { loci, groups } = layer;
        loci = element_exports.Loci.remap(loci, structure);
        if (!element_exports.Loci.isEmpty(loci)) {
          layers.push({ loci, groups });
        }
      }
      return { kind: "element-loci", layers };
    } else {
      return clipping;
    }
  }
  Clipping2.remap = remap;
  function merge3(clipping) {
    if (isEmpty3(clipping))
      return clipping;
    if (clipping.kind === "element-loci") {
      const { structure } = clipping.layers[0].loci;
      const map3 = /* @__PURE__ */ new Map();
      let shadowed = element_exports.Loci.none(structure);
      for (let i = 0, il = clipping.layers.length; i < il; ++i) {
        let { loci, groups } = clipping.layers[il - i - 1];
        loci = element_exports.Loci.subtract(loci, shadowed);
        shadowed = element_exports.Loci.union(loci, shadowed);
        if (!element_exports.Loci.isEmpty(loci)) {
          if (map3.has(groups)) {
            loci = element_exports.Loci.union(loci, map3.get(groups));
          }
          map3.set(groups, loci);
        }
      }
      const layers = [];
      map3.forEach((loci, groups) => {
        layers.push({ loci, groups });
      });
      return { kind: "element-loci", layers };
    } else {
      return clipping;
    }
  }
  Clipping2.merge = merge3;
  function filter4(clipping, filter5) {
    if (isEmpty3(clipping))
      return clipping;
    if (clipping.kind === "element-loci") {
      const { structure } = clipping.layers[0].loci;
      const layers = [];
      for (const layer of clipping.layers) {
        let { loci, groups } = layer;
        const filtered = element_exports.Loci.remap(loci, filter5);
        loci = element_exports.Loci.remap(filtered, structure);
        if (!element_exports.Loci.isEmpty(loci)) {
          layers.push({ loci, groups });
        }
      }
      return { kind: "element-loci", layers };
    } else {
      return clipping;
    }
  }
  Clipping2.filter = filter4;
  function ofScript(scriptLayers, structure) {
    const layers = [];
    for (let i = 0, il = scriptLayers.length; i < il; ++i) {
      const { script, groups } = scriptLayers[i];
      const loci = Script.toLoci(script, structure);
      if (!element_exports.Loci.isEmpty(loci)) {
        layers.push({ loci, groups });
      }
    }
    return { kind: "element-loci", layers };
  }
  Clipping2.ofScript = ofScript;
  function ofBundle(bundleLayers, structure) {
    const layers = [];
    for (let i = 0, il = bundleLayers.length; i < il; ++i) {
      const { bundle, groups } = bundleLayers[i];
      const loci = element_exports.Bundle.toLoci(bundle, structure.root);
      layers.push({ loci, groups });
    }
    return { kind: "element-loci", layers };
  }
  Clipping2.ofBundle = ofBundle;
  function toBundle(clipping) {
    const layers = [];
    for (let i = 0, il = clipping.layers.length; i < il; ++i) {
      const { loci, groups } = clipping.layers[i];
      const bundle = element_exports.Bundle.fromLoci(loci);
      layers.push({ bundle, groups });
    }
    return { kind: "element-loci", layers };
  }
  Clipping2.toBundle = toBundle;
})(Clipping || (Clipping = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/substance.js
function Substance(kind, layers) {
  return { kind, layers };
}
(function(Substance2) {
  Substance2.Empty = { kind: "empty-loci", layers: [] };
  function areEqual(sA, sB) {
    if (sA.layers.length === 0 && sB.layers.length === 0)
      return true;
    if (sA.layers.length !== sB.layers.length)
      return false;
    for (let i = 0, il = sA.layers.length; i < il; ++i) {
      if (sA.layers[i].clear !== sB.layers[i].clear)
        return false;
      if (!shallowEqual2(sA.layers[i].material, sB.layers[i].material))
        return false;
      if (!Loci.areEqual(sA.layers[i].loci, sB.layers[i].loci))
        return false;
    }
    return true;
  }
  Substance2.areEqual = areEqual;
  function isEmpty3(substance) {
    return substance.layers.length === 0;
  }
  Substance2.isEmpty = isEmpty3;
  function remap(substance, structure) {
    if (substance.kind === "element-loci") {
      const layers = [];
      for (const layer of substance.layers) {
        let { loci, material, clear: clear2 } = layer;
        loci = element_exports.Loci.remap(loci, structure);
        if (!element_exports.Loci.isEmpty(loci)) {
          layers.push({ loci, material, clear: clear2 });
        }
      }
      return { kind: "element-loci", layers };
    } else {
      return substance;
    }
  }
  Substance2.remap = remap;
  function merge3(substance) {
    if (isEmpty3(substance))
      return substance;
    if (substance.kind === "element-loci") {
      const { structure } = substance.layers[0].loci;
      let clearLoci = void 0;
      const map3 = /* @__PURE__ */ new Map();
      let shadowed = element_exports.Loci.none(structure);
      for (let i = 0, il = substance.layers.length; i < il; ++i) {
        let { loci, material, clear: clear2 } = substance.layers[il - i - 1];
        loci = element_exports.Loci.subtract(loci, shadowed);
        shadowed = element_exports.Loci.union(loci, shadowed);
        if (!element_exports.Loci.isEmpty(loci)) {
          if (clear2) {
            clearLoci = clearLoci ? element_exports.Loci.union(loci, clearLoci) : loci;
          } else {
            if (map3.has(material)) {
              loci = element_exports.Loci.union(loci, map3.get(material));
            }
            map3.set(material, loci);
          }
        }
      }
      const layers = [];
      if (clearLoci) {
        layers.push({ loci: clearLoci, material: Material(), clear: true });
      }
      map3.forEach((loci, material) => {
        layers.push({ loci, material, clear: false });
      });
      return { kind: "element-loci", layers };
    } else {
      return substance;
    }
  }
  Substance2.merge = merge3;
  function filter4(substance, filter5) {
    if (isEmpty3(substance))
      return substance;
    if (substance.kind === "element-loci") {
      const { structure } = substance.layers[0].loci;
      const layers = [];
      for (const layer of substance.layers) {
        let { loci, material, clear: clear2 } = layer;
        const filtered = element_exports.Loci.remap(loci, filter5);
        loci = element_exports.Loci.remap(filtered, structure);
        if (!element_exports.Loci.isEmpty(loci)) {
          layers.push({ loci, material, clear: clear2 });
        }
      }
      return { kind: "element-loci", layers };
    } else {
      return substance;
    }
  }
  Substance2.filter = filter4;
  function ofScript(scriptLayers, structure) {
    const layers = [];
    for (let i = 0, il = scriptLayers.length; i < il; ++i) {
      const { script, material, clear: clear2 } = scriptLayers[i];
      const loci = Script.toLoci(script, structure);
      if (!element_exports.Loci.isEmpty(loci)) {
        layers.push({ loci, material, clear: clear2 });
      }
    }
    return { kind: "element-loci", layers };
  }
  Substance2.ofScript = ofScript;
  function ofBundle(bundleLayers, structure) {
    const layers = [];
    for (let i = 0, il = bundleLayers.length; i < il; ++i) {
      const { bundle, material, clear: clear2 } = bundleLayers[i];
      const loci = element_exports.Bundle.toLoci(bundle, structure.root);
      layers.push({ loci, material, clear: clear2 });
    }
    return { kind: "element-loci", layers };
  }
  Substance2.ofBundle = ofBundle;
  function toBundle(overpaint) {
    const layers = [];
    for (let i = 0, il = overpaint.layers.length; i < il; ++i) {
      const { loci, material, clear: clear2 } = overpaint.layers[i];
      const bundle = element_exports.Bundle.fromLoci(loci);
      layers.push({ bundle, material, clear: clear2 });
    }
    return { kind: "element-loci", layers };
  }
  Substance2.toBundle = toBundle;
})(Substance || (Substance = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/emissive.js
function Emissive(kind, layers) {
  return { kind, layers };
}
(function(Emissive2) {
  Emissive2.Empty = { kind: "empty-loci", layers: [] };
  function areEqual(eA, eB) {
    if (eA.layers.length === 0 && eB.layers.length === 0)
      return true;
    if (eA.layers.length !== eB.layers.length)
      return false;
    for (let i = 0, il = eA.layers.length; i < il; ++i) {
      if (eA.layers[i].value !== eB.layers[i].value)
        return false;
      if (!Loci.areEqual(eA.layers[i].loci, eB.layers[i].loci))
        return false;
    }
    return true;
  }
  Emissive2.areEqual = areEqual;
  function isEmpty3(emissive) {
    return emissive.layers.length === 0;
  }
  Emissive2.isEmpty = isEmpty3;
  function remap(emissive, structure) {
    if (emissive.kind === "element-loci") {
      const layers = [];
      for (const layer of emissive.layers) {
        let { loci, value } = layer;
        loci = element_exports.Loci.remap(loci, structure);
        if (!element_exports.Loci.isEmpty(loci)) {
          layers.push({ loci, value });
        }
      }
      return { kind: "element-loci", layers };
    } else {
      return emissive;
    }
  }
  Emissive2.remap = remap;
  function merge3(emissive) {
    if (isEmpty3(emissive))
      return emissive;
    if (emissive.kind === "element-loci") {
      const { structure } = emissive.layers[0].loci;
      const map3 = /* @__PURE__ */ new Map();
      let shadowed = element_exports.Loci.none(structure);
      for (let i = 0, il = emissive.layers.length; i < il; ++i) {
        let { loci, value } = emissive.layers[il - i - 1];
        loci = element_exports.Loci.subtract(loci, shadowed);
        shadowed = element_exports.Loci.union(loci, shadowed);
        if (!element_exports.Loci.isEmpty(loci)) {
          if (map3.has(value)) {
            loci = element_exports.Loci.union(loci, map3.get(value));
          }
          map3.set(value, loci);
        }
      }
      const layers = [];
      map3.forEach((loci, value) => {
        layers.push({ loci, value });
      });
      return { kind: "element-loci", layers };
    } else {
      return emissive;
    }
  }
  Emissive2.merge = merge3;
  function filter4(emissive, filter5) {
    if (isEmpty3(emissive))
      return emissive;
    if (emissive.kind === "element-loci") {
      const { structure } = emissive.layers[0].loci;
      const layers = [];
      for (const layer of emissive.layers) {
        let { loci, value } = layer;
        const filtered = element_exports.Loci.remap(loci, filter5);
        loci = element_exports.Loci.remap(filtered, structure);
        if (!element_exports.Loci.isEmpty(loci)) {
          layers.push({ loci, value });
        }
      }
      return { kind: "element-loci", layers };
    } else {
      return emissive;
    }
  }
  Emissive2.filter = filter4;
  function ofScript(scriptLayers, structure) {
    const layers = [];
    for (let i = 0, il = scriptLayers.length; i < il; ++i) {
      const { script, value } = scriptLayers[i];
      const loci = Script.toLoci(script, structure);
      if (!element_exports.Loci.isEmpty(loci)) {
        layers.push({ loci, value });
      }
    }
    return { kind: "element-loci", layers };
  }
  Emissive2.ofScript = ofScript;
  function ofBundle(bundleLayers, structure) {
    const layers = [];
    for (let i = 0, il = bundleLayers.length; i < il; ++i) {
      const { bundle, value } = bundleLayers[i];
      const loci = element_exports.Bundle.toLoci(bundle, structure.root);
      layers.push({ loci, value });
    }
    return { kind: "element-loci", layers };
  }
  Emissive2.ofBundle = ofBundle;
  function toBundle(emissive) {
    const layers = [];
    for (let i = 0, il = emissive.layers.length; i < il; ++i) {
      const { loci, value } = emissive.layers[i];
      const bundle = element_exports.Bundle.fromLoci(loci);
      layers.push({ bundle, value });
    }
    return { kind: "element-loci", layers };
  }
  Emissive2.toBundle = toBundle;
})(Emissive || (Emissive = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/representation.js
var RepresentationProvider;
(function(RepresentationProvider2) {
  function getDefaultParams(r, ctx, data) {
    return ParamDefinition.getDefaultValues(r.getParams(ctx, data));
  }
  RepresentationProvider2.getDefaultParams = getDefaultParams;
})(RepresentationProvider || (RepresentationProvider = {}));
var EmptyRepresentationProvider = {
  name: "",
  label: "",
  description: "",
  factory: () => Representation.Empty,
  getParams: () => ({}),
  defaultValues: {},
  defaultColorTheme: { name: "" },
  defaultSizeTheme: { name: "" },
  isApplicable: () => true
};
function getTypes2(list2) {
  return list2.map((e) => [e.name, e.provider.label]);
}
var RepresentationRegistry = class {
  get default() {
    return this._list[0];
  }
  get types() {
    return getTypes2(this._list);
  }
  constructor() {
    this._list = [];
    this._map = /* @__PURE__ */ new Map();
    this._name = /* @__PURE__ */ new Map();
  }
  add(provider) {
    if (this._map.has(provider.name)) {
      throw new Error(`${provider.name} already registered.`);
    }
    this._list.push({ name: provider.name, provider });
    this._map.set(provider.name, provider);
    this._name.set(provider, provider.name);
  }
  getName(provider) {
    if (!this._name.has(provider))
      throw new Error(`'${provider.label}' is not a registered represenatation provider.`);
    return this._name.get(provider);
  }
  remove(provider) {
    const name = provider.name;
    this._list.splice(this._list.findIndex((e) => e.name === name), 1);
    const p = this._map.get(name);
    if (p) {
      this._map.delete(name);
      this._name.delete(p);
    }
  }
  get(name) {
    return this._map.get(name) || EmptyRepresentationProvider;
  }
  get list() {
    return this._list;
  }
  getApplicableList(data) {
    return this._list.filter((e) => e.provider.isApplicable(data));
  }
  getApplicableTypes(data) {
    return getTypes2(this.getApplicableList(data));
  }
  clear() {
    this._list.length = 0;
    this._map.clear();
    this._name.clear();
  }
};
var Representation;
(function(Representation2) {
  let Loci2;
  (function(Loci3) {
    function areEqual(a5, b5) {
      return a5.repr === b5.repr && Loci.areEqual(a5.loci, b5.loci);
    }
    Loci3.areEqual = areEqual;
    function isEmpty3(a5) {
      return Loci.isEmpty(a5.loci);
    }
    Loci3.isEmpty = isEmpty3;
    Loci3.Empty = { loci: EmptyLoci };
  })(Loci2 = Representation2.Loci || (Representation2.Loci = {}));
  function createState2() {
    return {
      visible: true,
      alphaFactor: 1,
      pickable: true,
      colorOnly: false,
      syncManually: false,
      transform: Mat4.identity(),
      overpaint: Overpaint.Empty,
      transparency: Transparency.Empty,
      emissive: Emissive.Empty,
      substance: Substance.Empty,
      clipping: Clipping.Empty,
      themeStrength: { overpaint: 1, transparency: 1, emissive: 1, substance: 1 },
      markerActions: MarkerActions.All
    };
  }
  Representation2.createState = createState2;
  function updateState(state, update10) {
    if (update10.visible !== void 0)
      state.visible = update10.visible;
    if (update10.alphaFactor !== void 0)
      state.alphaFactor = update10.alphaFactor;
    if (update10.pickable !== void 0)
      state.pickable = update10.pickable;
    if (update10.colorOnly !== void 0)
      state.colorOnly = update10.colorOnly;
    if (update10.overpaint !== void 0)
      state.overpaint = update10.overpaint;
    if (update10.transparency !== void 0)
      state.transparency = update10.transparency;
    if (update10.emissive !== void 0)
      state.emissive = update10.emissive;
    if (update10.substance !== void 0)
      state.substance = update10.substance;
    if (update10.clipping !== void 0)
      state.clipping = update10.clipping;
    if (update10.themeStrength !== void 0)
      state.themeStrength = update10.themeStrength;
    if (update10.syncManually !== void 0)
      state.syncManually = update10.syncManually;
    if (update10.transform !== void 0)
      Mat4.copy(state.transform, update10.transform);
    if (update10.markerActions !== void 0)
      state.markerActions = update10.markerActions;
  }
  Representation2.updateState = updateState;
  Representation2.StateBuilder = { create: createState2, update: updateState };
  Representation2.Empty = {
    label: "",
    groupCount: 0,
    renderObjects: [],
    geometryVersion: -1,
    props: {},
    params: {},
    updated: new Subject(),
    state: createState2(),
    theme: Theme.createEmpty(),
    createOrUpdate: () => Task.constant("", void 0),
    setState: () => {
    },
    setTheme: () => {
    },
    getLoci: () => EmptyLoci,
    getAllLoci: () => [],
    eachLocation: () => {
    },
    mark: () => false,
    destroy: () => {
    }
  };
  class GeometryState {
    constructor() {
      this.curr = /* @__PURE__ */ new Set();
      this.next = /* @__PURE__ */ new Set();
      this._version = -1;
    }
    get version() {
      return this._version;
    }
    add(id, version) {
      this.next.add(cantorPairing(id, version));
    }
    snapshot() {
      if (!SetUtils.areEqual(this.curr, this.next)) {
        this._version += 1;
      }
      [this.curr, this.next] = [this.next, this.curr];
      this.next.clear();
    }
  }
  Representation2.GeometryState = GeometryState;
  function createMulti(label2, ctx, getParams, stateBuilder, reprDefs) {
    let version = 0;
    const updated = new Subject();
    const geometryState = new GeometryState();
    const currentState = stateBuilder.create();
    let currentTheme = Theme.createEmpty();
    let currentParams;
    let currentProps;
    let currentData;
    const reprMap = {};
    const reprList = Object.keys(reprDefs).map((name, i) => {
      reprMap[i] = name;
      const repr = reprDefs[name](ctx, getParams);
      repr.setState(currentState);
      return repr;
    });
    return {
      label: label2,
      updated,
      get groupCount() {
        let groupCount = 0;
        if (currentProps) {
          const { visuals } = currentProps;
          for (let i = 0, il = reprList.length; i < il; ++i) {
            if (!visuals || visuals.includes(reprMap[i])) {
              groupCount += reprList[i].groupCount;
            }
          }
        }
        return groupCount;
      },
      get renderObjects() {
        const renderObjects = [];
        if (currentProps) {
          const { visuals } = currentProps;
          for (let i = 0, il = reprList.length; i < il; ++i) {
            if (!visuals || visuals.includes(reprMap[i])) {
              renderObjects.push(...reprList[i].renderObjects);
            }
          }
        }
        return renderObjects;
      },
      get geometryVersion() {
        return geometryState.version;
      },
      get props() {
        return currentProps;
      },
      get params() {
        return currentParams;
      },
      createOrUpdate: (props = {}, data) => {
        if (data && data !== currentData) {
          currentParams = getParams(ctx, data);
          currentData = data;
          if (!currentProps)
            currentProps = ParamDefinition.getDefaultValues(currentParams);
        }
        const qualityProps = getQualityProps(Object.assign({}, currentProps, props), currentData);
        Object.assign(currentProps, props, qualityProps);
        const { visuals } = currentProps;
        return Task.create(`Creating or updating '${label2}' representation`, async (runtime) => {
          for (let i = 0, il = reprList.length; i < il; ++i) {
            if (!visuals || visuals.includes(reprMap[i])) {
              await reprList[i].createOrUpdate(currentProps, currentData).runInContext(runtime);
            }
            geometryState.add(i, reprList[i].geometryVersion);
          }
          geometryState.snapshot();
          updated.next(version++);
        });
      },
      get state() {
        return currentState;
      },
      get theme() {
        return currentTheme;
      },
      getLoci: (pickingId) => {
        const { visuals } = currentProps;
        for (let i = 0, il = reprList.length; i < il; ++i) {
          if (!visuals || visuals.includes(reprMap[i])) {
            const loci = reprList[i].getLoci(pickingId);
            if (!isEmptyLoci(loci))
              return loci;
          }
        }
        return EmptyLoci;
      },
      getAllLoci: () => {
        const loci = [];
        const { visuals } = currentProps;
        for (let i = 0, il = reprList.length; i < il; ++i) {
          if (!visuals || visuals.includes(reprMap[i])) {
            loci.push(...reprList[i].getAllLoci());
          }
        }
        return loci;
      },
      eachLocation: (cb2) => {
        const { visuals } = currentProps;
        for (let i = 0, il = reprList.length; i < il; ++i) {
          if (!visuals || visuals.includes(reprMap[i])) {
            reprList[i].eachLocation(cb2);
          }
        }
      },
      mark: (loci, action) => {
        let marked = false;
        for (let i = 0, il = reprList.length; i < il; ++i) {
          marked = reprList[i].mark(loci, action) || marked;
        }
        return marked;
      },
      setState: (state) => {
        stateBuilder.update(currentState, state);
        for (let i = 0, il = reprList.length; i < il; ++i) {
          reprList[i].setState(state);
        }
      },
      setTheme: (theme) => {
        currentTheme = theme;
        for (let i = 0, il = reprList.length; i < il; ++i) {
          reprList[i].setTheme(theme);
        }
      },
      destroy() {
        for (let i = 0, il = reprList.length; i < il; ++i) {
          reprList[i].destroy();
        }
      }
    };
  }
  Representation2.createMulti = createMulti;
  function fromRenderObject(label2, renderObject) {
    let version = 0;
    const updated = new Subject();
    const geometryState = new GeometryState();
    const currentState = Representation2.createState();
    const currentTheme = Theme.createEmpty();
    const currentParams = ParamDefinition.clone(BaseGeometry.Params);
    const currentProps = ParamDefinition.getDefaultValues(BaseGeometry.Params);
    return {
      label: label2,
      updated,
      get groupCount() {
        return renderObject.values.uGroupCount.ref.value;
      },
      get renderObjects() {
        return [renderObject];
      },
      get geometryVersion() {
        return geometryState.version;
      },
      get props() {
        return currentProps;
      },
      get params() {
        return currentParams;
      },
      createOrUpdate: (props = {}) => {
        const qualityProps = getQualityProps(Object.assign({}, currentProps, props));
        Object.assign(currentProps, props, qualityProps);
        return Task.create(`Updating '${label2}' representation`, async (runtime) => {
          geometryState.add(0, renderObject.id);
          geometryState.snapshot();
          updated.next(version++);
        });
      },
      get state() {
        return currentState;
      },
      get theme() {
        return currentTheme;
      },
      getLoci: () => {
        return EmptyLoci;
      },
      getAllLoci: () => {
        return [];
      },
      eachLocation: () => {
      },
      mark: (loci, action) => {
        return false;
      },
      setState: (state) => {
        if (state.visible !== void 0)
          Visual.setVisibility(renderObject, state.visible);
        if (state.alphaFactor !== void 0)
          Visual.setAlphaFactor(renderObject, state.alphaFactor);
        if (state.pickable !== void 0)
          Visual.setPickable(renderObject, state.pickable);
        if (state.colorOnly !== void 0)
          Visual.setColorOnly(renderObject, state.colorOnly);
        if (state.overpaint !== void 0) {
        }
        if (state.transparency !== void 0) {
        }
        if (state.emissive !== void 0) {
        }
        if (state.substance !== void 0) {
        }
        if (state.clipping !== void 0) {
        }
        if (state.themeStrength !== void 0)
          Visual.setThemeStrength(renderObject, state.themeStrength);
        if (state.transform !== void 0)
          Visual.setTransform(renderObject, state.transform);
        Representation2.updateState(currentState, state);
      },
      setTheme: () => {
      },
      destroy() {
      }
    };
  }
  Representation2.fromRenderObject = fromRenderObject;
})(Representation || (Representation = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/shape/representation.js
function ShapeRepresentation(getShape, geometryUtils, builder = {}) {
  let version = 0;
  const updated = new Subject();
  const _state = Representation.createState();
  const materialId = getNextMaterialId();
  const renderObjects = [];
  let _renderObject;
  let _shape;
  let geometryVersion = -1;
  const _theme = Theme.createEmpty();
  const currentParams = geometryUtils.Params;
  let currentProps = ParamDefinition.getDefaultValues(currentParams);
  let locationIt;
  let positionIt;
  if (builder.modifyState)
    Representation.updateState(_state, builder.modifyState(_state));
  const updateState = VisualUpdateState.create();
  function prepareUpdate(props = {}, shape) {
    VisualUpdateState.reset(updateState);
    if (!shape && !_shape) {
      return;
    } else if (shape && !_shape) {
      updateState.createNew = true;
    } else if (shape && _shape && shape.id === _shape.id) {
    } else if (shape && _shape && shape.id !== _shape.id) {
      updateState.updateTransform = true;
      updateState.createGeometry = true;
    } else if (!shape) {
    } else {
      console.warn("unexpected state");
    }
    if (props.instanceGranularity !== currentProps.instanceGranularity) {
      updateState.updateTransform = true;
    }
    if (updateState.updateTransform) {
      updateState.updateColor = true;
      updateState.updateSize = true;
      updateState.updateMatrix = true;
    }
    if (updateState.createGeometry) {
      updateState.updateColor = true;
      updateState.updateSize = true;
    }
  }
  function createOrUpdate(props = {}, data) {
    if (builder.modifyProps)
      props = builder.modifyProps(props);
    return Task.create("ShapeRepresentation.create", async (runtime) => {
      const newProps = Object.assign(currentProps, props);
      const shape = data ? await getShape(runtime, data, newProps, _shape) : void 0;
      prepareUpdate(props, shape);
      if (shape) {
        _shape = shape;
        Object.assign(_theme, Shape.getTheme(_shape));
      }
      if (updateState.createNew) {
        renderObjects.length = 0;
        locationIt = Shape.groupIterator(_shape);
        const transform = Shape.createTransform(_shape.transforms, _shape.geometry.boundingSphere, newProps.cellSize, newProps.batchSize);
        const values2 = geometryUtils.createValues(_shape.geometry, transform, locationIt, _theme, newProps);
        const state = geometryUtils.createRenderableState(newProps);
        if (builder.modifyState)
          Object.assign(state, builder.modifyState(state));
        Representation.updateState(_state, state);
        _renderObject = createRenderObject(_shape.geometry.kind, values2, state, materialId);
        if (_renderObject)
          renderObjects.push(_renderObject);
        positionIt = geometryUtils.createPositionIterator(_shape.geometry, _renderObject.values);
      } else {
        if (!_renderObject) {
          throw new Error("expected renderObject to be available");
        }
        if (updateState.updateTransform) {
          locationIt = Shape.groupIterator(_shape);
          const { instanceCount, groupCount } = locationIt;
          if (props.instanceGranularity) {
            createMarkers(instanceCount, "instance", _renderObject.values);
          } else {
            createMarkers(instanceCount * groupCount, "groupInstance", _renderObject.values);
          }
        }
        if (updateState.updateMatrix) {
          Shape.createTransform(_shape.transforms, _shape.geometry.boundingSphere, newProps.cellSize, newProps.batchSize, _renderObject.values);
          if ("lodLevels" in _renderObject.values) {
            ValueCell.update(_renderObject.values.lodLevels, _renderObject.values.lodLevels.ref.value);
          }
        }
        if (updateState.createGeometry) {
          ValueCell.updateIfChanged(_renderObject.values.drawCount, Geometry.getDrawCount(_shape.geometry));
          ValueCell.updateIfChanged(_renderObject.values.uVertexCount, Geometry.getVertexCount(_shape.geometry));
          ValueCell.updateIfChanged(_renderObject.values.uGroupCount, Geometry.getGroupCount(_shape.geometry));
        }
        if (updateState.updateTransform || updateState.createGeometry) {
          geometryUtils.updateBoundingSphere(_renderObject.values, _shape.geometry);
          positionIt = geometryUtils.createPositionIterator(_shape.geometry, _renderObject.values);
        }
        if (updateState.updateColor) {
          createColors(locationIt, positionIt, _theme.color, _renderObject.values);
        }
        if (updateState.updateSize) {
          if ("uSize" in _renderObject.values) {
            createSizes(locationIt, _theme.size, _renderObject.values);
          }
        }
        geometryUtils.updateValues(_renderObject.values, newProps);
        geometryUtils.updateRenderableState(_renderObject.state, newProps);
      }
      currentProps = newProps;
      if (updateState.createGeometry || updateState.createNew) {
        geometryVersion += 1;
      }
      updated.next(version++);
    });
  }
  function eachInstance(loci, shape, apply) {
    let changed = false;
    if (!ShapeGroup.isLoci(loci))
      return false;
    if (ShapeGroup.isLociEmpty(loci))
      return false;
    if (loci.shape !== shape)
      return false;
    for (const g of loci.groups) {
      if (apply(Interval.ofSingleton(g.instance)))
        changed = true;
    }
    return changed;
  }
  function lociApply(loci, apply) {
    if (isEveryLoci(loci) || Shape.isLoci(loci) && loci.shape === _shape) {
      if (currentProps.instanceGranularity) {
        return apply(Interval.ofBounds(0, _shape.transforms.length));
      } else {
        return apply(Interval.ofBounds(0, _shape.groupCount * _shape.transforms.length));
      }
    } else {
      if (currentProps.instanceGranularity) {
        return eachInstance(loci, _shape, apply);
      } else {
        return eachShapeGroup(loci, _shape, apply);
      }
    }
  }
  return {
    label: "Shape geometry",
    get groupCount() {
      return locationIt ? locationIt.count : 0;
    },
    get props() {
      return currentProps;
    },
    get params() {
      return currentParams;
    },
    get state() {
      return _state;
    },
    get theme() {
      return _theme;
    },
    renderObjects,
    get geometryVersion() {
      return geometryVersion;
    },
    updated,
    createOrUpdate,
    getLoci(pickingId) {
      const { objectId, groupId, instanceId } = pickingId;
      if (_renderObject && _renderObject.id === objectId) {
        return ShapeGroup.Loci(_shape, [{ ids: OrderedSet.ofSingleton(groupId), instance: instanceId }]);
      }
      return EmptyLoci;
    },
    getAllLoci() {
      return [Shape.Loci(_shape)];
    },
    eachLocation: (cb2) => {
      locationIt.reset();
      while (locationIt.hasNext) {
        const { location, isSecondary } = locationIt.move();
        cb2(location, isSecondary);
      }
    },
    mark(loci, action) {
      if (!MarkerActions.is(_state.markerActions, action))
        return false;
      if (ShapeGroup.isLoci(loci) || Shape.isLoci(loci)) {
        if (loci.shape !== _shape)
          return false;
      } else if (!isEveryLoci(loci)) {
        return false;
      }
      return Visual.mark(_renderObject, loci, action, lociApply);
    },
    setState(state) {
      if (builder.modifyState)
        state = builder.modifyState(state);
      if (_renderObject) {
        if (state.visible !== void 0)
          Visual.setVisibility(_renderObject, state.visible);
        if (state.alphaFactor !== void 0)
          Visual.setAlphaFactor(_renderObject, state.alphaFactor);
        if (state.pickable !== void 0)
          Visual.setPickable(_renderObject, state.pickable);
        if (state.colorOnly !== void 0)
          Visual.setColorOnly(_renderObject, state.colorOnly);
        if (state.overpaint !== void 0) {
          Visual.setOverpaint(_renderObject, state.overpaint, lociApply, true);
        }
        if (state.transparency !== void 0) {
          Visual.setTransparency(_renderObject, state.transparency, lociApply, true);
        }
        if (state.substance !== void 0) {
          Visual.setSubstance(_renderObject, state.substance, lociApply, true);
        }
        if (state.transform !== void 0)
          Visual.setTransform(_renderObject, state.transform);
      }
      Representation.updateState(_state, state);
    },
    setTheme(theme) {
      if (isDebugMode) {
        console.warn("The `ShapeRepresentation` theme is fixed to `ShapeGroupColorTheme` and `ShapeGroupSizeTheme`. Colors are taken from `Shape.getColor` and sizes from `Shape.getSize`");
      }
    },
    destroy() {
      renderObjects.length = 0;
      if (_renderObject) {
        _renderObject.state.disposed = true;
        _renderObject = void 0;
      }
    }
  };
}
function eachShapeGroup(loci, shape, apply) {
  if (!ShapeGroup.isLoci(loci))
    return false;
  if (loci.shape !== shape)
    return false;
  let changed = false;
  const { groupCount } = shape;
  const { groups } = loci;
  for (const { ids, instance } of groups) {
    if (Interval.is(ids)) {
      const start = instance * groupCount + Interval.start(ids);
      const end = instance * groupCount + Interval.end(ids);
      if (apply(Interval.ofBounds(start, end)))
        changed = true;
    } else {
      for (let i = 0, _i = ids.length; i < _i; i++) {
        const idx = instance * groupCount + ids[i];
        if (apply(Interval.ofSingleton(idx)))
          changed = true;
      }
    }
  }
  return changed;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model/structure/structure/util/unit-transforms.js
var tmpMat = Mat4();
var StructureUnitTransforms = class {
  constructor(structure) {
    this.structure = structure;
    this.groupUnitTransforms = [];
    this.unitOffsetMap = IntMap.Mutable();
    this.groupIndexMap = IntMap.Mutable();
    this._isIdentity = void 0;
    this.version = 0;
    this.unitTransforms = new Float32Array(structure.units.length * 16);
    this.size = structure.units.length;
    this.reset();
    let groupOffset = 0;
    for (let i = 0, il = structure.unitSymmetryGroups.length; i < il; ++i) {
      const g = structure.unitSymmetryGroups[i];
      this.groupIndexMap.set(g.hashCode, i);
      const groupTransforms = this.unitTransforms.subarray(groupOffset, groupOffset + g.units.length * 16);
      this.groupUnitTransforms.push(groupTransforms);
      for (let j = 0, jl = g.units.length; j < jl; ++j) {
        this.unitOffsetMap.set(g.units[j].id, groupOffset + j * 16);
      }
      groupOffset += g.units.length * 16;
    }
  }
  reset() {
    this.version = 0;
    fillIdentityTransform(this.unitTransforms, this.size);
    this._isIdentity = true;
  }
  get isIdentity() {
    if (this._isIdentity === void 0) {
      this._isIdentity = true;
      for (let i = 0, il = this.size * 16; i < il; i += 16) {
        Mat4.fromArray(tmpMat, this.unitTransforms, i);
        if (!Mat4.isIdentity(tmpMat)) {
          this._isIdentity = false;
          break;
        }
      }
    }
    return this._isIdentity;
  }
  setTransform(matrix, unit) {
    this.version = (this.version + 1) % 2147483647;
    Mat4.toArray(matrix, this.unitTransforms, this.unitOffsetMap.get(unit.id));
    this._isIdentity = void 0;
  }
  getTransform(out, unit) {
    return Mat4.fromArray(out, this.unitTransforms, this.unitOffsetMap.get(unit.id));
  }
  getSymmetryGroupTransforms(group) {
    return this.groupUnitTransforms[this.groupIndexMap.get(group.hashCode)];
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/animation/helpers.js
var _unwindMatrix = Mat4();
function unwindStructureAssembly(structure, unitTransforms, t2) {
  for (let i = 0, _i = structure.units.length; i < _i; i++) {
    const u = structure.units[i];
    SymmetryOperator.lerpFromIdentity(_unwindMatrix, u.conformation.operator, t2);
    unitTransforms.setTransform(_unwindMatrix, u);
  }
}
var _centerVec = Vec3();
var _transVec = Vec3();
var _transMat = Mat4();
function explodeStructure(structure, unitTransforms, t2, sphere) {
  const d3 = sphere.radius * t2;
  for (let i = 0, _i = structure.units.length; i < _i; i++) {
    const u = structure.units[i];
    Vec3.transformMat4(_centerVec, u.lookup3d.boundary.sphere.center, u.conformation.operator.matrix);
    Vec3.sub(_transVec, _centerVec, sphere.center);
    Vec3.setMagnitude(_transVec, _transVec, d3);
    Mat4.fromTranslation(_transMat, _transVec);
    unitTransforms.setTransform(_transMat, u);
  }
}
var SpinStructureParams = {
  axis: ParamDefinition.MappedStatic("custom", {
    structure: ParamDefinition.Group({
      principalAxis: ParamDefinition.Select("dirA", [["dirA", "A"], ["dirB", "B"], ["dirC", "C"]])
    }),
    custom: ParamDefinition.Group({
      vector: ParamDefinition.Vec3(Vec3.create(0, 0, 1))
    })
  }),
  origin: ParamDefinition.MappedStatic("structure", {
    structure: ParamDefinition.Group({}),
    custom: ParamDefinition.Group({
      vector: ParamDefinition.Vec3(Vec3.create(0, 0, 0))
    })
  })
};
function getSpinStructureAxisAndOrigin(structure, props) {
  let axis, origin;
  if (props.axis.name === "custom") {
    axis = props.axis.params.vector;
  } else {
    const pa = Structure.getPrincipalAxes(structure);
    axis = pa.momentsAxes[props.axis.params.principalAxis];
  }
  if (props.origin.name === "custom") {
    origin = props.origin.params.vector;
  } else {
    const pa = Structure.getPrincipalAxes(structure);
    origin = pa.momentsAxes.origin;
  }
  return { axis, origin };
}
var _rotMat = Mat4();
var _transMat2 = Mat4();
var _t = Mat4();
function spinStructure(structure, unitTransforms, t2, axis, origin) {
  for (let i = 0, _i = structure.units.length; i < _i; i++) {
    const u = structure.units[i];
    Vec3.negate(_transVec, origin);
    Mat4.fromTranslation(_transMat, _transVec);
    Mat4.fromRotation(_rotMat, Math.PI * t2 * 2, axis);
    Mat4.fromTranslation(_transMat2, origin);
    Mat4.mul(_t, _rotMat, _transMat);
    Mat4.mul(_t, _transMat2, _t);
    unitTransforms.setTransform(_t, u);
  }
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/shape/model/unitcell.js
var translate05 = Mat4.fromTranslation(Mat4(), Vec3.create(0.5, 0.5, 0.5));
var unitCage = transformCage(cloneCage(BoxCage()), translate05);
var tmpRef = Vec3();
var tmpTranslate = Mat4();
var CellRef = {
  origin: "Origin",
  model: "Model"
};
var CellAttachment = {
  corner: "Corner",
  center: "Center"
};
var CellParams = {
  ...Mesh.Params,
  cellColor: ParamDefinition.Color(ColorNames.orange),
  cellScale: ParamDefinition.Numeric(2, { min: 0.1, max: 5, step: 0.1 }),
  ref: ParamDefinition.Select("model", ParamDefinition.objectToOptions(CellRef), { isEssential: true }),
  attachment: ParamDefinition.Select("corner", ParamDefinition.objectToOptions(CellAttachment), { isEssential: true })
};
var UnitcellVisuals = {
  "mesh": (ctx, getParams) => ShapeRepresentation(getUnitcellShape, Mesh.Utils)
};
var UnitcellParams = {
  ...CellParams
};
function getUnitcellMesh(data, props, mesh) {
  const state = MeshBuilder.createState(256, 128, mesh);
  const { fromFractional } = data.symmetry.spacegroup.cell;
  Vec3.copy(tmpRef, data.ref);
  if (props.attachment === "center") {
    Vec3.trunc(tmpRef, tmpRef);
    Vec3.subScalar(tmpRef, tmpRef, 0.5);
  } else {
    Vec3.floor(tmpRef, tmpRef);
  }
  Mat4.fromTranslation(tmpTranslate, tmpRef);
  const cellCage = transformCage(cloneCage(unitCage), tmpTranslate);
  const radius = Math.cbrt(data.symmetry.spacegroup.cell.volume) / 300 * props.cellScale;
  state.currentGroup = 1;
  MeshBuilder.addCage(state, fromFractional, cellCage, radius, 2, 20);
  const sphere = Sphere3D.fromDimensionsAndTransform(Sphere3D(), Vec3.unit, fromFractional);
  Vec3.transformMat4(tmpRef, tmpRef, fromFractional);
  Sphere3D.translate(sphere, sphere, tmpRef);
  Sphere3D.expand(sphere, sphere, radius);
  const m = MeshBuilder.getMesh(state);
  m.setBoundingSphere(sphere);
  return m;
}
function getUnitcellShape(ctx, data, props, shape) {
  const geo = getUnitcellMesh(data, props, shape && shape.geometry);
  const label2 = Symmetry.getUnitcellLabel(data.symmetry);
  return Shape.create(label2, data, geo, () => props.cellColor, () => 1, () => label2);
}
function getUnitcellData(model, symmetry, props) {
  const ref = Vec3();
  if (props.ref === "model") {
    Vec3.transformMat4(ref, Model.getCenter(model), symmetry.spacegroup.cell.toFractional);
  }
  return { symmetry, ref };
}
function UnitcellRepresentation(ctx, getParams) {
  return Representation.createMulti("Unit Cell", ctx, getParams, Representation.StateBuilder, UnitcellVisuals);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/text/text-builder.js
var quadIndices = new Uint16Array([
  0,
  1,
  2,
  1,
  3,
  2
]);
var caAdd33 = ChunkedArray.add3;
var caAdd22 = ChunkedArray.add2;
var caAdd4 = ChunkedArray.add;
var TextBuilder;
(function(TextBuilder2) {
  function create(props = {}, initialCount = 2048, chunkSize = 1024, text) {
    initialCount *= 2;
    chunkSize *= 2;
    const centers = ChunkedArray.create(Float32Array, 3, chunkSize, text ? text.centerBuffer.ref.value : initialCount);
    const mappings = ChunkedArray.create(Float32Array, 2, chunkSize, text ? text.mappingBuffer.ref.value : initialCount);
    const depths = ChunkedArray.create(Float32Array, 1, chunkSize, text ? text.depthBuffer.ref.value : initialCount);
    const indices2 = ChunkedArray.create(Uint32Array, 3, chunkSize, text ? text.indexBuffer.ref.value : initialCount);
    const groups = ChunkedArray.create(Float32Array, 1, chunkSize, text ? text.groupBuffer.ref.value : initialCount);
    const tcoords = ChunkedArray.create(Float32Array, 2, chunkSize, text ? text.tcoordBuffer.ref.value : initialCount);
    const p = { ...ParamDefinition.getDefaultValues(Text.Params), ...props };
    const { attachment, background, backgroundMargin, tether, tetherLength, tetherBaseWidth } = p;
    const fontAtlas = getFontAtlas(p);
    const margin = 1 / 2.5 * backgroundMargin;
    const outline = fontAtlas.buffer / fontAtlas.lineHeight;
    const add = (x, y, z, depth, group) => {
      caAdd33(centers, x, y, z);
      caAdd4(depths, depth);
      caAdd4(groups, group);
    };
    return {
      add: (str3, x, y, z, depth, scale, group) => {
        let bWidth = 0;
        const nChar = str3.length;
        for (let iChar = 0; iChar < nChar; ++iChar) {
          const c5 = fontAtlas.get(str3[iChar]);
          bWidth += c5.nw - 2 * outline;
        }
        const bHeight = 1 / 1.25;
        let yShift, xShift;
        if (attachment.startsWith("top")) {
          yShift = bHeight;
        } else if (attachment.startsWith("middle")) {
          yShift = bHeight / 2;
        } else {
          yShift = 0;
        }
        if (attachment.endsWith("right")) {
          xShift = bWidth;
        } else if (attachment.endsWith("center")) {
          xShift = bWidth / 2;
        } else {
          xShift = 0;
        }
        if (tether) {
          switch (attachment) {
            case "bottom-left":
              xShift -= tetherLength / 2 + margin + 0.1;
              yShift -= tetherLength / 2 + margin;
              break;
            case "bottom-center":
              yShift -= tetherLength + margin;
              break;
            case "bottom-right":
              xShift += tetherLength / 2 + margin + 0.1;
              yShift -= tetherLength / 2 + margin;
              break;
            case "middle-left":
              xShift -= tetherLength + margin + 0.1;
              break;
            case "middle-center":
              break;
            case "middle-right":
              xShift += tetherLength + margin + 0.1;
              break;
            case "top-left":
              xShift -= tetherLength / 2 + margin + 0.1;
              yShift += tetherLength / 2 + margin;
              break;
            case "top-center":
              yShift += tetherLength + margin;
              break;
            case "top-right":
              xShift += tetherLength / 2 + margin + 0.1;
              yShift += tetherLength / 2 + margin;
              break;
          }
        }
        const xLeft = (-xShift - margin - 0.1) * scale;
        const xRight = (bWidth - xShift + margin + 0.1) * scale;
        const yTop = (bHeight - yShift + margin) * scale;
        const yBottom = (-yShift - margin) * scale;
        if (background) {
          caAdd22(mappings, xLeft, yTop);
          caAdd22(mappings, xLeft, yBottom);
          caAdd22(mappings, xRight, yTop);
          caAdd22(mappings, xRight, yBottom);
          const offset = centers.elementCount;
          for (let i = 0; i < 4; ++i) {
            caAdd22(tcoords, 10, 10);
            add(x, y, z, depth, group);
          }
          caAdd33(indices2, offset + quadIndices[0], offset + quadIndices[1], offset + quadIndices[2]);
          caAdd33(indices2, offset + quadIndices[3], offset + quadIndices[4], offset + quadIndices[5]);
        }
        if (tether) {
          let xTip, yTip;
          let xBaseA, yBaseA;
          let xBaseB, yBaseB;
          let xBaseCenter, yBaseCenter;
          const scaledTetherLength = tetherLength * scale;
          const scaledTetherBaseWidth = tetherBaseWidth * scale;
          switch (attachment) {
            case "bottom-left":
              xTip = xLeft - scaledTetherLength / 2;
              xBaseA = xLeft + scaledTetherBaseWidth / 2;
              xBaseB = xLeft;
              xBaseCenter = xLeft;
              yTip = yBottom - scaledTetherLength / 2;
              yBaseA = yBottom;
              yBaseB = yBottom + scaledTetherBaseWidth / 2;
              yBaseCenter = yBottom;
              break;
            case "bottom-center":
              xTip = 0;
              xBaseA = scaledTetherBaseWidth / 2;
              xBaseB = -scaledTetherBaseWidth / 2;
              xBaseCenter = 0;
              yTip = yBottom - scaledTetherLength;
              yBaseA = yBottom;
              yBaseB = yBottom;
              yBaseCenter = yBottom;
              break;
            case "bottom-right":
              xTip = xRight + scaledTetherLength / 2;
              xBaseA = xRight;
              xBaseB = xRight - scaledTetherBaseWidth / 2;
              xBaseCenter = xRight;
              yTip = yBottom - scaledTetherLength / 2;
              yBaseA = yBottom + scaledTetherBaseWidth / 2;
              yBaseB = yBottom;
              yBaseCenter = yBottom;
              break;
            case "middle-left":
              xTip = xLeft - scaledTetherLength;
              xBaseA = xLeft;
              xBaseB = xLeft;
              xBaseCenter = xLeft;
              yTip = 0;
              yBaseA = -scaledTetherBaseWidth / 2;
              yBaseB = scaledTetherBaseWidth / 2;
              yBaseCenter = 0;
              break;
            case "middle-center":
              xTip = 0;
              xBaseA = 0;
              xBaseB = 0;
              xBaseCenter = 0;
              yTip = 0;
              yBaseA = 0;
              yBaseB = 0;
              yBaseCenter = 0;
              break;
            case "middle-right":
              xTip = xRight + scaledTetherLength;
              xBaseA = xRight;
              xBaseB = xRight;
              xBaseCenter = xRight;
              yTip = 0;
              yBaseA = scaledTetherBaseWidth / 2;
              yBaseB = -scaledTetherBaseWidth / 2;
              yBaseCenter = 0;
              break;
            case "top-left":
              xTip = xLeft - scaledTetherLength / 2;
              xBaseA = xLeft + scaledTetherBaseWidth / 2;
              xBaseB = xLeft;
              xBaseCenter = xLeft;
              yTip = yTop + scaledTetherLength / 2;
              yBaseA = yTop;
              yBaseB = yTop - scaledTetherBaseWidth / 2;
              yBaseCenter = yTop;
              break;
            case "top-center":
              xTip = 0;
              xBaseA = scaledTetherBaseWidth / 2;
              xBaseB = -scaledTetherBaseWidth / 2;
              xBaseCenter = 0;
              yTip = yTop + scaledTetherLength;
              yBaseA = yTop;
              yBaseB = yTop;
              yBaseCenter = yTop;
              break;
            case "top-right":
              xTip = xRight + scaledTetherLength / 2;
              xBaseA = xRight;
              xBaseB = xRight - scaledTetherBaseWidth / 2;
              xBaseCenter = xRight;
              yTip = yTop + scaledTetherLength / 2;
              yBaseA = yTop - scaledTetherBaseWidth / 2;
              yBaseB = yTop;
              yBaseCenter = yTop;
              break;
            default:
              assertUnreachable(attachment);
          }
          caAdd22(mappings, xTip, yTip);
          caAdd22(mappings, xBaseA, yBaseA);
          caAdd22(mappings, xBaseB, yBaseB);
          caAdd22(mappings, xBaseCenter, yBaseCenter);
          const offset = centers.elementCount;
          for (let i = 0; i < 4; ++i) {
            caAdd22(tcoords, 10, 10);
            add(x, y, z, depth, group);
          }
          caAdd33(indices2, offset, offset + 1, offset + 3);
          caAdd33(indices2, offset, offset + 3, offset + 2);
        }
        xShift += outline;
        yShift += outline;
        let xadvance = 0;
        for (let iChar = 0; iChar < nChar; ++iChar) {
          const c5 = fontAtlas.get(str3[iChar]);
          const left = (xadvance - xShift) * scale;
          const right = (xadvance + c5.nw - xShift) * scale;
          const top = (c5.nh - yShift) * scale;
          const bottom = -yShift * scale;
          caAdd22(mappings, left, top);
          caAdd22(mappings, left, bottom);
          caAdd22(mappings, right, top);
          caAdd22(mappings, right, bottom);
          const texWidth = fontAtlas.texture.width;
          const texHeight = fontAtlas.texture.height;
          caAdd22(tcoords, c5.x / texWidth, c5.y / texHeight);
          caAdd22(tcoords, c5.x / texWidth, (c5.y + c5.h) / texHeight);
          caAdd22(tcoords, (c5.x + c5.w) / texWidth, c5.y / texHeight);
          caAdd22(tcoords, (c5.x + c5.w) / texWidth, (c5.y + c5.h) / texHeight);
          xadvance += c5.nw - 2 * outline;
          const offset = centers.elementCount;
          for (let i = 0; i < 4; ++i)
            add(x, y, z, depth, group);
          caAdd33(indices2, offset + quadIndices[0], offset + quadIndices[1], offset + quadIndices[2]);
          caAdd33(indices2, offset + quadIndices[3], offset + quadIndices[4], offset + quadIndices[5]);
        }
      },
      getText: () => {
        const ft = fontAtlas.texture;
        const cb2 = ChunkedArray.compact(centers, true);
        const mb = ChunkedArray.compact(mappings, true);
        const db = ChunkedArray.compact(depths, true);
        const ib = ChunkedArray.compact(indices2, true);
        const gb = ChunkedArray.compact(groups, true);
        const tb = ChunkedArray.compact(tcoords, true);
        return Text.create(ft, cb2, mb, db, ib, gb, tb, indices2.elementCount / 2, text);
      }
    };
  }
  TextBuilder2.create = create;
})(TextBuilder || (TextBuilder = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-theme/label.js
var DefaultLabelOptions2 = {
  granularity: "element",
  condensed: false,
  reverse: false,
  countsOnly: false,
  hidePrefix: false,
  htmlStyling: true
};
function lociLabel(loci, options = {}) {
  var _a;
  switch (loci.kind) {
    case "structure-loci":
      return loci.structure.models.map((m) => m.entry).filter((l) => !!l).join(", ");
    case "element-loci":
      return structureElementStatsLabel(element_exports.Stats.ofLoci(loci), options);
    case "bond-loci":
      const bond = loci.bonds[0];
      return bond ? bondLabel(bond, options) : "";
    case "shape-loci":
      return loci.shape.name;
    case "group-loci":
      const g = loci.groups[0];
      return g ? loci.shape.getLabel(OrderedSet.start(g.ids), g.instance) : "";
    case "every-loci":
      return "Everything";
    case "empty-loci":
      return "Nothing";
    case "data-loci":
      return loci.getLabel();
    case "volume-loci":
      return loci.volume.label || "Volume";
    case "isosurface-loci":
      return [
        `${loci.volume.label || "Volume"}`,
        `Isosurface at ${Volume.IsoValue.toString(loci.isoValue)}`
      ].join(" | ");
    case "cell-loci":
      const size = OrderedSet.size(loci.indices);
      const start = OrderedSet.start(loci.indices);
      const absVal = Volume.IsoValue.absolute(loci.volume.grid.cells.data[start]);
      const relVal = Volume.IsoValue.toRelative(absVal, loci.volume.grid.stats);
      const label2 = [
        `${loci.volume.label || "Volume"}`,
        `${size === 1 ? `Cell #${start}` : `${size} Cells`}`
      ];
      if (size === 1) {
        label2.push(`${Volume.IsoValue.toString(absVal)} (${Volume.IsoValue.toString(relVal)})`);
      }
      return label2.join(" | ");
    case "segment-loci":
      const segmentLabels = (_a = Volume.Segmentation.get(loci.volume)) === null || _a === void 0 ? void 0 : _a.labels;
      if (segmentLabels && loci.segments.length === 1) {
        const label3 = segmentLabels[loci.segments[0]];
        if (label3)
          return label3;
      }
      return [
        `${loci.volume.label || "Volume"}`,
        `${loci.segments.length === 1 ? `Segment ${loci.segments[0]}` : `${loci.segments.length} Segments`}`
      ].join(" | ");
  }
}
function countLabel(count3, label2) {
  return count3 === 1 ? `1 ${label2}` : `${count3} ${label2}s`;
}
function otherLabel(count3, location, granularity, hidePrefix, reverse3, condensed) {
  return `${elementLabel(location, { granularity, hidePrefix, reverse: reverse3, condensed })} <small>[+ ${countLabel(count3 - 1, `other ${capitalize(granularity)}`)}]</small>`;
}
function getResidueCount(unit) {
  const { elements, model } = unit;
  const { chainAtomSegments, residueAtomSegments } = model.atomicHierarchy;
  const elementStart = chainAtomSegments.offsets[chainAtomSegments.index[elements[0]]];
  const elementEnd = chainAtomSegments.offsets[chainAtomSegments.index[elements[elements.length - 1]] + 1] - 1;
  return residueAtomSegments.index[elementEnd] - residueAtomSegments.index[elementStart] + 1;
}
function structureElementStatsLabel(stats, options = {}) {
  const o = { ...DefaultLabelOptions2, ...options };
  const label2 = _structureElementStatsLabel(stats, o.countsOnly, o.hidePrefix, o.condensed, o.reverse);
  return o.htmlStyling ? label2 : stripTags(label2);
}
function structureElementLociLabelMany(locis, options = {}) {
  const stats = element_exports.Stats.create();
  for (const l of locis) {
    element_exports.Stats.add(stats, stats, element_exports.Stats.ofLoci(l));
  }
  return structureElementStatsLabel(stats, options);
}
function _structureElementStatsLabel(stats, countsOnly = false, hidePrefix = false, condensed = false, reverse3 = false) {
  const { structureCount, chainCount, residueCount, conformationCount, elementCount } = stats;
  if (!countsOnly && elementCount === 1 && residueCount === 0 && chainCount === 0) {
    return elementLabel(stats.firstElementLoc, { hidePrefix, condensed, granularity: "element", reverse: reverse3 });
  } else if (!countsOnly && elementCount === 0 && residueCount === 1 && chainCount === 0) {
    return elementLabel(stats.firstResidueLoc, { hidePrefix, condensed, granularity: "residue", reverse: reverse3 });
  } else if (!countsOnly && elementCount === 0 && residueCount === 0 && chainCount === 1) {
    const { unit } = stats.firstChainLoc;
    const granularity = Unit.isAtomic(unit) && getResidueCount(unit) === 1 ? "residue" : Unit.Traits.is(unit.traits, Unit.Trait.MultiChain) ? "residue" : "chain";
    return elementLabel(stats.firstChainLoc, { hidePrefix, condensed, granularity, reverse: reverse3 });
  } else if (!countsOnly) {
    const label2 = [];
    if (structureCount > 0) {
      label2.push(structureCount === 1 ? elementLabel(stats.firstStructureLoc, { hidePrefix, condensed, granularity: "structure", reverse: reverse3 }) : otherLabel(structureCount, stats.firstStructureLoc, "structure", hidePrefix, reverse3, condensed));
    }
    if (chainCount > 0) {
      label2.push(chainCount === 1 ? elementLabel(stats.firstChainLoc, { condensed, granularity: "chain", hidePrefix, reverse: reverse3 }) : otherLabel(chainCount, stats.firstChainLoc, "chain", hidePrefix, reverse3, condensed));
      hidePrefix = true;
    }
    if (residueCount > 0) {
      label2.push(residueCount === 1 ? elementLabel(stats.firstResidueLoc, { condensed, granularity: "residue", hidePrefix, reverse: reverse3 }) : otherLabel(residueCount, stats.firstResidueLoc, "residue", hidePrefix, reverse3, condensed));
      hidePrefix = true;
    }
    if (conformationCount > 0) {
      label2.push(conformationCount === 1 ? elementLabel(stats.firstConformationLoc, { condensed, granularity: "conformation", hidePrefix, reverse: reverse3 }) : otherLabel(conformationCount, stats.firstConformationLoc, "conformation", hidePrefix, reverse3, condensed));
      hidePrefix = true;
    }
    if (elementCount > 0) {
      label2.push(elementCount === 1 ? elementLabel(stats.firstElementLoc, { condensed, granularity: "element", hidePrefix, reverse: reverse3 }) : otherLabel(elementCount, stats.firstElementLoc, "element", hidePrefix, reverse3, condensed));
    }
    return label2.join("<small> + </small>");
  } else {
    const label2 = [];
    if (structureCount > 0)
      label2.push(countLabel(structureCount, "Structure"));
    if (chainCount > 0)
      label2.push(countLabel(chainCount, "Chain"));
    if (residueCount > 0)
      label2.push(countLabel(residueCount, "Residue"));
    if (conformationCount > 0)
      label2.push(countLabel(conformationCount, "Conformation"));
    if (elementCount > 0)
      label2.push(countLabel(elementCount, "Element"));
    return label2.join("<small> + </small>");
  }
}
function bondLabel(bond, options = {}) {
  return bundleLabel({ loci: [
    element_exports.Loci(bond.aStructure, [{ unit: bond.aUnit, indices: OrderedSet.ofSingleton(bond.aIndex) }]),
    element_exports.Loci(bond.bStructure, [{ unit: bond.bUnit, indices: OrderedSet.ofSingleton(bond.bIndex) }])
  ] }, options);
}
function bundleLabel(bundle, options = {}) {
  const o = { ...DefaultLabelOptions2, ...options };
  const label2 = _bundleLabel(bundle, o);
  return o.htmlStyling ? label2 : stripTags(label2);
}
function _bundleLabel(bundle, options) {
  const { granularity, hidePrefix, reverse: reverse3, condensed } = options;
  let isSingleElements = true;
  for (const l of bundle.loci) {
    if (!element_exports.Loci.is(l) || element_exports.Loci.size(l) !== 1) {
      isSingleElements = false;
      break;
    }
  }
  if (isSingleElements) {
    const locations = bundle.loci.map((l) => {
      const { unit, indices: indices2 } = l.elements[0];
      return element_exports.Location.create(l.structure, unit, unit.elements[OrderedSet.start(indices2)]);
    });
    const labels = locations.map((l) => _elementLabel(l, granularity, hidePrefix, reverse3 || condensed));
    if (condensed) {
      return labels.map((l) => l[0].replace(/\[.*\]/g, "").trim()).filter((l) => !!l).join("  ");
    }
    let offset = 0;
    for (let i = 0, il = Math.min(...labels.map((l) => l.length)) - 1; i < il; ++i) {
      let areIdentical = true;
      for (let j = 1, jl = labels.length; j < jl; ++j) {
        if (labels[0][i] !== labels[j][i]) {
          areIdentical = false;
          break;
        }
      }
      if (areIdentical)
        offset += 1;
      else
        break;
    }
    if (offset > 0) {
      const offsetLabels = [labels[0].join(" | ")];
      for (let j = 1, jl = labels.length; j < jl; ++j) {
        offsetLabels.push(labels[j].slice(offset).filter((l) => !!l).join(" | "));
      }
      return offsetLabels.join("  ");
    } else {
      return labels.map((l) => l.filter((l2) => !!l2).join(" | ")).filter((l) => !!l).join("</br>");
    }
  } else {
    const labels = bundle.loci.map((l) => lociLabel(l, options));
    return labels.filter((l) => !!l).join(condensed ? "  " : "</br>");
  }
}
function elementLabel(location, options = {}) {
  var _a, _b;
  const o = { ...DefaultLabelOptions2, ...options };
  const _label = _elementLabel(location, o.granularity, o.hidePrefix, o.reverse || o.condensed);
  const label2 = o.condensed ? (_b = (_a = _label[0]) === null || _a === void 0 ? void 0 : _a.replace(/\[.*\]/g, "").trim()) !== null && _b !== void 0 ? _b : "" : _label.filter((l) => !!l).join(" | ");
  return o.htmlStyling ? label2 : stripTags(label2);
}
function _elementLabel(location, granularity = "element", hidePrefix = false, reverse3 = false) {
  const label2 = [];
  if (!hidePrefix) {
    let entry = location.unit.model.entry;
    if (entry.length > 30)
      entry = entry.substr(0, 27) + "";
    label2.push(`<small>${entry}</small>`);
    if (granularity !== "structure") {
      label2.push(`<small>Model ${location.unit.model.modelNum}</small>`);
      label2.push(`<small>Instance ${location.unit.conformation.operator.name}</small>`);
    }
  }
  if (Unit.isAtomic(location.unit)) {
    label2.push(..._atomicElementLabel(location, granularity, reverse3));
  } else if (Unit.isCoarse(location.unit)) {
    label2.push(..._coarseElementLabel(location, granularity));
  } else {
    label2.push("Unknown");
  }
  return reverse3 ? label2.reverse() : label2;
}
function _atomicElementLabel(location, granularity, hideOccupancy = false) {
  const rI = element_exports.Location.residueIndex(location);
  const label_asym_id = StructureProperties.chain.label_asym_id(location);
  const auth_asym_id = StructureProperties.chain.auth_asym_id(location);
  const has_label_seq_id = location.unit.model.atomicHierarchy.residues.label_seq_id.valueKind(rI) === Column.ValueKinds.Present;
  const label_seq_id = StructureProperties.residue.label_seq_id(location);
  const auth_seq_id = StructureProperties.residue.auth_seq_id(location);
  const ins_code = StructureProperties.residue.pdbx_PDB_ins_code(location);
  const comp_id = StructureProperties.atom.label_comp_id(location);
  const atom_id = StructureProperties.atom.label_atom_id(location);
  const alt_id = StructureProperties.atom.label_alt_id(location);
  const occupancy = StructureProperties.atom.occupancy(location);
  const sourceIndex = StructureProperties.atom.sourceIndex(location);
  const microHetCompIds = StructureProperties.residue.microheterogeneityCompIds(location);
  const compId2 = granularity === "residue" && microHetCompIds.length > 1 ? `(${microHetCompIds.join("|")})` : comp_id;
  const label2 = [];
  switch (granularity) {
    case "element": {
      const base = `<b>${atom_id}</b>${alt_id ? `%${alt_id}` : ""}`;
      const idx = `<small style='margin-left: 4px'>[idx <b>${sourceIndex + 1}</b>]</small>`;
      label2.push(`${base}${idx}`);
    }
    case "conformation":
      if (granularity === "conformation" && alt_id) {
        label2.push(`<small>Conformation</small> <b>${alt_id}</b>`);
      }
    case "residue":
      const seq_id = label_seq_id === auth_seq_id || !has_label_seq_id ? auth_seq_id : label_seq_id;
      label2.push(`<b>${compId2} ${seq_id}</b>${seq_id !== auth_seq_id ? ` <small>[auth</small> <b>${auth_seq_id}</b><small>]</small>` : ""}<b>${ins_code ? ins_code : ""}</b>`);
    case "chain":
      if (label_asym_id === auth_asym_id) {
        label2.push(`<b>${label_asym_id}</b>`);
      } else {
        if (granularity === "chain" && Unit.Traits.is(location.unit.traits, Unit.Trait.MultiChain)) {
          label2.push(`<small>[auth</small> <b>${auth_asym_id}</b><small>]</small>`);
        } else {
          label2.push(`<b>${label_asym_id}</b> <small>[auth</small> <b>${auth_asym_id}</b><small>]</small>`);
        }
      }
  }
  if (label2.length > 0 && occupancy !== 1 && !hideOccupancy) {
    label2[0] = `${label2[0]} <small>[occupancy</small> <b>${Math.round(100 * occupancy) / 100}</b><small>]</small>`;
  }
  return label2.reverse();
}
function _coarseElementLabel(location, granularity) {
  const asym_id = StructureProperties.coarse.asym_id(location);
  const seq_id_begin = StructureProperties.coarse.seq_id_begin(location);
  const seq_id_end = StructureProperties.coarse.seq_id_end(location);
  const label2 = [];
  switch (granularity) {
    case "element":
    case "conformation":
    case "residue":
      if (seq_id_begin === seq_id_end) {
        const entityIndex = StructureProperties.coarse.entityKey(location);
        const seq = location.unit.model.sequence.byEntityKey[entityIndex];
        const comp_id = seq.sequence.compId.value(seq_id_begin - 1);
        label2.push(`<b>${comp_id} ${seq_id_begin}</b>`);
      } else {
        label2.push(`<b>${seq_id_begin}-${seq_id_end}</b>`);
      }
    case "chain":
      label2.push(`<b>${asym_id}</b>`);
  }
  return label2.reverse();
}
function distanceLabel(pair, options = {}) {
  const o = { ...DefaultLabelOptions2, measureOnly: false, unitLabel: "", ...options };
  const [cA, cB] = pair.loci.map((l) => Loci.getCenter(l));
  const distance = `${Vec3.distance(cA, cB).toFixed(2)} ${o.unitLabel}`;
  if (o.measureOnly)
    return distance;
  const label2 = bundleLabel(pair, o);
  return o.condensed ? `${distance} | ${label2}` : `Distance ${distance}</br>${label2}`;
}
function angleLabel(triple, options = {}) {
  const o = { ...DefaultLabelOptions2, measureOnly: false, ...options };
  const [cA, cB, cC] = triple.loci.map((l) => Loci.getCenter(l));
  const vAB = Vec3.sub(Vec3(), cA, cB);
  const vCB = Vec3.sub(Vec3(), cC, cB);
  const angle = `${radToDeg(Vec3.angle(vAB, vCB)).toFixed(2)}`;
  if (o.measureOnly)
    return angle;
  const label2 = bundleLabel(triple, o);
  return o.condensed ? `${angle} | ${label2}` : `Angle ${angle}</br>${label2}`;
}
function dihedralLabel(quad, options = {}) {
  const o = { ...DefaultLabelOptions2, measureOnly: false, ...options };
  const [cA, cB, cC, cD] = quad.loci.map((l) => Loci.getCenter(l));
  const dihedral = `${radToDeg(Vec3.dihedralAngle(cA, cB, cC, cD)).toFixed(2)}`;
  if (o.measureOnly)
    return dihedral;
  const label2 = bundleLabel(quad, o);
  return o.condensed ? `${dihedral} | ${label2}` : `Dihedral ${dihedral}</br>${label2}`;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/shape/loci/common.js
var MeasurementRepresentationCommonTextParams = {
  customText: ParamDefinition.Text("", { label: "Text", description: "Override the label with custom value.", isEssential: true }),
  textColor: ParamDefinition.Color(ColorNames.black, { isEssential: true }),
  textSize: ParamDefinition.Numeric(0.5, { min: 0.1, max: 10, step: 0.1 }, { isEssential: true })
};
var LociLabelTextParams = {
  ...Text.Params,
  ...MeasurementRepresentationCommonTextParams,
  borderWidth: ParamDefinition.Numeric(0.2, { min: 0, max: 0.5, step: 0.01 })
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/shape/loci/distance.js
var SharedParams = {
  unitLabel: ParamDefinition.Text("", { isEssential: true })
};
var LineParams = {
  ...Lines.Params,
  ...SharedParams,
  lineSizeAttenuation: ParamDefinition.Boolean(true),
  linesColor: ParamDefinition.Color(ColorNames.lightgreen, { isEssential: true }),
  linesSize: ParamDefinition.Numeric(0.075, { min: 0.01, max: 5, step: 0.01 }),
  dashLength: ParamDefinition.Numeric(0.2, { min: 0.01, max: 0.2, step: 0.01 })
};
var TextParams = {
  ...LociLabelTextParams,
  ...SharedParams
};
var DistanceVisuals = {
  "lines": (ctx, getParams) => ShapeRepresentation(getLinesShape, Lines.Utils, { modifyState: (s) => ({ ...s, markerActions: MarkerActions.Highlighting }) }),
  "text": (ctx, getParams) => ShapeRepresentation(getTextShape, Text.Utils, { modifyState: (s) => ({ ...s, markerActions: MarkerAction.None }) })
};
var DistanceParams = {
  ...LineParams,
  ...TextParams,
  visuals: ParamDefinition.MultiSelect(["lines", "text"], ParamDefinition.objectToOptions(DistanceVisuals))
};
function getDistanceState() {
  return {
    sphereA: Sphere3D(),
    sphereB: Sphere3D(),
    center: Vec3(),
    distance: 0
  };
}
function setDistanceState(pair, state) {
  const { sphereA, sphereB, center } = state;
  const [lociA, lociB] = pair.loci;
  Loci.getBoundingSphere(lociA, sphereA);
  Loci.getBoundingSphere(lociB, sphereB);
  Vec3.add(center, sphereA.center, sphereB.center);
  Vec3.scale(center, center, 0.5);
  state.distance = Vec3.distance(sphereA.center, sphereB.center);
  return state;
}
var tmpState = getDistanceState();
function getDistanceName(data, unitLabel) {
  return data.pairs.length === 1 ? `Distance ${distanceLabel(data.pairs[0], { unitLabel, measureOnly: true })}` : `${data.pairs.length} Distances`;
}
function buildLines(data, props, lines) {
  const builder = LinesBuilder.create(128, 64, lines);
  for (let i = 0, il = data.pairs.length; i < il; ++i) {
    setDistanceState(data.pairs[i], tmpState);
    builder.addFixedLengthDashes(tmpState.sphereA.center, tmpState.sphereB.center, props.dashLength, i);
  }
  return builder.getLines();
}
function getLinesShape(ctx, data, props, shape) {
  const lines = buildLines(data, props, shape && shape.geometry);
  const name = getDistanceName(data, props.unitLabel);
  const getLabel = (groupId) => distanceLabel(data.pairs[groupId], props);
  return Shape.create(name, data, lines, () => props.linesColor, () => props.linesSize, getLabel);
}
function buildText(data, props, text) {
  const builder = TextBuilder.create(props, 128, 64, text);
  for (let i = 0, il = data.pairs.length; i < il; ++i) {
    setDistanceState(data.pairs[i], tmpState);
    const { center, distance, sphereA, sphereB } = tmpState;
    const label2 = props.customText || `${distance.toFixed(2)} ${props.unitLabel}`;
    const radius = Math.max(2, sphereA.radius, sphereB.radius);
    const scale = radius / 2;
    builder.add(label2, center[0], center[1], center[2], 1, scale, i);
  }
  return builder.getText();
}
function getTextShape(ctx, data, props, shape) {
  const text = buildText(data, props, shape && shape.geometry);
  const name = getDistanceName(data, props.unitLabel);
  const getLabel = (groupId) => distanceLabel(data.pairs[groupId], props);
  return Shape.create(name, data, text, () => props.textColor, () => props.textSize, getLabel);
}
function DistanceRepresentation(ctx, getParams) {
  return Representation.createMulti("Distance", ctx, getParams, Representation.StateBuilder, DistanceVisuals);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms/helpers.js
function getDistanceDataFromStructureSelections(s) {
  const lociA = s[0].loci;
  const lociB = s[1].loci;
  return { pairs: [{ loci: [lociA, lociB] }] };
}
function getAngleDataFromStructureSelections(s) {
  const lociA = s[0].loci;
  const lociB = s[1].loci;
  const lociC = s[2].loci;
  return { triples: [{ loci: [lociA, lociB, lociC] }] };
}
function getDihedralDataFromStructureSelections(s) {
  const lociA = s[0].loci;
  const lociB = s[1].loci;
  const lociC = s[2].loci;
  const lociD = s[3].loci;
  return { quads: [{ loci: [lociA, lociB, lociC, lociD] }] };
}
function getLabelDataFromStructureSelections(s) {
  const loci = s[0].loci;
  return { infos: [{ loci }] };
}
function getOrientationDataFromStructureSelections(s) {
  return { locis: s.map((v3) => v3.loci) };
}
function getPlaneDataFromStructureSelections(s) {
  return { locis: s.map((v3) => v3.loci) };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/shape/loci/label.js
var TextParams2 = {
  ...LociLabelTextParams
};
var LabelVisuals = {
  "text": (ctx, getParams) => ShapeRepresentation(getTextShape2, Text.Utils)
};
var LabelParams = {
  ...TextParams2,
  scaleByRadius: ParamDefinition.Boolean(true),
  visuals: ParamDefinition.MultiSelect(["text"], ParamDefinition.objectToOptions(LabelVisuals)),
  snapshotKey: ParamDefinition.Text("", { isEssential: true, disableInteractiveUpdates: true, description: "Activate the snapshot with the provided key when clicking on the label" }),
  tooltip: ParamDefinition.Text("", { isEssential: true, multiline: true, disableInteractiveUpdates: true, placeholder: "Tooltip", description: "Tooltip text to be displayed when hovering over the label" })
};
var tmpSphere = Sphere3D();
function label(info, condensed = false) {
  return info.label || lociLabel(info.loci, { hidePrefix: true, htmlStyling: false, condensed });
}
function getLabelName(data) {
  return data.infos.length === 1 ? label(data.infos[0]) : `${data.infos.length} Labels`;
}
function buildText2(data, props, text) {
  const builder = TextBuilder.create(props, 128, 64, text);
  const customLabel = props.customText.trim();
  for (let i = 0, il = data.infos.length; i < il; ++i) {
    const info = data.infos[i];
    const sphere = Loci.getBoundingSphere(info.loci, tmpSphere);
    if (!sphere)
      continue;
    const { center, radius } = sphere;
    const text2 = customLabel || label(info, true);
    builder.add(text2, center[0], center[1], center[2], props.scaleByRadius ? radius / 0.9 : 0, props.scaleByRadius ? Math.max(1, radius) : 1, i);
  }
  return builder.getText();
}
function getTextShape2(ctx, data, props, shape) {
  var _a, _b;
  const text = buildText2(data, props, shape && shape.geometry);
  const name = getLabelName(data);
  const tooltip = (_b = (_a = props.tooltip) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : "";
  const customLabel = props.customText.trim();
  let getLabel;
  if (tooltip) {
    getLabel = (_) => tooltip;
  } else if (customLabel) {
    getLabel = (_) => customLabel;
  } else {
    getLabel = (groupId) => label(data.infos[groupId]);
  }
  return Shape.create(name, data, text, () => props.textColor, () => props.textSize, getLabel);
}
function LabelRepresentation(ctx, getParams) {
  return Representation.createMulti("Label", ctx, getParams, Representation.StateBuilder, LabelVisuals);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/mesh/builder/axes.js
var tmpVec = Vec3();
var tmpMatrix = Mat4.identity();
var tmpVertices = new Float32Array(6 * 3);
var tmpEdges = new Uint8Array([0, 1, 2, 3, 4, 5]);
function addAxes(state, axes, radiusScale, detail, radialSegments) {
  const { origin, dirA, dirB, dirC } = axes;
  Vec3.add(tmpVec, origin, dirA);
  Vec3.toArray(Vec3.add(tmpVec, origin, dirA), tmpVertices, 0);
  Vec3.toArray(Vec3.sub(tmpVec, origin, dirA), tmpVertices, 3);
  Vec3.toArray(Vec3.add(tmpVec, origin, dirB), tmpVertices, 6);
  Vec3.toArray(Vec3.sub(tmpVec, origin, dirB), tmpVertices, 9);
  Vec3.toArray(Vec3.add(tmpVec, origin, dirC), tmpVertices, 12);
  Vec3.toArray(Vec3.sub(tmpVec, origin, dirC), tmpVertices, 15);
  const cage = createCage(tmpVertices, tmpEdges);
  const volume = Axes3D.volume(axes);
  const radius = Math.cbrt(volume) / 300 * radiusScale;
  MeshBuilder.addCage(state, tmpMatrix, cage, radius, detail, radialSegments);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/mesh/builder/box.js
var tmpStart = Vec3.zero();
var tmpEnd = Vec3.zero();
var tmpBoxVecCorner = Vec3();
var tmpBoxVecA = Vec3();
var tmpBoxVecB = Vec3();
var tmpBoxVecC = Vec3();
var tmpMatrix2 = Mat4.identity();
var tmpVertices2 = new Float32Array(8 * 3);
var tmpEdges2 = new Uint8Array([
  0,
  1,
  0,
  3,
  0,
  6,
  1,
  2,
  1,
  7,
  2,
  3,
  2,
  4,
  3,
  5,
  4,
  5,
  4,
  7,
  5,
  6,
  6,
  7
]);
function addOrientedBox(state, axes, radiusScale, detail, radialSegments) {
  const { origin, dirA, dirB, dirC } = axes;
  const negDirA = Vec3.negate(tmpBoxVecA, dirA);
  const negDirB = Vec3.negate(tmpBoxVecB, dirB);
  const negDirC = Vec3.negate(tmpBoxVecC, dirC);
  let offset = 0;
  const addCornerHelper = function(v1, v22, v3) {
    Vec3.copy(tmpBoxVecCorner, origin);
    Vec3.add(tmpBoxVecCorner, tmpBoxVecCorner, v1);
    Vec3.add(tmpBoxVecCorner, tmpBoxVecCorner, v22);
    Vec3.add(tmpBoxVecCorner, tmpBoxVecCorner, v3);
    Vec3.toArray(tmpBoxVecCorner, tmpVertices2, offset);
    offset += 3;
  };
  addCornerHelper(dirA, dirB, dirC);
  addCornerHelper(dirA, dirB, negDirC);
  addCornerHelper(dirA, negDirB, negDirC);
  addCornerHelper(dirA, negDirB, dirC);
  addCornerHelper(negDirA, negDirB, negDirC);
  addCornerHelper(negDirA, negDirB, dirC);
  addCornerHelper(negDirA, dirB, dirC);
  addCornerHelper(negDirA, dirB, negDirC);
  const cage = createCage(tmpVertices2, tmpEdges2);
  const volume = Axes3D.volume(axes);
  const radius = Math.cbrt(volume) / 300 * radiusScale;
  MeshBuilder.addCage(state, tmpMatrix2, cage, radius, detail, radialSegments);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/mesh/builder/ellipsoid.js
var tmpEllipsoidMat = Mat4.identity();
var tmpVec2 = Vec3();
function setEllipsoidMat(m, center, dirMajor, dirMinor, radiusScale) {
  Vec3.add(tmpVec2, center, dirMajor);
  Mat4.targetTo(m, center, tmpVec2, dirMinor);
  Mat4.setTranslation(m, center);
  return Mat4.scale(m, m, radiusScale);
}
function addEllipsoid(state, center, dirMajor, dirMinor, radiusScale, detail) {
  MeshBuilder.addPrimitive(state, setEllipsoidMat(tmpEllipsoidMat, center, dirMajor, dirMinor, radiusScale), getSphere(detail));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/shape/loci/orientation.js
var SharedParams2 = {
  color: ParamDefinition.Color(ColorNames.orange),
  scaleFactor: ParamDefinition.Numeric(1, { min: 0.1, max: 10, step: 0.1 }),
  radiusScale: ParamDefinition.Numeric(2, { min: 0.1, max: 10, step: 0.1 })
};
var AxesParams = {
  ...Mesh.Params,
  ...SharedParams2
};
var BoxParams = {
  ...Mesh.Params,
  ...SharedParams2
};
var EllipsoidParams = {
  ...Mesh.Params,
  ...SharedParams2
};
var OrientationVisuals = {
  "axes": (ctx, getParams) => ShapeRepresentation(getAxesShape, Mesh.Utils),
  "box": (ctx, getParams) => ShapeRepresentation(getBoxShape, Mesh.Utils),
  "ellipsoid": (ctx, getParams) => ShapeRepresentation(getEllipsoidShape, Mesh.Utils)
};
var OrientationParams = {
  ...AxesParams,
  ...BoxParams,
  ...EllipsoidParams,
  visuals: ParamDefinition.MultiSelect(["box"], ParamDefinition.objectToOptions(OrientationVisuals))
};
function getAxesName(locis) {
  const label2 = structureElementLociLabelMany(locis, { countsOnly: true });
  return `Principal Axes of ${label2}`;
}
function buildAxesMesh(data, props, mesh) {
  const state = MeshBuilder.createState(256, 128, mesh);
  const principalAxes = element_exports.Loci.getPrincipalAxesMany(data.locis);
  Axes3D.scale(principalAxes.momentsAxes, principalAxes.momentsAxes, props.scaleFactor);
  state.currentGroup = 0;
  addAxes(state, principalAxes.momentsAxes, props.radiusScale, 2, 20);
  return MeshBuilder.getMesh(state);
}
function getAxesShape(ctx, data, props, shape) {
  const mesh = buildAxesMesh(data, props, shape && shape.geometry);
  const name = getAxesName(data.locis);
  return Shape.create(name, data, mesh, () => props.color, () => 1, () => name);
}
function getBoxName(locis) {
  const label2 = structureElementLociLabelMany(locis, { countsOnly: true });
  return `Oriented Box of ${label2}`;
}
function buildBoxMesh(data, props, mesh) {
  const state = MeshBuilder.createState(256, 128, mesh);
  const principalAxes = element_exports.Loci.getPrincipalAxesMany(data.locis);
  Axes3D.scale(principalAxes.boxAxes, principalAxes.boxAxes, props.scaleFactor);
  state.currentGroup = 0;
  addOrientedBox(state, principalAxes.boxAxes, props.radiusScale, 2, 20);
  return MeshBuilder.getMesh(state);
}
function getBoxShape(ctx, data, props, shape) {
  const mesh = buildBoxMesh(data, props, shape && shape.geometry);
  const name = getBoxName(data.locis);
  return Shape.create(name, data, mesh, () => props.color, () => 1, () => name);
}
function getEllipsoidName(locis) {
  const label2 = structureElementLociLabelMany(locis, { countsOnly: true });
  return `Oriented Ellipsoid of ${label2}`;
}
function buildEllipsoidMesh(data, props, mesh) {
  const state = MeshBuilder.createState(256, 128, mesh);
  const principalAxes = element_exports.Loci.getPrincipalAxesMany(data.locis);
  const axes = principalAxes.boxAxes;
  const { origin, dirA, dirB } = axes;
  const size = Axes3D.size(Vec3(), axes);
  Vec3.scale(size, size, 0.5 * props.scaleFactor);
  const radiusScale = Vec3.create(size[2], size[1], size[0]);
  state.currentGroup = 0;
  addEllipsoid(state, origin, dirA, dirB, radiusScale, 2);
  return MeshBuilder.getMesh(state);
}
function getEllipsoidShape(ctx, data, props, shape) {
  const mesh = buildEllipsoidMesh(data, props, shape && shape.geometry);
  const name = getEllipsoidName(data.locis);
  return Shape.create(name, data, mesh, () => props.color, () => 1, () => name);
}
function OrientationRepresentation(ctx, getParams) {
  const repr = Representation.createMulti("Orientation", ctx, getParams, Representation.StateBuilder, OrientationVisuals);
  repr.setState({ markerActions: MarkerActions.Highlighting });
  return repr;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/primitive/circle.js
var DefaultCircleProps = {
  radius: 1,
  segments: 36,
  thetaStart: 0,
  thetaLength: Math.PI * 2
};
function Circle(props) {
  const { radius, segments, thetaStart, thetaLength } = { ...DefaultCircleProps, ...props };
  const isFull = thetaLength === Math.PI * 2;
  const count3 = isFull ? segments + 1 : segments + 2;
  const vertices2 = new Float32Array(count3 * 3);
  const normals = new Float32Array(count3 * 3);
  const indices2 = new Uint32Array(segments * 3);
  vertices2[0] = 0;
  vertices2[1] = 0;
  vertices2[2] = 0;
  normals[0] = 0;
  normals[1] = 1;
  normals[2] = 0;
  for (let s = 0, i = 3; s < segments; ++s, i += 3) {
    const segment = thetaStart + s / segments * thetaLength;
    vertices2[i] = radius * Math.sin(segment);
    vertices2[i + 1] = 0;
    vertices2[i + 2] = radius * Math.cos(segment);
    normals[i] = 0;
    normals[i + 1] = 1;
    normals[i + 2] = 0;
  }
  for (let s = 1, i = 0; s < segments; ++s, i += 3) {
    indices2[i] = s;
    indices2[i + 1] = s + 1;
    indices2[i + 2] = 0;
  }
  if (isFull) {
    const j = (segments - 1) * 3;
    indices2[j] = segments;
    indices2[j + 1] = 1;
    indices2[j + 2] = 0;
  } else {
    const segment = thetaStart + thetaLength;
    const i = (segments + 1) * 3;
    vertices2[i] = radius * Math.sin(segment);
    vertices2[i + 1] = 0;
    vertices2[i + 2] = radius * Math.cos(segment);
    normals[i] = 0;
    normals[i + 1] = 1;
    normals[i + 2] = 0;
    const j = (segments - 1) * 3;
    indices2[j] = segments;
    indices2[j + 1] = segments + 1;
    indices2[j + 2] = 0;
  }
  return { vertices: vertices2, normals, indices: indices2 };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/shape/loci/angle.js
var SharedParams3 = {
  color: ParamDefinition.Color(ColorNames.lightgreen),
  arcScale: ParamDefinition.Numeric(0.7, { min: 0.01, max: 1, step: 0.01 })
};
var LinesParams = {
  ...Lines.Params,
  ...SharedParams3,
  lineSizeAttenuation: ParamDefinition.Boolean(true),
  linesSize: ParamDefinition.Numeric(0.04, { min: 0.01, max: 5, step: 0.01 }),
  dashLength: ParamDefinition.Numeric(0.04, { min: 0.01, max: 0.2, step: 0.01 })
};
var VectorsParams = {
  ...LinesParams
};
var ArcParams = {
  ...LinesParams
};
var SectorParams = {
  ...Mesh.Params,
  ...SharedParams3,
  ignoreLight: ParamDefinition.Boolean(true),
  sectorOpacity: ParamDefinition.Numeric(0.75, { min: 0, max: 1, step: 0.01 })
};
var AngleVisuals = {
  "vectors": (ctx, getParams) => ShapeRepresentation(getVectorsShape, Lines.Utils, { modifyState: (s) => ({ ...s, pickable: false }) }),
  "arc": (ctx, getParams) => ShapeRepresentation(getArcShape, Lines.Utils, { modifyState: (s) => ({ ...s, pickable: false }) }),
  "sector": (ctx, getParams) => ShapeRepresentation(getSectorShape, Mesh.Utils, { modifyProps: (p) => ({ ...p, alpha: p.sectorOpacity }), modifyState: (s) => ({ ...s, markerActions: MarkerActions.Highlighting }) }),
  "text": (ctx, getParams) => ShapeRepresentation(getTextShape3, Text.Utils, { modifyState: (s) => ({ ...s, markerActions: MarkerAction.None }) })
};
var AngleParams = {
  ...VectorsParams,
  ...ArcParams,
  ...SectorParams,
  ...LociLabelTextParams,
  visuals: ParamDefinition.MultiSelect(["vectors", "sector", "text"], ParamDefinition.objectToOptions(AngleVisuals))
};
function getAngleState() {
  return {
    sphereA: Sphere3D(),
    sphereB: Sphere3D(),
    sphereC: Sphere3D(),
    arcDirA: Vec3(),
    arcDirC: Vec3(),
    arcNormal: Vec3(),
    radius: 0,
    angle: 0
  };
}
var tmpVec3 = Vec3();
var tmpMat2 = Mat4();
function setAngleState(triple, state, arcScale) {
  const { sphereA, sphereB, sphereC } = state;
  const { arcDirA, arcDirC, arcNormal } = state;
  const [lociA, lociB, lociC] = triple.loci;
  Loci.getBoundingSphere(lociA, sphereA);
  Loci.getBoundingSphere(lociB, sphereB);
  Loci.getBoundingSphere(lociC, sphereC);
  Vec3.sub(arcDirA, sphereA.center, sphereB.center);
  Vec3.sub(arcDirC, sphereC.center, sphereB.center);
  Vec3.cross(arcNormal, arcDirA, arcDirC);
  const len = Math.min(Vec3.magnitude(arcDirA), Vec3.magnitude(arcDirC));
  const radius = len * arcScale;
  state.radius = radius;
  state.angle = Vec3.angle(arcDirA, arcDirC);
  return state;
}
function getCircle(state, segmentLength) {
  const { radius, angle } = state;
  const segments = segmentLength ? arcLength(angle, radius) / segmentLength : 32;
  Mat4.targetTo(tmpMat2, state.sphereB.center, state.sphereA.center, state.arcNormal);
  Mat4.setTranslation(tmpMat2, state.sphereB.center);
  Mat4.mul(tmpMat2, tmpMat2, Mat4.rotY180);
  const circle = Circle({ radius, thetaLength: angle, segments });
  return transformPrimitive(circle, tmpMat2);
}
var tmpState2 = getAngleState();
function getAngleName(data) {
  return data.triples.length === 1 ? `Angle ${angleLabel(data.triples[0], { measureOnly: true })}` : `${data.triples.length} Angles`;
}
function buildVectorsLines(data, props, lines) {
  const builder = LinesBuilder.create(128, 64, lines);
  for (let i = 0, il = data.triples.length; i < il; ++i) {
    setAngleState(data.triples[i], tmpState2, props.arcScale);
    builder.addFixedLengthDashes(tmpState2.sphereB.center, tmpState2.sphereA.center, props.dashLength, i);
    builder.addFixedLengthDashes(tmpState2.sphereB.center, tmpState2.sphereC.center, props.dashLength, i);
  }
  return builder.getLines();
}
function getVectorsShape(ctx, data, props, shape) {
  const lines = buildVectorsLines(data, props, shape && shape.geometry);
  const name = getAngleName(data);
  return Shape.create(name, data, lines, () => props.color, () => props.linesSize, () => "");
}
function buildArcLines(data, props, lines) {
  const builder = LinesBuilder.create(128, 64, lines);
  for (let i = 0, il = data.triples.length; i < il; ++i) {
    setAngleState(data.triples[i], tmpState2, props.arcScale);
    const circle = getCircle(tmpState2, props.dashLength);
    const { indices: indices2, vertices: vertices2 } = circle;
    for (let j = 0, jl = indices2.length; j < jl; j += 3) {
      if (j % 2 === 1)
        continue;
      const start = indices2[j] * 3;
      const end = indices2[j + 1] * 3;
      const startX = vertices2[start];
      const startY = vertices2[start + 1];
      const startZ = vertices2[start + 2];
      const endX = vertices2[end];
      const endY = vertices2[end + 1];
      const endZ = vertices2[end + 2];
      builder.add(startX, startY, startZ, endX, endY, endZ, i);
    }
  }
  return builder.getLines();
}
function getArcShape(ctx, data, props, shape) {
  const lines = buildArcLines(data, props, shape && shape.geometry);
  const name = getAngleName(data);
  return Shape.create(name, data, lines, () => props.color, () => props.linesSize, () => "");
}
function buildSectorMesh(data, props, mesh) {
  const state = MeshBuilder.createState(128, 64, mesh);
  for (let i = 0, il = data.triples.length; i < il; ++i) {
    setAngleState(data.triples[i], tmpState2, props.arcScale);
    const circle = getCircle(tmpState2);
    state.currentGroup = i;
    MeshBuilder.addPrimitive(state, Mat4.id, circle);
    MeshBuilder.addPrimitiveFlipped(state, Mat4.id, circle);
  }
  return MeshBuilder.getMesh(state);
}
function getSectorShape(ctx, data, props, shape) {
  const mesh = buildSectorMesh(data, props, shape && shape.geometry);
  const name = getAngleName(data);
  const getLabel = (groupId) => angleLabel(data.triples[groupId]);
  return Shape.create(name, data, mesh, () => props.color, () => 1, getLabel);
}
function buildText3(data, props, text) {
  const builder = TextBuilder.create(props, 128, 64, text);
  for (let i = 0, il = data.triples.length; i < il; ++i) {
    setAngleState(data.triples[i], tmpState2, props.arcScale);
    Vec3.add(tmpVec3, tmpState2.arcDirA, tmpState2.arcDirC);
    Vec3.setMagnitude(tmpVec3, tmpVec3, tmpState2.radius);
    Vec3.add(tmpVec3, tmpState2.sphereB.center, tmpVec3);
    const angle = radToDeg(tmpState2.angle).toFixed(2);
    const label2 = props.customText || `${angle}`;
    const radius = Math.max(2, tmpState2.sphereA.radius, tmpState2.sphereB.radius, tmpState2.sphereC.radius);
    const scale = radius / 2;
    builder.add(label2, tmpVec3[0], tmpVec3[1], tmpVec3[2], 0.1, scale, i);
  }
  return builder.getText();
}
function getTextShape3(ctx, data, props, shape) {
  const text = buildText3(data, props, shape && shape.geometry);
  const name = getAngleName(data);
  const getLabel = (groupId) => angleLabel(data.triples[groupId]);
  return Shape.create(name, data, text, () => props.textColor, () => props.textSize, getLabel);
}
function AngleRepresentation(ctx, getParams) {
  return Representation.createMulti("Angle", ctx, getParams, Representation.StateBuilder, AngleVisuals);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/shape/loci/dihedral.js
var SharedParams4 = {
  color: ParamDefinition.Color(ColorNames.lightgreen),
  arcScale: ParamDefinition.Numeric(0.7, { min: 0.01, max: 1, step: 0.01 })
};
var LinesParams2 = {
  ...Lines.Params,
  ...SharedParams4,
  lineSizeAttenuation: ParamDefinition.Boolean(true),
  linesSize: ParamDefinition.Numeric(0.04, { min: 0.01, max: 5, step: 0.01 }),
  dashLength: ParamDefinition.Numeric(0.04, { min: 0.01, max: 0.2, step: 0.01 })
};
var VectorsParams2 = {
  ...LinesParams2
};
var ExtendersParams = {
  ...LinesParams2
};
var ArmsParams = {
  ...LinesParams2
};
var ArcParams2 = {
  ...LinesParams2
};
var SectorParams2 = {
  ...Mesh.Params,
  ...SharedParams4,
  ignoreLight: ParamDefinition.Boolean(true),
  sectorOpacity: ParamDefinition.Numeric(0.75, { min: 0, max: 1, step: 0.01 })
};
var DihedralVisuals = {
  "vectors": (ctx, getParams) => ShapeRepresentation(getVectorsShape2, Lines.Utils, { modifyState: (s) => ({ ...s, pickable: false }) }),
  "extenders": (ctx, getParams) => ShapeRepresentation(getExtendersShape, Lines.Utils, { modifyState: (s) => ({ ...s, pickable: false }) }),
  "connector": (ctx, getParams) => ShapeRepresentation(getConnectorShape, Lines.Utils, { modifyState: (s) => ({ ...s, pickable: false }) }),
  "arms": (ctx, getParams) => ShapeRepresentation(getArmsShape, Lines.Utils, { modifyState: (s) => ({ ...s, pickable: false }) }),
  "arc": (ctx, getParams) => ShapeRepresentation(getArcShape2, Lines.Utils, { modifyState: (s) => ({ ...s, pickable: false }) }),
  "sector": (ctx, getParams) => ShapeRepresentation(getSectorShape2, Mesh.Utils, { modifyProps: (p) => ({ ...p, alpha: p.sectorOpacity }), modifyState: (s) => ({ ...s, markerActions: MarkerActions.Highlighting }) }),
  "text": (ctx, getParams) => ShapeRepresentation(getTextShape4, Text.Utils, { modifyState: (s) => ({ ...s, markerActions: MarkerAction.None }) })
};
var DihedralParams = {
  ...VectorsParams2,
  ...ExtendersParams,
  ...ArmsParams,
  ...ArcParams2,
  ...SectorParams2,
  ...LociLabelTextParams,
  visuals: ParamDefinition.MultiSelect(["extenders", "arms", "sector", "text"], ParamDefinition.objectToOptions(DihedralVisuals))
};
function getDihedralState() {
  return {
    sphereA: Sphere3D(),
    sphereB: Sphere3D(),
    sphereC: Sphere3D(),
    sphereD: Sphere3D(),
    dirBA: Vec3(),
    dirCD: Vec3(),
    projA: Vec3(),
    projD: Vec3(),
    arcPointA: Vec3(),
    arcPointD: Vec3(),
    arcDirA: Vec3(),
    arcDirD: Vec3(),
    arcCenter: Vec3(),
    arcNormal: Vec3(),
    radius: 0,
    angle: 0
  };
}
var tmpVec4 = Vec3();
var tmpMat4 = Mat4();
function setDihedralState(quad, state, arcScale) {
  const { sphereA, sphereB, sphereC, sphereD, dirBA, dirCD, projA, projD } = state;
  const { arcPointA, arcPointD, arcDirA, arcDirD, arcCenter, arcNormal } = state;
  const [lociA, lociB, lociC, lociD] = quad.loci;
  Loci.getBoundingSphere(lociA, sphereA);
  Loci.getBoundingSphere(lociB, sphereB);
  Loci.getBoundingSphere(lociC, sphereC);
  Loci.getBoundingSphere(lociD, sphereD);
  Vec3.add(arcCenter, sphereB.center, sphereC.center);
  Vec3.scale(arcCenter, arcCenter, 0.5);
  Vec3.sub(dirBA, sphereA.center, sphereB.center);
  Vec3.sub(dirCD, sphereD.center, sphereC.center);
  Vec3.add(arcPointA, arcCenter, dirBA);
  Vec3.add(arcPointD, arcCenter, dirCD);
  Vec3.sub(arcNormal, sphereC.center, sphereB.center);
  Vec3.orthogonalize(arcDirA, arcNormal, dirBA);
  Vec3.orthogonalize(arcDirD, arcNormal, dirCD);
  Vec3.projectPointOnVector(projA, arcPointA, arcDirA, arcCenter);
  Vec3.projectPointOnVector(projD, arcPointD, arcDirD, arcCenter);
  const len = Math.min(Vec3.distance(projA, arcCenter), Vec3.distance(projD, arcCenter));
  const radius = len * arcScale;
  Vec3.setMagnitude(arcDirA, arcDirA, radius);
  Vec3.setMagnitude(arcDirD, arcDirD, radius);
  Vec3.add(arcPointA, arcCenter, arcDirA);
  Vec3.add(arcPointD, arcCenter, arcDirD);
  state.radius = radius;
  state.angle = Vec3.dihedralAngle(sphereA.center, sphereB.center, sphereC.center, sphereD.center);
  Vec3.matchDirection(tmpVec4, arcNormal, Vec3.sub(tmpVec4, arcPointA, sphereA.center));
  const angleA = Vec3.angle(dirBA, tmpVec4);
  const lenA = radius / Math.cos(angleA - halfPI);
  Vec3.add(projA, sphereB.center, Vec3.setMagnitude(tmpVec4, dirBA, lenA));
  Vec3.matchDirection(tmpVec4, arcNormal, Vec3.sub(tmpVec4, arcPointD, sphereD.center));
  const angleD = Vec3.angle(dirCD, tmpVec4);
  const lenD = radius / Math.cos(angleD - halfPI);
  Vec3.add(projD, sphereC.center, Vec3.setMagnitude(tmpVec4, dirCD, lenD));
  return state;
}
function getCircle2(state, segmentLength) {
  const { radius, angle } = state;
  const segments = segmentLength ? arcLength(angle, radius) / segmentLength : 32;
  Mat4.targetTo(tmpMat4, state.arcCenter, angle < 0 ? state.arcPointD : state.arcPointA, state.arcNormal);
  Mat4.setTranslation(tmpMat4, state.arcCenter);
  Mat4.mul(tmpMat4, tmpMat4, Mat4.rotY180);
  const circle = Circle({ radius, thetaLength: Math.abs(angle), segments });
  return transformPrimitive(circle, tmpMat4);
}
var tmpState3 = getDihedralState();
function getDihedralName(data) {
  return data.quads.length === 1 ? `Dihedral ${dihedralLabel(data.quads[0], { measureOnly: true })}` : `${data.quads.length} Dihedrals`;
}
function buildVectorsLines2(data, props, lines) {
  const builder = LinesBuilder.create(128, 64, lines);
  for (let i = 0, il = data.quads.length; i < il; ++i) {
    setDihedralState(data.quads[i], tmpState3, props.arcScale);
    builder.addFixedLengthDashes(tmpState3.arcCenter, tmpState3.arcPointA, props.dashLength, i);
    builder.addFixedLengthDashes(tmpState3.arcCenter, tmpState3.arcPointD, props.dashLength, i);
  }
  return builder.getLines();
}
function getVectorsShape2(ctx, data, props, shape) {
  const lines = buildVectorsLines2(data, props, shape && shape.geometry);
  const name = getDihedralName(data);
  return Shape.create(name, data, lines, () => props.color, () => props.linesSize, () => "");
}
function buildConnectorLine(data, props, lines) {
  const builder = LinesBuilder.create(128, 64, lines);
  for (let i = 0, il = data.quads.length; i < il; ++i) {
    setDihedralState(data.quads[i], tmpState3, props.arcScale);
    builder.addFixedLengthDashes(tmpState3.sphereB.center, tmpState3.sphereC.center, props.dashLength, i);
  }
  return builder.getLines();
}
function getConnectorShape(ctx, data, props, shape) {
  const lines = buildConnectorLine(data, props, shape && shape.geometry);
  const name = getDihedralName(data);
  return Shape.create(name, data, lines, () => props.color, () => props.linesSize, () => "");
}
function buildArmsLines(data, props, lines) {
  const builder = LinesBuilder.create(128, 64, lines);
  for (let i = 0, il = data.quads.length; i < il; ++i) {
    setDihedralState(data.quads[i], tmpState3, props.arcScale);
    builder.addFixedLengthDashes(tmpState3.sphereB.center, tmpState3.sphereA.center, props.dashLength, i);
    builder.addFixedLengthDashes(tmpState3.sphereC.center, tmpState3.sphereD.center, props.dashLength, i);
  }
  return builder.getLines();
}
function getArmsShape(ctx, data, props, shape) {
  const lines = buildArmsLines(data, props, shape && shape.geometry);
  const name = getDihedralName(data);
  return Shape.create(name, data, lines, () => props.color, () => props.linesSize, () => "");
}
function buildExtendersLines(data, props, lines) {
  const builder = LinesBuilder.create(128, 64, lines);
  for (let i = 0, il = data.quads.length; i < il; ++i) {
    setDihedralState(data.quads[i], tmpState3, props.arcScale);
    builder.addFixedLengthDashes(tmpState3.arcPointA, tmpState3.projA, props.dashLength, i);
    builder.addFixedLengthDashes(tmpState3.arcPointD, tmpState3.projD, props.dashLength, i);
  }
  return builder.getLines();
}
function getExtendersShape(ctx, data, props, shape) {
  const lines = buildExtendersLines(data, props, shape && shape.geometry);
  const name = getDihedralName(data);
  return Shape.create(name, data, lines, () => props.color, () => props.linesSize, () => "");
}
function buildArcLines2(data, props, lines) {
  const builder = LinesBuilder.create(128, 64, lines);
  for (let i = 0, il = data.quads.length; i < il; ++i) {
    setDihedralState(data.quads[i], tmpState3, props.arcScale);
    const circle = getCircle2(tmpState3, props.dashLength);
    const { indices: indices2, vertices: vertices2 } = circle;
    for (let j = 0, jl = indices2.length; j < jl; j += 3) {
      if (j % 2 === 1)
        continue;
      const start = indices2[j] * 3;
      const end = indices2[j + 1] * 3;
      const startX = vertices2[start];
      const startY = vertices2[start + 1];
      const startZ = vertices2[start + 2];
      const endX = vertices2[end];
      const endY = vertices2[end + 1];
      const endZ = vertices2[end + 2];
      builder.add(startX, startY, startZ, endX, endY, endZ, i);
    }
  }
  return builder.getLines();
}
function getArcShape2(ctx, data, props, shape) {
  const lines = buildArcLines2(data, props, shape && shape.geometry);
  const name = getDihedralName(data);
  return Shape.create(name, data, lines, () => props.color, () => props.linesSize, () => "");
}
function buildSectorMesh2(data, props, mesh) {
  const state = MeshBuilder.createState(128, 64, mesh);
  for (let i = 0, il = data.quads.length; i < il; ++i) {
    setDihedralState(data.quads[i], tmpState3, props.arcScale);
    const circle = getCircle2(tmpState3);
    state.currentGroup = i;
    MeshBuilder.addPrimitive(state, Mat4.id, circle);
    MeshBuilder.addPrimitiveFlipped(state, Mat4.id, circle);
  }
  return MeshBuilder.getMesh(state);
}
function getSectorShape2(ctx, data, props, shape) {
  const mesh = buildSectorMesh2(data, props, shape && shape.geometry);
  const name = getDihedralName(data);
  const getLabel = (groupId) => dihedralLabel(data.quads[groupId]);
  return Shape.create(name, data, mesh, () => props.color, () => 1, getLabel);
}
function buildText4(data, props, text) {
  const builder = TextBuilder.create(props, 128, 64, text);
  for (let i = 0, il = data.quads.length; i < il; ++i) {
    setDihedralState(data.quads[i], tmpState3, props.arcScale);
    Vec3.add(tmpVec4, tmpState3.arcDirA, tmpState3.arcDirD);
    Vec3.setMagnitude(tmpVec4, tmpVec4, tmpState3.radius);
    Vec3.add(tmpVec4, tmpState3.arcCenter, tmpVec4);
    let angle = radToDeg(tmpState3.angle).toFixed(2);
    if (angle === "-0.00")
      angle = "0.00";
    const label2 = props.customText || `${angle}`;
    const radius = Math.max(2, tmpState3.sphereA.radius, tmpState3.sphereB.radius, tmpState3.sphereC.radius, tmpState3.sphereD.radius);
    const scale = radius / 2;
    builder.add(label2, tmpVec4[0], tmpVec4[1], tmpVec4[2], 0.1, scale, i);
  }
  return builder.getText();
}
function getTextShape4(ctx, data, props, shape) {
  const text = buildText4(data, props, shape && shape.geometry);
  const name = getDihedralName(data);
  const getLabel = (groupId) => dihedralLabel(data.quads[groupId]);
  return Shape.create(name, data, text, () => props.textColor, () => props.textSize, getLabel);
}
function DihedralRepresentation(ctx, getParams) {
  return Representation.createMulti("Dihedral", ctx, getParams, Representation.StateBuilder, DihedralVisuals);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms/shape.js
var shape_exports = {};
__export(shape_exports, {
  BoxShape3D: () => BoxShape3D,
  getBoxMesh: () => getBoxMesh
});
var BoxShape3D = PluginStateTransform.BuiltIn({
  name: "box-shape-3d",
  display: "Box Shape",
  from: PluginStateObject.Root,
  to: PluginStateObject.Shape.Provider,
  params: {
    bottomLeft: ParamDefinition.Vec3(Vec3()),
    topRight: ParamDefinition.Vec3(Vec3.create(1, 1, 1)),
    radius: ParamDefinition.Numeric(0.15, { min: 0.01, max: 4, step: 0.01 }),
    color: ParamDefinition.Color(ColorNames.red)
  }
})({
  canAutoUpdate() {
    return true;
  },
  apply({ params }) {
    return Task.create("Shape Representation", async (ctx) => {
      return new PluginStateObject.Shape.Provider({
        label: "Box",
        data: params,
        params: Mesh.Params,
        getShape: (_, data) => {
          const mesh = getBoxMesh(Box3D.create(params.bottomLeft, params.topRight), params.radius);
          return Shape.create("Box", data, mesh, () => data.color, () => 1, () => "Box");
        },
        geometryUtils: Mesh.Utils
      }, { label: "Box" });
    });
  }
});
function getBoxMesh(box2, radius, oldMesh) {
  const diag = Vec3.sub(Vec3(), box2.max, box2.min);
  const translateUnit = Mat4.fromTranslation(Mat4(), Vec3.create(0.5, 0.5, 0.5));
  const scale = Mat4.fromScaling(Mat4(), diag);
  const translate = Mat4.fromTranslation(Mat4(), box2.min);
  const transform = Mat4.mul3(Mat4(), translate, scale, translateUnit);
  const state = MeshBuilder.createState(256, 128, oldMesh);
  state.currentGroup = 1;
  MeshBuilder.addCage(state, transform, BoxCage(), radius, 2, 20);
  const mesh = MeshBuilder.getMesh(state);
  const center = Vec3.scaleAndAdd(Vec3(), box2.min, diag, 0.5);
  const sphereRadius = Vec3.distance(box2.min, center);
  mesh.setBoundingSphere(Sphere3D.create(center, sphereRadius));
  return mesh;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/primitive/plane.js
var plane = {
  vertices: new Float32Array([
    -0.5,
    0.5,
    0,
    0.5,
    0.5,
    0,
    -0.5,
    -0.5,
    0,
    0.5,
    -0.5,
    0
  ]),
  normals: new Float32Array([
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1
  ]),
  indices: new Uint32Array([
    0,
    2,
    1,
    1,
    2,
    3
  ])
};
var planeCage = {
  vertices: plane.vertices,
  edges: new Uint32Array([0, 1, 2, 3, 3, 1, 2, 0])
};
function Plane() {
  return plane;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/shape/loci/plane.js
var _PlaneParams = {
  ...Mesh.Params,
  color: ParamDefinition.Color(ColorNames.orange),
  scaleFactor: ParamDefinition.Numeric(1, { min: 0.1, max: 10, step: 0.1 })
};
var PlaneVisuals = {
  "plane": (ctx, getParams) => ShapeRepresentation(getPlaneShape, Mesh.Utils)
};
var PlaneParams = {
  ..._PlaneParams,
  visuals: ParamDefinition.MultiSelect(["plane"], ParamDefinition.objectToOptions(PlaneVisuals))
};
function getPlaneName(locis) {
  const label2 = structureElementLociLabelMany(locis, { countsOnly: true });
  return `Best Fit Plane of ${label2}`;
}
var tmpMat5 = Mat4();
var tmpV5 = Vec3();
function buildPlaneMesh(data, props, mesh) {
  const state = MeshBuilder.createState(256, 128, mesh);
  const principalAxes = element_exports.Loci.getPrincipalAxesMany(data.locis);
  const axes = principalAxes.boxAxes;
  const plane2 = Plane();
  Vec3.add(tmpV5, axes.origin, axes.dirC);
  Mat4.targetTo(tmpMat5, tmpV5, axes.origin, axes.dirB);
  Mat4.scale(tmpMat5, tmpMat5, Axes3D.size(tmpV5, axes));
  Mat4.scaleUniformly(tmpMat5, tmpMat5, props.scaleFactor);
  Mat4.setTranslation(tmpMat5, axes.origin);
  state.currentGroup = 0;
  MeshBuilder.addPrimitive(state, tmpMat5, plane2);
  MeshBuilder.addPrimitiveFlipped(state, tmpMat5, plane2);
  return MeshBuilder.getMesh(state);
}
function getPlaneShape(ctx, data, props, shape) {
  const mesh = buildPlaneMesh(data, props, shape && shape.geometry);
  const name = getPlaneName(data.locis);
  return Shape.create(name, data, mesh, () => props.color, () => 1, () => name);
}
function PlaneRepresentation(ctx, getParams) {
  const repr = Representation.createMulti("Plane", ctx, getParams, Representation.StateBuilder, PlaneVisuals);
  repr.setState({ markerActions: MarkerActions.Highlighting });
  return repr;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms/representation.js
var StructureRepresentation3D = PluginStateTransform.BuiltIn({
  name: "structure-representation-3d",
  display: "3D Representation",
  from: PluginStateObject.Molecule.Structure,
  to: PluginStateObject.Molecule.Structure.Representation3D,
  params: (a5, ctx) => {
    const { registry, themes: themeCtx } = ctx.representation.structure;
    const type = registry.get(registry.default.name);
    if (!a5) {
      const colorThemeInfo2 = {
        help: (value) => {
          const { name, params } = value;
          const p = themeCtx.colorThemeRegistry.get(name);
          const ct = p.factory({}, params);
          return { description: ct.description, legend: ct.legend };
        }
      };
      return {
        type: ParamDefinition.Mapped(registry.default.name, registry.types, (name) => ParamDefinition.Group(registry.get(name).getParams(themeCtx, Structure.Empty))),
        colorTheme: ParamDefinition.Mapped(type.defaultColorTheme.name, themeCtx.colorThemeRegistry.types, (name) => ParamDefinition.Group(themeCtx.colorThemeRegistry.get(name).getParams({ structure: Structure.Empty })), colorThemeInfo2),
        sizeTheme: ParamDefinition.Mapped(type.defaultSizeTheme.name, themeCtx.sizeThemeRegistry.types, (name) => ParamDefinition.Group(themeCtx.sizeThemeRegistry.get(name).getParams({ structure: Structure.Empty })))
      };
    }
    const dataCtx = { structure: a5.data };
    const colorThemeInfo = {
      help: (value) => {
        const { name, params } = value;
        const p = themeCtx.colorThemeRegistry.get(name);
        const ct = p.factory(dataCtx, params);
        return { description: ct.description, legend: ct.legend };
      }
    };
    return {
      type: ParamDefinition.Mapped(registry.default.name, registry.getApplicableTypes(a5.data), (name) => ParamDefinition.Group(registry.get(name).getParams(themeCtx, a5.data))),
      colorTheme: ParamDefinition.Mapped(type.defaultColorTheme.name, themeCtx.colorThemeRegistry.getApplicableTypes(dataCtx), (name) => ParamDefinition.Group(themeCtx.colorThemeRegistry.get(name).getParams(dataCtx)), colorThemeInfo),
      sizeTheme: ParamDefinition.Mapped(type.defaultSizeTheme.name, themeCtx.sizeThemeRegistry.getApplicableTypes(dataCtx), (name) => ParamDefinition.Group(themeCtx.sizeThemeRegistry.get(name).getParams(dataCtx)))
    };
  }
})({
  canAutoUpdate({ a: a5, oldParams, newParams }) {
    return a5.data.elementCount < 1e4 || oldParams.type.name === newParams.type.name && newParams.type.params.quality !== "custom";
  },
  apply({ a: a5, params, cache }, plugin) {
    return Task.create("Structure Representation", async (ctx) => {
      var _a, _b;
      const propertyCtx = { runtime: ctx, assetManager: plugin.managers.asset, errorContext: plugin.errorContext };
      const provider = plugin.representation.structure.registry.get(params.type.name);
      const data = ((_a = provider.getData) === null || _a === void 0 ? void 0 : _a.call(provider, a5.data, params.type.params)) || a5.data;
      if (provider.ensureCustomProperties)
        await provider.ensureCustomProperties.attach(propertyCtx, data);
      const repr = provider.factory({ webgl: (_b = plugin.canvas3d) === null || _b === void 0 ? void 0 : _b.webgl, ...plugin.representation.structure.themes }, provider.getParams);
      await Theme.ensureDependencies(propertyCtx, plugin.representation.structure.themes, { structure: data }, params);
      repr.setTheme(Theme.create(plugin.representation.structure.themes, { structure: data }, params));
      const props = params.type.params || {};
      await repr.createOrUpdate(props, data).runInContext(ctx);
      return new PluginStateObject.Molecule.Structure.Representation3D({ repr, sourceData: a5.data }, { label: provider.label });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams, cache }, plugin) {
    return Task.create("Structure Representation", async (ctx) => {
      var _a, _b;
      if (newParams.type.name !== oldParams.type.name)
        return Transformer.UpdateResult.Recreate;
      const provider = plugin.representation.structure.registry.get(newParams.type.name);
      if ((_a = provider.mustRecreate) === null || _a === void 0 ? void 0 : _a.call(provider, oldParams.type.params, newParams.type.params))
        return Transformer.UpdateResult.Recreate;
      const data = ((_b = provider.getData) === null || _b === void 0 ? void 0 : _b.call(provider, a5.data, newParams.type.params)) || a5.data;
      const propertyCtx = { runtime: ctx, assetManager: plugin.managers.asset, errorContext: plugin.errorContext };
      if (provider.ensureCustomProperties)
        await provider.ensureCustomProperties.attach(propertyCtx, data);
      Theme.releaseDependencies(plugin.representation.structure.themes, { structure: b5.data.sourceData }, oldParams);
      await Theme.ensureDependencies(propertyCtx, plugin.representation.structure.themes, { structure: data }, newParams);
      b5.data.repr.setTheme(Theme.create(plugin.representation.structure.themes, { structure: data }, newParams));
      const props = { ...b5.data.repr.props, ...newParams.type.params };
      await b5.data.repr.createOrUpdate(props, data).runInContext(ctx);
      b5.data.sourceData = a5.data;
      return Transformer.UpdateResult.Updated;
    });
  },
  dispose({ b: b5, params }, plugin) {
    if (!b5 || !params)
      return;
    const structure = b5.data.sourceData;
    const provider = plugin.representation.structure.registry.get(params.type.name);
    if (provider.ensureCustomProperties)
      provider.ensureCustomProperties.detach(structure);
    Theme.releaseDependencies(plugin.representation.structure.themes, { structure }, params);
  },
  interpolate(src, tar, t2) {
    if (src.colorTheme.name !== "uniform" || tar.colorTheme.name !== "uniform") {
      return t2 <= 0.5 ? src : tar;
    }
    const from2 = src.colorTheme.params.value, to = tar.colorTheme.params.value;
    const value = Color.interpolate(from2, to, t2);
    return {
      type: t2 <= 0.5 ? src.type : tar.type,
      colorTheme: { name: "uniform", params: { value } },
      sizeTheme: t2 <= 0.5 ? src.sizeTheme : tar.sizeTheme
    };
  }
});
var UnwindStructureAssemblyRepresentation3D = PluginStateTransform.BuiltIn({
  name: "unwind-structure-assembly-representation-3d",
  display: "Unwind Assembly 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: { t: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.01 }) }
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const unitTransforms = new StructureUnitTransforms(structure);
    unwindStructureAssembly(structure, unitTransforms, params.t);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { unitTransforms },
      initialState: { unitTransforms: new StructureUnitTransforms(structure) },
      info: structure,
      repr: a5.data.repr
    }, { label: `Unwind T = ${params.t.toFixed(2)}` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const structure = b5.data.info;
    if (a5.data.sourceData !== structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    if (oldParams.t === newParams.t)
      return Transformer.UpdateResult.Unchanged;
    const unitTransforms = b5.data.state.unitTransforms;
    unwindStructureAssembly(structure, unitTransforms, newParams.t);
    b5.label = `Unwind T = ${newParams.t.toFixed(2)}`;
    b5.data.repr = a5.data.repr;
    return Transformer.UpdateResult.Updated;
  }
});
var ExplodeStructureRepresentation3D = PluginStateTransform.BuiltIn({
  name: "explode-structure-representation-3d",
  display: "Explode 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: { t: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.01 }) }
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const unitTransforms = new StructureUnitTransforms(structure);
    explodeStructure(structure, unitTransforms, params.t, structure.root.boundary.sphere);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { unitTransforms },
      initialState: { unitTransforms: new StructureUnitTransforms(structure) },
      info: structure,
      repr: a5.data.repr
    }, { label: `Explode T = ${params.t.toFixed(2)}` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const structure = a5.data.sourceData;
    if (b5.data.info !== structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    if (oldParams.t === newParams.t)
      return Transformer.UpdateResult.Unchanged;
    const unitTransforms = b5.data.state.unitTransforms;
    explodeStructure(structure, unitTransforms, newParams.t, structure.root.boundary.sphere);
    b5.label = `Explode T = ${newParams.t.toFixed(2)}`;
    b5.data.repr = a5.data.repr;
    return Transformer.UpdateResult.Updated;
  }
});
var SpinStructureRepresentation3D = PluginStateTransform.BuiltIn({
  name: "spin-structure-representation-3d",
  display: "Spin 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: {
    t: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.01 }),
    ...SpinStructureParams
  }
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const unitTransforms = new StructureUnitTransforms(structure);
    const { axis, origin } = getSpinStructureAxisAndOrigin(structure.root, params);
    spinStructure(structure, unitTransforms, params.t, axis, origin);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { unitTransforms },
      initialState: { unitTransforms: new StructureUnitTransforms(structure) },
      info: structure,
      repr: a5.data.repr
    }, { label: `Spin T = ${params.t.toFixed(2)}` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const structure = a5.data.sourceData;
    if (b5.data.info !== structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    if (oldParams.t === newParams.t && oldParams.axis === newParams.axis && oldParams.origin === newParams.origin)
      return Transformer.UpdateResult.Unchanged;
    const unitTransforms = b5.data.state.unitTransforms;
    const { axis, origin } = getSpinStructureAxisAndOrigin(structure.root, newParams);
    spinStructure(structure, unitTransforms, newParams.t, axis, origin);
    b5.label = `Spin T = ${newParams.t.toFixed(2)}`;
    b5.data.repr = a5.data.repr;
    return Transformer.UpdateResult.Updated;
  }
});
var OverpaintStructureRepresentation3DFromScript = PluginStateTransform.BuiltIn({
  name: "overpaint-structure-representation-3d-from-script",
  display: "Overpaint 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: () => ({
    layers: ParamDefinition.ObjectList({
      script: ParamDefinition.Script(Script("(sel.atom.all)", "mol-script")),
      color: ParamDefinition.Color(ColorNames.blueviolet),
      clear: ParamDefinition.Boolean(false)
    }, (e) => `${e.clear ? "Clear" : Color.toRgbString(e.color)}`, {
      defaultValue: [{
        script: Script("(sel.atom.all)", "mol-script"),
        color: ColorNames.blueviolet,
        clear: false
      }]
    })
  })
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const geometryVersion = a5.data.repr.geometryVersion;
    const overpaint = Overpaint.ofScript(params.layers, structure);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { overpaint },
      initialState: { overpaint: Overpaint.Empty },
      info: { structure, geometryVersion },
      repr: a5.data.repr
    }, { label: `Overpaint (${overpaint.layers.length} Layers)` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const info = b5.data.info;
    const newStructure = a5.data.sourceData;
    if (newStructure !== info.structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    const newGeometryVersion = a5.data.repr.geometryVersion;
    if (newGeometryVersion !== info.geometryVersion && hasColorSmoothingProp(a5.data.repr.props))
      return Transformer.UpdateResult.Recreate;
    const oldOverpaint = b5.data.state.overpaint;
    const newOverpaint = Overpaint.ofScript(newParams.layers, newStructure);
    if (Overpaint.areEqual(oldOverpaint, newOverpaint))
      return Transformer.UpdateResult.Unchanged;
    info.geometryVersion = newGeometryVersion;
    b5.data.state.overpaint = newOverpaint;
    b5.data.repr = a5.data.repr;
    b5.label = `Overpaint (${newOverpaint.layers.length} Layers)`;
    return Transformer.UpdateResult.Updated;
  }
});
var OverpaintStructureRepresentation3DFromBundle = PluginStateTransform.BuiltIn({
  name: "overpaint-structure-representation-3d-from-bundle",
  display: "Overpaint 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: () => ({
    layers: ParamDefinition.ObjectList({
      bundle: ParamDefinition.Value(element_exports.Bundle.Empty),
      color: ParamDefinition.Color(ColorNames.blueviolet),
      clear: ParamDefinition.Boolean(false)
    }, (e) => `${e.clear ? "Clear" : Color.toRgbString(e.color)}`, {
      defaultValue: [{
        bundle: element_exports.Bundle.Empty,
        color: ColorNames.blueviolet,
        clear: false
      }],
      isHidden: true
    })
  })
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const geometryVersion = a5.data.repr.geometryVersion;
    const overpaint = Overpaint.ofBundle(params.layers, structure);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { overpaint },
      initialState: { overpaint: Overpaint.Empty },
      info: { structure, geometryVersion },
      repr: a5.data.repr
    }, { label: `Overpaint (${overpaint.layers.length} Layers)` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const info = b5.data.info;
    const newStructure = a5.data.sourceData;
    if (newStructure !== info.structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    const newGeometryVersion = a5.data.repr.geometryVersion;
    if (newGeometryVersion !== info.geometryVersion && hasColorSmoothingProp(a5.data.repr.props))
      return Transformer.UpdateResult.Recreate;
    const oldOverpaint = b5.data.state.overpaint;
    const newOverpaint = Overpaint.ofBundle(newParams.layers, newStructure);
    if (Overpaint.areEqual(oldOverpaint, newOverpaint))
      return Transformer.UpdateResult.Unchanged;
    info.geometryVersion = newGeometryVersion;
    b5.data.state.overpaint = newOverpaint;
    b5.data.repr = a5.data.repr;
    b5.label = `Overpaint (${newOverpaint.layers.length} Layers)`;
    return Transformer.UpdateResult.Updated;
  }
});
var TransparencyStructureRepresentation3DFromScript = PluginStateTransform.BuiltIn({
  name: "transparency-structure-representation-3d-from-script",
  display: "Transparency 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: () => ({
    layers: ParamDefinition.ObjectList({
      script: ParamDefinition.Script(Script("(sel.atom.all)", "mol-script")),
      value: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }, { label: "Transparency" })
    }, (e) => `Transparency (${e.value})`, {
      defaultValue: [{
        script: Script("(sel.atom.all)", "mol-script"),
        value: 0.5
      }]
    })
  })
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const geometryVersion = a5.data.repr.geometryVersion;
    const transparency = Transparency.ofScript(params.layers, structure);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { transparency },
      initialState: { transparency: Transparency.Empty },
      info: { structure, geometryVersion },
      repr: a5.data.repr
    }, { label: `Transparency (${transparency.layers.length} Layers)` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const info = b5.data.info;
    const newStructure = a5.data.sourceData;
    if (newStructure !== info.structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    const newGeometryVersion = a5.data.repr.geometryVersion;
    if (newGeometryVersion !== info.geometryVersion && hasColorSmoothingProp(a5.data.repr.props))
      return Transformer.UpdateResult.Recreate;
    const oldTransparency = b5.data.state.transparency;
    const newTransparency = Transparency.ofScript(newParams.layers, newStructure);
    if (Transparency.areEqual(oldTransparency, newTransparency))
      return Transformer.UpdateResult.Unchanged;
    info.geometryVersion = newGeometryVersion;
    b5.data.state.transparency = newTransparency;
    b5.data.repr = a5.data.repr;
    b5.label = `Transparency (${newTransparency.layers.length} Layers)`;
    return Transformer.UpdateResult.Updated;
  }
});
var TransparencyStructureRepresentation3DFromBundle = PluginStateTransform.BuiltIn({
  name: "transparency-structure-representation-3d-from-bundle",
  display: "Transparency 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: () => ({
    layers: ParamDefinition.ObjectList({
      bundle: ParamDefinition.Value(element_exports.Bundle.Empty),
      value: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }, { label: "Transparency" })
    }, (e) => `Transparency (${e.value})`, {
      defaultValue: [{
        bundle: element_exports.Bundle.Empty,
        value: 0.5
      }],
      isHidden: true
    })
  })
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const geometryVersion = a5.data.repr.geometryVersion;
    const transparency = Transparency.ofBundle(params.layers, structure);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { transparency },
      initialState: { transparency: Transparency.Empty },
      info: { structure, geometryVersion },
      repr: a5.data.repr
    }, { label: `Transparency (${transparency.layers.length} Layers)` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const info = b5.data.info;
    const newStructure = a5.data.sourceData;
    if (newStructure !== info.structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    const newGeometryVersion = a5.data.repr.geometryVersion;
    if (newGeometryVersion !== info.geometryVersion && hasColorSmoothingProp(a5.data.repr.props))
      return Transformer.UpdateResult.Recreate;
    const oldTransparency = b5.data.state.transparency;
    const newTransparency = Transparency.ofBundle(newParams.layers, newStructure);
    if (Transparency.areEqual(oldTransparency, newTransparency))
      return Transformer.UpdateResult.Unchanged;
    info.geometryVersion = newGeometryVersion;
    b5.data.state.transparency = newTransparency;
    b5.data.repr = a5.data.repr;
    b5.label = `Transparency (${newTransparency.layers.length} Layers)`;
    return Transformer.UpdateResult.Updated;
  }
});
var EmissiveStructureRepresentation3DFromScript = PluginStateTransform.BuiltIn({
  name: "emissive-structure-representation-3d-from-script",
  display: "Emissive 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: () => ({
    layers: ParamDefinition.ObjectList({
      script: ParamDefinition.Script(Script("(sel.atom.all)", "mol-script")),
      value: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }, { label: "Emissive" })
    }, (e) => `Emissive (${e.value})`, {
      defaultValue: [{
        script: Script("(sel.atom.all)", "mol-script"),
        value: 0.5
      }]
    })
  })
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const geometryVersion = a5.data.repr.geometryVersion;
    const emissive = Emissive.ofScript(params.layers, structure);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { emissive },
      initialState: { emissive: Emissive.Empty },
      info: { structure, geometryVersion },
      repr: a5.data.repr
    }, { label: `Emissive (${emissive.layers.length} Layers)` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const info = b5.data.info;
    const newStructure = a5.data.sourceData;
    if (newStructure !== info.structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    const newGeometryVersion = a5.data.repr.geometryVersion;
    if (newGeometryVersion !== info.geometryVersion && hasColorSmoothingProp(a5.data.repr.props))
      return Transformer.UpdateResult.Recreate;
    const oldEmissive = b5.data.state.emissive;
    const newEmissive = Emissive.ofScript(newParams.layers, newStructure);
    if (Emissive.areEqual(oldEmissive, newEmissive))
      return Transformer.UpdateResult.Unchanged;
    info.geometryVersion = newGeometryVersion;
    b5.data.state.emissive = newEmissive;
    b5.data.repr = a5.data.repr;
    b5.label = `Emissive (${newEmissive.layers.length} Layers)`;
    return Transformer.UpdateResult.Updated;
  }
});
var EmissiveStructureRepresentation3DFromBundle = PluginStateTransform.BuiltIn({
  name: "emissive-structure-representation-3d-from-bundle",
  display: "Emissive 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: () => ({
    layers: ParamDefinition.ObjectList({
      bundle: ParamDefinition.Value(element_exports.Bundle.Empty),
      value: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }, { label: "Emissive" })
    }, (e) => `Emissive (${e.value})`, {
      defaultValue: [{
        bundle: element_exports.Bundle.Empty,
        value: 0.5
      }],
      isHidden: true
    })
  })
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const geometryVersion = a5.data.repr.geometryVersion;
    const emissive = Emissive.ofBundle(params.layers, structure);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { emissive },
      initialState: { emissive: Emissive.Empty },
      info: { structure, geometryVersion },
      repr: a5.data.repr
    }, { label: `Emissive (${emissive.layers.length} Layers)` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const info = b5.data.info;
    const newStructure = a5.data.sourceData;
    if (newStructure !== info.structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    const newGeometryVersion = a5.data.repr.geometryVersion;
    if (newGeometryVersion !== info.geometryVersion && hasColorSmoothingProp(a5.data.repr.props))
      return Transformer.UpdateResult.Recreate;
    const oldEmissive = b5.data.state.emissive;
    const newEmissive = Emissive.ofBundle(newParams.layers, newStructure);
    if (Emissive.areEqual(oldEmissive, newEmissive))
      return Transformer.UpdateResult.Unchanged;
    info.geometryVersion = newGeometryVersion;
    b5.data.state.emissive = newEmissive;
    b5.data.repr = a5.data.repr;
    b5.label = `Emissive (${newEmissive.layers.length} Layers)`;
    return Transformer.UpdateResult.Updated;
  }
});
var SubstanceStructureRepresentation3DFromScript = PluginStateTransform.BuiltIn({
  name: "substance-structure-representation-3d-from-script",
  display: "Substance 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: () => ({
    layers: ParamDefinition.ObjectList({
      script: ParamDefinition.Script(Script("(sel.atom.all)", "mol-script")),
      material: Material.getParam(),
      clear: ParamDefinition.Boolean(false)
    }, (e) => `${e.clear ? "Clear" : Material.toString(e.material)}`, {
      defaultValue: [{
        script: Script("(sel.atom.all)", "mol-script"),
        material: Material({ roughness: 1 }),
        clear: false
      }]
    })
  })
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const geometryVersion = a5.data.repr.geometryVersion;
    const substance = Substance.ofScript(params.layers, structure);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { substance },
      initialState: { substance: Substance.Empty },
      info: { structure, geometryVersion },
      repr: a5.data.repr
    }, { label: `Substance (${substance.layers.length} Layers)` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const info = b5.data.info;
    const newStructure = a5.data.sourceData;
    if (newStructure !== info.structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    const newGeometryVersion = a5.data.repr.geometryVersion;
    if (newGeometryVersion !== info.geometryVersion && hasColorSmoothingProp(a5.data.repr.props))
      return Transformer.UpdateResult.Recreate;
    const oldSubstance = b5.data.state.substance;
    const newSubstance = Substance.ofScript(newParams.layers, newStructure);
    if (Substance.areEqual(oldSubstance, newSubstance))
      return Transformer.UpdateResult.Unchanged;
    info.geometryVersion = newGeometryVersion;
    b5.data.state.substance = newSubstance;
    b5.data.repr = a5.data.repr;
    b5.label = `Substance (${newSubstance.layers.length} Layers)`;
    return Transformer.UpdateResult.Updated;
  }
});
var SubstanceStructureRepresentation3DFromBundle = PluginStateTransform.BuiltIn({
  name: "substance-structure-representation-3d-from-bundle",
  display: "Substance 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: () => ({
    layers: ParamDefinition.ObjectList({
      bundle: ParamDefinition.Value(element_exports.Bundle.Empty),
      material: Material.getParam(),
      clear: ParamDefinition.Boolean(false)
    }, (e) => `${e.clear ? "Clear" : Material.toString(e.material)}`, {
      defaultValue: [{
        bundle: element_exports.Bundle.Empty,
        material: Material({ roughness: 1 }),
        clear: false
      }],
      isHidden: true
    })
  })
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const geometryVersion = a5.data.repr.geometryVersion;
    const substance = Substance.ofBundle(params.layers, structure);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { substance },
      initialState: { substance: Substance.Empty },
      info: { structure, geometryVersion },
      repr: a5.data.repr
    }, { label: `Substance (${substance.layers.length} Layers)` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const info = b5.data.info;
    const newStructure = a5.data.sourceData;
    if (newStructure !== info.structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    const newGeometryVersion = a5.data.repr.geometryVersion;
    if (newGeometryVersion !== info.geometryVersion && hasColorSmoothingProp(a5.data.repr.props))
      return Transformer.UpdateResult.Recreate;
    const oldSubstance = b5.data.state.substance;
    const newSubstance = Substance.ofBundle(newParams.layers, newStructure);
    if (Substance.areEqual(oldSubstance, newSubstance))
      return Transformer.UpdateResult.Unchanged;
    info.geometryVersion = newGeometryVersion;
    b5.data.state.substance = newSubstance;
    b5.data.repr = a5.data.repr;
    b5.label = `Substance (${newSubstance.layers.length} Layers)`;
    return Transformer.UpdateResult.Updated;
  }
});
var ClippingStructureRepresentation3DFromScript = PluginStateTransform.BuiltIn({
  name: "clipping-structure-representation-3d-from-script",
  display: "Clipping 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: () => ({
    layers: ParamDefinition.ObjectList({
      script: ParamDefinition.Script(Script("(sel.atom.all)", "mol-script")),
      groups: ParamDefinition.Converted((g) => Clipping.Groups.toNames(g), (n) => Clipping.Groups.fromNames(n), ParamDefinition.MultiSelect(ObjectKeys(Clipping.Groups.Names), ParamDefinition.objectToOptions(Clipping.Groups.Names)))
    }, (e) => `${Clipping.Groups.toNames(e.groups).length} group(s)`, {
      defaultValue: [{
        script: Script("(sel.atom.all)", "mol-script"),
        groups: Clipping.Groups.Flag.None
      }]
    })
  })
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const clipping = Clipping.ofScript(params.layers, structure);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { clipping },
      initialState: { clipping: Clipping.Empty },
      info: structure,
      repr: a5.data.repr
    }, { label: `Clipping (${clipping.layers.length} Layers)` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const structure = b5.data.info;
    if (a5.data.sourceData !== structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    const oldClipping = b5.data.state.clipping;
    const newClipping = Clipping.ofScript(newParams.layers, structure);
    if (Clipping.areEqual(oldClipping, newClipping))
      return Transformer.UpdateResult.Unchanged;
    b5.data.state.clipping = newClipping;
    b5.data.repr = a5.data.repr;
    b5.label = `Clipping (${newClipping.layers.length} Layers)`;
    return Transformer.UpdateResult.Updated;
  }
});
var ClippingStructureRepresentation3DFromBundle = PluginStateTransform.BuiltIn({
  name: "clipping-structure-representation-3d-from-bundle",
  display: "Clipping 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: () => ({
    layers: ParamDefinition.ObjectList({
      bundle: ParamDefinition.Value(element_exports.Bundle.Empty),
      groups: ParamDefinition.Converted((g) => Clipping.Groups.toNames(g), (n) => Clipping.Groups.fromNames(n), ParamDefinition.MultiSelect(ObjectKeys(Clipping.Groups.Names), ParamDefinition.objectToOptions(Clipping.Groups.Names)))
    }, (e) => `${Clipping.Groups.toNames(e.groups).length} group(s)`, {
      defaultValue: [{
        bundle: element_exports.Bundle.Empty,
        groups: Clipping.Groups.Flag.None
      }],
      isHidden: true
    })
  })
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    const structure = a5.data.sourceData;
    const clipping = Clipping.ofBundle(params.layers, structure);
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: { clipping },
      initialState: { clipping: Clipping.Empty },
      info: structure,
      repr: a5.data.repr
    }, { label: `Clipping (${clipping.layers.length} Layers)` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    const structure = b5.data.info;
    if (a5.data.sourceData !== structure)
      return Transformer.UpdateResult.Recreate;
    if (a5.data.repr !== b5.data.repr)
      return Transformer.UpdateResult.Recreate;
    const oldClipping = b5.data.state.clipping;
    const newClipping = Clipping.ofBundle(newParams.layers, structure);
    if (Clipping.areEqual(oldClipping, newClipping))
      return Transformer.UpdateResult.Unchanged;
    b5.data.state.clipping = newClipping;
    b5.data.repr = a5.data.repr;
    b5.label = `Clipping (${newClipping.layers.length} Layers)`;
    return Transformer.UpdateResult.Updated;
  }
});
var ThemeStrengthRepresentation3D = PluginStateTransform.BuiltIn({
  name: "theme-strength-representation-3d",
  display: "Theme Strength 3D Representation",
  from: PluginStateObject.Molecule.Structure.Representation3D,
  to: PluginStateObject.Molecule.Structure.Representation3DState,
  params: () => ({
    overpaintStrength: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.01 }),
    transparencyStrength: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.01 }),
    emissiveStrength: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.01 }),
    substanceStrength: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.01 })
  })
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }) {
    return new PluginStateObject.Molecule.Structure.Representation3DState({
      state: {
        themeStrength: {
          overpaint: params.overpaintStrength,
          transparency: params.transparencyStrength,
          emissive: params.emissiveStrength,
          substance: params.substanceStrength
        }
      },
      initialState: {
        themeStrength: { overpaint: 1, transparency: 1, emissive: 1, substance: 1 }
      },
      info: {},
      repr: a5.data.repr
    }, { label: "Theme Strength", description: `${params.overpaintStrength.toFixed(2)}, ${params.transparencyStrength.toFixed(2)}, ${params.emissiveStrength.toFixed(2)}, ${params.substanceStrength.toFixed(2)}` });
  },
  update({ a: a5, b: b5, newParams, oldParams }) {
    var _a, _b, _c, _d;
    if (newParams.overpaintStrength === ((_a = b5.data.state.themeStrength) === null || _a === void 0 ? void 0 : _a.overpaint) && newParams.transparencyStrength === ((_b = b5.data.state.themeStrength) === null || _b === void 0 ? void 0 : _b.transparency) && newParams.emissiveStrength === ((_c = b5.data.state.themeStrength) === null || _c === void 0 ? void 0 : _c.emissive) && newParams.substanceStrength === ((_d = b5.data.state.themeStrength) === null || _d === void 0 ? void 0 : _d.substance))
      return Transformer.UpdateResult.Unchanged;
    b5.data.state.themeStrength = {
      overpaint: newParams.overpaintStrength,
      transparency: newParams.transparencyStrength,
      emissive: newParams.emissiveStrength,
      substance: newParams.substanceStrength
    };
    b5.data.repr = a5.data.repr;
    b5.label = "Theme Strength";
    b5.description = `${newParams.overpaintStrength.toFixed(2)}, ${newParams.transparencyStrength.toFixed(2)}, ${newParams.emissiveStrength.toFixed(2)}, ${newParams.substanceStrength.toFixed(2)}`;
    return Transformer.UpdateResult.Updated;
  },
  interpolate(src, tar, t2) {
    return {
      overpaintStrength: lerp(src.overpaintStrength, tar.overpaintStrength, t2),
      transparencyStrength: lerp(src.transparencyStrength, tar.transparencyStrength, t2),
      emissiveStrength: lerp(src.emissiveStrength, tar.emissiveStrength, t2),
      substanceStrength: lerp(src.substanceStrength, tar.substanceStrength, t2)
    };
  }
});
var VolumeRepresentation3DHelpers;
(function(VolumeRepresentation3DHelpers2) {
  function getDefaultParams(ctx, name, volume, volumeParams, colorName, colorParams, sizeName, sizeParams) {
    const type = ctx.representation.volume.registry.get(name);
    const colorType = ctx.representation.volume.themes.colorThemeRegistry.get(colorName || type.defaultColorTheme.name);
    const sizeType = ctx.representation.volume.themes.sizeThemeRegistry.get(sizeName || type.defaultSizeTheme.name);
    const volumeDefaultParams = ParamDefinition.getDefaultValues(type.getParams(ctx.representation.volume.themes, volume));
    return {
      type: { name, params: volumeParams ? { ...volumeDefaultParams, ...volumeParams } : volumeDefaultParams },
      colorTheme: { name: colorType.name, params: colorParams ? { ...colorType.defaultValues, ...colorParams } : colorType.defaultValues },
      sizeTheme: { name: sizeType.name, params: sizeParams ? { ...sizeType.defaultValues, ...sizeParams } : sizeType.defaultValues }
    };
  }
  VolumeRepresentation3DHelpers2.getDefaultParams = getDefaultParams;
  function getDefaultParamsStatic(ctx, name, volumeParams, colorName, colorParams, sizeName, sizeParams) {
    const type = ctx.representation.volume.registry.get(name);
    const colorType = ctx.representation.volume.themes.colorThemeRegistry.get(colorName || type.defaultColorTheme.name);
    const sizeType = ctx.representation.volume.themes.sizeThemeRegistry.get(sizeName || type.defaultSizeTheme.name);
    return {
      type: { name, params: volumeParams ? { ...type.defaultValues, ...volumeParams } : type.defaultValues },
      colorTheme: { name: type.defaultColorTheme.name, params: colorParams ? { ...colorType.defaultValues, ...colorParams } : colorType.defaultValues },
      sizeTheme: { name: type.defaultSizeTheme.name, params: sizeParams ? { ...sizeType.defaultValues, ...sizeParams } : sizeType.defaultValues }
    };
  }
  VolumeRepresentation3DHelpers2.getDefaultParamsStatic = getDefaultParamsStatic;
  function getDescription(props) {
    var _a, _b, _c, _d;
    if (props.isoValue) {
      return Volume.IsoValue.toString(props.isoValue);
    } else if ((_b = (_a = props.renderMode) === null || _a === void 0 ? void 0 : _a.params) === null || _b === void 0 ? void 0 : _b.isoValue) {
      return Volume.IsoValue.toString((_d = (_c = props.renderMode) === null || _c === void 0 ? void 0 : _c.params) === null || _d === void 0 ? void 0 : _d.isoValue);
    }
  }
  VolumeRepresentation3DHelpers2.getDescription = getDescription;
})(VolumeRepresentation3DHelpers || (VolumeRepresentation3DHelpers = {}));
var VolumeRepresentation3D = PluginStateTransform.BuiltIn({
  name: "volume-representation-3d",
  display: "3D Representation",
  from: PluginStateObject.Volume.Data,
  to: PluginStateObject.Volume.Representation3D,
  params: (a5, ctx) => {
    const { registry, themes: themeCtx } = ctx.representation.volume;
    const type = registry.get(registry.default.name);
    if (!a5) {
      return {
        type: ParamDefinition.Mapped(registry.default.name, registry.types, (name) => ParamDefinition.Group(registry.get(name).getParams(themeCtx, Volume.One))),
        colorTheme: ParamDefinition.Mapped(type.defaultColorTheme.name, themeCtx.colorThemeRegistry.types, (name) => ParamDefinition.Group(themeCtx.colorThemeRegistry.get(name).getParams({ volume: Volume.One }))),
        sizeTheme: ParamDefinition.Mapped(type.defaultSizeTheme.name, themeCtx.sizeThemeRegistry.types, (name) => ParamDefinition.Group(themeCtx.sizeThemeRegistry.get(name).getParams({ volume: Volume.One })))
      };
    }
    const dataCtx = { volume: a5.data };
    return {
      type: ParamDefinition.Mapped(registry.default.name, registry.types, (name) => ParamDefinition.Group(registry.get(name).getParams(themeCtx, a5.data))),
      colorTheme: ParamDefinition.Mapped(type.defaultColorTheme.name, themeCtx.colorThemeRegistry.getApplicableTypes(dataCtx), (name) => ParamDefinition.Group(themeCtx.colorThemeRegistry.get(name).getParams(dataCtx))),
      sizeTheme: ParamDefinition.Mapped(type.defaultSizeTheme.name, themeCtx.sizeThemeRegistry.getApplicableTypes(dataCtx), (name) => ParamDefinition.Group(themeCtx.sizeThemeRegistry.get(name).getParams(dataCtx)))
    };
  }
})({
  canAutoUpdate({ oldParams, newParams }) {
    return oldParams.type.name === newParams.type.name;
  },
  apply({ a: a5, params }, plugin) {
    return Task.create("Volume Representation", async (ctx) => {
      var _a;
      const propertyCtx = { runtime: ctx, assetManager: plugin.managers.asset, errorContext: plugin.errorContext };
      const provider = plugin.representation.volume.registry.get(params.type.name);
      if (provider.ensureCustomProperties)
        await provider.ensureCustomProperties.attach(propertyCtx, a5.data);
      const repr = provider.factory({ webgl: (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.webgl, ...plugin.representation.volume.themes }, provider.getParams);
      repr.setTheme(Theme.create(plugin.representation.volume.themes, { volume: a5.data, locationKinds: provider.locationKinds }, params));
      const props = params.type.params || {};
      await repr.createOrUpdate(props, a5.data).runInContext(ctx);
      return new PluginStateObject.Volume.Representation3D({ repr, sourceData: a5.data }, { label: provider.label, description: VolumeRepresentation3DHelpers.getDescription(props) });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams }, plugin) {
    return Task.create("Volume Representation", async (ctx) => {
      var _a;
      const oldProvider = plugin.representation.volume.registry.get(oldParams.type.name);
      if (newParams.type.name !== oldParams.type.name) {
        (_a = oldProvider.ensureCustomProperties) === null || _a === void 0 ? void 0 : _a.detach(a5.data);
        return Transformer.UpdateResult.Recreate;
      }
      const props = { ...b5.data.repr.props, ...newParams.type.params };
      b5.data.repr.setTheme(Theme.create(plugin.representation.volume.themes, { volume: a5.data, locationKinds: oldProvider.locationKinds }, newParams));
      await b5.data.repr.createOrUpdate(props, a5.data).runInContext(ctx);
      b5.data.sourceData = a5.data;
      b5.description = VolumeRepresentation3DHelpers.getDescription(props);
      return Transformer.UpdateResult.Updated;
    });
  }
});
var ShapeRepresentation3D = PluginStateTransform.BuiltIn({
  name: "shape-representation-3d",
  display: "3D Representation",
  from: PluginStateObject.Shape.Provider,
  to: PluginStateObject.Shape.Representation3D,
  params: (a5, ctx) => {
    return a5 ? a5.data.params : BaseGeometry.Params;
  }
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }, plugin) {
    return Task.create("Shape Representation", async (ctx) => {
      const props = { ...ParamDefinition.getDefaultValues(a5.data.params), ...params };
      const repr = ShapeRepresentation(a5.data.getShape, a5.data.geometryUtils);
      await repr.createOrUpdate(props, a5.data.data).runInContext(ctx);
      return new PluginStateObject.Shape.Representation3D({ repr, sourceData: a5.data }, { label: a5.data.label });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams }, plugin) {
    return Task.create("Shape Representation", async (ctx) => {
      const props = { ...b5.data.repr.props, ...newParams };
      await b5.data.repr.createOrUpdate(props, a5.data.data).runInContext(ctx);
      b5.data.sourceData = a5.data;
      return Transformer.UpdateResult.Updated;
    });
  }
});
var ModelUnitcell3D = PluginStateTransform.BuiltIn({
  name: "model-unitcell-3d",
  display: "Model Unit Cell",
  from: PluginStateObject.Molecule.Model,
  to: PluginStateObject.Shape.Representation3D,
  params: () => ({
    ...UnitcellParams
  })
})({
  isApplicable: (a5) => !!ModelSymmetry.Provider.get(a5.data),
  canAutoUpdate({ oldParams, newParams }) {
    return true;
  },
  apply({ a: a5, params }, plugin) {
    return Task.create("Model Unit Cell", async (ctx) => {
      var _a;
      const symmetry = ModelSymmetry.Provider.get(a5.data);
      if (!symmetry)
        return StateObject.Null;
      const data = getUnitcellData(a5.data, symmetry, params);
      const repr = UnitcellRepresentation({ webgl: (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.webgl, ...plugin.representation.structure.themes }, () => UnitcellParams);
      await repr.createOrUpdate(params, data).runInContext(ctx);
      return new PluginStateObject.Shape.Representation3D({ repr, sourceData: data }, { label: `Unit Cell`, description: symmetry.spacegroup.name });
    });
  },
  update({ a: a5, b: b5, newParams }) {
    return Task.create("Model Unit Cell", async (ctx) => {
      const symmetry = ModelSymmetry.Provider.get(a5.data);
      if (!symmetry)
        return Transformer.UpdateResult.Null;
      const props = { ...b5.data.repr.props, ...newParams };
      const data = getUnitcellData(a5.data, symmetry, props);
      await b5.data.repr.createOrUpdate(props, data).runInContext(ctx);
      b5.data.sourceData = data;
      return Transformer.UpdateResult.Updated;
    });
  }
});
var StructureBoundingBox3D = PluginStateTransform.BuiltIn({
  name: "structure-bounding-box-3d",
  display: "Bounding Box",
  from: PluginStateObject.Molecule.Structure,
  to: PluginStateObject.Shape.Representation3D,
  params: {
    radius: ParamDefinition.Numeric(0.05, { min: 0.01, max: 4, step: 0.01 }, { isEssential: true }),
    color: ParamDefinition.Color(ColorNames.red, { isEssential: true }),
    ...Mesh.Params
  }
})({
  canAutoUpdate() {
    return true;
  },
  apply({ a: a5, params }, plugin) {
    return Task.create("Bounding Box", async (ctx) => {
      const repr = ShapeRepresentation((_, data, __, shape) => {
        const mesh = getBoxMesh(data.box, data.radius, shape === null || shape === void 0 ? void 0 : shape.geometry);
        return Shape.create("Bouding Box", data, mesh, () => data.color, () => 1, () => "Bounding Box");
      }, Mesh.Utils);
      await repr.createOrUpdate(params, { box: a5.data.boundary.box, radius: params.radius, color: params.color }).runInContext(ctx);
      return new PluginStateObject.Shape.Representation3D({ repr, sourceData: a5.data }, { label: `Bounding Box` });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams }, plugin) {
    return Task.create("Bounding Box", async (ctx) => {
      await b5.data.repr.createOrUpdate(newParams, { box: a5.data.boundary.box, radius: newParams.radius, color: newParams.color }).runInContext(ctx);
      b5.data.sourceData = a5.data;
      return Transformer.UpdateResult.Updated;
    });
  }
});
var StructureSelectionsDistance3D = PluginStateTransform.BuiltIn({
  name: "structure-selections-distance-3d",
  display: "3D Distance",
  from: PluginStateObject.Molecule.Structure.Selections,
  to: PluginStateObject.Shape.Representation3D,
  params: () => ({
    ...DistanceParams
  })
})({
  canAutoUpdate({ oldParams, newParams }) {
    return true;
  },
  apply({ a: a5, params }, plugin) {
    return Task.create("Structure Distance", async (ctx) => {
      var _a;
      const data = getDistanceDataFromStructureSelections(a5.data);
      const repr = DistanceRepresentation({ webgl: (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.webgl, ...plugin.representation.structure.themes }, () => DistanceParams);
      await repr.createOrUpdate(params, data).runInContext(ctx);
      return new PluginStateObject.Shape.Representation3D({ repr, sourceData: data }, { label: `Distance` });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams }, plugin) {
    return Task.create("Structure Distance", async (ctx) => {
      const props = { ...b5.data.repr.props, ...newParams };
      const data = getDistanceDataFromStructureSelections(a5.data);
      await b5.data.repr.createOrUpdate(props, data).runInContext(ctx);
      b5.data.sourceData = data;
      return Transformer.UpdateResult.Updated;
    });
  }
});
var StructureSelectionsAngle3D = PluginStateTransform.BuiltIn({
  name: "structure-selections-angle-3d",
  display: "3D Angle",
  from: PluginStateObject.Molecule.Structure.Selections,
  to: PluginStateObject.Shape.Representation3D,
  params: () => ({
    ...AngleParams
  })
})({
  canAutoUpdate({ oldParams, newParams }) {
    return true;
  },
  apply({ a: a5, params }, plugin) {
    return Task.create("Structure Angle", async (ctx) => {
      var _a;
      const data = getAngleDataFromStructureSelections(a5.data);
      const repr = AngleRepresentation({ webgl: (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.webgl, ...plugin.representation.structure.themes }, () => AngleParams);
      await repr.createOrUpdate(params, data).runInContext(ctx);
      return new PluginStateObject.Shape.Representation3D({ repr, sourceData: data }, { label: `Angle` });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams }, plugin) {
    return Task.create("Structure Angle", async (ctx) => {
      const props = { ...b5.data.repr.props, ...newParams };
      const data = getAngleDataFromStructureSelections(a5.data);
      await b5.data.repr.createOrUpdate(props, data).runInContext(ctx);
      b5.data.sourceData = data;
      return Transformer.UpdateResult.Updated;
    });
  }
});
var StructureSelectionsDihedral3D = PluginStateTransform.BuiltIn({
  name: "structure-selections-dihedral-3d",
  display: "3D Dihedral",
  from: PluginStateObject.Molecule.Structure.Selections,
  to: PluginStateObject.Shape.Representation3D,
  params: () => ({
    ...DihedralParams
  })
})({
  canAutoUpdate({ oldParams, newParams }) {
    return true;
  },
  apply({ a: a5, params }, plugin) {
    return Task.create("Structure Dihedral", async (ctx) => {
      var _a;
      const data = getDihedralDataFromStructureSelections(a5.data);
      const repr = DihedralRepresentation({ webgl: (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.webgl, ...plugin.representation.structure.themes }, () => DihedralParams);
      await repr.createOrUpdate(params, data).runInContext(ctx);
      return new PluginStateObject.Shape.Representation3D({ repr, sourceData: data }, { label: `Dihedral` });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams }, plugin) {
    return Task.create("Structure Dihedral", async (ctx) => {
      const props = { ...b5.data.repr.props, ...newParams };
      const data = getDihedralDataFromStructureSelections(a5.data);
      await b5.data.repr.createOrUpdate(props, data).runInContext(ctx);
      b5.data.sourceData = data;
      return Transformer.UpdateResult.Updated;
    });
  }
});
var StructureSelectionsLabel3D = PluginStateTransform.BuiltIn({
  name: "structure-selections-label-3d",
  display: "3D Label",
  from: PluginStateObject.Molecule.Structure.Selections,
  to: PluginStateObject.Shape.Representation3D,
  params: () => ({
    ...LabelParams
  })
})({
  canAutoUpdate({ oldParams, newParams }) {
    return true;
  },
  apply({ a: a5, params }, plugin) {
    return Task.create("Structure Label", async (ctx) => {
      var _a, _b, _c;
      const data = getLabelDataFromStructureSelections(a5.data);
      const repr = LabelRepresentation({ webgl: (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.webgl, ...plugin.representation.structure.themes }, () => LabelParams);
      await repr.createOrUpdate(params, data).runInContext(ctx);
      const pickable = !!(((_b = params.snapshotKey) === null || _b === void 0 ? void 0 : _b.trim()) || ((_c = params.tooltip) === null || _c === void 0 ? void 0 : _c.trim()));
      repr.setState({ pickable, markerActions: pickable ? MarkerActions.Highlighting : MarkerAction.None });
      return new PluginStateObject.Shape.Representation3D({ repr, sourceData: data }, { label: `Label` });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams }, plugin) {
    return Task.create("Structure Label", async (ctx) => {
      var _a, _b;
      const props = { ...b5.data.repr.props, ...newParams };
      const data = getLabelDataFromStructureSelections(a5.data);
      await b5.data.repr.createOrUpdate(props, data).runInContext(ctx);
      b5.data.sourceData = data;
      const pickable = !!(((_a = newParams.snapshotKey) === null || _a === void 0 ? void 0 : _a.trim()) || ((_b = newParams.tooltip) === null || _b === void 0 ? void 0 : _b.trim()));
      b5.data.repr.setState({ pickable, markerActions: pickable ? MarkerActions.Highlighting : MarkerAction.None });
      return Transformer.UpdateResult.Updated;
    });
  }
});
var StructureSelectionsOrientation3D = PluginStateTransform.BuiltIn({
  name: "structure-selections-orientation-3d",
  display: "3D Orientation",
  from: PluginStateObject.Molecule.Structure.Selections,
  to: PluginStateObject.Shape.Representation3D,
  params: () => ({
    ...OrientationParams
  })
})({
  canAutoUpdate({ oldParams, newParams }) {
    return true;
  },
  apply({ a: a5, params }, plugin) {
    return Task.create("Structure Orientation", async (ctx) => {
      var _a;
      const data = getOrientationDataFromStructureSelections(a5.data);
      const repr = OrientationRepresentation({ webgl: (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.webgl, ...plugin.representation.structure.themes }, () => OrientationParams);
      await repr.createOrUpdate(params, data).runInContext(ctx);
      return new PluginStateObject.Shape.Representation3D({ repr, sourceData: data }, { label: `Orientation` });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams }, plugin) {
    return Task.create("Structure Orientation", async (ctx) => {
      const props = { ...b5.data.repr.props, ...newParams };
      const data = getOrientationDataFromStructureSelections(a5.data);
      await b5.data.repr.createOrUpdate(props, data).runInContext(ctx);
      b5.data.sourceData = data;
      return Transformer.UpdateResult.Updated;
    });
  }
});
var StructureSelectionsPlane3D = PluginStateTransform.BuiltIn({
  name: "structure-selections-plane-3d",
  display: "3D Plane",
  from: PluginStateObject.Molecule.Structure.Selections,
  to: PluginStateObject.Shape.Representation3D,
  params: () => ({
    ...PlaneParams
  })
})({
  canAutoUpdate({ oldParams, newParams }) {
    return true;
  },
  apply({ a: a5, params }, plugin) {
    return Task.create("Structure Plane", async (ctx) => {
      var _a;
      const data = getPlaneDataFromStructureSelections(a5.data);
      const repr = PlaneRepresentation({ webgl: (_a = plugin.canvas3d) === null || _a === void 0 ? void 0 : _a.webgl, ...plugin.representation.structure.themes }, () => PlaneParams);
      await repr.createOrUpdate(params, data).runInContext(ctx);
      return new PluginStateObject.Shape.Representation3D({ repr, sourceData: data }, { label: `Plane` });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams }, plugin) {
    return Task.create("Structure Plane", async (ctx) => {
      const props = { ...b5.data.repr.props, ...newParams };
      const data = getPlaneDataFromStructureSelections(a5.data);
      await b5.data.repr.createOrUpdate(props, data).runInContext(ctx);
      b5.data.sourceData = data;
      return Transformer.UpdateResult.Updated;
    });
  }
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms.js
var StateTransforms = {
  Data: data_exports,
  Misc: misc_exports,
  Model: model_exports,
  Volume: volume_exports,
  Representation: representation_exports,
  Shape: shape_exports
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/helpers/structure-selection-query.js
var StructureSelectionCategory;
(function(StructureSelectionCategory2) {
  StructureSelectionCategory2["Type"] = "Type";
  StructureSelectionCategory2["Structure"] = "Structure Property";
  StructureSelectionCategory2["Atom"] = "Atom Property";
  StructureSelectionCategory2["Bond"] = "Bond Property";
  StructureSelectionCategory2["Residue"] = "Residue Property";
  StructureSelectionCategory2["AminoAcid"] = "Amino Acid";
  StructureSelectionCategory2["NucleicBase"] = "Nucleic Base";
  StructureSelectionCategory2["Manipulate"] = "Manipulate Selection";
  StructureSelectionCategory2["Validation"] = "Validation";
  StructureSelectionCategory2["Misc"] = "Miscellaneous";
  StructureSelectionCategory2["Internal"] = "Internal";
})(StructureSelectionCategory || (StructureSelectionCategory = {}));
function StructureSelectionQuery(label2, expression, props = {}) {
  var _a;
  let _query;
  return {
    label: label2,
    expression,
    description: props.description || "",
    category: (_a = props.category) !== null && _a !== void 0 ? _a : StructureSelectionCategory.Misc,
    isHidden: !!props.isHidden,
    priority: props.priority || 0,
    referencesCurrent: !!props.referencesCurrent,
    get query() {
      if (!_query)
        _query = compile(expression);
      return _query;
    },
    ensureCustomProperties: props.ensureCustomProperties,
    async getSelection(plugin, runtime, structure) {
      const current3 = plugin.managers.structure.selection.getStructure(structure);
      const currentSelection = current3 ? StructureSelection.Sequence(structure, [current3]) : StructureSelection.Empty(structure);
      if (props.ensureCustomProperties) {
        await props.ensureCustomProperties({ runtime, assetManager: plugin.managers.asset }, structure);
      }
      if (!_query)
        _query = compile(expression);
      return _query(new QueryContext(structure, { currentSelection }));
    }
  };
}
var all = StructureSelectionQuery("All", MolScriptBuilder.struct.generator.all(), { category: "", priority: 1e3 });
var current2 = StructureSelectionQuery("Current Selection", MolScriptBuilder.internal.generator.current(), { category: "", referencesCurrent: true });
var polymer = StructureSelectionQuery("Polymer", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.atomGroups({
    "entity-test": MolScriptBuilder.core.logic.and([
      MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "polymer"]),
      MolScriptBuilder.core.str.match([
        MolScriptBuilder.re("(polypeptide|cyclic-pseudo-peptide|peptide-like|nucleotide|peptide nucleic acid)", "i"),
        MolScriptBuilder.ammp("entitySubtype")
      ])
    ])
  })
]), { category: StructureSelectionCategory.Type });
var trace = StructureSelectionQuery("Trace", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.combinator.merge([
    MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.generator.atomGroups({
        "entity-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "polymer"]),
        "chain-test": MolScriptBuilder.core.set.has([
          MolScriptBuilder.set("sphere", "gaussian"),
          MolScriptBuilder.ammp("objectPrimitive")
        ])
      })
    ]),
    MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.generator.atomGroups({
        "entity-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "polymer"]),
        "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
        "atom-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set("CA", "P"), MolScriptBuilder.ammp("label_atom_id")])
      })
    ])
  ])
]), { category: StructureSelectionCategory.Structure });
var _proteinEntityTest = MolScriptBuilder.core.logic.and([
  MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "polymer"]),
  MolScriptBuilder.core.str.match([
    MolScriptBuilder.re("(polypeptide|cyclic-pseudo-peptide|peptide-like)", "i"),
    MolScriptBuilder.ammp("entitySubtype")
  ])
]);
var _nucleiEntityTest = MolScriptBuilder.core.logic.and([
  MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "polymer"]),
  MolScriptBuilder.core.str.match([
    MolScriptBuilder.re("(nucleotide|peptide nucleic acid)", "i"),
    MolScriptBuilder.ammp("entitySubtype")
  ])
]);
var _nonPolymerResidueTest = MolScriptBuilder.core.str.match([
  MolScriptBuilder.re("non-polymer|(amino|carboxy) terminus|peptide-like", "i"),
  MolScriptBuilder.ammp("chemCompType")
]);
var backbone = StructureSelectionQuery("Backbone", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.combinator.merge([
    MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.generator.atomGroups({
        "entity-test": _proteinEntityTest,
        "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
        "residue-test": MolScriptBuilder.core.logic.not([_nonPolymerResidueTest]),
        "atom-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set(...SetUtils.toArray(ProteinBackboneAtoms)), MolScriptBuilder.ammp("label_atom_id")])
      })
    ]),
    MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.generator.atomGroups({
        "entity-test": _nucleiEntityTest,
        "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
        "residue-test": MolScriptBuilder.core.logic.not([_nonPolymerResidueTest]),
        "atom-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set(...SetUtils.toArray(NucleicBackboneAtoms)), MolScriptBuilder.ammp("label_atom_id")])
      })
    ])
  ])
]), { category: StructureSelectionCategory.Structure });
var sidechain = StructureSelectionQuery("Sidechain", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.combinator.merge([
    MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.generator.atomGroups({
        "entity-test": _proteinEntityTest,
        "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
        "residue-test": MolScriptBuilder.core.logic.not([_nonPolymerResidueTest]),
        "atom-test": MolScriptBuilder.core.logic.or([
          MolScriptBuilder.core.logic.not([
            MolScriptBuilder.core.set.has([MolScriptBuilder.set(...SetUtils.toArray(ProteinBackboneAtoms)), MolScriptBuilder.ammp("label_atom_id")])
          ])
        ])
      })
    ]),
    MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.generator.atomGroups({
        "entity-test": _nucleiEntityTest,
        "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
        "residue-test": MolScriptBuilder.core.logic.not([_nonPolymerResidueTest]),
        "atom-test": MolScriptBuilder.core.logic.or([
          MolScriptBuilder.core.logic.not([
            MolScriptBuilder.core.set.has([MolScriptBuilder.set(...SetUtils.toArray(NucleicBackboneAtoms)), MolScriptBuilder.ammp("label_atom_id")])
          ])
        ])
      })
    ])
  ])
]), { category: StructureSelectionCategory.Structure });
var sidechainWithTrace = StructureSelectionQuery("Sidechain with Trace", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.combinator.merge([
    MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.generator.atomGroups({
        "entity-test": _proteinEntityTest,
        "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
        "residue-test": MolScriptBuilder.core.logic.not([_nonPolymerResidueTest]),
        "atom-test": MolScriptBuilder.core.logic.or([
          MolScriptBuilder.core.logic.not([
            MolScriptBuilder.core.set.has([MolScriptBuilder.set(...SetUtils.toArray(ProteinBackboneAtoms)), MolScriptBuilder.ammp("label_atom_id")])
          ]),
          MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("label_atom_id"), "CA"]),
          MolScriptBuilder.core.logic.and([
            MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("auth_comp_id"), "PRO"]),
            MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("label_atom_id"), "N"])
          ])
        ])
      })
    ]),
    MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.generator.atomGroups({
        "entity-test": _nucleiEntityTest,
        "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
        "residue-test": MolScriptBuilder.core.logic.not([_nonPolymerResidueTest]),
        "atom-test": MolScriptBuilder.core.logic.or([
          MolScriptBuilder.core.logic.not([
            MolScriptBuilder.core.set.has([MolScriptBuilder.set(...SetUtils.toArray(NucleicBackboneAtoms)), MolScriptBuilder.ammp("label_atom_id")])
          ]),
          MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("label_atom_id"), "P"])
        ])
      })
    ])
  ])
]), { category: StructureSelectionCategory.Structure });
var protein = StructureSelectionQuery("Protein", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.atomGroups({ "entity-test": _proteinEntityTest })
]), { category: StructureSelectionCategory.Type });
var nucleic = StructureSelectionQuery("Nucleic", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.atomGroups({ "entity-test": _nucleiEntityTest })
]), { category: StructureSelectionCategory.Type });
var helix = StructureSelectionQuery("Helix", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.atomGroups({
    "entity-test": _proteinEntityTest,
    "residue-test": MolScriptBuilder.core.flags.hasAny([
      MolScriptBuilder.ammp("secondaryStructureFlags"),
      MolScriptBuilder.core.type.bitflags([SecondaryStructureType.Flag.Helix])
    ])
  })
]), {
  category: StructureSelectionCategory.Structure,
  ensureCustomProperties: (ctx, structure) => {
    return SecondaryStructureProvider.attach(ctx, structure);
  }
});
var beta = StructureSelectionQuery("Beta Strand/Sheet", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.atomGroups({
    "entity-test": _proteinEntityTest,
    "residue-test": MolScriptBuilder.core.flags.hasAny([
      MolScriptBuilder.ammp("secondaryStructureFlags"),
      MolScriptBuilder.core.type.bitflags([SecondaryStructureType.Flag.Beta])
    ])
  })
]), {
  category: StructureSelectionCategory.Structure,
  ensureCustomProperties: (ctx, structure) => {
    return SecondaryStructureProvider.attach(ctx, structure);
  }
});
var water = StructureSelectionQuery("Water", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.atomGroups({
    "entity-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "water"])
  })
]), { category: StructureSelectionCategory.Type });
var ion = StructureSelectionQuery("Ion", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.atomGroups({
    "entity-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entitySubtype"), "ion"])
  })
]), { category: StructureSelectionCategory.Type });
var lipid = StructureSelectionQuery("Lipid", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.atomGroups({
    "entity-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entitySubtype"), "lipid"])
  })
]), { category: StructureSelectionCategory.Type });
var branched = StructureSelectionQuery("Carbohydrate", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.atomGroups({
    "entity-test": MolScriptBuilder.core.logic.or([
      MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "branched"]),
      MolScriptBuilder.core.logic.and([
        MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "non-polymer"]),
        MolScriptBuilder.core.str.match([
          MolScriptBuilder.re("oligosaccharide", "i"),
          MolScriptBuilder.ammp("entitySubtype")
        ])
      ])
    ])
  })
]), { category: StructureSelectionCategory.Type });
var branchedPlusConnected = StructureSelectionQuery("Carbohydrate with Connected", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.includeConnected({
    0: branched.expression,
    "layer-count": 1,
    "as-whole-residues": true
  })
]), { category: StructureSelectionCategory.Internal, isHidden: true });
var branchedConnectedOnly = StructureSelectionQuery("Connected to Carbohydrate", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.exceptBy({
    0: branchedPlusConnected.expression,
    by: branched.expression
  })
]), { category: StructureSelectionCategory.Internal, isHidden: true });
var ligand = StructureSelectionQuery("Ligand", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.exceptBy({
    0: MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.combinator.merge([
        MolScriptBuilder.struct.modifier.union([
          MolScriptBuilder.struct.generator.atomGroups({
            "entity-test": MolScriptBuilder.core.logic.and([
              MolScriptBuilder.core.logic.or([
                MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "non-polymer"]),
                MolScriptBuilder.core.rel.neq([MolScriptBuilder.ammp("entityPrdId"), ""])
              ]),
              MolScriptBuilder.core.logic.not([MolScriptBuilder.core.str.match([
                MolScriptBuilder.re("(oligosaccharide|lipid|ion)", "i"),
                MolScriptBuilder.ammp("entitySubtype")
              ])])
            ]),
            "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
            "residue-test": MolScriptBuilder.core.logic.not([
              MolScriptBuilder.core.str.match([MolScriptBuilder.re("saccharide", "i"), MolScriptBuilder.ammp("chemCompType")])
            ])
          })
        ]),
        MolScriptBuilder.struct.modifier.union([
          MolScriptBuilder.struct.generator.atomGroups({
            "entity-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "polymer"]),
            "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
            "residue-test": _nonPolymerResidueTest
          })
        ])
      ])
    ]),
    by: MolScriptBuilder.struct.combinator.merge([
      MolScriptBuilder.struct.modifier.union([
        MolScriptBuilder.struct.generator.atomGroups({
          "entity-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "polymer"]),
          "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
          "residue-test": MolScriptBuilder.core.set.has([
            MolScriptBuilder.set(...SetUtils.toArray(PolymerNames)),
            MolScriptBuilder.ammp("label_comp_id")
          ])
        })
      ]),
      MolScriptBuilder.struct.generator.atomGroups({
        "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
        "residue-test": MolScriptBuilder.core.set.has([
          MolScriptBuilder.set(...SetUtils.toArray(CommonProteinCaps)),
          MolScriptBuilder.ammp("label_comp_id")
        ])
      })
    ])
  })
]), { category: StructureSelectionCategory.Type });
var ligandPlusConnected = StructureSelectionQuery("Ligand with Connected", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.exceptBy({
    0: MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.modifier.includeConnected({
        0: ligand.expression,
        "layer-count": 1,
        "as-whole-residues": true,
        "bond-test": MolScriptBuilder.core.flags.hasAny([
          MolScriptBuilder.struct.bondProperty.flags(),
          MolScriptBuilder.core.type.bitflags([
            BondType.Flag.Covalent | BondType.Flag.MetallicCoordination
          ])
        ])
      })
    ]),
    by: branched.expression
  })
]), { category: StructureSelectionCategory.Internal, isHidden: true });
var ligandConnectedOnly = StructureSelectionQuery("Connected to Ligand", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.exceptBy({
    0: ligandPlusConnected.expression,
    by: ligand.expression
  })
]), { category: StructureSelectionCategory.Internal, isHidden: true });
var connectedOnly = StructureSelectionQuery("Connected to Ligand or Carbohydrate", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.combinator.merge([
    branchedConnectedOnly.expression,
    ligandConnectedOnly.expression
  ])
]), { category: StructureSelectionCategory.Internal, isHidden: true });
var disulfideBridges = StructureSelectionQuery("Disulfide Bridges", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.combinator.merge([
    MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.modifier.wholeResidues([
        MolScriptBuilder.struct.filter.isConnectedTo({
          0: MolScriptBuilder.struct.generator.atomGroups({
            "residue-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set("CYS"), MolScriptBuilder.ammp("auth_comp_id")]),
            "atom-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set("SG"), MolScriptBuilder.ammp("label_atom_id")])
          }),
          target: MolScriptBuilder.struct.generator.atomGroups({
            "residue-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set("CYS"), MolScriptBuilder.ammp("auth_comp_id")]),
            "atom-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set("SG"), MolScriptBuilder.ammp("label_atom_id")])
          }),
          "bond-test": true
        })
      ])
    ]),
    MolScriptBuilder.struct.modifier.union([
      MolScriptBuilder.struct.modifier.wholeResidues([
        MolScriptBuilder.struct.modifier.union([
          MolScriptBuilder.struct.generator.bondedAtomicPairs({
            0: MolScriptBuilder.core.flags.hasAny([
              MolScriptBuilder.struct.bondProperty.flags(),
              MolScriptBuilder.core.type.bitflags([BondType.Flag.Disulfide])
            ])
          })
        ])
      ])
    ])
  ])
]), { category: StructureSelectionCategory.Bond });
var nosBridges = StructureSelectionQuery("NOS Bridges", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.wholeResidues([
    MolScriptBuilder.struct.filter.isConnectedTo({
      0: MolScriptBuilder.struct.generator.atomGroups({
        "residue-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set("CSO", "LYS"), MolScriptBuilder.ammp("auth_comp_id")]),
        "atom-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set("OD", "NZ"), MolScriptBuilder.ammp("label_atom_id")])
      }),
      target: MolScriptBuilder.struct.generator.atomGroups({
        "residue-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set("CSO", "LYS"), MolScriptBuilder.ammp("auth_comp_id")]),
        "atom-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set("OD", "NZ"), MolScriptBuilder.ammp("label_atom_id")])
      }),
      "bond-test": true
    })
  ])
]), { category: StructureSelectionCategory.Bond });
var nonStandardPolymer = StructureSelectionQuery("Non-standard Residues in Polymers", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.atomGroups({
    "entity-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("entityType"), "polymer"]),
    "chain-test": MolScriptBuilder.core.rel.eq([MolScriptBuilder.ammp("objectPrimitive"), "atomistic"]),
    "residue-test": MolScriptBuilder.ammp("isNonStandard")
  })
]), { category: StructureSelectionCategory.Residue });
var coarse = StructureSelectionQuery("Coarse Elements", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.atomGroups({
    "chain-test": MolScriptBuilder.core.set.has([
      MolScriptBuilder.set("sphere", "gaussian"),
      MolScriptBuilder.ammp("objectPrimitive")
    ])
  })
]), { category: StructureSelectionCategory.Type });
var ring = StructureSelectionQuery("Rings in Residues", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.rings()
]), { category: StructureSelectionCategory.Residue });
var aromaticRing = StructureSelectionQuery("Aromatic Rings in Residues", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.generator.rings({ "only-aromatic": true })
]), { category: StructureSelectionCategory.Residue });
var surroundings = StructureSelectionQuery("Surrounding Residues (5 ) of Selection", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.exceptBy({
    0: MolScriptBuilder.struct.modifier.includeSurroundings({
      0: MolScriptBuilder.internal.generator.current(),
      radius: 5,
      "as-whole-residues": true
    }),
    by: MolScriptBuilder.internal.generator.current()
  })
]), {
  description: "Select residues within 5  of the current selection.",
  category: StructureSelectionCategory.Manipulate,
  referencesCurrent: true
});
var surroundingLigands = StructureSelectionQuery("Surrounding Ligands (5 ) of Selection", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.surroundingLigands({
    0: MolScriptBuilder.internal.generator.current(),
    radius: 5,
    "include-water": true
  })
]), {
  description: "Select ligand components within 5  of the current selection.",
  category: StructureSelectionCategory.Manipulate,
  referencesCurrent: true
});
var surroundingAtoms = StructureSelectionQuery("Surrounding Atoms (5 ) of Selection", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.exceptBy({
    0: MolScriptBuilder.struct.modifier.includeSurroundings({
      0: MolScriptBuilder.internal.generator.current(),
      radius: 5,
      "as-whole-residues": false
    }),
    by: MolScriptBuilder.internal.generator.current()
  })
]), {
  description: "Select atoms within 5  of the current selection.",
  category: StructureSelectionCategory.Manipulate,
  referencesCurrent: true
});
var complement = StructureSelectionQuery("Inverse / Complement of Selection", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.exceptBy({
    0: MolScriptBuilder.struct.generator.all(),
    by: MolScriptBuilder.internal.generator.current()
  })
]), {
  description: "Select everything not in the current selection.",
  category: StructureSelectionCategory.Manipulate,
  referencesCurrent: true
});
var covalentlyBonded = StructureSelectionQuery("Residues Covalently Bonded to Selection", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.includeConnected({
    0: MolScriptBuilder.internal.generator.current(),
    "layer-count": 1,
    "as-whole-residues": true
  })
]), {
  description: "Select residues covalently bonded to current selection.",
  category: StructureSelectionCategory.Manipulate,
  referencesCurrent: true
});
var covalentlyBondedComponent = StructureSelectionQuery("Covalently Bonded Component", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.includeConnected({
    0: MolScriptBuilder.internal.generator.current(),
    "fixed-point": true
  })
]), {
  description: "Select covalently bonded component based on current selection.",
  category: StructureSelectionCategory.Manipulate,
  referencesCurrent: true
});
var covalentlyOrMetallicBonded = StructureSelectionQuery("Residues with Cov. or Metallic Bond to Selection", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.includeConnected({
    0: MolScriptBuilder.internal.generator.current(),
    "layer-count": 1,
    "as-whole-residues": true,
    "bond-test": MolScriptBuilder.core.flags.hasAny([
      MolScriptBuilder.struct.bondProperty.flags(),
      MolScriptBuilder.core.type.bitflags([
        BondType.Flag.Covalent | BondType.Flag.MetallicCoordination
      ])
    ])
  })
]), {
  description: "Select residues with covalent or metallic bond to current selection.",
  category: StructureSelectionCategory.Manipulate,
  referencesCurrent: true
});
var wholeResidues = StructureSelectionQuery("Whole Residues of Selection", MolScriptBuilder.struct.modifier.union([
  MolScriptBuilder.struct.modifier.wholeResidues({
    0: MolScriptBuilder.internal.generator.current()
  })
]), {
  description: "Expand current selection to whole residues.",
  category: StructureSelectionCategory.Manipulate,
  referencesCurrent: true
});
var StandardAminoAcids = [
  [["HIS"], "Histidine"],
  [["ARG"], "Arginine"],
  [["LYS"], "Lysine"],
  [["ILE"], "Isoleucine"],
  [["PHE"], "Phenylalanine"],
  [["LEU"], "Leucine"],
  [["TRP"], "Tryptophan"],
  [["ALA"], "Alanine"],
  [["MET"], "Methionine"],
  [["PRO"], "Proline"],
  [["CYS"], "Cysteine"],
  [["ASN"], "Asparagine"],
  [["VAL"], "Valine"],
  [["GLY"], "Glycine"],
  [["SER"], "Serine"],
  [["GLN"], "Glutamine"],
  [["TYR"], "Tyrosine"],
  [["ASP"], "Aspartic Acid"],
  [["GLU"], "Glutamic Acid"],
  [["THR"], "Threonine"],
  [["SEC"], "Selenocysteine"],
  [["PYL"], "Pyrrolysine"],
  [["UNK"], "Unknown"]
].sort((a5, b5) => a5[1] < b5[1] ? -1 : a5[1] > b5[1] ? 1 : 0);
var StandardNucleicBases = [
  [["A", "DA"], "Adenosine"],
  [["C", "DC"], "Cytidine"],
  [["T", "DT"], "Thymidine"],
  [["G", "DG"], "Guanosine"],
  [["I", "DI"], "Inosine"],
  [["U", "DU"], "Uridine"],
  [["N", "DN"], "Unknown"]
].sort((a5, b5) => a5[1] < b5[1] ? -1 : a5[1] > b5[1] ? 1 : 0);
function ResidueQuery([names, label2], category, priority = 0) {
  const description = names.length === 1 && !StandardResidues.has(names[0]) ? `[${names[0]}] ${label2}` : `${label2} (${names.join(", ")})`;
  return StructureSelectionQuery(description, MolScriptBuilder.struct.modifier.union([
    MolScriptBuilder.struct.generator.atomGroups({
      "residue-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set(...names), MolScriptBuilder.ammp("auth_comp_id")])
    })
  ]), { category, priority, description });
}
function ElementSymbolQuery([names, label2], category, priority) {
  const description = `${label2} (${names.join(", ")})`;
  return StructureSelectionQuery(description, MolScriptBuilder.struct.modifier.union([
    MolScriptBuilder.struct.generator.atomGroups({
      "atom-test": MolScriptBuilder.core.set.has([MolScriptBuilder.set(...names), MolScriptBuilder.acp("elementSymbol")])
    })
  ]), { category, priority, description });
}
function EntityDescriptionQuery([names, label2], category, priority) {
  const description = `${label2}`;
  return StructureSelectionQuery(`${label2}`, MolScriptBuilder.struct.modifier.union([
    MolScriptBuilder.struct.generator.atomGroups({
      "entity-test": MolScriptBuilder.core.list.equal([MolScriptBuilder.list(...names), MolScriptBuilder.ammp("entityDescription")])
    })
  ]), { category, priority, description });
}
var StandardResidues = SetUtils.unionMany(AminoAcidNamesL, RnaBaseNames, DnaBaseNames, WaterNames);
function getElementQueries(structures) {
  const uniqueElements = /* @__PURE__ */ new Set();
  for (const structure of structures) {
    structure.uniqueElementSymbols.forEach((e) => uniqueElements.add(e));
  }
  const queries = [];
  uniqueElements.forEach((e) => {
    const label2 = ElementNames[e] || e;
    queries.push(ElementSymbolQuery([[e], label2], "Element Symbol", 0));
  });
  return queries;
}
function getNonStandardResidueQueries(structures) {
  const residueLabels = /* @__PURE__ */ new Map();
  const uniqueResidues = /* @__PURE__ */ new Set();
  for (const structure of structures) {
    structure.uniqueResidueNames.forEach((r) => uniqueResidues.add(r));
    for (const m of structure.models) {
      structure.uniqueResidueNames.forEach((r) => {
        const comp = m.properties.chemicalComponentMap.get(r);
        if (comp)
          residueLabels.set(r, comp.name);
      });
    }
  }
  const queries = [];
  SetUtils.difference(uniqueResidues, StandardResidues).forEach((r) => {
    const label2 = residueLabels.get(r) || r;
    queries.push(ResidueQuery([[r], label2], "Ligand/Non-standard Residue", 200));
  });
  return queries;
}
function getPolymerAndBranchedEntityQueries(structures) {
  const uniqueEntities = /* @__PURE__ */ new Map();
  const l = element_exports.Location.create();
  for (const structure of structures) {
    l.structure = structure;
    for (const ug of structure.unitSymmetryGroups) {
      l.unit = ug.units[0];
      l.element = ug.elements[0];
      const entityType = StructureProperties.entity.type(l);
      if (entityType === "polymer" || entityType === "branched") {
        const description = StructureProperties.entity.pdbx_description(l);
        uniqueEntities.set(description.join(", "), description);
      }
    }
  }
  const queries = [];
  uniqueEntities.forEach((v3, k) => {
    queries.push(EntityDescriptionQuery([v3, k], "Polymer/Carbohydrate Entities", 300));
  });
  return queries;
}
var StructureSelectionQueries = {
  all,
  current: current2,
  polymer,
  trace,
  backbone,
  sidechain,
  sidechainWithTrace,
  protein,
  nucleic,
  helix,
  beta,
  water,
  ion,
  lipid,
  branched,
  branchedPlusConnected,
  branchedConnectedOnly,
  ligand,
  ligandPlusConnected,
  ligandConnectedOnly,
  connectedOnly,
  disulfideBridges,
  nosBridges,
  nonStandardPolymer,
  coarse,
  ring,
  aromaticRing,
  surroundings,
  surroundingLigands,
  surroundingAtoms,
  complement,
  covalentlyBonded,
  covalentlyOrMetallicBonded,
  covalentlyBondedComponent,
  wholeResidues
};
var StructureSelectionQueryRegistry = class {
  add(q) {
    this.list.push(q);
    this.options.push([q, q.label, q.category]);
    this.version += 1;
  }
  remove(q) {
    const idx = this.list.indexOf(q);
    if (idx !== -1) {
      this.list.splice(idx, 1);
      this.options.splice(idx, 1);
      this.version += 1;
    }
  }
  constructor() {
    this.list = [];
    this.options = [];
    this.version = 1;
    this.list.push(...Object.values(StructureSelectionQueries), ...StandardAminoAcids.map((v3) => ResidueQuery(v3, StructureSelectionCategory.AminoAcid)), ...StandardNucleicBases.map((v3) => ResidueQuery(v3, StructureSelectionCategory.NucleicBase)));
    this.options.push(...this.list.map((q) => [q, q.label, q.category]));
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/helpers/structure-component.js
var StaticStructureComponentTypes = [
  "all",
  "polymer",
  "protein",
  "nucleic",
  "water",
  "ion",
  "lipid",
  "branched",
  "ligand",
  "non-standard",
  "coarse"
];
var StructureComponentParams = () => ({
  type: ParamDefinition.MappedStatic("static", {
    static: ParamDefinition.Text("polymer"),
    expression: ParamDefinition.Value(MolScriptBuilder.struct.generator.all),
    bundle: ParamDefinition.Value(element_exports.Bundle.Empty),
    script: ParamDefinition.Script({ language: "mol-script", expression: "(sel.atom.all)" })
  }, { isHidden: true }),
  nullIfEmpty: ParamDefinition.Optional(ParamDefinition.Boolean(true, { isHidden: true })),
  label: ParamDefinition.Text("", { isHidden: true })
});
function createStructureComponent(a5, params, cache) {
  cache.source = a5;
  let component = Structure.Empty;
  let label2 = void 0;
  switch (params.type.name) {
    case "static": {
      let query;
      switch (params.type.params) {
        case "all":
          query = StructureSelectionQueries.all.query;
          label2 = "All";
          break;
        case "polymer":
          query = StructureSelectionQueries.polymer.query;
          label2 = "Polymer";
          break;
        case "protein":
          query = StructureSelectionQueries.protein.query;
          label2 = "Protein";
          break;
        case "nucleic":
          query = StructureSelectionQueries.nucleic.query;
          label2 = "Nucleic";
          break;
        case "water":
          query = Queries.internal.water();
          label2 = "Water";
          break;
        case "ion":
          query = StructureSelectionQueries.ion.query;
          label2 = "Ion";
          break;
        case "lipid":
          query = StructureSelectionQueries.lipid.query;
          label2 = "Lipid";
          break;
        case "branched":
          query = StructureSelectionQueries.branchedPlusConnected.query;
          label2 = "Branched";
          break;
        case "ligand":
          query = StructureSelectionQueries.ligandPlusConnected.query;
          label2 = "Ligand";
          break;
        case "non-standard":
          query = StructureSelectionQueries.nonStandardPolymer.query;
          label2 = "Non-standard";
          break;
        case "coarse":
          query = StructureSelectionQueries.coarse.query;
          label2 = "Coarse";
          break;
        default:
          assertUnreachable(params.type);
      }
      const result = query(new QueryContext(a5));
      component = StructureSelection.unionStructure(result);
      break;
    }
    case "script":
    case "expression": {
      const { selection, entry } = StructureQueryHelper.createAndRun(a5, params.type.params);
      cache.entry = entry;
      component = StructureSelection.unionStructure(selection);
      break;
    }
    case "bundle": {
      if (params.type.params.hash !== a5.hashCode)
        break;
      component = element_exports.Bundle.toStructure(params.type.params, a5);
      break;
    }
  }
  if (params.nullIfEmpty && component.elementCount === 0)
    return StateObject.Null;
  const props = { label: `${params.label || label2 || "Component"}`, description: Structure.elementDescription(component) };
  return new PluginStateObject.Molecule.Structure(component, props);
}
function updateStructureComponent(a5, b5, oldParams, newParams, cache) {
  if (oldParams.type.name !== newParams.type.name)
    return Transformer.UpdateResult.Recreate;
  let updated = false;
  switch (newParams.type.name) {
    case "static": {
      if (oldParams.type.params !== newParams.type.params) {
        return Transformer.UpdateResult.Recreate;
      }
      if (!Structure.areEquivalent(a5, cache.source)) {
        return Transformer.UpdateResult.Recreate;
      }
      if (b5.data.model === a5.model)
        return Transformer.UpdateResult.Unchanged;
      if (!Model.areHierarchiesEqual(a5.model, b5.data.model))
        return Transformer.UpdateResult.Recreate;
      b5.data = b5.data.remapModel(a5.model);
      return Transformer.UpdateResult.Updated;
    }
    case "script":
      if (!Script.areEqual(oldParams.type.params, newParams.type.params)) {
        return Transformer.UpdateResult.Recreate;
      }
    case "expression": {
      if (oldParams.type.params !== newParams.type.params) {
        return Transformer.UpdateResult.Recreate;
      }
      if (a5 === cache.source)
        break;
      const entry = cache.entry;
      const selection = StructureQueryHelper.updateStructure(entry, a5);
      cache.source = a5;
      b5.data = StructureSelection.unionStructure(selection);
      StructureQueryHelper.updateStructureObject(b5, selection, newParams.label);
      updated = true;
      break;
    }
    case "bundle": {
      if (a5 === cache.source && element_exports.Bundle.areEqual(oldParams.type.params, newParams.type.params)) {
        break;
      }
      cache.source = a5;
      if (newParams.type.params.hash !== a5.hashCode) {
        updated = b5.data.elementCount !== 0;
        b5.data = b5.data.elementCount === 0 ? b5.data : Structure.Empty;
      } else {
        updated = true;
        b5.data = element_exports.Bundle.toStructure(newParams.type.params, a5);
      }
      break;
    }
  }
  if (updated) {
    if (newParams.nullIfEmpty && b5.data.elementCount === 0)
      return Transformer.UpdateResult.Null;
    b5.description = Structure.elementDescription(b5.data);
  }
  if (oldParams.label !== newParams.label) {
    updated = true;
    b5.label = `${newParams.label || b5.label}`;
  }
  return updated ? Transformer.UpdateResult.Updated : Transformer.UpdateResult.Unchanged;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/mol/parser.js
function formalChargeMapper(key2) {
  switch (key2) {
    case 7:
      return -3;
    case 6:
      return -2;
    case 5:
      return -1;
    case 0:
      return 0;
    case 3:
      return 1;
    case 2:
      return 2;
    case 1:
      return 3;
    case 4:
      return 0;
    default:
      console.error(`Value ${key2} is outside the 0-7 range, defaulting to 0.`);
      return 0;
  }
}
function handleAtoms4(tokenizer, count3) {
  const x = TokenBuilder.create(tokenizer.data, count3 * 2);
  const y = TokenBuilder.create(tokenizer.data, count3 * 2);
  const z = TokenBuilder.create(tokenizer.data, count3 * 2);
  const type_symbol = TokenBuilder.create(tokenizer.data, count3 * 2);
  const formal_charge = TokenBuilder.create(tokenizer.data, count3 * 2);
  for (let i = 0; i < count3; ++i) {
    Tokenizer.markLine(tokenizer);
    const { tokenStart: s, position } = tokenizer;
    Tokenizer.trim(tokenizer, s, s + 10);
    TokenBuilder.addUnchecked(x, tokenizer.tokenStart, tokenizer.tokenEnd);
    Tokenizer.trim(tokenizer, s + 10, s + 20);
    TokenBuilder.addUnchecked(y, tokenizer.tokenStart, tokenizer.tokenEnd);
    Tokenizer.trim(tokenizer, s + 20, s + 30);
    TokenBuilder.addUnchecked(z, tokenizer.tokenStart, tokenizer.tokenEnd);
    Tokenizer.trim(tokenizer, s + 31, s + 34);
    TokenBuilder.addUnchecked(type_symbol, tokenizer.tokenStart, tokenizer.tokenEnd);
    Tokenizer.trim(tokenizer, s + 36, s + 39);
    TokenBuilder.addUnchecked(formal_charge, tokenizer.tokenStart, tokenizer.tokenEnd);
    tokenizer.position = position;
  }
  return {
    count: count3,
    x: TokenColumnProvider(x)(Column.Schema.float),
    y: TokenColumnProvider(y)(Column.Schema.float),
    z: TokenColumnProvider(z)(Column.Schema.float),
    type_symbol: TokenColumnProvider(type_symbol)(Column.Schema.str),
    formal_charge: TokenColumnProvider(formal_charge)(Column.Schema.int)
  };
}
function handleBonds3(tokenizer, count3) {
  const atomIdxA = TokenBuilder.create(tokenizer.data, count3 * 2);
  const atomIdxB = TokenBuilder.create(tokenizer.data, count3 * 2);
  const order = TokenBuilder.create(tokenizer.data, count3 * 2);
  for (let i = 0; i < count3; ++i) {
    Tokenizer.markLine(tokenizer);
    const { tokenStart: s, position } = tokenizer;
    Tokenizer.trim(tokenizer, s, s + 3);
    TokenBuilder.addUnchecked(atomIdxA, tokenizer.tokenStart, tokenizer.tokenEnd);
    Tokenizer.trim(tokenizer, s + 3, s + 6);
    TokenBuilder.addUnchecked(atomIdxB, tokenizer.tokenStart, tokenizer.tokenEnd);
    Tokenizer.trim(tokenizer, s + 6, s + 9);
    TokenBuilder.addUnchecked(order, tokenizer.tokenStart, tokenizer.tokenEnd);
    tokenizer.position = position;
  }
  return {
    count: count3,
    atomIdxA: TokenColumnProvider(atomIdxA)(Column.Schema.int),
    atomIdxB: TokenColumnProvider(atomIdxB)(Column.Schema.int),
    order: TokenColumnProvider(order)(Column.Schema.int)
  };
}
function handleFormalCharges(tokenizer, lineStart, formalCharges) {
  Tokenizer.trim(tokenizer, lineStart + 6, lineStart + 9);
  const numOfCharges = parseInt(Tokenizer.getTokenString(tokenizer));
  for (let i = 0; i < numOfCharges; ++i) {
    const offset = 9 + i * 8;
    Tokenizer.trim(tokenizer, lineStart + offset, lineStart + offset + 4);
    const _atomIdx = Tokenizer.getTokenString(tokenizer);
    formalCharges.atomIdx.push(+_atomIdx);
    Tokenizer.trim(tokenizer, lineStart + offset + 4, lineStart + offset + 8);
    const _charge = Tokenizer.getTokenString(tokenizer);
    formalCharges.charge.push(+_charge);
  }
  Tokenizer.eatLine(tokenizer);
}
function handleAttachmentPoints(line) {
  const tokens = line.trim().split(/\s+/g);
  const points2 = [];
  for (let i = 1; i < tokens.length; i += 2) {
    const atomIdx = +tokens[i];
    const kind = +tokens[i + 1] || 0;
    points2.push({ atomIdx, kind });
  }
  return points2;
}
function handlePropertiesBlock(tokenizer) {
  const _atomIdx = [];
  const _charge = [];
  const _formalCharges = { atomIdx: _atomIdx, charge: _charge };
  let attachmentPoints = void 0;
  while (tokenizer.position < tokenizer.length) {
    const { position: s } = tokenizer;
    Tokenizer.trim(tokenizer, s + 3, s + 6);
    const propertyType = Tokenizer.getTokenString(tokenizer);
    if (propertyType === "END")
      break;
    Tokenizer.eatLine(tokenizer);
    switch (propertyType) {
      case "CHG":
        handleFormalCharges(tokenizer, s, _formalCharges);
        break;
      case "APO":
        attachmentPoints = handleAttachmentPoints(Tokenizer.getTokenString(tokenizer).substring(3));
        break;
      default:
        break;
    }
  }
  const formalCharges = {
    atomIdx: Column.ofIntArray(_formalCharges.atomIdx),
    charge: Column.ofIntArray(_formalCharges.charge)
  };
  return { formalCharges, attachmentPoints };
}
function parseInternal8(data) {
  const tokenizer = Tokenizer(data);
  const title = Tokenizer.readLine(tokenizer).trim();
  const program = Tokenizer.readLine(tokenizer).trim();
  const comment = Tokenizer.readLine(tokenizer).trim();
  const counts = Tokenizer.readLine(tokenizer);
  const atomCount = +counts.substr(0, 3), bondCount2 = +counts.substr(3, 3);
  const atoms = handleAtoms4(tokenizer, atomCount);
  const bonds = handleBonds3(tokenizer, bondCount2);
  const result = {
    title,
    program,
    comment,
    atoms,
    bonds,
    ...handlePropertiesBlock(tokenizer)
  };
  return ReaderResult.success(result);
}
function parseMol(data) {
  return Task.create("Parse Mol", async () => {
    return parseInternal8(data);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/mol.js
async function getMolModels(mol, format, ctx) {
  const { atoms, bonds, formalCharges } = mol;
  const MOL = Column.ofConst("MOL", mol.atoms.count, Column.Schema.str);
  const A = Column.ofConst("A", mol.atoms.count, Column.Schema.str);
  const type_symbol = Column.asArrayColumn(atoms.type_symbol);
  const seq_id = Column.ofConst(1, atoms.count, Column.Schema.int);
  const computedFormalCharges = new Int32Array(mol.atoms.count);
  if (formalCharges.atomIdx.rowCount > 0) {
    for (let i = 0; i < formalCharges.atomIdx.rowCount; i++) {
      computedFormalCharges[formalCharges.atomIdx.value(i) - 1] = formalCharges.charge.value(i);
    }
  } else {
    for (let i = 0; i < mol.atoms.count; i++) {
      computedFormalCharges[i] = formalChargeMapper(atoms.formal_charge.value(i));
    }
  }
  const atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
    auth_asym_id: A,
    auth_atom_id: type_symbol,
    auth_comp_id: MOL,
    auth_seq_id: seq_id,
    Cartn_x: Column.asArrayColumn(atoms.x, Float32Array),
    Cartn_y: Column.asArrayColumn(atoms.y, Float32Array),
    Cartn_z: Column.asArrayColumn(atoms.z, Float32Array),
    id: Column.range(1, atoms.count),
    label_asym_id: A,
    label_atom_id: type_symbol,
    label_comp_id: MOL,
    label_seq_id: seq_id,
    label_entity_id: Column.ofConst("1", atoms.count, Column.Schema.str),
    occupancy: Column.ofConst(1, atoms.count, Column.Schema.float),
    type_symbol,
    pdbx_PDB_model_num: Column.ofConst(1, atoms.count, Column.Schema.int),
    pdbx_formal_charge: Column.ofIntArray(computedFormalCharges)
  }, atoms.count);
  const entityBuilder = new EntityBuilder();
  entityBuilder.setNames([["MOL", "Unknown Entity"]]);
  entityBuilder.getEntityId("MOL", MoleculeType.Unknown, "A");
  const componentBuilder = new ComponentBuilder(seq_id, type_symbol);
  componentBuilder.setNames([["MOL", "Unknown Molecule"]]);
  componentBuilder.add("MOL", 0);
  const basic = createBasic({
    entity: entityBuilder.getEntityTable(),
    chem_comp: componentBuilder.getChemCompTable(),
    atom_site
  });
  const models = await createModels(basic, format !== null && format !== void 0 ? format : MolFormat.create(mol), ctx);
  if (models.frameCount > 0) {
    const indexA = Column.ofIntArray(Column.mapToArray(bonds.atomIdxA, (x) => x - 1, Int32Array));
    const indexB = Column.ofIntArray(Column.mapToArray(bonds.atomIdxB, (x) => x - 1, Int32Array));
    const order = Column.asArrayColumn(bonds.order, Int32Array);
    const pairBonds = IndexPairBonds.fromData({ pairs: { indexA, indexB, order }, count: atoms.count }, { maxDistance: Infinity });
    IndexPairBonds.Provider.set(models.representative, pairBonds);
  }
  return models;
}
var MolFormat;
(function(MolFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "mol";
  }
  MolFormat2.is = is3;
  function create(mol) {
    return { kind: "mol", name: mol.title, data: mol };
  }
  MolFormat2.create = create;
})(MolFormat || (MolFormat = {}));
function trajectoryFromMol(mol) {
  return Task.create("Parse MOL", (ctx) => getMolModels(mol, void 0, ctx));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/cif-core.js
function getSpacegroupNameOrNumber(space_group) {
  const groupNumber = space_group.it_number.value(0);
  const groupName = space_group["name_h-m_full"].value(0).replace("-", " ");
  if (!space_group.it_number.isDefined)
    return groupName;
  if (!space_group["name_h-m_full"].isDefined)
    return groupNumber;
  return groupNumber;
}
function getSymmetry(db) {
  const { cell, space_group } = db;
  const nameOrNumber = getSpacegroupNameOrNumber(space_group);
  const spaceCell = SpacegroupCell.create(nameOrNumber, Vec3.create(cell.length_a.value(0), cell.length_b.value(0), cell.length_c.value(0)), Vec3.scale(Vec3(), Vec3.create(cell.angle_alpha.value(0), cell.angle_beta.value(0), cell.angle_gamma.value(0)), Math.PI / 180));
  return {
    spacegroup: Spacegroup.create(spaceCell),
    assemblies: [],
    isNonStandardCrystalFrame: false,
    ncsOperators: []
  };
}
async function getModels(db, format, ctx) {
  var _a;
  const atomCount = db.atom_site._rowCount;
  const MOL = Column.ofConst("MOL", atomCount, Column.Schema.str);
  const A = Column.ofConst("A", atomCount, Column.Schema.str);
  const seq_id = Column.ofConst(1, atomCount, Column.Schema.int);
  const symmetry = getSymmetry(db);
  const m = symmetry.spacegroup.cell.fromFractional;
  const { fract_x, fract_y, fract_z } = db.atom_site;
  const x = new Float32Array(atomCount);
  const y = new Float32Array(atomCount);
  const z = new Float32Array(atomCount);
  const v3 = Vec3();
  for (let i = 0; i < atomCount; ++i) {
    Vec3.set(v3, fract_x.value(i), fract_y.value(i), fract_z.value(i));
    Vec3.transformMat4(v3, v3, m);
    x[i] = v3[0], y[i] = v3[1], z[i] = v3[2];
  }
  const { type_symbol, label: label2 } = db.atom_site;
  let typeSymbol2;
  let formalCharge2;
  if (type_symbol.isDefined) {
    const element_symbol = new Array(atomCount);
    const formal_charge = new Int8Array(atomCount);
    for (let i = 0; i < atomCount; ++i) {
      const ts = type_symbol.value(i);
      const n = ts.length;
      if (ts[n - 1] === "+") {
        element_symbol[i] = ts.substring(0, n - 2);
        formal_charge[i] = parseInt(ts[n - 2]);
      } else if (ts[n - 2] === "+") {
        element_symbol[i] = ts.substring(0, n - 2);
        formal_charge[i] = parseInt(ts[n - 1]);
      } else if (ts[n - 1] === "-") {
        element_symbol[i] = ts.substring(0, n - 2);
        formal_charge[i] = -parseInt(ts[n - 2]);
      } else if (ts[n - 2] === "-") {
        element_symbol[i] = ts.substring(0, n - 2);
        formal_charge[i] = -parseInt(ts[n - 1]);
      } else {
        element_symbol[i] = ts;
        formal_charge[i] = 0;
      }
    }
    typeSymbol2 = Column.ofStringArray(element_symbol);
    formalCharge2 = Column.ofIntArray(formal_charge);
  } else {
    const element_symbol = new Array(atomCount);
    for (let i = 0; i < atomCount; ++i) {
      element_symbol[i] = guessElementSymbolString(label2.value(i), "");
    }
    typeSymbol2 = Column.ofStringArray(element_symbol);
    formalCharge2 = Column.Undefined(atomCount, Column.Schema.int);
  }
  const atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
    auth_asym_id: A,
    auth_atom_id: label2,
    auth_comp_id: MOL,
    auth_seq_id: seq_id,
    Cartn_x: Column.ofFloatArray(x),
    Cartn_y: Column.ofFloatArray(y),
    Cartn_z: Column.ofFloatArray(z),
    id: Column.range(0, atomCount - 1),
    label_asym_id: A,
    label_atom_id: label2,
    label_comp_id: MOL,
    label_seq_id: seq_id,
    label_entity_id: Column.ofConst("1", atomCount, Column.Schema.str),
    occupancy: db.atom_site.occupancy.isDefined ? db.atom_site.occupancy : Column.ofConst(1, atomCount, Column.Schema.float),
    type_symbol: typeSymbol2,
    pdbx_formal_charge: formalCharge2,
    pdbx_PDB_model_num: Column.ofConst(1, atomCount, Column.Schema.int),
    B_iso_or_equiv: db.atom_site.u_iso_or_equiv
  }, atomCount);
  const name = db.chemical.name_common.value(0) || db.chemical.name_systematic.value(0) || db.chemical_formula.sum.value(0);
  const entityBuilder = new EntityBuilder();
  entityBuilder.setNames([["MOL", name || "Unknown Entity"]]);
  entityBuilder.getEntityId("MOL", MoleculeType.Unknown, "A");
  const componentBuilder = new ComponentBuilder(seq_id, db.atom_site.type_symbol);
  componentBuilder.setNames([["MOL", name || "Unknown Molecule"]]);
  componentBuilder.add("MOL", 0);
  const basic = createBasic({
    entity: entityBuilder.getEntityTable(),
    chem_comp: componentBuilder.getChemCompTable(),
    atom_site
  });
  const models = await createModels(basic, format, ctx);
  if (models.frameCount > 0) {
    const first4 = models.representative;
    ModelSymmetry.Provider.set(first4, symmetry);
    const bondCount2 = db.geom_bond._rowCount;
    if (bondCount2 > 0) {
      const labelIndexMap = {};
      const { label: label3 } = db.atom_site;
      for (let i = 0, il = label3.rowCount; i < il; ++i) {
        labelIndexMap[label3.value(i)] = i;
      }
      const bond_type = (_a = format.data.frame.categories.ccdc_geom_bond_type) === null || _a === void 0 ? void 0 : _a.getField("");
      const indexA = [];
      const indexB = [];
      const order = [];
      const dist = [];
      const flag = [];
      const included = /* @__PURE__ */ new Set();
      let j = 0;
      const { atom_site_label_1, atom_site_label_2, valence, distance } = db.geom_bond;
      for (let i = 0; i < bondCount2; ++i) {
        const iA = labelIndexMap[atom_site_label_1.value(i)];
        const iB = labelIndexMap[atom_site_label_2.value(i)];
        const id = iA < iB ? cantorPairing(iA, iB) : cantorPairing(iB, iA);
        if (included.has(id))
          continue;
        included.add(id);
        indexA[j] = iA;
        indexB[j] = iB;
        dist[j] = distance.value(i) || -1;
        if (bond_type) {
          const t2 = bond_type.str(i);
          if (t2 === "D") {
            order[j] = 2;
            flag[j] = BondType.Flag.Covalent;
          } else if (t2 === "A") {
            order[j] = 1;
            flag[j] = BondType.Flag.Covalent | BondType.Flag.Aromatic;
          } else if (t2 === "S") {
            order[j] = 1;
            flag[j] = BondType.Flag.Covalent;
          } else {
            order[j] = 1;
            flag[j] = BondType.Flag.Covalent;
          }
        } else {
          flag[j] = BondType.Flag.Covalent;
          order[j] = valence.isDefined ? valence.value(i) : 1;
        }
        j += 1;
      }
      IndexPairBonds.Provider.set(first4, IndexPairBonds.fromData({ pairs: {
        indexA: Column.ofIntArray(indexA),
        indexB: Column.ofIntArray(indexB),
        order: Column.ofIntArray(order),
        distance: Column.ofFloatArray(dist),
        flag: Column.ofIntArray(flag)
      }, count: atomCount }));
    }
  }
  return models;
}
function atomSiteAnisotropFromCifCore(model) {
  if (!CifCoreFormat.is(model.sourceData))
    return;
  const { atom_site, atom_site_aniso } = model.sourceData.data.db;
  const data = Table.ofPartialColumns(AtomSiteAnisotrop.Schema, {
    U: atom_site_aniso.u
  }, atom_site_aniso._rowCount);
  const elementToAnsiotrop = AtomSiteAnisotrop.getElementToAnsiotropFromLabel(atom_site.label, atom_site_aniso.label);
  return { data, elementToAnsiotrop };
}
function atomSiteAnisotropApplicableCifCore(model) {
  if (!CifCoreFormat.is(model.sourceData))
    return false;
  return model.sourceData.data.db.atom_site_aniso.u.isDefined;
}
AtomSiteAnisotrop.Provider.formatRegistry.add("cifCore", atomSiteAnisotropFromCifCore, atomSiteAnisotropApplicableCifCore);
var CifCoreFormat;
(function(CifCoreFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "cifCore";
  }
  CifCoreFormat2.is = is3;
  function fromFrame(frame, db) {
    if (!db)
      db = CIF.schema.cifCore(frame);
    const name = db.database_code.depnum_ccdc_archive.value(0) || db.database_code.depnum_ccdc_fiz.value(0) || db.database_code.icsd.value(0) || db.database_code.mdf.value(0) || db.database_code.nbs.value(0) || db.database_code.csd.value(0) || db.database_code.cod.value(0) || db._name;
    return { kind: "cifCore", name, data: { db, frame } };
  }
  CifCoreFormat2.fromFrame = fromFrame;
})(CifCoreFormat || (CifCoreFormat = {}));
function trajectoryFromCifCore(frame) {
  const format = CifCoreFormat.fromFrame(frame);
  return Task.create("Parse CIF Core", (ctx) => getModels(format.data.db, format, ctx));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/cube.js
async function getModels2(cube, ctx) {
  const { atoms } = cube;
  const MOL = Column.ofConst("MOL", cube.atoms.count, Column.Schema.str);
  const A = Column.ofConst("A", cube.atoms.count, Column.Schema.str);
  const type_symbol = Column.ofArray({ array: Column.mapToArray(atoms.number, (n) => getElementFromAtomicNumber(n)), schema: Column.Schema.Aliased(Column.Schema.str) });
  const seq_id = Column.ofConst(1, atoms.count, Column.Schema.int);
  const atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
    auth_asym_id: A,
    auth_atom_id: type_symbol,
    auth_comp_id: MOL,
    auth_seq_id: seq_id,
    Cartn_x: Column.asArrayColumn(atoms.x, Float32Array),
    Cartn_y: Column.asArrayColumn(atoms.y, Float32Array),
    Cartn_z: Column.asArrayColumn(atoms.z, Float32Array),
    id: Column.range(0, atoms.count - 1),
    label_asym_id: A,
    label_atom_id: type_symbol,
    label_comp_id: MOL,
    label_seq_id: seq_id,
    label_entity_id: Column.ofConst("1", atoms.count, Column.Schema.str),
    occupancy: Column.ofConst(1, atoms.count, Column.Schema.float),
    type_symbol,
    pdbx_PDB_model_num: Column.ofConst(1, atoms.count, Column.Schema.int)
  }, atoms.count);
  const entityBuilder = new EntityBuilder();
  entityBuilder.setNames([["MOL", "Unknown Entity"]]);
  entityBuilder.getEntityId("MOL", MoleculeType.Unknown, "A");
  const componentBuilder = new ComponentBuilder(seq_id, type_symbol);
  componentBuilder.setNames([["MOL", "Unknown Molecule"]]);
  componentBuilder.add("MOL", 0);
  const basic = createBasic({
    entity: entityBuilder.getEntityTable(),
    chem_comp: componentBuilder.getChemCompTable(),
    atom_site
  });
  return await createModels(basic, CubeFormat2.create(cube), ctx);
}
var CubeFormat2;
(function(CubeFormat3) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "cube";
  }
  CubeFormat3.is = is3;
  function create(cube) {
    return { kind: "cube", name: cube.header.comment1, data: cube };
  }
  CubeFormat3.create = create;
})(CubeFormat2 || (CubeFormat2 = {}));
function trajectoryFromCube(cube) {
  return Task.create("Parse Cube", (ctx) => getModels2(cube, ctx));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/mol2/parser.js
var { skipWhitespace: skipWhitespace3, eatValue: eatValue3, markLine: markLine3, getTokenString, skipStrictWhitespace } = Tokenizer;
function createEmptyMolecule() {
  return {
    mol_name: "",
    num_atoms: 0,
    num_bonds: 0,
    num_subst: 0,
    num_feat: 0,
    num_sets: 0,
    mol_type: "",
    charge_type: "",
    status_bits: "",
    mol_comment: ""
  };
}
function State7(tokenizer, runtimeCtx) {
  return {
    tokenizer,
    molecule: createEmptyMolecule(),
    runtimeCtx
  };
}
var reWhitespace3 = /\s+/g;
function handleMolecule(state) {
  const { tokenizer, molecule } = state;
  while (getTokenString(tokenizer) !== "@<TRIPOS>MOLECULE" && tokenizer.position < tokenizer.data.length) {
    markLine3(tokenizer);
  }
  markLine3(tokenizer);
  molecule.mol_name = getTokenString(tokenizer);
  markLine3(tokenizer);
  const values2 = getTokenString(tokenizer).trim().split(reWhitespace3);
  molecule.num_atoms = parseInt(values2[0]);
  molecule.num_bonds = parseInt(values2[1]);
  molecule.num_subst = parseInt(values2[2]);
  molecule.num_feat = parseInt(values2[3]);
  molecule.num_sets = parseInt(values2[4]);
  markLine3(tokenizer);
  const mol_type = getTokenString(tokenizer);
  if (mol_type.startsWith("@<TRIPOS>"))
    return;
  molecule.mol_type = mol_type;
  markLine3(tokenizer);
  const charge_type = getTokenString(tokenizer);
  if (charge_type.startsWith("@<TRIPOS>"))
    return;
  molecule.charge_type = charge_type;
  markLine3(tokenizer);
  const status_bits = getTokenString(tokenizer);
  if (status_bits.startsWith("@<TRIPOS>"))
    return;
  molecule.status_bits = status_bits;
  markLine3(tokenizer);
  const mol_comment = getTokenString(tokenizer);
  if (mol_comment.startsWith("@<TRIPOS>"))
    return;
  molecule.mol_comment = mol_comment;
}
function _readColumnsAndGetMaxCount(linesToRead, tokenIndexColums, tokenizer) {
  let maxColumnCount = 0;
  for (let i = 0; i < linesToRead; i++) {
    let tokenIndex = 0;
    skipWhitespace3(tokenizer);
    while (true) {
      skipStrictWhitespace(tokenizer);
      tokenizer.tokenStart = tokenizer.position;
      eatValue3(tokenizer);
      if (tokenizer.tokenStart === tokenizer.tokenEnd)
        break;
      const col = tokenIndexColums[tokenIndex++];
      if (!col)
        continue;
      TokenBuilder.addUnchecked(col, tokenizer.tokenStart, tokenizer.tokenEnd);
    }
    if (tokenIndex > maxColumnCount)
      maxColumnCount = tokenIndex;
    for (let cI = tokenIndex; cI < tokenIndexColums.length; cI++) {
      TokenBuilder.addUnchecked(tokenIndexColums[cI], 0, 0);
    }
  }
  return maxColumnCount + 1;
}
async function handleAtoms5(state) {
  const { tokenizer, molecule } = state;
  while (getTokenString(tokenizer) !== "@<TRIPOS>ATOM" && tokenizer.position < tokenizer.data.length) {
    markLine3(tokenizer);
  }
  const initialTokenizerPosition = tokenizer.position;
  const initialTokenizerLineNumber = tokenizer.lineNumber;
  const atom_idTokens = TokenBuilder.create(tokenizer.data, molecule.num_atoms * 2);
  const atom_nameTokens = TokenBuilder.create(tokenizer.data, molecule.num_atoms * 2);
  const xTokens = TokenBuilder.create(tokenizer.data, molecule.num_atoms * 2);
  const yTokens = TokenBuilder.create(tokenizer.data, molecule.num_atoms * 2);
  const zTokens = TokenBuilder.create(tokenizer.data, molecule.num_atoms * 2);
  const atom_typeTokens = TokenBuilder.create(tokenizer.data, molecule.num_atoms * 2);
  const subst_idTokens = TokenBuilder.create(tokenizer.data, molecule.num_atoms * 2);
  const subst_nameTokens = TokenBuilder.create(tokenizer.data, molecule.num_atoms * 2);
  const chargeTokens = TokenBuilder.create(tokenizer.data, molecule.num_atoms * 2);
  const status_bitTokens = TokenBuilder.create(tokenizer.data, molecule.num_atoms * 2);
  const undefFloat = Column.Undefined(molecule.num_atoms, Column.Schema.float);
  const undefInt = Column.Undefined(molecule.num_atoms, Column.Schema.int);
  const undefStr = Column.Undefined(molecule.num_atoms, Column.Schema.str);
  tokenizer.position = initialTokenizerPosition;
  tokenizer.lineNumber = initialTokenizerLineNumber;
  let maxColumnCount = 0;
  const tokenIndexToColumn = [
    atom_idTokens,
    atom_nameTokens,
    xTokens,
    yTokens,
    zTokens,
    atom_typeTokens,
    subst_idTokens,
    subst_nameTokens,
    chargeTokens,
    status_bitTokens
  ];
  const { length } = tokenizer;
  let linesAlreadyRead = 0;
  await chunkedSubtask(state.runtimeCtx, 1e5, void 0, (chunkSize) => {
    const linesToRead = Math.min(molecule.num_atoms - linesAlreadyRead, chunkSize);
    maxColumnCount = _readColumnsAndGetMaxCount(linesToRead, tokenIndexToColumn, tokenizer);
    linesAlreadyRead += linesToRead;
    return linesToRead;
  }, (ctx) => ctx.update({ message: "Parsing...", current: tokenizer.position, max: length }));
  const ret = {
    count: molecule.num_atoms,
    atom_id: TokenColumnProvider(atom_idTokens)(Column.Schema.int),
    atom_name: TokenColumnProvider(atom_nameTokens)(Column.Schema.str),
    x: TokenColumnProvider(xTokens)(Column.Schema.float),
    y: TokenColumnProvider(yTokens)(Column.Schema.float),
    z: TokenColumnProvider(zTokens)(Column.Schema.float),
    atom_type: maxColumnCount > 5 ? TokenColumnProvider(atom_typeTokens)(Column.Schema.str) : undefStr,
    subst_id: maxColumnCount > 6 ? TokenColumnProvider(subst_idTokens)(Column.Schema.int) : undefInt,
    subst_name: maxColumnCount > 7 ? TokenColumnProvider(subst_nameTokens)(Column.Schema.str) : undefStr,
    charge: maxColumnCount > 8 ? TokenColumnProvider(chargeTokens)(Column.Schema.float) : undefFloat,
    status_bit: maxColumnCount > 9 ? TokenColumnProvider(status_bitTokens)(Column.Schema.str) : undefStr
  };
  return ret;
}
async function handleBonds4(state) {
  const { tokenizer, molecule } = state;
  while (getTokenString(tokenizer) !== "@<TRIPOS>BOND" && tokenizer.position < tokenizer.data.length) {
    markLine3(tokenizer);
  }
  const initialTokenizerPosition = tokenizer.position;
  const initialTokenizerLineNumber = tokenizer.lineNumber;
  const bond_idTokens = TokenBuilder.create(tokenizer.data, molecule.num_bonds * 2);
  const origin_bond_idTokens = TokenBuilder.create(tokenizer.data, molecule.num_bonds * 2);
  const target_bond_idTokens = TokenBuilder.create(tokenizer.data, molecule.num_bonds * 2);
  const bondTypeTokens = TokenBuilder.create(tokenizer.data, molecule.num_bonds * 2);
  const status_bitTokens = TokenBuilder.create(tokenizer.data, molecule.num_bonds * 2);
  tokenizer.position = initialTokenizerPosition;
  tokenizer.lineNumber = initialTokenizerLineNumber;
  let maxColumnCount = 0;
  const tokenIndexToColumn = [
    bond_idTokens,
    origin_bond_idTokens,
    target_bond_idTokens,
    bondTypeTokens,
    status_bitTokens
  ];
  const { length } = tokenizer;
  let linesAlreadyRead = 0;
  await chunkedSubtask(state.runtimeCtx, 1e5, void 0, (chunkSize) => {
    const linesToRead = Math.min(molecule.num_bonds - linesAlreadyRead, chunkSize);
    maxColumnCount = _readColumnsAndGetMaxCount(linesToRead, tokenIndexToColumn, tokenizer);
    linesAlreadyRead += linesToRead;
    return linesToRead;
  }, (ctx) => ctx.update({ message: "Parsing...", current: tokenizer.position, max: length }));
  const ret = {
    count: molecule.num_bonds,
    bond_id: TokenColumnProvider(bond_idTokens)(Column.Schema.int),
    origin_atom_id: TokenColumnProvider(origin_bond_idTokens)(Column.Schema.int),
    target_atom_id: TokenColumnProvider(target_bond_idTokens)(Column.Schema.int),
    bond_type: TokenColumnProvider(bondTypeTokens)(Column.Schema.str),
    status_bits: maxColumnCount > 4 ? TokenColumnProvider(status_bitTokens)(Column.Schema.str) : Column.Undefined(molecule.num_bonds, Column.Schema.str)
  };
  return ret;
}
function handleCrysin(state) {
  const { tokenizer } = state;
  while (tokenizer.position < tokenizer.data.length) {
    const l = getTokenString(tokenizer);
    if (l === "@<TRIPOS>MOLECULE") {
      return;
    } else if (l === "@<TRIPOS>CRYSIN") {
      break;
    } else {
      markLine3(tokenizer);
    }
  }
  if (tokenizer.position >= tokenizer.data.length)
    return;
  markLine3(tokenizer);
  const values2 = getTokenString(tokenizer).trim().split(reWhitespace3);
  return {
    a: parseFloat(values2[0]),
    b: parseFloat(values2[1]),
    c: parseFloat(values2[2]),
    alpha: parseFloat(values2[3]),
    beta: parseFloat(values2[4]),
    gamma: parseFloat(values2[5]),
    spaceGroup: parseInt(values2[6], 10),
    setting: parseInt(values2[7], 10)
  };
}
async function parseInternal9(ctx, data, name) {
  const tokenizer = Tokenizer(data);
  ctx.update({ message: "Parsing...", current: 0, max: data.length });
  const structures = [];
  while (tokenizer.position < data.length) {
    const state = State7(tokenizer, ctx);
    handleMolecule(state);
    const atoms = await handleAtoms5(state);
    const bonds = await handleBonds4(state);
    const crysin = handleCrysin(state);
    structures.push({ molecule: state.molecule, atoms, bonds, crysin });
    skipWhitespace3(tokenizer);
    while (getTokenString(tokenizer) !== "@<TRIPOS>MOLECULE" && tokenizer.position < tokenizer.data.length) {
      markLine3(tokenizer);
    }
  }
  const result = { name, structures };
  return ReaderResult.success(result);
}
function parseMol2(data, name) {
  return Task.create("Parse MOL2", async (ctx) => {
    return await parseInternal9(ctx, data, name);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/mol2.js
async function getModels3(mol2, ctx) {
  const models = [];
  for (let i = 0, il = mol2.structures.length; i < il; ++i) {
    const { molecule, atoms, bonds, crysin } = mol2.structures[i];
    const A = Column.ofConst("A", atoms.count, Column.Schema.str);
    const type_symbol = new Array(atoms.count);
    let hasAtomType = false;
    for (let i2 = 0; i2 < atoms.count; ++i2) {
      if (atoms.atom_type.value(i2).includes(".")) {
        hasAtomType = true;
        break;
      }
    }
    for (let i2 = 0; i2 < atoms.count; ++i2) {
      type_symbol[i2] = hasAtomType ? atoms.atom_type.value(i2).split(".")[0].toUpperCase() : guessElementSymbolString(atoms.atom_name.value(i2), atoms.subst_name.value(i2));
    }
    const atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
      auth_asym_id: A,
      auth_atom_id: Column.asArrayColumn(atoms.atom_name),
      auth_comp_id: atoms.subst_name,
      auth_seq_id: atoms.subst_id,
      Cartn_x: Column.asArrayColumn(atoms.x, Float32Array),
      Cartn_y: Column.asArrayColumn(atoms.y, Float32Array),
      Cartn_z: Column.asArrayColumn(atoms.z, Float32Array),
      id: Column.asArrayColumn(atoms.atom_id),
      label_asym_id: A,
      label_atom_id: Column.asArrayColumn(atoms.atom_name),
      label_comp_id: atoms.subst_name,
      label_seq_id: atoms.subst_id,
      label_entity_id: Column.ofConst("1", atoms.count, Column.Schema.str),
      occupancy: Column.ofConst(1, atoms.count, Column.Schema.float),
      type_symbol: Column.ofStringArray(type_symbol),
      pdbx_PDB_model_num: Column.ofConst(i, atoms.count, Column.Schema.int)
    }, atoms.count);
    const entityBuilder = new EntityBuilder();
    entityBuilder.setNames([["MOL", molecule.mol_name || "Unknown Entity"]]);
    entityBuilder.getEntityId("MOL", MoleculeType.Unknown, "A");
    const componentBuilder = new ComponentBuilder(atoms.subst_id, atoms.atom_name);
    for (let i2 = 0, il2 = atoms.subst_name.rowCount; i2 < il2; ++i2) {
      componentBuilder.add(atoms.subst_name.value(i2), i2);
    }
    const basic = createBasic({
      entity: entityBuilder.getEntityTable(),
      chem_comp: componentBuilder.getChemCompTable(),
      atom_site
    });
    const _models = await createModels(basic, Mol2Format.create(mol2), ctx);
    if (_models.frameCount > 0) {
      const indexA = Column.ofIntArray(Column.mapToArray(bonds.origin_atom_id, (x) => x - 1, Int32Array));
      const indexB = Column.ofIntArray(Column.mapToArray(bonds.target_atom_id, (x) => x - 1, Int32Array));
      const key2 = bonds.bond_id;
      const order = Column.ofIntArray(Column.mapToArray(bonds.bond_type, (x) => {
        switch (x) {
          case "ar":
          case "am":
          case "un":
            return 1;
          case "du":
          case "nc":
            return 0;
          default:
            return parseInt(x);
        }
      }, Int8Array));
      const flag = Column.ofIntArray(Column.mapToArray(bonds.bond_type, (x) => {
        switch (x) {
          case "ar":
          case "am":
            return BondType.Flag.Aromatic | BondType.Flag.Covalent;
          case "du":
          case "nc":
            return BondType.Flag.None;
          case "un":
          default:
            return BondType.Flag.Covalent;
        }
      }, Int8Array));
      const pairBonds = IndexPairBonds.fromData({ pairs: { key: key2, indexA, indexB, order, flag }, count: atoms.count }, { maxDistance: crysin ? -1 : Infinity });
      const first4 = _models.representative;
      IndexPairBonds.Provider.set(first4, pairBonds);
      AtomPartialCharge.Provider.set(first4, {
        data: atoms.charge,
        type: molecule.charge_type
      });
      if (crysin) {
        const symmetry = getSymmetry2(crysin);
        if (symmetry)
          ModelSymmetry.Provider.set(first4, symmetry);
      }
      models.push(first4);
    }
  }
  return new ArrayTrajectory(models);
}
function getSymmetry2(crysin) {
  if (crysin.setting !== 1)
    return;
  const spaceCell = SpacegroupCell.create(crysin.spaceGroup, Vec3.create(crysin.a, crysin.b, crysin.c), Vec3.scale(Vec3(), Vec3.create(crysin.alpha, crysin.beta, crysin.gamma), Math.PI / 180));
  return {
    spacegroup: Spacegroup.create(spaceCell),
    assemblies: [],
    isNonStandardCrystalFrame: false,
    ncsOperators: []
  };
}
var Mol2Format;
(function(Mol2Format2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "mol2";
  }
  Mol2Format2.is = is3;
  function create(mol2) {
    return { kind: "mol2", name: mol2.name, data: mol2 };
  }
  Mol2Format2.create = create;
})(Mol2Format || (Mol2Format = {}));
function trajectoryFromMol2(mol2) {
  return Task.create("Parse MOL2", (ctx) => getModels3(mol2, ctx));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/xtc/parser.js
var MagicInts = new Uint32Array([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  8,
  10,
  12,
  16,
  20,
  25,
  32,
  40,
  50,
  64,
  80,
  101,
  128,
  161,
  203,
  256,
  322,
  406,
  512,
  645,
  812,
  1024,
  1290,
  1625,
  2048,
  2580,
  3250,
  4096,
  5060,
  6501,
  8192,
  10321,
  13003,
  16384,
  20642,
  26007,
  32768,
  41285,
  52015,
  65536,
  82570,
  104031,
  131072,
  165140,
  208063,
  262144,
  330280,
  416127,
  524287,
  660561,
  832255,
  1048576,
  1321122,
  1664510,
  2097152,
  2642245,
  3329021,
  4194304,
  5284491,
  6658042,
  8388607,
  10568983,
  13316085,
  16777216
]);
var FirstIdx = 9;
var Decoder;
(function(Decoder2) {
  function sizeOfInt(size) {
    let num = 1;
    let numOfBits = 0;
    while (size >= num && numOfBits < 32) {
      numOfBits++;
      num <<= 1;
    }
    return numOfBits;
  }
  Decoder2.sizeOfInt = sizeOfInt;
  const _tmpBytes = new Uint8Array(32);
  function sizeOfInts(numOfInts, sizes) {
    let numOfBytes = 1;
    let numOfBits = 0;
    _tmpBytes[0] = 1;
    for (let i = 0; i < numOfInts; i++) {
      let bytecnt;
      let tmp = 0;
      for (bytecnt = 0; bytecnt < numOfBytes; bytecnt++) {
        tmp += _tmpBytes[bytecnt] * sizes[i];
        _tmpBytes[bytecnt] = tmp & 255;
        tmp >>= 8;
      }
      while (tmp !== 0) {
        _tmpBytes[bytecnt++] = tmp & 255;
        tmp >>= 8;
      }
      numOfBytes = bytecnt;
    }
    let num = 1;
    numOfBytes--;
    while (_tmpBytes[numOfBytes] >= num) {
      numOfBits++;
      num *= 2;
    }
    return numOfBits + numOfBytes * 8;
  }
  Decoder2.sizeOfInts = sizeOfInts;
  const _buffer = new ArrayBuffer(8 * 3);
  Decoder2.buf = new Int32Array(_buffer);
  const uint32view = new Uint32Array(_buffer);
  function decodeBits(cbuf, offset, numOfBits1) {
    let numOfBits = numOfBits1;
    const mask = (1 << numOfBits) - 1;
    let lastBB0 = uint32view[1];
    let lastBB1 = uint32view[2];
    let cnt = Decoder2.buf[0];
    let num = 0;
    while (numOfBits >= 8) {
      lastBB1 = lastBB1 << 8 | cbuf[offset + cnt++];
      num |= lastBB1 >> lastBB0 << numOfBits - 8;
      numOfBits -= 8;
    }
    if (numOfBits > 0) {
      if (lastBB0 < numOfBits) {
        lastBB0 += 8;
        lastBB1 = lastBB1 << 8 | cbuf[offset + cnt++];
      }
      lastBB0 -= numOfBits;
      num |= lastBB1 >> lastBB0 & (1 << numOfBits) - 1;
    }
    num &= mask;
    Decoder2.buf[0] = cnt;
    Decoder2.buf[1] = lastBB0;
    Decoder2.buf[2] = lastBB1;
    return num;
  }
  Decoder2.decodeBits = decodeBits;
  function decodeByte(cbuf, offset) {
    let lastBB1 = uint32view[2];
    const cnt = Decoder2.buf[0];
    lastBB1 = lastBB1 << 8 | cbuf[offset + cnt];
    Decoder2.buf[0] = cnt + 1;
    Decoder2.buf[2] = lastBB1;
    return lastBB1 >> uint32view[1] & 255;
  }
  const intBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  function decodeInts(cbuf, offset, numOfBits1, sizes, nums) {
    let numOfBits = numOfBits1;
    let numOfBytes = 0;
    intBytes[0] = 0;
    intBytes[1] = 0;
    intBytes[2] = 0;
    intBytes[3] = 0;
    while (numOfBits > 8) {
      intBytes[numOfBytes++] = decodeByte(cbuf, offset);
      numOfBits -= 8;
    }
    if (numOfBits > 0) {
      intBytes[numOfBytes++] = decodeBits(cbuf, offset, numOfBits);
    }
    for (let i = 2; i > 0; i--) {
      let num = 0;
      const s = sizes[i];
      for (let j = numOfBytes - 1; j >= 0; j--) {
        num = num << 8 | intBytes[j];
        const t2 = num / s | 0;
        intBytes[j] = t2;
        num = num - t2 * s;
      }
      nums[i] = num;
    }
    nums[0] = intBytes[0] | intBytes[1] << 8 | intBytes[2] << 16 | intBytes[3] << 24;
  }
  Decoder2.decodeInts = decodeInts;
})(Decoder || (Decoder = {}));
function undefinedError() {
  throw new Error("(xdrfile error) Undefined error.");
}
async function parseInternal10(ctx, data) {
  const dv = new DataView(data.buffer, data.byteOffset);
  const f = {
    frames: [],
    boxes: [],
    times: [],
    timeOffset: 0,
    deltaTime: 0
  };
  const coordinates = f.frames;
  const boxes = f.boxes;
  const times = f.times;
  const minMaxInt = [0, 0, 0, 0, 0, 0];
  const sizeint = [0, 0, 0];
  const bitsizeint = [0, 0, 0];
  const sizesmall = [0, 0, 0];
  const thiscoord = [0.1, 0.1, 0.1];
  const prevcoord = [0.1, 0.1, 0.1];
  let offset = 0;
  const buf = Decoder.buf;
  while (true) {
    let frameCoords;
    const natoms = dv.getInt32(offset + 4);
    offset += 12;
    times.push(dv.getFloat32(offset));
    offset += 4;
    const box2 = new Float32Array(9);
    for (let i = 0; i < 9; ++i) {
      box2[i] = dv.getFloat32(offset) * 10;
      offset += 4;
    }
    boxes.push(box2);
    if (natoms <= 9) {
      frameCoords = { count: natoms, x: new Float32Array(natoms), y: new Float32Array(natoms), z: new Float32Array(natoms) };
      offset += 4;
      for (let i = 0; i < natoms; ++i) {
        frameCoords.x[i] = dv.getFloat32(offset);
        frameCoords.y[i] = dv.getFloat32(offset + 4);
        frameCoords.z[i] = dv.getFloat32(offset + 8);
        offset += 12;
      }
    } else {
      buf[0] = buf[1] = buf[2] = 0;
      sizeint[0] = sizeint[1] = sizeint[2] = 0;
      sizesmall[0] = sizesmall[1] = sizesmall[2] = 0;
      bitsizeint[0] = bitsizeint[1] = bitsizeint[2] = 0;
      thiscoord[0] = thiscoord[1] = thiscoord[2] = 0;
      prevcoord[0] = prevcoord[1] = prevcoord[2] = 0;
      frameCoords = { count: natoms, x: new Float32Array(natoms), y: new Float32Array(natoms), z: new Float32Array(natoms) };
      let lfp = 0;
      const lsize = dv.getInt32(offset);
      offset += 4;
      const precision = dv.getFloat32(offset);
      offset += 4;
      minMaxInt[0] = dv.getInt32(offset);
      minMaxInt[1] = dv.getInt32(offset + 4);
      minMaxInt[2] = dv.getInt32(offset + 8);
      minMaxInt[3] = dv.getInt32(offset + 12);
      minMaxInt[4] = dv.getInt32(offset + 16);
      minMaxInt[5] = dv.getInt32(offset + 20);
      sizeint[0] = minMaxInt[3] - minMaxInt[0] + 1;
      sizeint[1] = minMaxInt[4] - minMaxInt[1] + 1;
      sizeint[2] = minMaxInt[5] - minMaxInt[2] + 1;
      offset += 24;
      let bitsize;
      if ((sizeint[0] | sizeint[1] | sizeint[2]) > 16777215) {
        bitsizeint[0] = Decoder.sizeOfInt(sizeint[0]);
        bitsizeint[1] = Decoder.sizeOfInt(sizeint[1]);
        bitsizeint[2] = Decoder.sizeOfInt(sizeint[2]);
        bitsize = 0;
      } else {
        bitsize = Decoder.sizeOfInts(3, sizeint);
      }
      let smallidx = dv.getInt32(offset);
      offset += 4;
      let tmpIdx = smallidx - 1;
      tmpIdx = FirstIdx > tmpIdx ? FirstIdx : tmpIdx;
      let smaller = MagicInts[tmpIdx] / 2 | 0;
      let smallnum = MagicInts[smallidx] / 2 | 0;
      sizesmall[0] = sizesmall[1] = sizesmall[2] = MagicInts[smallidx];
      const adz = Math.ceil(dv.getInt32(offset) / 4) * 4;
      offset += 4;
      const invPrecision = 1 / precision;
      let run = 0;
      let i = 0;
      thiscoord[0] = thiscoord[1] = thiscoord[2] = 0;
      while (i < lsize) {
        if (bitsize === 0) {
          thiscoord[0] = Decoder.decodeBits(data, offset, bitsizeint[0]);
          thiscoord[1] = Decoder.decodeBits(data, offset, bitsizeint[1]);
          thiscoord[2] = Decoder.decodeBits(data, offset, bitsizeint[2]);
        } else {
          Decoder.decodeInts(data, offset, bitsize, sizeint, thiscoord);
        }
        i++;
        thiscoord[0] += minMaxInt[0];
        thiscoord[1] += minMaxInt[1];
        thiscoord[2] += minMaxInt[2];
        prevcoord[0] = thiscoord[0];
        prevcoord[1] = thiscoord[1];
        prevcoord[2] = thiscoord[2];
        const flag = Decoder.decodeBits(data, offset, 1);
        let isSmaller = 0;
        if (flag === 1) {
          run = Decoder.decodeBits(data, offset, 5);
          isSmaller = run % 3;
          run -= isSmaller;
          isSmaller--;
        }
        if (run > 0) {
          thiscoord[0] = thiscoord[1] = thiscoord[2] = 0;
          for (let k = 0; k < run; k += 3) {
            Decoder.decodeInts(data, offset, smallidx, sizesmall, thiscoord);
            i++;
            thiscoord[0] += prevcoord[0] - smallnum;
            thiscoord[1] += prevcoord[1] - smallnum;
            thiscoord[2] += prevcoord[2] - smallnum;
            if (k === 0) {
              let tmpSwap = thiscoord[0];
              thiscoord[0] = prevcoord[0];
              prevcoord[0] = tmpSwap;
              tmpSwap = thiscoord[1];
              thiscoord[1] = prevcoord[1];
              prevcoord[1] = tmpSwap;
              tmpSwap = thiscoord[2];
              thiscoord[2] = prevcoord[2];
              prevcoord[2] = tmpSwap;
              frameCoords.x[lfp] = prevcoord[0] * invPrecision;
              frameCoords.y[lfp] = prevcoord[1] * invPrecision;
              frameCoords.z[lfp] = prevcoord[2] * invPrecision;
              lfp++;
            } else {
              prevcoord[0] = thiscoord[0];
              prevcoord[1] = thiscoord[1];
              prevcoord[2] = thiscoord[2];
            }
            frameCoords.x[lfp] = thiscoord[0] * invPrecision;
            frameCoords.y[lfp] = thiscoord[1] * invPrecision;
            frameCoords.z[lfp] = thiscoord[2] * invPrecision;
            lfp++;
          }
        } else {
          frameCoords.x[lfp] = thiscoord[0] * invPrecision;
          frameCoords.y[lfp] = thiscoord[1] * invPrecision;
          frameCoords.z[lfp] = thiscoord[2] * invPrecision;
          lfp++;
        }
        smallidx += isSmaller;
        if (isSmaller < 0) {
          smallnum = smaller;
          if (smallidx > FirstIdx) {
            smaller = MagicInts[smallidx - 1] / 2 | 0;
          } else {
            smaller = 0;
          }
        } else if (isSmaller > 0) {
          smaller = smallnum;
          smallnum = MagicInts[smallidx] / 2 | 0;
        }
        sizesmall[0] = sizesmall[1] = sizesmall[2] = MagicInts[smallidx];
        if (sizesmall[0] === 0 || sizesmall[1] === 0 || sizesmall[2] === 0) {
          undefinedError();
        }
      }
      offset += adz;
    }
    for (let c5 = 0; c5 < natoms; c5++) {
      frameCoords.x[c5] *= 10;
      frameCoords.y[c5] *= 10;
      frameCoords.z[c5] *= 10;
    }
    coordinates.push(frameCoords);
    if (ctx.shouldUpdate) {
      await ctx.update({ current: offset, max: data.length });
    }
    if (offset >= data.length)
      break;
  }
  if (times.length >= 1) {
    f.timeOffset = times[0];
  }
  if (times.length >= 2) {
    f.deltaTime = times[1] - times[0];
  }
  return f;
}
function parseXtc(data) {
  return Task.create("Parse XTC", async (ctx) => {
    try {
      ctx.update({ canAbort: true, message: "Parsing trajectory..." });
      const file = await parseInternal10(ctx, data);
      return ReaderResult.success(file);
    } catch (e) {
      return ReaderResult.error("" + e);
    }
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/xtc.js
function coordinatesFromXtc(file) {
  return Task.create("Parse XTC", async (ctx) => {
    await ctx.update("Converting to coordinates");
    const deltaTime = Time(file.deltaTime, "step");
    const offsetTime = Time(file.timeOffset, deltaTime.unit);
    const frames = [];
    for (let i = 0, il = file.frames.length; i < il; ++i) {
      const box2 = file.boxes[i];
      const x = Vec3.fromArray(Vec3(), box2, 0);
      const y = Vec3.fromArray(Vec3(), box2, 3);
      const z = Vec3.fromArray(Vec3(), box2, 6);
      frames.push({
        elementCount: file.frames[i].count,
        cell: Cell.fromBasis(x, y, z),
        x: file.frames[i].x,
        y: file.frames[i].y,
        z: file.frames[i].z,
        xyzOrdering: { isIdentity: true },
        time: Time(offsetTime.value + deltaTime.value * i, deltaTime.unit)
      });
    }
    return Coordinates.create(frames, deltaTime, offsetTime);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/xyz/parser.js
function handleMolecule2(tokenizer) {
  let count3 = tokenizer.position >= tokenizer.data.length - 1 ? 0 : +Tokenizer.readLine(tokenizer);
  if (isNaN(count3))
    count3 = 0;
  const comment = Tokenizer.readLine(tokenizer);
  const x = new Float64Array(count3);
  const y = new Float64Array(count3);
  const z = new Float64Array(count3);
  const type_symbol = new Array(count3);
  for (let i = 0; i < count3; ++i) {
    const line = Tokenizer.readLineTrim(tokenizer);
    const fields = line.split(/\s+/g);
    type_symbol[i] = fields[0];
    x[i] = +fields[1];
    y[i] = +fields[2];
    z[i] = +fields[3];
  }
  return {
    count: count3,
    comment,
    x: Column.ofFloatArray(x),
    y: Column.ofFloatArray(y),
    z: Column.ofFloatArray(z),
    type_symbol: Column.ofStringArray(type_symbol)
  };
}
function parseInternal11(data) {
  const tokenizer = Tokenizer(data);
  const molecules = [];
  while (true) {
    const mol = handleMolecule2(tokenizer);
    if (mol.count === 0)
      break;
    molecules.push(mol);
  }
  const result = { molecules };
  return ReaderResult.success(result);
}
function parseXyz(data) {
  return Task.create("Parse Mol", async () => {
    return parseInternal11(data);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/xyz.js
function getModels4(mol, ctx) {
  const { molecules } = mol;
  let count3 = 0;
  for (const m of molecules)
    count3 += m.count;
  const type_symbols = new Array(count3);
  const id = new Int32Array(count3);
  const x = new Float32Array(count3);
  const y = new Float32Array(count3);
  const z = new Float32Array(count3);
  const model_num = new Int32Array(count3);
  let offset = 0;
  for (let i = 0; i < molecules.length; i++) {
    const m = molecules[i];
    for (let j = 0; j < m.count; j++) {
      type_symbols[offset] = m.type_symbol.value(j);
      x[offset] = m.x.value(j);
      y[offset] = m.y.value(j);
      z[offset] = m.z.value(j);
      id[offset] = j;
      model_num[offset] = i;
      offset++;
    }
  }
  const MOL = Column.ofConst("MOL", count3, Column.Schema.str);
  const A = Column.ofConst("A", count3, Column.Schema.str);
  const seq_id = Column.ofConst(1, count3, Column.Schema.int);
  const type_symbol = Column.ofStringArray(type_symbols);
  const atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
    auth_asym_id: A,
    auth_atom_id: type_symbol,
    auth_comp_id: MOL,
    auth_seq_id: seq_id,
    Cartn_x: Column.ofFloatArray(x),
    Cartn_y: Column.ofFloatArray(y),
    Cartn_z: Column.ofFloatArray(z),
    id: Column.ofIntArray(id),
    label_asym_id: A,
    label_atom_id: type_symbol,
    label_comp_id: MOL,
    label_seq_id: seq_id,
    label_entity_id: Column.ofConst("1", count3, Column.Schema.str),
    occupancy: Column.ofConst(1, count3, Column.Schema.float),
    type_symbol,
    pdbx_PDB_model_num: Column.ofIntArray(model_num)
  }, count3);
  const entityBuilder = new EntityBuilder();
  entityBuilder.setNames([["MOL", "Unknown Entity"]]);
  entityBuilder.getEntityId("MOL", MoleculeType.Unknown, "A");
  const componentBuilder = new ComponentBuilder(seq_id, type_symbol);
  componentBuilder.setNames([["MOL", "Unknown Molecule"]]);
  componentBuilder.add("MOL", 0);
  const basic = createBasic({
    entity: entityBuilder.getEntityTable(),
    chem_comp: componentBuilder.getChemCompTable(),
    atom_site
  });
  return createModels(basic, XyzFormat.create(mol), ctx);
}
var XyzFormat;
(function(XyzFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "xyz";
  }
  XyzFormat2.is = is3;
  function create(mol) {
    return { kind: "xyz", name: "xyz", data: mol };
  }
  XyzFormat2.create = create;
})(XyzFormat || (XyzFormat = {}));
function trajectoryFromXyz(mol) {
  return Task.create("Parse XYZ", (ctx) => getModels4(mol, ctx));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/lammps/schema.js
var lammpsUnitStyles = {
  lj: {
    mass: "unitless",
    distance: "unitless",
    time: "unitless",
    energy: "unitless",
    velocity: "unitless",
    force: "unitless",
    torque: "unitless",
    temperature: "unitless",
    pressure: "unitless",
    viscosity: "unitless",
    charge: "unitless",
    density: "unitless",
    scale: 1
  },
  real: {
    mass: "grams/mole",
    distance: "Angstroms",
    time: "femtoseconds",
    energy: "Kcal/mol",
    velocity: "Angstroms/femtosecond",
    force: "Kcal/mol-Angstrom",
    torque: "Kcal/mol",
    temperature: "Kelvin",
    pressure: "atmospheres",
    viscosity: "Poise",
    charge: "multiple of electron charge",
    dipole: "charge*Angstroms",
    electricField: "volts/Angstrom",
    density: "g/cm^3",
    scale: 1
  },
  metal: {
    mass: "grams/mole",
    distance: "Angstroms",
    time: "picoseconds",
    energy: "eV",
    velocity: "Angstroms/picosecond",
    force: "eV/Angstrom",
    torque: "eV",
    temperature: "Kelvin",
    pressure: "bars",
    viscosity: "Poise",
    charge: "multiple of electron charge",
    dipole: "charge*Angstroms",
    electricField: "volts/Angstrom",
    density: "g/cm^3",
    scale: 1
  },
  si: {
    mass: "kilograms",
    distance: "meters",
    time: "seconds",
    energy: "Joules",
    velocity: "meters/second",
    force: "Newtons",
    torque: "Newton-meters",
    temperature: "Kelvin",
    pressure: "Pascals",
    viscosity: "Pascal*second",
    charge: "Coulombs",
    dipole: "Coulombs*meters",
    electricField: "volts/meter",
    density: "kg/m^3",
    scale: 1
    // leave as is
  },
  cgs: {
    mass: "grams",
    distance: "centimeters",
    time: "seconds",
    energy: "ergs",
    velocity: "centimeters/second",
    force: "dynes",
    torque: "dyne-centimeters",
    temperature: "Kelvin",
    pressure: "dyne/cm^2",
    viscosity: "Poise",
    charge: "statcoulombs",
    dipole: "statcoul-cm",
    electricField: "statvolt/cm",
    density: "g/cm^3",
    scale: 1
    // leave as is
  },
  electron: {
    mass: "atomic mass units",
    distance: "Bohr",
    time: "femtoseconds",
    energy: "Hartrees",
    velocity: "Bohr/atomic time units",
    force: "Hartrees/Bohr",
    temperature: "Kelvin",
    pressure: "Pascals",
    charge: "multiple of electron charge",
    dipole: "Debye",
    electricField: "volts/cm",
    density: "unitless",
    torque: "",
    viscosity: "",
    scale: 0.529177
  },
  micro: {
    mass: "picograms",
    distance: "micrometers",
    time: "microseconds",
    energy: "picogram-micrometer^2/microsecond^2",
    velocity: "micrometers/microsecond",
    force: "picogram-micrometer/microsecond^2",
    torque: "picogram-micrometer^2/microsecond^2",
    temperature: "Kelvin",
    pressure: "picogram/(micrometer-microsecond^2)",
    viscosity: "picogram/(micrometer-microsecond)",
    charge: "picocoulombs",
    dipole: "picocoulomb-micrometer",
    electricField: "volt/micrometer",
    density: "pg/m^3",
    scale: 1
    // leave as is
  },
  nano: {
    mass: "attograms",
    distance: "nanometers",
    time: "nanoseconds",
    energy: "attogram-nanometer^2/nanosecond^2",
    velocity: "nanometers/nanosecond",
    force: "attogram-nanometer/nanosecond^2",
    torque: "attogram-nanometer^2/nanosecond^2",
    temperature: "Kelvin",
    pressure: "attogram/(nanometer-nanosecond^2)",
    viscosity: "attogram/(nanometer-nanosecond)",
    charge: "multiple of electron charge",
    dipole: "charge-nanometer",
    electricField: "volt/nanometer",
    density: "ag/nm^3",
    scale: 10
  }
};
var UnitStyles = ["real", "metal", "si", "cgs", "electron", "micro", "nano", "lj"];

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/lammps/data/parser.js
var { readLine: readLine4, skipWhitespace: skipWhitespace4, eatValue: eatValue4, eatLine: eatLine3, markStart: markStart3 } = Tokenizer;
var reWhitespace4 = /\s+/;
function State8(tokenizer, runtimeCtx) {
  return {
    tokenizer,
    runtimeCtx
  };
}
async function handleAtoms6(state, count3, atom_style) {
  const { tokenizer } = state;
  const atomId2 = TokenBuilder.create(tokenizer.data, count3 * 2);
  const moleculeId = TokenBuilder.create(tokenizer.data, count3 * 2);
  const atomType = TokenBuilder.create(tokenizer.data, count3 * 2);
  const charge = TokenBuilder.create(tokenizer.data, count3 * 2);
  const x = TokenBuilder.create(tokenizer.data, count3 * 2);
  const y = TokenBuilder.create(tokenizer.data, count3 * 2);
  const z = TokenBuilder.create(tokenizer.data, count3 * 2);
  const columns = {
    full: [atomId2, moleculeId, atomType, charge, x, y, z],
    atomic: [atomId2, atomType, x, y, z],
    bond: [atomId2, moleculeId, atomType, x, y, z]
  };
  const n = columns[atom_style].length;
  const { position } = tokenizer;
  readLine4(tokenizer).trim();
  tokenizer.position = position;
  const { length } = tokenizer;
  let linesAlreadyRead = 0;
  await chunkedSubtask(state.runtimeCtx, 1e5, void 0, (chunkSize) => {
    const linesToRead = Math.min(count3 - linesAlreadyRead, chunkSize);
    for (let i = 0; i < linesToRead; ++i) {
      for (let j = 0; j < n; ++j) {
        skipWhitespace4(tokenizer);
        markStart3(tokenizer);
        eatValue4(tokenizer);
        const column = columns[atom_style][j];
        if (column) {
          TokenBuilder.addUnchecked(column, tokenizer.tokenStart, tokenizer.tokenEnd);
        }
      }
      eatLine3(tokenizer);
      markStart3(tokenizer);
    }
    linesAlreadyRead += linesToRead;
    return linesToRead;
  }, (ctx) => ctx.update({ message: "Parsing...", current: tokenizer.position, max: length }));
  return {
    count: count3,
    atomId: TokenColumnProvider(atomId2)(Column.Schema.int),
    moleculeId: TokenColumnProvider(moleculeId)(Column.Schema.int),
    atomType: TokenColumnProvider(atomType)(Column.Schema.int),
    charge: TokenColumnProvider(charge)(Column.Schema.float),
    x: TokenColumnProvider(x)(Column.Schema.float),
    y: TokenColumnProvider(y)(Column.Schema.float),
    z: TokenColumnProvider(z)(Column.Schema.float)
  };
}
async function handleBonds5(state, count3) {
  const { tokenizer } = state;
  const bondId = TokenBuilder.create(tokenizer.data, count3 * 2);
  const bondType = TokenBuilder.create(tokenizer.data, count3 * 2);
  const atomIdA = TokenBuilder.create(tokenizer.data, count3 * 2);
  const atomIdB = TokenBuilder.create(tokenizer.data, count3 * 2);
  const { length } = tokenizer;
  let bondsAlreadyRead = 0;
  await chunkedSubtask(state.runtimeCtx, 10, void 0, (chunkSize) => {
    const bondsToRead = Math.min(count3 - bondsAlreadyRead, chunkSize);
    for (let i = 0; i < bondsToRead; ++i) {
      for (let j = 0; j < 4; ++j) {
        skipWhitespace4(tokenizer);
        markStart3(tokenizer);
        eatValue4(tokenizer);
        switch (j) {
          case 0:
            TokenBuilder.addUnchecked(bondId, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
          case 1:
            TokenBuilder.addUnchecked(bondType, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
          case 2:
            TokenBuilder.addUnchecked(atomIdA, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
          case 3:
            TokenBuilder.addUnchecked(atomIdB, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
        }
      }
    }
    bondsAlreadyRead += bondsToRead;
    return bondsToRead;
  }, (ctx) => ctx.update({ message: "Parsing...", current: tokenizer.position, max: length }));
  return {
    count: count3,
    bondId: TokenColumnProvider(bondId)(Column.Schema.int),
    bondType: TokenColumnProvider(bondType)(Column.Schema.int),
    atomIdA: TokenColumnProvider(atomIdA)(Column.Schema.int),
    atomIdB: TokenColumnProvider(atomIdB)(Column.Schema.int)
  };
}
var AtomStyles = ["full", "atomic", "bond"];
async function parseInternal12(data, ctx) {
  const tokenizer = Tokenizer(data);
  const state = State8(tokenizer, ctx);
  let atoms = void 0;
  let bonds = void 0;
  let numAtoms = 0;
  let numBonds = 0;
  let atom_style = "full";
  while (tokenizer.tokenEnd < tokenizer.length) {
    const line = readLine4(state.tokenizer).trim();
    if (line.includes("atoms")) {
      numAtoms = parseInt(line.split(reWhitespace4)[0]);
    } else if (line.includes("bonds")) {
      numBonds = parseInt(line.split(reWhitespace4)[0]);
    } else if (line.includes("Masses")) {
    } else if (line.includes("Atoms")) {
      const parts = line.split("#");
      if (parts.length > 1) {
        const atomStyle = parts[1].trim();
        if (AtomStyles.includes(atomStyle)) {
          atom_style = atomStyle;
        } else {
          console.warn(`Unknown atom style: ${atomStyle}`);
        }
      }
      atoms = await handleAtoms6(state, numAtoms, atom_style);
    } else if (line.includes("Bonds")) {
      bonds = await handleBonds5(state, numBonds);
    }
  }
  if (atoms === void 0) {
    return ReaderResult.error("no atoms data");
  }
  if (bonds === void 0) {
    bonds = {
      count: 0,
      bondId: Column.ofIntArray([]),
      bondType: Column.ofIntArray([]),
      atomIdA: Column.ofIntArray([]),
      atomIdB: Column.ofIntArray([])
    };
  }
  const result = {
    atoms,
    bonds
  };
  return ReaderResult.success(result);
}
function parseLammpsData(data) {
  return Task.create("Parse LammpsData", async (ctx) => {
    return await parseInternal12(data, ctx);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/lammps-data.js
async function getModels5(mol, ctx, unitsStyle = "real") {
  const { atoms, bonds } = mol;
  const models = [];
  const count3 = atoms.count;
  const scale = lammpsUnitStyles[unitsStyle].scale;
  const type_symbols = new Array(count3);
  const id = new Int32Array(count3);
  const cx = new Float32Array(count3);
  const cy = new Float32Array(count3);
  const cz = new Float32Array(count3);
  const model_num = new Int32Array(count3);
  let offset = 0;
  for (let j = 0; j < count3; j++) {
    type_symbols[offset] = atoms.atomType.value(j).toString();
    cx[offset] = atoms.x.value(j) * scale;
    cy[offset] = atoms.y.value(j) * scale;
    cz[offset] = atoms.z.value(j) * scale;
    id[offset] = atoms.atomId.value(j) - 1;
    model_num[offset] = 0;
    offset++;
  }
  const MOL = Column.ofConst("MOL", count3, Column.Schema.str);
  const asym_id = Column.ofLambda({
    value: (row) => atoms.moleculeId.value(row).toString(),
    rowCount: count3,
    schema: Column.Schema.str
  });
  const seq_id = Column.ofConst(1, count3, Column.Schema.int);
  const type_symbol = Column.ofStringArray(type_symbols);
  const atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
    auth_asym_id: asym_id,
    auth_atom_id: type_symbol,
    auth_comp_id: MOL,
    auth_seq_id: seq_id,
    Cartn_x: Column.ofFloatArray(cx),
    Cartn_y: Column.ofFloatArray(cy),
    Cartn_z: Column.ofFloatArray(cz),
    id: Column.ofIntArray(id),
    label_asym_id: asym_id,
    label_atom_id: type_symbol,
    label_comp_id: MOL,
    label_seq_id: seq_id,
    label_entity_id: Column.ofConst("1", count3, Column.Schema.str),
    occupancy: Column.ofConst(1, count3, Column.Schema.float),
    type_symbol,
    pdbx_PDB_model_num: Column.ofIntArray(model_num)
  }, count3);
  const entityBuilder = new EntityBuilder();
  entityBuilder.setNames([["MOL", "Unknown Entity"]]);
  entityBuilder.getEntityId("MOL", MoleculeType.Unknown, "A");
  const componentBuilder = new ComponentBuilder(seq_id, type_symbol);
  componentBuilder.setNames([["MOL", "Unknown Molecule"]]);
  componentBuilder.add("MOL", 0);
  const basic = createBasic({
    entity: entityBuilder.getEntityTable(),
    chem_comp: componentBuilder.getChemCompTable(),
    atom_site
  });
  const _models = await createModels(basic, LammpsDataFormat.create(mol), ctx);
  if (_models.frameCount > 0) {
    const first4 = _models.representative;
    if (bonds.count !== 0) {
      const indexA = Column.ofIntArray(Column.mapToArray(bonds.atomIdA, (x) => x - 1, Int32Array));
      const indexB = Column.ofIntArray(Column.mapToArray(bonds.atomIdB, (x) => x - 1, Int32Array));
      const key2 = bonds.bondId;
      const order = Column.ofConst(1, bonds.count, Column.Schema.int);
      const flag = Column.ofConst(BondType.Flag.Covalent, bonds.count, Column.Schema.int);
      const pairBonds = IndexPairBonds.fromData({ pairs: { key: key2, indexA, indexB, order, flag }, count: atoms.count }, { maxDistance: Infinity });
      IndexPairBonds.Provider.set(first4, pairBonds);
    }
    AtomPartialCharge.Provider.set(first4, {
      data: atoms.charge,
      type: "NO_CHARGES"
    });
    models.push(first4);
  }
  return new ArrayTrajectory(models);
}
var LammpsDataFormat;
(function(LammpsDataFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "data";
  }
  LammpsDataFormat2.is = is3;
  function create(mol) {
    return { kind: "data", name: "data", data: mol };
  }
  LammpsDataFormat2.create = create;
})(LammpsDataFormat || (LammpsDataFormat = {}));
function trajectoryFromLammpsData(mol, unitsStyle) {
  if (unitsStyle === void 0)
    unitsStyle = "real";
  return Task.create("Parse Lammps Data", (ctx) => getModels5(mol, ctx, unitsStyle));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/lammps/traj/parser.js
var { readLine: readLine5, skipWhitespace: skipWhitespace5, eatValue: eatValue5, eatLine: eatLine4, markStart: markStart4 } = Tokenizer;
function State9(tokenizer, runtimeCtx) {
  return {
    tokenizer,
    runtimeCtx
  };
}
async function handleAtoms7(state, count3, parts) {
  const { tokenizer } = state;
  const columnIndexMap = Object.fromEntries(parts.map((colName, index) => [colName, index]));
  const xCol = parts.findIndex((p) => p[0] === "x");
  const yCol = parts.findIndex((p) => p[0] === "y");
  const zCol = parts.findIndex((p) => p[0] === "z");
  const atomMode = parts[xCol];
  const atomId2 = TokenBuilder.create(tokenizer.data, count3 * 2);
  const moleculeType = TokenBuilder.create(tokenizer.data, count3 * 2);
  const atomType = TokenBuilder.create(tokenizer.data, count3 * 2);
  const x = TokenBuilder.create(tokenizer.data, count3 * 2);
  const y = TokenBuilder.create(tokenizer.data, count3 * 2);
  const z = TokenBuilder.create(tokenizer.data, count3 * 2);
  const { position } = tokenizer;
  tokenizer.position = position;
  const n = parts.length;
  const { length } = tokenizer;
  let linesAlreadyRead = 0;
  await chunkedSubtask(state.runtimeCtx, 1e5, void 0, (chunkSize) => {
    const linesToRead = Math.min(count3 - linesAlreadyRead, chunkSize);
    for (let i = 0; i < linesToRead; ++i) {
      for (let j = 0; j < n; ++j) {
        skipWhitespace5(tokenizer);
        markStart4(tokenizer);
        eatValue5(tokenizer);
        switch (j) {
          case columnIndexMap["id"]:
            TokenBuilder.addUnchecked(atomId2, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
          case columnIndexMap["mol"]:
            TokenBuilder.addUnchecked(moleculeType, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
          case columnIndexMap["type"]:
            TokenBuilder.addUnchecked(atomType, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
          case xCol:
            TokenBuilder.addUnchecked(x, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
          case yCol:
            TokenBuilder.addUnchecked(y, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
          case zCol:
            TokenBuilder.addUnchecked(z, tokenizer.tokenStart, tokenizer.tokenEnd);
            break;
        }
      }
      eatLine4(tokenizer);
      markStart4(tokenizer);
    }
    linesAlreadyRead += linesToRead;
    return linesToRead;
  }, (ctx) => ctx.update({ message: "Parsing...", current: tokenizer.position, max: length }));
  return {
    count: count3,
    atomMode,
    atomId: TokenColumnProvider(atomId2)(Column.Schema.int),
    moleculeId: TokenColumnProvider(moleculeType)(Column.Schema.int),
    atomType: TokenColumnProvider(atomType)(Column.Schema.int),
    x: TokenColumnProvider(x)(Column.Schema.float),
    y: TokenColumnProvider(y)(Column.Schema.float),
    z: TokenColumnProvider(z)(Column.Schema.float)
  };
}
async function parseInternal13(data, ctx) {
  const tokenizer = Tokenizer(data);
  const state = State9(tokenizer, ctx);
  const f = {
    frames: [],
    times: [],
    bounds: [],
    timeOffset: 0,
    deltaTime: 0
  };
  const frames = f.frames;
  let numAtoms = 0;
  let timestep = 0;
  while (tokenizer.tokenEnd < tokenizer.length) {
    const line = readLine5(state.tokenizer).trim();
    if (line.includes("ITEM: TIMESTEP")) {
      timestep = parseInt(readLine5(state.tokenizer).trim());
      f.times.push(timestep);
    } else if (line.includes("ITEM: NUMBER OF ATOMS")) {
      numAtoms = parseInt(readLine5(state.tokenizer).trim());
    } else if (line.includes("ITEM: ATOMS")) {
      const parts = line.split(" ").slice(2);
      const frame = await handleAtoms7(state, numAtoms, parts);
      frames.push(frame);
    } else if (line.includes("ITEM: BOX BOUNDS")) {
      const tokens = line.split("ITEM: BOX BOUNDS ")[1].split(" ");
      const px = tokens[0];
      const py = tokens[1];
      const pz = tokens[2];
      const xbound = readLine5(state.tokenizer).trim().split(" ");
      const ybound = readLine5(state.tokenizer).trim().split(" ");
      const zbound = readLine5(state.tokenizer).trim().split(" ");
      const xlo = parseFloat(xbound[0]);
      const xhi = parseFloat(xbound[1]);
      const ylo = parseFloat(ybound[0]);
      const yhi = parseFloat(ybound[1]);
      const zlo = parseFloat(zbound[0]);
      const zhi = parseFloat(zbound[1]);
      f.bounds.push({
        lower: [xlo, ylo, zlo],
        length: [xhi - xlo, yhi - ylo, zhi - zlo],
        periodicity: [px, py, pz]
      });
    }
  }
  if (f.times.length >= 1) {
    f.timeOffset = f.times[0];
  }
  if (f.times.length >= 2) {
    f.deltaTime = f.times[1] - f.times[0];
  }
  return ReaderResult.success(f);
}
function parseLammpsTrajectory(data) {
  return Task.create("Parse Lammp Trajectory", async (ctx) => {
    return await parseInternal13(data, ctx);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/lammps-trajectory.js
function coordinatesFromLammpsTrajectory(file, unitsStyle = "real") {
  return Task.create("Parse Lammps Trajectory", async (ctx) => {
    await ctx.update("Converting to coordinates");
    const scale = lammpsUnitStyles[unitsStyle].scale;
    const deltaTime = Time(file.deltaTime, "step");
    const offsetTime = Time(file.timeOffset, deltaTime.unit);
    const offset_pos = { x: 0, y: 0, z: 0 };
    const offset_scale = { x: 1, y: 1, z: 1 };
    const atomsMode = file.frames[0].atomMode;
    const isScaled = atomsMode.includes("s");
    const frames = [];
    for (let i = 0, il = file.frames.length; i < il; ++i) {
      const box2 = file.bounds[i];
      if (isScaled) {
        offset_scale.x = box2.length[0];
        offset_scale.y = box2.length[1];
        offset_scale.z = box2.length[2];
        offset_pos.x = box2.lower[0];
        offset_pos.y = box2.lower[1];
        offset_pos.z = box2.lower[2];
      }
      const count3 = file.frames[i].count;
      const cx = new Float32Array(count3);
      const cy = new Float32Array(count3);
      const cz = new Float32Array(count3);
      let offset = 0;
      for (let j = 0; j < count3; j++) {
        cx[offset] = (file.frames[i].x.value(j) * offset_scale.x + offset_pos.x) * scale;
        cy[offset] = (file.frames[i].y.value(j) * offset_scale.y + offset_pos.y) * scale;
        cz[offset] = (file.frames[i].z.value(j) * offset_scale.z + offset_pos.z) * scale;
        offset++;
      }
      frames.push({
        elementCount: file.frames[i].count,
        x: cx,
        y: cy,
        z: cz,
        xyzOrdering: { isIdentity: true },
        time: Time(offsetTime.value + deltaTime.value * i, deltaTime.unit)
      });
    }
    return Coordinates.create(frames, deltaTime, offsetTime);
  });
}
async function getModels6(mol, ctx, unitsStyle = "real") {
  const atoms = mol.frames[0];
  const count3 = atoms.count;
  const atomsMode = atoms.atomMode;
  const box2 = mol.bounds[0];
  const offset_pos = { x: 0, y: 0, z: 0 };
  const offset_scale = { x: 1, y: 1, z: 1 };
  const scale = lammpsUnitStyles[unitsStyle].scale;
  if (atomsMode.includes("s")) {
    offset_scale.x = box2.length[0];
    offset_scale.y = box2.length[1];
    offset_scale.z = box2.length[2];
    offset_pos.x = box2.lower[0];
    offset_pos.y = box2.lower[1];
    offset_pos.z = box2.lower[2];
  }
  const type_symbols = new Array(count3);
  const id = new Int32Array(count3);
  const cx = new Float32Array(count3);
  const cy = new Float32Array(count3);
  const cz = new Float32Array(count3);
  const model_num = new Int32Array(count3);
  let offset = 0;
  for (let j = 0; j < count3; j++) {
    type_symbols[offset] = atoms.atomType.value(j).toString();
    cx[offset] = (atoms.x.value(j) * offset_scale.x + offset_pos.x) * scale;
    cy[offset] = (atoms.y.value(j) * offset_scale.y + offset_pos.y) * scale;
    cz[offset] = (atoms.z.value(j) * offset_scale.z + offset_pos.z) * scale;
    id[offset] = atoms.atomId.value(j);
    model_num[offset] = 0;
    offset++;
  }
  const MOL = Column.ofConst("MOL", count3, Column.Schema.str);
  const asym_id = Column.ofLambda({
    value: (row) => atoms.moleculeId.value(row).toString(),
    rowCount: count3,
    schema: Column.Schema.str
  });
  const seq_id = Column.ofConst(1, count3, Column.Schema.int);
  const type_symbol = Column.ofStringArray(type_symbols);
  const atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
    auth_asym_id: asym_id,
    auth_atom_id: type_symbol,
    auth_comp_id: MOL,
    auth_seq_id: seq_id,
    Cartn_x: Column.ofFloatArray(cx),
    Cartn_y: Column.ofFloatArray(cy),
    Cartn_z: Column.ofFloatArray(cz),
    id: Column.ofIntArray(id),
    label_asym_id: asym_id,
    label_atom_id: type_symbol,
    label_comp_id: MOL,
    label_seq_id: seq_id,
    label_entity_id: Column.ofConst("1", count3, Column.Schema.str),
    occupancy: Column.ofConst(1, count3, Column.Schema.float),
    type_symbol,
    pdbx_PDB_model_num: Column.ofIntArray(model_num)
  }, count3);
  const entityBuilder = new EntityBuilder();
  entityBuilder.setNames([["MOL", "Unknown Entity"]]);
  entityBuilder.getEntityId("MOL", MoleculeType.Unknown, "A");
  const componentBuilder = new ComponentBuilder(seq_id, type_symbol);
  componentBuilder.setNames([["MOL", "Unknown Molecule"]]);
  componentBuilder.add("MOL", 0);
  const basic = createBasic({
    entity: entityBuilder.getEntityTable(),
    chem_comp: componentBuilder.getChemCompTable(),
    atom_site
  });
  const _models = await createModels(basic, LammpsTrajectoryFormat.create(mol), ctx);
  const first4 = _models.representative;
  const coordinates = await coordinatesFromLammpsTrajectory(mol, unitsStyle).runInContext(ctx);
  return Model.trajectoryFromModelAndCoordinates(first4, coordinates);
}
var LammpsTrajectoryFormat;
(function(LammpsTrajectoryFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "lammpstrj";
  }
  LammpsTrajectoryFormat2.is = is3;
  function create(mol) {
    return { kind: "lammpstrj", name: "lammpstrj", data: mol };
  }
  LammpsTrajectoryFormat2.create = create;
})(LammpsTrajectoryFormat || (LammpsTrajectoryFormat = {}));
function trajectoryFromLammpsTrajectory(mol, unitsStyle) {
  if (unitsStyle === void 0)
    unitsStyle = "real";
  return Task.create("Parse Lammps Traj Data", (ctx) => getModels6(mol, ctx, unitsStyle));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/sdf/parser-v3-util.js
function isV3(versionLine) {
  return versionLine.trim().endsWith("V3000");
}
function handleCountsV3(tokenizer) {
  const atomCount = TokenBuilder.create(tokenizer.data, 1);
  const bondCount2 = TokenBuilder.create(tokenizer.data, 1);
  Tokenizer.eatLine(tokenizer);
  skipSingleValue(tokenizer);
  skipSingleValue(tokenizer);
  skipSingleValue(tokenizer);
  addSingleValue(tokenizer, atomCount);
  addSingleValue(tokenizer, bondCount2);
  Tokenizer.eatLine(tokenizer);
  return {
    atomCount: TokenColumnProvider(atomCount)(Column.Schema.int).value(0),
    bondCount: TokenColumnProvider(bondCount2)(Column.Schema.int).value(0)
  };
}
function handleAtomsV3(tokenizer, atomCount) {
  const x = TokenBuilder.create(tokenizer.data, atomCount * 2);
  const y = TokenBuilder.create(tokenizer.data, atomCount * 2);
  const z = TokenBuilder.create(tokenizer.data, atomCount * 2);
  const type_symbol = TokenBuilder.create(tokenizer.data, atomCount * 2);
  for (let i = 0; i < atomCount; ++i) {
    Tokenizer.markLine(tokenizer);
    skipSingleValue(tokenizer);
    skipSingleValue(tokenizer);
    skipSingleValue(tokenizer);
    const { position } = tokenizer;
    addSingleValue(tokenizer, type_symbol);
    addSingleValue(tokenizer, x);
    addSingleValue(tokenizer, y);
    addSingleValue(tokenizer, z);
    tokenizer.position = position;
  }
  Tokenizer.eatLine(tokenizer);
  Tokenizer.eatLine(tokenizer);
  return {
    count: atomCount,
    x: TokenColumnProvider(x)(Column.Schema.float),
    y: TokenColumnProvider(y)(Column.Schema.float),
    z: TokenColumnProvider(z)(Column.Schema.float),
    type_symbol: TokenColumnProvider(type_symbol)(Column.Schema.str),
    /* No support for formal charge parsing in V3000 molfiles at the moment,
    so all charges default to 0.*/
    formal_charge: Column.ofConst(0, atomCount, Column.Schema.int)
  };
}
function handleBondsV3(tokenizer, bondCount2) {
  const atomIdxA = TokenBuilder.create(tokenizer.data, bondCount2 * 2);
  const atomIdxB = TokenBuilder.create(tokenizer.data, bondCount2 * 2);
  const order = TokenBuilder.create(tokenizer.data, bondCount2 * 2);
  for (let i = 0; i < bondCount2; ++i) {
    Tokenizer.markLine(tokenizer);
    skipSingleValue(tokenizer);
    skipSingleValue(tokenizer);
    skipSingleValue(tokenizer);
    const { position } = tokenizer;
    addSingleValue(tokenizer, order);
    addSingleValue(tokenizer, atomIdxA);
    addSingleValue(tokenizer, atomIdxB);
    tokenizer.position = position;
  }
  Tokenizer.eatLine(tokenizer);
  Tokenizer.eatLine(tokenizer);
  return {
    count: bondCount2,
    atomIdxA: TokenColumnProvider(atomIdxA)(Column.Schema.float),
    atomIdxB: TokenColumnProvider(atomIdxB)(Column.Schema.float),
    order: TokenColumnProvider(order)(Column.Schema.float)
  };
}
function skipSingleValue(tokenizer) {
  Tokenizer.skipWhitespace(tokenizer);
  Tokenizer.eatValue(tokenizer);
}
function addSingleValue(tokenizer, tokens) {
  const { position: valueStart } = tokenizer;
  Tokenizer.skipWhitespace(tokenizer);
  Tokenizer.eatValue(tokenizer);
  Tokenizer.trim(tokenizer, valueStart, tokenizer.position);
  TokenBuilder.addUnchecked(tokens, tokenizer.tokenStart, tokenizer.tokenEnd);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/sdf/parser.js
var delimiter = "$$$$";
function handleDataItems(tokenizer) {
  const dataHeader = TokenBuilder.create(tokenizer.data, 32);
  const data = TokenBuilder.create(tokenizer.data, 32);
  while (tokenizer.position < tokenizer.length) {
    const line = Tokenizer.readLine(tokenizer);
    if (line.startsWith(delimiter))
      break;
    if (!line)
      continue;
    if (line.startsWith("> ")) {
      TokenBuilder.add(dataHeader, tokenizer.tokenStart + 2, tokenizer.tokenEnd);
      Tokenizer.markLine(tokenizer);
      const start = tokenizer.tokenStart;
      let end = tokenizer.tokenEnd;
      let added = false;
      while (tokenizer.position < tokenizer.length) {
        const line2 = Tokenizer.readLine(tokenizer);
        if (!line2 || line2.startsWith(delimiter) || line2.startsWith("> ")) {
          TokenBuilder.add(data, start, end);
          added = true;
          break;
        }
        end = tokenizer.tokenEnd;
      }
      if (!added) {
        TokenBuilder.add(data, start, end);
      }
    }
  }
  return {
    dataHeader: TokenColumnProvider(dataHeader)(Column.Schema.str),
    data: TokenColumnProvider(data)(Column.Schema.str)
  };
}
function handleCountsV2(countsAndVersion) {
  return {
    atomCount: +countsAndVersion.substr(0, 3),
    bondCount: +countsAndVersion.substr(3, 3)
  };
}
function handleMolFile(tokenizer) {
  const title = Tokenizer.readLine(tokenizer).trim();
  const program = Tokenizer.readLine(tokenizer).trim();
  const comment = Tokenizer.readLine(tokenizer).trim();
  const countsAndVersion = Tokenizer.readLine(tokenizer);
  const molIsV3 = isV3(countsAndVersion);
  const { atomCount, bondCount: bondCount2 } = molIsV3 ? handleCountsV3(tokenizer) : handleCountsV2(countsAndVersion);
  if (Number.isNaN(atomCount) || Number.isNaN(bondCount2)) {
    while (tokenizer.position < tokenizer.length) {
      const line = Tokenizer.readLine(tokenizer);
      if (line.startsWith(delimiter))
        break;
    }
    return;
  }
  const nullFormalCharges = {
    atomIdx: Column.ofConst(0, atomCount, Column.Schema.int),
    charge: Column.ofConst(0, atomCount, Column.Schema.int)
  };
  const atoms = molIsV3 ? handleAtomsV3(tokenizer, atomCount) : handleAtoms4(tokenizer, atomCount);
  const bonds = molIsV3 ? handleBondsV3(tokenizer, bondCount2) : handleBonds3(tokenizer, bondCount2);
  const properties4 = molIsV3 ? { formalCharges: nullFormalCharges } : handlePropertiesBlock(tokenizer);
  const dataItems = handleDataItems(tokenizer);
  return {
    molFile: { title, program, comment, atoms, bonds, ...properties4 },
    dataItems
  };
}
function parseInternal14(data) {
  const tokenizer = Tokenizer(data);
  const compounds = [];
  while (tokenizer.position < tokenizer.length) {
    const c5 = handleMolFile(tokenizer);
    if (c5)
      compounds.push(c5);
  }
  return ReaderResult.success({ compounds });
}
function parseSdf(data) {
  return Task.create("Parse Sdf", async () => {
    return parseInternal14(data);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/sdf.js
var SdfFormat;
(function(SdfFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "sdf";
  }
  SdfFormat2.is = is3;
  function create(mol) {
    return { kind: "sdf", name: mol.molFile.title, data: mol };
  }
  SdfFormat2.create = create;
})(SdfFormat || (SdfFormat = {}));
function trajectoryFromSdf(mol) {
  return Task.create("Parse SDF", (ctx) => getMolModels(mol.molFile, SdfFormat.create(mol), ctx));
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/trr/parser.js
async function parseInternal15(data) {
  const dv = new DataView(data.buffer);
  const f = {
    frames: [],
    boxes: [],
    times: [],
    timeOffset: 0,
    deltaTime: 0
  };
  const coordinates = f.frames;
  const boxes = f.boxes;
  const times = f.times;
  let offset = 0;
  while (true) {
    offset += 8;
    const versionSize = dv.getInt32(offset);
    offset += 4;
    offset += versionSize;
    const boxSize = dv.getInt32(offset + 8);
    const virSize = dv.getInt32(offset + 12);
    const presSize = dv.getInt32(offset + 16);
    const coordSize = dv.getInt32(offset + 28);
    const velocitySize = dv.getInt32(offset + 32);
    const forceSize = dv.getInt32(offset + 36);
    const natoms = dv.getInt32(offset + 40);
    offset += 52;
    const floatSize = boxSize / 9;
    const natoms3 = natoms * 3;
    if (floatSize === 8) {
      times.push(dv.getFloat64(offset));
    } else {
      times.push(dv.getFloat32(offset));
    }
    offset += 2 * floatSize;
    if (boxSize) {
      const box2 = new Float32Array(9);
      if (floatSize === 8) {
        for (let i = 0; i < 9; ++i) {
          box2[i] = dv.getFloat64(offset) * 10;
          offset += 8;
        }
      } else {
        for (let i = 0; i < 9; ++i) {
          box2[i] = dv.getFloat32(offset) * 10;
          offset += 4;
        }
      }
      boxes.push(box2);
    }
    offset += virSize;
    offset += presSize;
    if (coordSize) {
      const x = new Float32Array(natoms);
      const y = new Float32Array(natoms);
      const z = new Float32Array(natoms);
      if (floatSize === 8) {
        for (let i = 0; i < natoms; ++i) {
          x[i] = dv.getFloat64(offset) * 10;
          y[i] = dv.getFloat64(offset + 8) * 10;
          z[i] = dv.getFloat64(offset + 16) * 10;
          offset += 24;
        }
      } else {
        const tmp = new Uint32Array(data.buffer, offset, natoms3);
        for (let i = 0; i < natoms3; ++i) {
          const value = tmp[i];
          tmp[i] = (value & 255) << 24 | (value & 65280) << 8 | value >> 8 & 65280 | value >> 24 & 255;
        }
        const frameCoords = new Float32Array(data.buffer, offset, natoms3);
        for (let i = 0; i < natoms; ++i) {
          x[i] = frameCoords[i * 3] * 10;
          y[i] = frameCoords[i * 3 + 1] * 10;
          z[i] = frameCoords[i * 3 + 2] * 10;
          offset += 12;
        }
      }
      coordinates.push({ count: natoms, x, y, z });
    }
    offset += velocitySize;
    offset += forceSize;
    if (offset >= data.byteLength)
      break;
  }
  if (times.length >= 1) {
    f.timeOffset = times[0];
  }
  if (times.length >= 2) {
    f.deltaTime = times[1] - times[0];
  }
  return f;
}
function parseTrr(data) {
  return Task.create("Parse TRR", async (ctx) => {
    try {
      ctx.update({ canAbort: true, message: "Parsing trajectory..." });
      const file = await parseInternal15(data);
      return ReaderResult.success(file);
    } catch (e) {
      return ReaderResult.error("" + e);
    }
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/trr.js
function coordinatesFromTrr(file) {
  return Task.create("Parse TRR", async (ctx) => {
    await ctx.update("Converting to coordinates");
    const deltaTime = Time(file.deltaTime, "step");
    const offsetTime = Time(file.timeOffset, deltaTime.unit);
    const frames = [];
    for (let i = 0, il = file.frames.length; i < il; ++i) {
      const box2 = file.boxes[i];
      const x = Vec3.fromArray(Vec3(), box2, 0);
      const y = Vec3.fromArray(Vec3(), box2, 3);
      const z = Vec3.fromArray(Vec3(), box2, 6);
      frames.push({
        elementCount: file.frames[i].count,
        cell: Cell.fromBasis(x, y, z),
        x: file.frames[i].x,
        y: file.frames[i].y,
        z: file.frames[i].z,
        xyzOrdering: { isIdentity: true },
        time: Time(offsetTime.value + deltaTime.value * i, deltaTime.unit)
      });
    }
    return Coordinates.create(frames, deltaTime, offsetTime);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/io-buffer.js
var defaultByteLength = 1024 * 8;
var charArray = [];
var IOBuffer = class {
  /**
   * If it's a number, it will initialize the buffer with the number as
   * the buffer's length. If it's undefined, it will initialize the buffer
   * with a default length of 8 Kb. If its an ArrayBuffer, a TypedArray,
   * it will create a view over the underlying ArrayBuffer.
   */
  constructor(data, params = {}) {
    this._mark = 0;
    this._marks = [];
    this.offset = 0;
    this.littleEndian = true;
    let dataIsGiven = false;
    if (data === void 0) {
      data = defaultByteLength;
    }
    if (typeof data === "number") {
      data = new ArrayBuffer(data);
    } else {
      dataIsGiven = true;
    }
    const offset = params.offset ? params.offset >>> 0 : 0;
    const byteLength = data.byteLength - offset;
    let dvOffset = offset;
    if (!(data instanceof ArrayBuffer)) {
      if (data.byteLength !== data.buffer.byteLength) {
        dvOffset = data.byteOffset + offset;
      }
      data = data.buffer;
    }
    if (dataIsGiven) {
      this._lastWrittenByte = byteLength;
    } else {
      this._lastWrittenByte = 0;
    }
    this.buffer = data;
    this.length = byteLength;
    this.byteLength = byteLength;
    this.byteOffset = dvOffset;
    this._data = new DataView(this.buffer, dvOffset, byteLength);
  }
  /**
   * Checks if the memory allocated to the buffer is sufficient to store more bytes after the offset
   * @param byteLength The needed memory in bytes
   */
  available(byteLength = 1) {
    return this.offset + byteLength <= this.length;
  }
  /**
   * Check if little-endian mode is used for reading and writing multi-byte values
   * Returns true if little-endian mode is used, false otherwise
   */
  isLittleEndian() {
    return this.littleEndian;
  }
  /**
   * Set little-endian mode for reading and writing multi-byte values
   */
  setLittleEndian() {
    this.littleEndian = true;
    return this;
  }
  /**
   * Check if big-endian mode is used for reading and writing multi-byte values
   * Returns true if big-endian mode is used, false otherwise
   */
  isBigEndian() {
    return !this.littleEndian;
  }
  /**
   * Switches to big-endian mode for reading and writing multi-byte values
   */
  setBigEndian() {
    this.littleEndian = false;
    return this;
  }
  /**
   * Move the pointer n bytes forward
   */
  skip(n) {
    if (n === void 0)
      n = 1;
    this.offset += n;
    return this;
  }
  /**
   * Move the pointer to the given offset
   */
  seek(offset) {
    this.offset = offset;
    return this;
  }
  /**
   * Store the current pointer offset.
   */
  mark() {
    this._mark = this.offset;
    return this;
  }
  /**
   * Move the pointer back to the last pointer offset set by mark
   */
  reset() {
    this.offset = this._mark;
    return this;
  }
  /**
   * Push the current pointer offset to the mark stack
   */
  pushMark() {
    this._marks.push(this.offset);
    return this;
  }
  /**
   * Pop the last pointer offset from the mark stack, and set the current pointer offset to the popped value
   */
  popMark() {
    const offset = this._marks.pop();
    if (offset === void 0)
      throw new Error("Mark stack empty");
    this.seek(offset);
    return this;
  }
  /**
   * Move the pointer offset back to 0
   */
  rewind() {
    this.offset = 0;
    return this;
  }
  /**
   * Make sure the buffer has sufficient memory to write a given byteLength at the current pointer offset
   * If the buffer's memory is insufficient, this method will create a new buffer (a copy) with a length
   * that is twice (byteLength + current offset)
   */
  ensureAvailable(byteLength) {
    if (byteLength === void 0)
      byteLength = 1;
    if (!this.available(byteLength)) {
      const lengthNeeded = this.offset + byteLength;
      const newLength = lengthNeeded * 2;
      const newArray = new Uint8Array(newLength);
      newArray.set(new Uint8Array(this.buffer));
      this.buffer = newArray.buffer;
      this.length = this.byteLength = newLength;
      this._data = new DataView(this.buffer);
    }
    return this;
  }
  /**
   * Read a byte and return false if the byte's value is 0, or true otherwise
   * Moves pointer forward
   */
  readBoolean() {
    return this.readUint8() !== 0;
  }
  /**
   * Read a signed 8-bit integer and move pointer forward
   */
  readInt8() {
    return this._data.getInt8(this.offset++);
  }
  /**
   * Read an unsigned 8-bit integer and move pointer forward
   */
  readUint8() {
    return this._data.getUint8(this.offset++);
  }
  /**
   * Alias for {@link IOBuffer#readUint8}
   */
  readByte() {
    return this.readUint8();
  }
  /**
   * Read n bytes and move pointer forward.
   */
  readBytes(n) {
    if (n === void 0)
      n = 1;
    const bytes = new Uint8Array(n);
    for (let i = 0; i < n; i++) {
      bytes[i] = this.readByte();
    }
    return bytes;
  }
  /**
   * Read a 16-bit signed integer and move pointer forward
   */
  readInt16() {
    const value = this._data.getInt16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  /**
   * Read a 16-bit unsigned integer and move pointer forward
   */
  readUint16() {
    const value = this._data.getUint16(this.offset, this.littleEndian);
    this.offset += 2;
    return value;
  }
  /**
   * Read a 32-bit signed integer and move pointer forward
   */
  readInt32() {
    const value = this._data.getInt32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  /**
   * Read a 32-bit unsigned integer and move pointer forward
   */
  readUint32() {
    const value = this._data.getUint32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  /**
   * Read a 32-bit floating number and move pointer forward
   */
  readFloat32() {
    const value = this._data.getFloat32(this.offset, this.littleEndian);
    this.offset += 4;
    return value;
  }
  /**
   * Read a 64-bit floating number and move pointer forward
   */
  readFloat64() {
    const value = this._data.getFloat64(this.offset, this.littleEndian);
    this.offset += 8;
    return value;
  }
  /**
   * Read 1-byte ascii character and move pointer forward
   */
  readChar() {
    return String.fromCharCode(this.readInt8());
  }
  /**
   * Read n 1-byte ascii characters and move pointer forward
   */
  readChars(n = 1) {
    charArray.length = n;
    for (let i = 0; i < n; i++) {
      charArray[i] = this.readChar();
    }
    return charArray.join("");
  }
  /**
   * Write 0xff if the passed value is truthy, 0x00 otherwise
   */
  writeBoolean(value = false) {
    this.writeUint8(value ? 255 : 0);
    return this;
  }
  /**
   * Write value as an 8-bit signed integer
   */
  writeInt8(value) {
    this.ensureAvailable(1);
    this._data.setInt8(this.offset++, value);
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write value as a 8-bit unsigned integer
   */
  writeUint8(value) {
    this.ensureAvailable(1);
    this._data.setUint8(this.offset++, value);
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * An alias for IOBuffer#writeUint8
   */
  writeByte(value) {
    return this.writeUint8(value);
  }
  /**
   * Write bytes
   */
  writeBytes(bytes) {
    this.ensureAvailable(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
      this._data.setUint8(this.offset++, bytes[i]);
    }
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write value as an 16-bit signed integer
   */
  writeInt16(value) {
    this.ensureAvailable(2);
    this._data.setInt16(this.offset, value, this.littleEndian);
    this.offset += 2;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write value as a 16-bit unsigned integer
   */
  writeUint16(value) {
    this.ensureAvailable(2);
    this._data.setUint16(this.offset, value, this.littleEndian);
    this.offset += 2;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write a 32-bit signed integer at the current pointer offset
   */
  writeInt32(value) {
    this.ensureAvailable(4);
    this._data.setInt32(this.offset, value, this.littleEndian);
    this.offset += 4;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write a 32-bit unsigned integer at the current pointer offset
   */
  writeUint32(value) {
    this.ensureAvailable(4);
    this._data.setUint32(this.offset, value, this.littleEndian);
    this.offset += 4;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write a 32-bit floating number at the current pointer offset
   */
  writeFloat32(value) {
    this.ensureAvailable(4);
    this._data.setFloat32(this.offset, value, this.littleEndian);
    this.offset += 4;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write a 64-bit floating number at the current pointer offset
   */
  writeFloat64(value) {
    this.ensureAvailable(8);
    this._data.setFloat64(this.offset, value, this.littleEndian);
    this.offset += 8;
    this._updateLastWrittenByte();
    return this;
  }
  /**
   * Write the charCode of the passed string's first character to the current pointer offset
   */
  writeChar(str3) {
    return this.writeUint8(str3.charCodeAt(0));
  }
  /**
   * Write the charCodes of the passed string's characters to the current pointer offset
   */
  writeChars(str3) {
    for (let i = 0; i < str3.length; i++) {
      this.writeUint8(str3.charCodeAt(i));
    }
    return this;
  }
  /**
   * Export a Uint8Array view of the internal buffer.
   * The view starts at the byte offset and its length
   * is calculated to stop at the last written byte or the original length.
   */
  toArray() {
    return new Uint8Array(this.buffer, this.byteOffset, this._lastWrittenByte);
  }
  /**
   * Update the last written byte offset
   */
  _updateLastWrittenByte() {
    if (this.offset > this._lastWrittenByte) {
      this._lastWrittenByte = this.offset;
    }
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/common/netcdf/reader.js
function notNetcdf(statement, reason) {
  if (statement) {
    throw new TypeError("Not a valid NetCDF v3.x file: " + reason);
  }
}
function padding(buffer2) {
  if (buffer2.offset % 4 !== 0) {
    buffer2.skip(4 - buffer2.offset % 4);
  }
}
function readName(buffer2) {
  const nameLength = buffer2.readUint32();
  const name = buffer2.readChars(nameLength);
  padding(buffer2);
  return name;
}
var types = {
  BYTE: 1,
  CHAR: 2,
  SHORT: 3,
  INT: 4,
  FLOAT: 5,
  DOUBLE: 6
};
function num2str(type) {
  switch (Number(type)) {
    case types.BYTE:
      return "byte";
    case types.CHAR:
      return "char";
    case types.SHORT:
      return "short";
    case types.INT:
      return "int";
    case types.FLOAT:
      return "float";
    case types.DOUBLE:
      return "double";
    default:
      return "undefined";
  }
}
function num2bytes(type) {
  switch (Number(type)) {
    case types.BYTE:
      return 1;
    case types.CHAR:
      return 1;
    case types.SHORT:
      return 2;
    case types.INT:
      return 4;
    case types.FLOAT:
      return 4;
    case types.DOUBLE:
      return 8;
    default:
      return -1;
  }
}
function str2num(type) {
  switch (String(type)) {
    case "byte":
      return types.BYTE;
    case "char":
      return types.CHAR;
    case "short":
      return types.SHORT;
    case "int":
      return types.INT;
    case "float":
      return types.FLOAT;
    case "double":
      return types.DOUBLE;
    default:
      return -1;
  }
}
function readNumber(size, bufferReader) {
  if (size !== 1) {
    const numbers = new Array(size);
    for (let i = 0; i < size; i++) {
      numbers[i] = bufferReader();
    }
    return numbers;
  } else {
    return bufferReader();
  }
}
function readType(buffer2, type, size) {
  switch (type) {
    case types.BYTE:
      return buffer2.readBytes(size);
    case types.CHAR:
      return trimNull(buffer2.readChars(size));
    case types.SHORT:
      return readNumber(size, buffer2.readInt16.bind(buffer2));
    case types.INT:
      return readNumber(size, buffer2.readInt32.bind(buffer2));
    case types.FLOAT:
      return readNumber(size, buffer2.readFloat32.bind(buffer2));
    case types.DOUBLE:
      return readNumber(size, buffer2.readFloat64.bind(buffer2));
    default:
      notNetcdf(true, "non valid type " + type);
      return void 0;
  }
}
function trimNull(value) {
  if (value.charCodeAt(value.length - 1) === 0) {
    return value.substring(0, value.length - 1);
  }
  return value;
}
function nonRecord(buffer2, variable) {
  const type = str2num(variable.type);
  const size = variable.size / num2bytes(type);
  const data = new Array(size);
  for (let i = 0; i < size; i++) {
    data[i] = readType(buffer2, type, 1);
  }
  return data;
}
function record(buffer2, variable, recordDimension) {
  const type = str2num(variable.type);
  const width = variable.size ? variable.size / num2bytes(type) : 1;
  const size = recordDimension.length;
  const data = new Array(size);
  const step = recordDimension.recordStep;
  for (let i = 0; i < size; i++) {
    const currentOffset = buffer2.offset;
    data[i] = readType(buffer2, type, width);
    buffer2.seek(currentOffset + step);
  }
  return data;
}
var ZERO = 0;
var NC_DIMENSION = 10;
var NC_VARIABLE = 11;
var NC_ATTRIBUTE = 12;
function header(buffer2, version) {
  const header2 = { recordDimension: { length: buffer2.readUint32() } };
  header2.version = version;
  const dimList = dimensionsList(buffer2);
  header2.recordDimension.id = dimList.recordId;
  header2.recordDimension.name = dimList.recordName;
  header2.dimensions = dimList.dimensions;
  header2.globalAttributes = attributesList(buffer2);
  const variables = variablesList(buffer2, dimList.recordId, version);
  header2.variables = variables.variables;
  header2.recordDimension.recordStep = variables.recordStep;
  return header2;
}
function dimensionsList(buffer2) {
  let dimensions, recordId, recordName2;
  const dimList = buffer2.readUint32();
  if (dimList === ZERO) {
    notNetcdf(buffer2.readUint32() !== ZERO, "wrong empty tag for list of dimensions");
    return [];
  } else {
    notNetcdf(dimList !== NC_DIMENSION, "wrong tag for list of dimensions");
    const dimensionSize = buffer2.readUint32();
    dimensions = new Array(dimensionSize);
    for (let dim = 0; dim < dimensionSize; dim++) {
      const name = readName(buffer2);
      const size = buffer2.readUint32();
      if (size === 0) {
        recordId = dim;
        recordName2 = name;
      }
      dimensions[dim] = {
        name,
        size
      };
    }
    return {
      dimensions,
      recordId,
      recordName: recordName2
    };
  }
}
function attributesList(buffer2) {
  let attributes;
  const gAttList = buffer2.readUint32();
  if (gAttList === ZERO) {
    notNetcdf(buffer2.readUint32() !== ZERO, "wrong empty tag for list of attributes");
    return [];
  } else {
    notNetcdf(gAttList !== NC_ATTRIBUTE, "wrong tag for list of attributes");
    const attributeSize = buffer2.readUint32();
    attributes = new Array(attributeSize);
    for (let gAtt = 0; gAtt < attributeSize; gAtt++) {
      const name = readName(buffer2);
      const type = buffer2.readUint32();
      notNetcdf(type < 1 || type > 6, "non valid type " + type);
      const size = buffer2.readUint32();
      const value = readType(buffer2, type, size);
      padding(buffer2);
      attributes[gAtt] = {
        name,
        type: num2str(type),
        value
      };
    }
  }
  return attributes;
}
function variablesList(buffer2, recordId, version) {
  const varList = buffer2.readUint32();
  let recordStep = 0;
  let variables;
  if (varList === ZERO) {
    notNetcdf(buffer2.readUint32() !== ZERO, "wrong empty tag for list of variables");
    return [];
  } else {
    notNetcdf(varList !== NC_VARIABLE, "wrong tag for list of variables");
    const variableSize = buffer2.readUint32();
    variables = new Array(variableSize);
    for (let v3 = 0; v3 < variableSize; v3++) {
      const name = readName(buffer2);
      const dimensionality = buffer2.readUint32();
      const dimensionsIds = new Array(dimensionality);
      for (let dim = 0; dim < dimensionality; dim++) {
        dimensionsIds[dim] = buffer2.readUint32();
      }
      const attributes = attributesList(buffer2);
      const type = buffer2.readUint32();
      notNetcdf(type < 1 && type > 6, "non valid type " + type);
      const varSize = buffer2.readUint32();
      let offset = buffer2.readUint32();
      if (version === 2) {
        notNetcdf(offset > 0, "offsets larger than 4GB not supported");
        offset = buffer2.readUint32();
      }
      if (dimensionsIds[0] === recordId) {
        recordStep += varSize;
      }
      variables[v3] = {
        name,
        dimensions: dimensionsIds,
        attributes,
        type: num2str(type),
        size: varSize,
        offset,
        record: dimensionsIds[0] === recordId
      };
    }
  }
  return {
    variables,
    recordStep
  };
}
var NetcdfReader = class {
  constructor(data) {
    const buffer2 = new IOBuffer(data);
    buffer2.setBigEndian();
    notNetcdf(buffer2.readChars(3) !== "CDF", "should start with CDF");
    const version = buffer2.readByte();
    notNetcdf(version > 2, "unknown version");
    this.header = header(buffer2, version);
    this.buffer = buffer2;
  }
  /**
   * Version for the NetCDF format
   */
  get version() {
    if (this.header.version === 1) {
      return "classic format";
    } else {
      return "64-bit offset format";
    }
  }
  get recordDimension() {
    return this.header.recordDimension;
  }
  get dimensions() {
    return this.header.dimensions;
  }
  get globalAttributes() {
    return this.header.globalAttributes;
  }
  get variables() {
    return this.header.variables;
  }
  /**
   * Checks if a variable is available
   * @param {string|object} variableName - Name of the variable to check
   * @return {Boolean} - Variable existence
   */
  hasDataVariable(variableName) {
    return this.header.variables && this.header.variables.findIndex((val) => val.name === variableName) !== -1;
  }
  /**
   * Retrieves the data for a given variable
   * @param {string|object} variableName - Name of the variable to search or variable object
   * @return {Array} - List with the variable values
   */
  getDataVariable(variableName) {
    var _a;
    let variable;
    if (typeof variableName === "string") {
      variable = (_a = this.header.variables) === null || _a === void 0 ? void 0 : _a.find((val) => val.name === variableName);
    } else {
      variable = variableName;
    }
    if (variable === void 0)
      throw new Error("variable not found");
    this.buffer.seek(variable.offset);
    if (variable.record) {
      return record(this.buffer, variable, this.header.recordDimension);
    } else {
      return nonRecord(this.buffer, variable);
    }
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-io/reader/nctraj/parser.js
async function parseInternal16(data) {
  const nc = new NetcdfReader(data);
  const f = {
    coordinates: [],
    time: [],
    timeOffset: 0,
    deltaTime: 1
  };
  for (const c5 of nc.getDataVariable("coordinates"))
    f.coordinates.push(c5);
  if (nc.hasDataVariable("velocities")) {
    const velocities = [];
    for (const v3 of nc.getDataVariable("velocities"))
      velocities.push(v3);
    f.velocities = velocities;
  }
  if (nc.hasDataVariable("forces")) {
    const forces = [];
    for (const f2 of nc.getDataVariable("forces"))
      forces.push(f2);
    f.forces = forces;
  }
  if (nc.hasDataVariable("cell_lengths")) {
    const cell_lengths = [];
    for (const l of nc.getDataVariable("cell_lengths"))
      cell_lengths.push(l);
    f.cell_lengths = cell_lengths;
  }
  if (nc.hasDataVariable("cell_angles")) {
    const cell_angles = [];
    for (const a5 of nc.getDataVariable("cell_angles"))
      cell_angles.push(a5);
    f.cell_angles = cell_angles;
  }
  if (nc.hasDataVariable("time")) {
    const time = [];
    for (const t2 of nc.getDataVariable("time"))
      time.push(t2);
    f.time = time;
  }
  if (f.time) {
    if (f.time.length >= 1) {
      f.timeOffset = f.time[0];
    }
    if (f.time.length >= 2) {
      f.deltaTime = f.time[1] - f.time[0];
    }
  }
  return f;
}
function parseNctraj(data) {
  return Task.create("Parse NCTRAJ", async (ctx) => {
    try {
      ctx.update({ canAbort: true, message: "Parsing trajectory..." });
      const file = await parseInternal16(data);
      return ReaderResult.success(file);
    } catch (e) {
      return ReaderResult.error("" + e);
    }
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/nctraj.js
function coordinatesFromNctraj(file) {
  return Task.create("Parse NCTRAJ", async (ctx) => {
    await ctx.update("Converting to coordinates");
    const deltaTime = Time(file.deltaTime, "step");
    const offsetTime = Time(file.timeOffset, deltaTime.unit);
    const frames = [];
    for (let i = 0, il = file.coordinates.length; i < il; ++i) {
      const c5 = file.coordinates[i];
      const elementCount = c5.length / 3;
      const x = new Float32Array(elementCount);
      const y = new Float32Array(elementCount);
      const z = new Float32Array(elementCount);
      for (let j = 0, jl = c5.length; j < jl; j += 3) {
        x[j / 3] = c5[j];
        y[j / 3] = c5[j + 1];
        z[j / 3] = c5[j + 2];
      }
      const frame = {
        elementCount,
        x,
        y,
        z,
        xyzOrdering: { isIdentity: true },
        time: Time(offsetTime.value + deltaTime.value * i, deltaTime.unit)
      };
      if (file.cell_lengths) {
        const lengths = file.cell_lengths[i];
        const x2 = Vec3.scale(Vec3(), Vec3.unitX, lengths[0]);
        const y2 = Vec3.scale(Vec3(), Vec3.unitY, lengths[1]);
        const z2 = Vec3.scale(Vec3(), Vec3.unitZ, lengths[2]);
        frame.cell = Cell.fromBasis(x2, y2, z2);
      }
      frames.push(frame);
    }
    return Coordinates.create(frames, deltaTime, offsetTime);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/prmtop.js
function getBasic3(prmtop) {
  const { pointers, residuePointer, residueLabel, atomName } = prmtop;
  const atomCount = pointers.NATOM;
  const residueCount = pointers.NRES;
  const residueIds = new Uint32Array(atomCount);
  const residueNames = [];
  const addResidue = (i, from2, to) => {
    const rn = residueLabel.value(i);
    for (let j = from2, jl = to; j < jl; ++j) {
      residueIds[j] = i + 1;
      residueNames[j] = rn;
    }
  };
  for (let i = 0, il = residueCount - 1; i < il; ++i) {
    addResidue(i, residuePointer.value(i) - 1, residuePointer.value(i + 1) - 1);
  }
  addResidue(residueCount - 1, residuePointer.value(residueCount - 1) - 1, atomCount);
  const residueId = Column.ofIntArray(residueIds);
  const residueName = Column.ofStringArray(residueNames);
  const entityIds = new Array(atomCount);
  const asymIds = new Array(atomCount);
  const seqIds = new Uint32Array(atomCount);
  const ids = new Uint32Array(atomCount);
  const entityBuilder = new EntityBuilder();
  const componentBuilder = new ComponentBuilder(residueId, atomName);
  let currentEntityId = "";
  let currentAsymIndex = 0;
  let currentAsymId = "";
  let currentSeqId = 0;
  let prevMoleculeType = MoleculeType.Unknown;
  let prevResidueNumber = -1;
  for (let i = 0, il = atomCount; i < il; ++i) {
    const residueNumber = residueId.value(i);
    if (residueNumber !== prevResidueNumber) {
      const compId2 = residueName.value(i);
      const moleculeType = getMoleculeType(componentBuilder.add(compId2, i).type, compId2);
      if (moleculeType !== prevMoleculeType) {
        currentAsymId = getChainId(currentAsymIndex);
        currentAsymIndex += 1;
        currentSeqId = 0;
      }
      currentEntityId = entityBuilder.getEntityId(compId2, moleculeType, currentAsymId);
      currentSeqId += 1;
      prevResidueNumber = residueNumber;
      prevMoleculeType = moleculeType;
    }
    entityIds[i] = currentEntityId;
    asymIds[i] = currentAsymId;
    seqIds[i] = currentSeqId;
    ids[i] = i;
  }
  const id = Column.ofIntArray(ids);
  const asym_id = Column.ofStringArray(asymIds);
  const type_symbol = new Array(atomCount);
  for (let i = 0; i < atomCount; ++i) {
    type_symbol[i] = guessElementSymbolString(atomName.value(i), residueName.value(i));
  }
  const atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
    auth_asym_id: asym_id,
    auth_atom_id: Column.asArrayColumn(atomName),
    auth_comp_id: residueName,
    auth_seq_id: residueId,
    id: Column.asArrayColumn(id),
    label_asym_id: asym_id,
    label_atom_id: Column.asArrayColumn(atomName),
    label_comp_id: residueName,
    label_seq_id: Column.ofIntArray(seqIds),
    label_entity_id: Column.ofStringArray(entityIds),
    occupancy: Column.ofConst(1, atomCount, Column.Schema.float),
    type_symbol: Column.ofStringArray(type_symbol),
    pdbx_PDB_model_num: Column.ofConst(1, atomCount, Column.Schema.int)
  }, atomCount);
  const basic = createBasic({
    entity: entityBuilder.getEntityTable(),
    chem_comp: componentBuilder.getChemCompTable(),
    atom_site
  });
  return basic;
}
var PrmtopFormat;
(function(PrmtopFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "prmtop";
  }
  PrmtopFormat2.is = is3;
  function fromPrmtop(prmtop) {
    return { kind: "prmtop", name: prmtop.title.join(" ") || "PRMTOP", data: prmtop };
  }
  PrmtopFormat2.fromPrmtop = fromPrmtop;
})(PrmtopFormat || (PrmtopFormat = {}));
function topologyFromPrmtop(prmtop) {
  return Task.create("Parse PRMTOP", async (ctx) => {
    const format = PrmtopFormat.fromPrmtop(prmtop);
    const basic = getBasic3(prmtop);
    const { pointers: { NBONH, NBONA }, bondsIncHydrogen, bondsWithoutHydrogen } = prmtop;
    const bondCount2 = NBONH + NBONA;
    const bonds = {
      indexA: Column.ofLambda({
        value: (row) => {
          return row < NBONH ? bondsIncHydrogen.value(row * 3) / 3 : bondsWithoutHydrogen.value((row - NBONH) * 3) / 3;
        },
        rowCount: bondCount2,
        schema: Column.Schema.int
      }),
      indexB: Column.ofLambda({
        value: (row) => {
          return row < NBONH ? bondsIncHydrogen.value(row * 3 + 1) / 3 : bondsWithoutHydrogen.value((row - NBONH) * 3 + 1) / 3;
        },
        rowCount: bondCount2,
        schema: Column.Schema.int
      }),
      order: Column.ofConst(1, bondCount2, Column.Schema.int)
    };
    return Topology.create(prmtop.title.join(" ") || "PRMTOP", basic, bonds, format);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-formats/structure/top.js
function getBasic4(top) {
  const { molecules, compounds } = top;
  const singleResidue = {};
  let atomCount = 0;
  for (let i = 0, il = molecules._rowCount; i < il; ++i) {
    const mol = molecules.compound.value(i);
    const count3 = molecules.molCount.value(i);
    const { atoms } = compounds[mol];
    Column.asArrayColumn(atoms.atom);
    Column.asArrayColumn(atoms.resnr);
    Column.asArrayColumn(atoms.residu);
    atomCount += count3 * atoms._rowCount;
    let prevResnr = atoms.resnr.value(0);
    singleResidue[mol] = true;
    for (let j = 1, jl = atoms._rowCount; j < jl; ++j) {
      const resnr = atoms.resnr.value(j);
      if (resnr !== prevResnr) {
        singleResidue[mol] = false;
        break;
      }
      prevResnr = resnr;
    }
  }
  const atomNames = new Array(atomCount);
  const residueIds = new Uint32Array(atomCount);
  const residueNames = new Array(atomCount);
  let k = 0;
  for (let i = 0, il = molecules._rowCount; i < il; ++i) {
    const mol = molecules.compound.value(i);
    const count3 = molecules.molCount.value(i);
    const { atoms } = compounds[mol];
    const isSingleResidue = singleResidue[mol];
    for (let j = 0; j < count3; ++j) {
      for (let l = 0, ll = atoms._rowCount; l < ll; ++l) {
        atomNames[k] = atoms.atom.value(l);
        residueIds[k] = atoms.resnr.value(l);
        residueNames[k] = atoms.residu.value(l);
        if (isSingleResidue)
          residueIds[k] += j;
        k += 1;
      }
    }
  }
  const atomName = Column.ofStringArray(atomNames);
  const residueId = Column.ofIntArray(residueIds);
  const residueName = Column.ofStringArray(residueNames);
  const entityIds = new Array(atomCount);
  const asymIds = new Array(atomCount);
  const seqIds = new Uint32Array(atomCount);
  const ids = new Uint32Array(atomCount);
  const entityBuilder = new EntityBuilder();
  const componentBuilder = new ComponentBuilder(residueId, atomName);
  let currentEntityId = "";
  let currentAsymIndex = 0;
  let currentAsymId = "";
  let currentSeqId = 0;
  let prevMoleculeType = MoleculeType.Unknown;
  let prevResidueNumber = -1;
  for (let i = 0, il = atomCount; i < il; ++i) {
    const residueNumber = residueId.value(i);
    if (residueNumber !== prevResidueNumber) {
      const compId2 = residueName.value(i);
      const moleculeType = getMoleculeType(componentBuilder.add(compId2, i).type, compId2);
      if (moleculeType !== prevMoleculeType) {
        currentAsymId = getChainId(currentAsymIndex);
        currentAsymIndex += 1;
        currentSeqId = 0;
      }
      currentEntityId = entityBuilder.getEntityId(compId2, moleculeType, currentAsymId);
      currentSeqId += 1;
      prevResidueNumber = residueNumber;
      prevMoleculeType = moleculeType;
    }
    entityIds[i] = currentEntityId;
    asymIds[i] = currentAsymId;
    seqIds[i] = currentSeqId;
    ids[i] = i;
  }
  const id = Column.ofIntArray(ids);
  const asym_id = Column.ofStringArray(asymIds);
  const type_symbol = new Array(atomCount);
  for (let i = 0; i < atomCount; ++i) {
    type_symbol[i] = guessElementSymbolString(atomName.value(i), residueName.value(i));
  }
  const atom_site = Table.ofPartialColumns(BasicSchema.atom_site, {
    auth_asym_id: asym_id,
    auth_atom_id: Column.asArrayColumn(atomName),
    auth_comp_id: residueName,
    auth_seq_id: residueId,
    id: Column.asArrayColumn(id),
    label_asym_id: asym_id,
    label_atom_id: Column.asArrayColumn(atomName),
    label_comp_id: residueName,
    label_seq_id: Column.ofIntArray(seqIds),
    label_entity_id: Column.ofStringArray(entityIds),
    occupancy: Column.ofConst(1, atomCount, Column.Schema.float),
    type_symbol: Column.ofStringArray(type_symbol),
    pdbx_PDB_model_num: Column.ofConst(1, atomCount, Column.Schema.int)
  }, atomCount);
  const basic = createBasic({
    entity: entityBuilder.getEntityTable(),
    chem_comp: componentBuilder.getChemCompTable(),
    atom_site
  });
  return basic;
}
function getBonds(top) {
  const { molecules, compounds } = top;
  const indexA = [];
  const indexB = [];
  let atomOffset = 0;
  for (let i = 0, il = molecules._rowCount; i < il; ++i) {
    const mol = molecules.compound.value(i);
    const count3 = molecules.molCount.value(i);
    const { atoms, bonds } = compounds[mol];
    if (bonds) {
      for (let j = 0; j < count3; ++j) {
        for (let l = 0, ll = bonds._rowCount; l < ll; ++l) {
          indexA.push(bonds.ai.value(l) - 1 + atomOffset);
          indexB.push(bonds.aj.value(l) - 1 + atomOffset);
        }
        atomOffset += atoms._rowCount;
      }
    } else if (mol === "TIP3") {
      for (let j = 0; j < count3; ++j) {
        indexA.push(0 + atomOffset);
        indexB.push(1 + atomOffset);
        indexA.push(0 + atomOffset);
        indexB.push(2 + atomOffset);
        atomOffset += atoms._rowCount;
      }
    } else {
      atomOffset += count3 * atoms._rowCount;
    }
  }
  return {
    indexA: Column.ofIntArray(indexA),
    indexB: Column.ofIntArray(indexB),
    order: Column.ofConst(1, indexA.length, Column.Schema.int)
  };
}
var TopFormat;
(function(TopFormat2) {
  function is3(x) {
    return (x === null || x === void 0 ? void 0 : x.kind) === "top";
  }
  TopFormat2.is = is3;
  function fromTop(top) {
    return { kind: "top", name: top.system || "TOP", data: top };
  }
  TopFormat2.fromTop = fromTop;
})(TopFormat || (TopFormat = {}));
function topologyFromTop(top) {
  return Task.create("Parse TOP", async (ctx) => {
    const format = TopFormat.fromTop(top);
    const basic = getBasic4(top);
    const bonds = getBonds(top);
    return Topology.create(top.system || "TOP", basic, bonds, format);
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/transforms/model.js
var CoordinatesFromDcd = PluginStateTransform.BuiltIn({
  name: "coordinates-from-dcd",
  display: { name: "Parse DCD", description: "Parse DCD binary data." },
  from: [PluginStateObject.Data.Binary],
  to: PluginStateObject.Molecule.Coordinates
})({
  apply({ a: a5 }) {
    return Task.create("Parse DCD", async (ctx) => {
      const parsed = await parseDcd(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const coordinates = await coordinatesFromDcd(parsed.result).runInContext(ctx);
      return new PluginStateObject.Molecule.Coordinates(coordinates, { label: a5.label, description: "Coordinates" });
    });
  }
});
var CoordinatesFromXtc = PluginStateTransform.BuiltIn({
  name: "coordinates-from-xtc",
  display: { name: "Parse XTC", description: "Parse XTC binary data." },
  from: [PluginStateObject.Data.Binary],
  to: PluginStateObject.Molecule.Coordinates
})({
  apply({ a: a5 }) {
    return Task.create("Parse XTC", async (ctx) => {
      const parsed = await parseXtc(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const coordinates = await coordinatesFromXtc(parsed.result).runInContext(ctx);
      return new PluginStateObject.Molecule.Coordinates(coordinates, { label: a5.label, description: "Coordinates" });
    });
  }
});
var CoordinatesFromTrr = PluginStateTransform.BuiltIn({
  name: "coordinates-from-trr",
  display: { name: "Parse TRR", description: "Parse TRR binary data." },
  from: [PluginStateObject.Data.Binary],
  to: PluginStateObject.Molecule.Coordinates
})({
  apply({ a: a5 }) {
    return Task.create("Parse TRR", async (ctx) => {
      const parsed = await parseTrr(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const coordinates = await coordinatesFromTrr(parsed.result).runInContext(ctx);
      return new PluginStateObject.Molecule.Coordinates(coordinates, { label: a5.label, description: "Coordinates" });
    });
  }
});
var CoordinatesFromNctraj = PluginStateTransform.BuiltIn({
  name: "coordinates-from-nctraj",
  display: { name: "Parse NCTRAJ", description: "Parse NCTRAJ binary data." },
  from: [PluginStateObject.Data.Binary],
  to: PluginStateObject.Molecule.Coordinates
})({
  apply({ a: a5 }) {
    return Task.create("Parse NCTRAJ", async (ctx) => {
      const parsed = await parseNctraj(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const coordinates = await coordinatesFromNctraj(parsed.result).runInContext(ctx);
      return new PluginStateObject.Molecule.Coordinates(coordinates, { label: a5.label, description: "Coordinates" });
    });
  }
});
var CoordinatesFromLammpstraj = PluginStateTransform.BuiltIn({
  name: "coordinates-from-lammpstraj",
  display: { name: "Parse LAMMPSTRAJ", description: "Parse LAMMPSTRAJ data." },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Molecule.Coordinates
})({
  apply({ a: a5 }) {
    return Task.create("Parse LAMMPSTRAJ", async (ctx) => {
      const parsed = await parseLammpsTrajectory(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const coordinates = await coordinatesFromLammpsTrajectory(parsed.result).runInContext(ctx);
      return new PluginStateObject.Molecule.Coordinates(coordinates, { label: a5.label, description: "Coordinates" });
    });
  }
});
var TopologyFromPsf = PluginStateTransform.BuiltIn({
  name: "topology-from-psf",
  display: { name: "PSF Topology", description: "Create topology from PSF." },
  from: [PluginStateObject.Format.Psf],
  to: PluginStateObject.Molecule.Topology
})({
  apply({ a: a5 }) {
    return Task.create("Create Topology", async (ctx) => {
      const topology = await topologyFromPsf(a5.data).runInContext(ctx);
      return new PluginStateObject.Molecule.Topology(topology, { label: topology.label || a5.label, description: "Topology" });
    });
  }
});
var TopologyFromPrmtop = PluginStateTransform.BuiltIn({
  name: "topology-from-prmtop",
  display: { name: "PRMTOP Topology", description: "Create topology from PRMTOP." },
  from: [PluginStateObject.Format.Prmtop],
  to: PluginStateObject.Molecule.Topology
})({
  apply({ a: a5 }) {
    return Task.create("Create Topology", async (ctx) => {
      const topology = await topologyFromPrmtop(a5.data).runInContext(ctx);
      return new PluginStateObject.Molecule.Topology(topology, { label: topology.label || a5.label, description: "Topology" });
    });
  }
});
var TopologyFromTop = PluginStateTransform.BuiltIn({
  name: "topology-from-top",
  display: { name: "TOP Topology", description: "Create topology from TOP." },
  from: [PluginStateObject.Format.Top],
  to: PluginStateObject.Molecule.Topology
})({
  apply({ a: a5 }) {
    return Task.create("Create Topology", async (ctx) => {
      const topology = await topologyFromTop(a5.data).runInContext(ctx);
      return new PluginStateObject.Molecule.Topology(topology, { label: topology.label || a5.label, description: "Topology" });
    });
  }
});
async function getTrajectory(ctx, obj, coordinates) {
  if (obj.type === PluginStateObject.Molecule.Topology.type) {
    const topology = obj.data;
    return await Model.trajectoryFromTopologyAndCoordinates(topology, coordinates).runInContext(ctx);
  } else if (obj.type === PluginStateObject.Molecule.Model.type) {
    const model = obj.data;
    return Model.trajectoryFromModelAndCoordinates(model, coordinates);
  }
  throw new Error("no model/topology found");
}
var TrajectoryFromModelAndCoordinates = PluginStateTransform.BuiltIn({
  name: "trajectory-from-model-and-coordinates",
  display: { name: "Trajectory from Topology & Coordinates", description: "Create a trajectory from existing model/topology and coordinates." },
  from: PluginStateObject.Root,
  to: PluginStateObject.Molecule.Trajectory,
  params: {
    modelRef: ParamDefinition.Text("", { isHidden: true }),
    coordinatesRef: ParamDefinition.Text("", { isHidden: true })
  }
})({
  apply({ params, dependencies }) {
    return Task.create("Create trajectory from model/topology and coordinates", async (ctx) => {
      const coordinates = dependencies[params.coordinatesRef].data;
      const trajectory = await getTrajectory(ctx, dependencies[params.modelRef], coordinates);
      const props = { label: "Trajectory", description: `${trajectory.frameCount} model${trajectory.frameCount === 1 ? "" : "s"}` };
      return new PluginStateObject.Molecule.Trajectory(trajectory, props);
    });
  }
});
var TrajectoryFromBlob = PluginStateTransform.BuiltIn({
  name: "trajectory-from-blob",
  display: { name: "Parse Blob", description: "Parse format blob into a single trajectory." },
  from: PluginStateObject.Format.Blob,
  to: PluginStateObject.Molecule.Trajectory
})({
  apply({ a: a5 }) {
    return Task.create("Parse Format Blob", async (ctx) => {
      const models = [];
      for (const e of a5.data) {
        if (e.kind !== "cif")
          continue;
        const block = e.data.blocks[0];
        const xs = await trajectoryFromMmCIF(block).runInContext(ctx);
        if (xs.frameCount === 0)
          throw new Error("No models found.");
        for (let i = 0; i < xs.frameCount; i++) {
          const x = await Task.resolveInContext(xs.getFrameAtIndex(i), ctx);
          models.push(x);
        }
      }
      for (let i = 0; i < models.length; i++) {
        Model.TrajectoryInfo.set(models[i], { index: i, size: models.length });
      }
      const props = { label: "Trajectory", description: `${models.length} model${models.length === 1 ? "" : "s"}` };
      return new PluginStateObject.Molecule.Trajectory(new ArrayTrajectory(models), props);
    });
  }
});
function trajectoryProps(trajectory) {
  const first4 = trajectory.representative;
  return { label: `${first4.entry}`, description: `${trajectory.frameCount} model${trajectory.frameCount === 1 ? "" : "s"}` };
}
var TrajectoryFromMmCif = PluginStateTransform.BuiltIn({
  name: "trajectory-from-mmcif",
  display: { name: "Trajectory from mmCIF", description: "Identify and create all separate models in the specified CIF data block" },
  from: PluginStateObject.Format.Cif,
  to: PluginStateObject.Molecule.Trajectory,
  params(a5) {
    if (!a5) {
      return {
        loadAllBlocks: ParamDefinition.Optional(ParamDefinition.Boolean(false, { description: "If True, ignore Block Header and Block Index parameters and parse all datablocks into a single trajectory." })),
        blockHeader: ParamDefinition.Optional(ParamDefinition.Text(void 0, { description: "Header of the block to parse. If not specifed, Block Index parameter applies.", hideIf: (p) => p.loadAllBlocks === true })),
        blockIndex: ParamDefinition.Optional(ParamDefinition.Numeric(0, { min: 0, step: 1 }, { description: "Zero-based index of the block to parse. Only applies when Block Header parameter is not specified.", hideIf: (p) => p.loadAllBlocks === true || p.blockHeader }))
      };
    }
    const { blocks } = a5.data;
    const headers = blocks.map((b5) => [b5.header, b5.header]);
    headers.push(["", "[Use Block Index]"]);
    return {
      loadAllBlocks: ParamDefinition.Optional(ParamDefinition.Boolean(false, { description: "If True, ignore Block Header and Block Index parameters and parse all data blocks into a single trajectory." })),
      blockHeader: ParamDefinition.Optional(ParamDefinition.Select(blocks[0] && blocks[0].header, headers, { description: "Header of the block to parse. If not specifed, Block Index parameter applies.", hideIf: (p) => p.loadAllBlocks === true })),
      blockIndex: ParamDefinition.Optional(ParamDefinition.Numeric(0, { min: 0, step: 1, max: blocks.length - 1 }, { description: "Zero-based index of the block to parse. Only applies when Block Header parameter is not specified.", hideIf: (p) => p.loadAllBlocks === true || p.blockHeader }))
    };
  }
})({
  isApplicable: (a5) => a5.data.blocks.length > 0,
  apply({ a: a5, params }) {
    return Task.create("Parse mmCIF", async (ctx) => {
      var _a;
      let trajectory;
      if (params.loadAllBlocks) {
        const models = [];
        for (const block of a5.data.blocks) {
          if (ctx.shouldUpdate) {
            await ctx.update(`Parsing ${block.header}...`);
          }
          const t2 = await trajectoryFromMmCIF(block).runInContext(ctx);
          for (let i = 0; i < t2.frameCount; i++) {
            models.push(await Task.resolveInContext(t2.getFrameAtIndex(i), ctx));
          }
        }
        trajectory = new ArrayTrajectory(models);
      } else {
        const header2 = params.blockHeader || a5.data.blocks[(_a = params.blockIndex) !== null && _a !== void 0 ? _a : 0].header;
        const block = a5.data.blocks.find((b5) => b5.header === header2);
        if (!block)
          throw new Error(`Data block '${[header2]}' not found.`);
        const isCcd = block.categoryNames.includes("chem_comp_atom") && !block.categoryNames.includes("atom_site") && !block.categoryNames.includes("ihm_sphere_obj_site") && !block.categoryNames.includes("ihm_gaussian_obj_site");
        trajectory = isCcd ? await trajectoryFromCCD(block).runInContext(ctx) : await trajectoryFromMmCIF(block, a5.data).runInContext(ctx);
      }
      if (trajectory.frameCount === 0)
        throw new Error("No models found.");
      const props = trajectoryProps(trajectory);
      return new PluginStateObject.Molecule.Trajectory(trajectory, props);
    });
  }
});
var TrajectoryFromPDB = PluginStateTransform.BuiltIn({
  name: "trajectory-from-pdb",
  display: { name: "Parse PDB", description: "Parse PDB string and create trajectory." },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Molecule.Trajectory,
  params: {
    isPdbqt: ParamDefinition.Boolean(false)
  }
})({
  apply({ a: a5, params }) {
    return Task.create("Parse PDB", async (ctx) => {
      const parsed = await parsePDB(a5.data, a5.label, params.isPdbqt).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const models = await trajectoryFromPDB(parsed.result).runInContext(ctx);
      const props = trajectoryProps(models);
      return new PluginStateObject.Molecule.Trajectory(models, props);
    });
  }
});
var TrajectoryFromGRO = PluginStateTransform.BuiltIn({
  name: "trajectory-from-gro",
  display: { name: "Parse GRO", description: "Parse GRO string and create trajectory." },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Molecule.Trajectory
})({
  apply({ a: a5 }) {
    return Task.create("Parse GRO", async (ctx) => {
      const parsed = await parseGRO(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const models = await trajectoryFromGRO(parsed.result).runInContext(ctx);
      const props = trajectoryProps(models);
      return new PluginStateObject.Molecule.Trajectory(models, props);
    });
  }
});
var TrajectoryFromXYZ = PluginStateTransform.BuiltIn({
  name: "trajectory-from-xyz",
  display: { name: "Parse XYZ", description: "Parse XYZ string and create trajectory." },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Molecule.Trajectory
})({
  apply({ a: a5 }) {
    return Task.create("Parse XYZ", async (ctx) => {
      const parsed = await parseXyz(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const models = await trajectoryFromXyz(parsed.result).runInContext(ctx);
      const props = trajectoryProps(models);
      return new PluginStateObject.Molecule.Trajectory(models, props);
    });
  }
});
var TrajectoryFromLammpsData = PluginStateTransform.BuiltIn({
  name: "trajectory-from-lammps-data",
  display: { name: "Parse Lammps Data", description: "Parse Lammps Data from string and create trajectory." },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Molecule.Trajectory,
  params: {
    unitsStyle: ParamDefinition.Select("real", ParamDefinition.arrayToOptions(UnitStyles))
  }
})({
  apply({ a: a5, params }) {
    return Task.create("Parse Lammps Data", async (ctx) => {
      const parsed = await parseLammpsData(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const models = await trajectoryFromLammpsData(parsed.result, params.unitsStyle).runInContext(ctx);
      const props = trajectoryProps(models);
      return new PluginStateObject.Molecule.Trajectory(models, props);
    });
  }
});
var TrajectoryFromLammpsTrajData = PluginStateTransform.BuiltIn({
  name: "trajectory-from-lammps-traj-data",
  display: { name: "Parse Lammps traj Data", description: "Parse Lammps Traj Data string and create trajectory." },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Molecule.Trajectory,
  params: {
    unitsStyle: ParamDefinition.Select("real", ParamDefinition.arrayToOptions(UnitStyles))
  }
})({
  apply({ a: a5, params }) {
    return Task.create("Parse Lammps Data", async (ctx) => {
      const parsed = await parseLammpsTrajectory(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const models = await trajectoryFromLammpsTrajectory(parsed.result, params.unitsStyle).runInContext(ctx);
      const props = trajectoryProps(models);
      return new PluginStateObject.Molecule.Trajectory(models, props);
    });
  }
});
var TrajectoryFromMOL = PluginStateTransform.BuiltIn({
  name: "trajectory-from-mol",
  display: { name: "Parse MOL", description: "Parse MOL string and create trajectory." },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Molecule.Trajectory
})({
  apply({ a: a5 }) {
    return Task.create("Parse MOL", async (ctx) => {
      const parsed = await parseMol(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const models = await trajectoryFromMol(parsed.result).runInContext(ctx);
      const props = trajectoryProps(models);
      return new PluginStateObject.Molecule.Trajectory(models, props);
    });
  }
});
var TrajectoryFromSDF = PluginStateTransform.BuiltIn({
  name: "trajectory-from-sdf",
  display: { name: "Parse SDF", description: "Parse SDF string and create trajectory." },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Molecule.Trajectory
})({
  apply({ a: a5 }) {
    return Task.create("Parse SDF", async (ctx) => {
      const parsed = await parseSdf(a5.data).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const models = [];
      for (const compound of parsed.result.compounds) {
        const traj2 = await trajectoryFromSdf(compound).runInContext(ctx);
        for (let i = 0; i < traj2.frameCount; i++) {
          models.push(await Task.resolveInContext(traj2.getFrameAtIndex(i), ctx));
        }
      }
      const traj = new ArrayTrajectory(models);
      const props = trajectoryProps(traj);
      return new PluginStateObject.Molecule.Trajectory(traj, props);
    });
  }
});
var TrajectoryFromMOL2 = PluginStateTransform.BuiltIn({
  name: "trajectory-from-mol2",
  display: { name: "Parse MOL2", description: "Parse MOL2 string and create trajectory." },
  from: [PluginStateObject.Data.String],
  to: PluginStateObject.Molecule.Trajectory
})({
  apply({ a: a5 }) {
    return Task.create("Parse MOL2", async (ctx) => {
      const parsed = await parseMol2(a5.data, a5.label).runInContext(ctx);
      if (parsed.isError)
        throw new Error(parsed.message);
      const models = await trajectoryFromMol2(parsed.result).runInContext(ctx);
      const props = trajectoryProps(models);
      return new PluginStateObject.Molecule.Trajectory(models, props);
    });
  }
});
var TrajectoryFromCube = PluginStateTransform.BuiltIn({
  name: "trajectory-from-cube",
  display: { name: "Parse Cube", description: "Parse Cube file to create a trajectory." },
  from: PluginStateObject.Format.Cube,
  to: PluginStateObject.Molecule.Trajectory
})({
  apply({ a: a5 }) {
    return Task.create("Parse MOL", async (ctx) => {
      const models = await trajectoryFromCube(a5.data).runInContext(ctx);
      const props = trajectoryProps(models);
      return new PluginStateObject.Molecule.Trajectory(models, props);
    });
  }
});
var TrajectoryFromCifCore = PluginStateTransform.BuiltIn({
  name: "trajectory-from-cif-core",
  display: { name: "Parse CIF Core", description: "Identify and create all separate models in the specified CIF data block" },
  from: PluginStateObject.Format.Cif,
  to: PluginStateObject.Molecule.Trajectory,
  params(a5) {
    if (!a5) {
      return {
        blockHeader: ParamDefinition.Optional(ParamDefinition.Text(void 0, { description: "Header of the block to parse. If none is specifed, the 1st data block in the file is used." }))
      };
    }
    const { blocks } = a5.data;
    return {
      blockHeader: ParamDefinition.Optional(ParamDefinition.Select(blocks[0] && blocks[0].header, blocks.map((b5) => [b5.header, b5.header]), { description: "Header of the block to parse" }))
    };
  }
})({
  apply({ a: a5, params }) {
    return Task.create("Parse CIF Core", async (ctx) => {
      const header2 = params.blockHeader || a5.data.blocks[0].header;
      const block = a5.data.blocks.find((b5) => b5.header === header2);
      if (!block)
        throw new Error(`Data block '${[header2]}' not found.`);
      const models = await trajectoryFromCifCore(block).runInContext(ctx);
      if (models.frameCount === 0)
        throw new Error("No models found.");
      const props = trajectoryProps(models);
      return new PluginStateObject.Molecule.Trajectory(models, props);
    });
  }
});
var plus1 = (v3) => v3 + 1;
var minus1 = (v3) => v3 - 1;
var ModelFromTrajectory = PluginStateTransform.BuiltIn({
  name: "model-from-trajectory",
  display: { name: "Molecular Model", description: "Create a molecular model from specified index in a trajectory." },
  from: PluginStateObject.Molecule.Trajectory,
  to: PluginStateObject.Molecule.Model,
  params: (a5) => {
    if (!a5) {
      return { modelIndex: ParamDefinition.Numeric(0, {}, { description: "Zero-based index of the model", immediateUpdate: true }) };
    }
    return { modelIndex: ParamDefinition.Converted(plus1, minus1, ParamDefinition.Numeric(1, { min: 1, max: a5.data.frameCount, step: 1 }, { description: "Model Index", immediateUpdate: true })) };
  }
})({
  isApplicable: (a5) => a5.data.frameCount > 0,
  apply({ a: a5, params }) {
    return Task.create("Model from Trajectory", async (ctx) => {
      let modelIndex = params.modelIndex % a5.data.frameCount;
      if (modelIndex < 0)
        modelIndex += a5.data.frameCount;
      const model = await Task.resolveInContext(a5.data.getFrameAtIndex(modelIndex), ctx);
      const label2 = `Model ${modelIndex + 1}`;
      const description = a5.data.frameCount === 1 ? void 0 : `of ${a5.data.frameCount}`;
      return new PluginStateObject.Molecule.Model(model, { label: label2, description });
    });
  },
  interpolate(a5, b5, t2) {
    const modelIndex = t2 >= 1 ? b5.modelIndex : a5.modelIndex + Math.floor((b5.modelIndex - a5.modelIndex + 1) * t2);
    return { modelIndex };
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customProperties.dispose();
  }
});
var StructureFromTrajectory = PluginStateTransform.BuiltIn({
  name: "structure-from-trajectory",
  display: { name: "Structure from Trajectory", description: "Create a molecular structure from a trajectory." },
  from: PluginStateObject.Molecule.Trajectory,
  to: PluginStateObject.Molecule.Structure
})({
  apply({ a: a5 }) {
    return Task.create("Build Structure", async (ctx) => {
      const s = await Structure.ofTrajectory(a5.data, ctx);
      const props = { label: "Ensemble", description: Structure.elementDescription(s) };
      return new PluginStateObject.Molecule.Structure(s, props);
    });
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customPropertyDescriptors.dispose();
  }
});
var StructureFromModel = PluginStateTransform.BuiltIn({
  name: "structure-from-model",
  display: { name: "Structure", description: "Create a molecular structure (model, assembly, or symmetry) from the specified model." },
  from: PluginStateObject.Molecule.Model,
  to: PluginStateObject.Molecule.Structure,
  params(a5) {
    return RootStructureDefinition.getParams(a5 && a5.data);
  }
})({
  canAutoUpdate({ oldParams, newParams }) {
    return RootStructureDefinition.canAutoUpdate(oldParams.type, newParams.type);
  },
  apply({ a: a5, params }, plugin) {
    return Task.create("Build Structure", async (ctx) => {
      return RootStructureDefinition.create(plugin, ctx, a5.data, params && params.type);
    });
  },
  update: ({ a: a5, b: b5, oldParams, newParams }) => {
    if (!deepEqual(oldParams, newParams))
      return Transformer.UpdateResult.Recreate;
    if (b5.data.model === a5.data)
      return Transformer.UpdateResult.Unchanged;
    if (!Model.areHierarchiesEqual(a5.data, b5.data.model))
      return Transformer.UpdateResult.Recreate;
    b5.data = b5.data.remapModel(a5.data);
    return Transformer.UpdateResult.Updated;
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customPropertyDescriptors.dispose();
  }
});
var _translation = Vec3();
var _m = Mat4();
var _n = Mat4();
var TransformStructureConformation = PluginStateTransform.BuiltIn({
  name: "transform-structure-conformation",
  display: { name: "Transform Conformation" },
  isDecorator: true,
  from: PluginStateObject.Molecule.Structure,
  to: PluginStateObject.Molecule.Structure,
  params: {
    transform: ParamDefinition.MappedStatic("components", {
      components: ParamDefinition.Group({
        axis: ParamDefinition.Vec3(Vec3.create(1, 0, 0)),
        angle: ParamDefinition.Numeric(0, { min: -180, max: 180, step: 0.1 }),
        translation: ParamDefinition.Vec3(Vec3.create(0, 0, 0))
      }, { isFlat: true }),
      matrix: ParamDefinition.Group({
        data: ParamDefinition.Mat4(Mat4.identity()),
        transpose: ParamDefinition.Boolean(false)
      }, { isFlat: true })
    }, { label: "Kind" })
  }
})({
  canAutoUpdate({ newParams }) {
    return newParams.transform.name !== "matrix";
  },
  apply({ a: a5, params }) {
    const transform = Mat4();
    if (params.transform.name === "components") {
      const { axis, angle, translation } = params.transform.params;
      const center = a5.data.boundary.sphere.center;
      Mat4.fromTranslation(_m, Vec3.negate(_translation, center));
      Mat4.fromTranslation(_n, Vec3.add(_translation, center, translation));
      const rot = Mat4.fromRotation(Mat4(), Math.PI / 180 * angle, Vec3.normalize(Vec3(), axis));
      Mat4.mul3(transform, _n, rot, _m);
    } else if (params.transform.name === "matrix") {
      Mat4.copy(transform, params.transform.params.data);
      if (params.transform.params.transpose)
        Mat4.transpose(transform, transform);
    }
    const s = Structure.transform(a5.data, transform);
    return new PluginStateObject.Molecule.Structure(s, { label: a5.label, description: `${a5.description} [Transformed]` });
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customPropertyDescriptors.dispose();
  }
  // interpolate(src, tar, t) {
  //     // TODO: optimize
  //     const u = Mat4.fromRotation(Mat4(), Math.PI / 180 * src.angle, Vec3.normalize(Vec3(), src.axis));
  //     Mat4.setTranslation(u, src.translation);
  //     const v = Mat4.fromRotation(Mat4(), Math.PI / 180 * tar.angle, Vec3.normalize(Vec3(), tar.axis));
  //     Mat4.setTranslation(v, tar.translation);
  //     const m = SymmetryOperator.slerp(Mat4(), u, v, t);
  //     const rot = Mat4.getRotation(Quat.zero(), m);
  //     const axis = Vec3();
  //     const angle = Quat.getAxisAngle(axis, rot);
  //     const translation = Mat4.getTranslation(Vec3(), m);
  //     return { axis, angle, translation };
  // }
});
var ModelWithCoordinates = PluginStateTransform.BuiltIn({
  name: "model-with-coordinates",
  display: { name: "Model With Coordinates", description: "Updates the current model with provided coordinate frame" },
  from: PluginStateObject.Molecule.Model,
  to: PluginStateObject.Molecule.Model,
  params: {
    frameIndex: ParamDefinition.Optional(ParamDefinition.Numeric(0, void 0, { isHidden: true })),
    frameCount: ParamDefinition.Optional(ParamDefinition.Numeric(1, void 0, { isHidden: true })),
    atomicCoordinateFrame: ParamDefinition.Optional(ParamDefinition.Value(void 0, { isHidden: true }))
  },
  isDecorator: true
})({
  apply({ a: a5, params }) {
    var _a, _b;
    if (!params.atomicCoordinateFrame) {
      return a5;
    }
    const model = { ...a5.data, atomicConformation: Model.getAtomicConformationFromFrame(a5.data, params.atomicCoordinateFrame) };
    Model.TrajectoryInfo.set(model, { index: (_a = params.frameIndex) !== null && _a !== void 0 ? _a : 0, size: (_b = params.frameCount) !== null && _b !== void 0 ? _b : 1 });
    return new PluginStateObject.Molecule.Model(model, { label: a5.label, description: a5.description });
  },
  update: ({ a: a5, b: b5, oldParams, newParams }) => {
    var _a, _b;
    if (oldParams.atomicCoordinateFrame === newParams.atomicCoordinateFrame) {
      return Transformer.UpdateResult.Unchanged;
    }
    if (!newParams.atomicCoordinateFrame) {
      b5.data = a5.data;
    } else {
      b5.data = { ...b5.data, atomicConformation: Model.getAtomicConformationFromFrame(b5.data, newParams.atomicCoordinateFrame) };
    }
    Model.TrajectoryInfo.set(b5.data, { index: (_a = newParams.frameIndex) !== null && _a !== void 0 ? _a : 0, size: (_b = newParams.frameCount) !== null && _b !== void 0 ? _b : 1 });
    return Transformer.UpdateResult.Updated;
  }
});
var StructureSelectionFromExpression = PluginStateTransform.BuiltIn({
  name: "structure-selection-from-expression",
  display: { name: "Selection", description: "Create a molecular structure from the specified expression." },
  from: PluginStateObject.Molecule.Structure,
  to: PluginStateObject.Molecule.Structure,
  params: () => ({
    expression: ParamDefinition.Value(MolScriptBuilder.struct.generator.all, { isHidden: true }),
    label: ParamDefinition.Optional(ParamDefinition.Text("", { isHidden: true }))
  })
})({
  apply({ a: a5, params, cache }) {
    const { selection, entry } = StructureQueryHelper.createAndRun(a5.data, params.expression);
    cache.entry = entry;
    if (StructureSelection.isEmpty(selection))
      return StateObject.Null;
    const s = StructureSelection.unionStructure(selection);
    const props = { label: `${params.label || "Selection"}`, description: Structure.elementDescription(s) };
    return new PluginStateObject.Molecule.Structure(s, props);
  },
  update: ({ a: a5, b: b5, oldParams, newParams, cache }) => {
    if (oldParams.expression !== newParams.expression)
      return Transformer.UpdateResult.Recreate;
    const entry = cache.entry;
    if (entry.currentStructure === a5.data) {
      return Transformer.UpdateResult.Unchanged;
    }
    const selection = StructureQueryHelper.updateStructure(entry, a5.data);
    if (StructureSelection.isEmpty(selection))
      return Transformer.UpdateResult.Null;
    StructureQueryHelper.updateStructureObject(b5, selection, newParams.label);
    return Transformer.UpdateResult.Updated;
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customPropertyDescriptors.dispose();
  }
});
var MultiStructureSelectionFromExpression = PluginStateTransform.BuiltIn({
  name: "structure-multi-selection-from-expression",
  display: { name: "Multi-structure Measurement Selection", description: "Create selection object from multiple structures." },
  from: PluginStateObject.Root,
  to: PluginStateObject.Molecule.Structure.Selections,
  params: () => ({
    selections: ParamDefinition.ObjectList({
      key: ParamDefinition.Text(void 0, { description: "A unique key." }),
      ref: ParamDefinition.Text(),
      groupId: ParamDefinition.Optional(ParamDefinition.Text()),
      expression: ParamDefinition.Value(MolScriptBuilder.struct.generator.empty)
    }, (e) => e.ref, { isHidden: true }),
    isTransitive: ParamDefinition.Optional(ParamDefinition.Boolean(false, { isHidden: true, description: "Remap the selections from the original structure if structurally equivalent." })),
    label: ParamDefinition.Optional(ParamDefinition.Text("", { isHidden: true }))
  })
})({
  apply({ params, cache, dependencies }) {
    const entries3 = /* @__PURE__ */ new Map();
    const selections = [];
    let totalSize = 0;
    for (const sel of params.selections) {
      const { selection, entry } = StructureQueryHelper.createAndRun(dependencies[sel.ref].data, sel.expression);
      entries3.set(sel.key, entry);
      const loci = StructureSelection.toLociWithSourceUnits(selection);
      selections.push({ key: sel.key, structureRef: sel.ref, loci, groupId: sel.groupId });
      totalSize += element_exports.Loci.size(loci);
    }
    cache.entries = entries3;
    const props = { label: `${params.label || "Multi-selection"}`, description: `${params.selections.length} source(s), ${totalSize} element(s) total` };
    return new PluginStateObject.Molecule.Structure.Selections(selections, props);
  },
  update: ({ b: b5, oldParams, newParams, cache, dependencies }) => {
    if (!!oldParams.isTransitive !== !!newParams.isTransitive)
      return Transformer.UpdateResult.Recreate;
    const cacheEntries = cache.entries;
    const entries3 = /* @__PURE__ */ new Map();
    const current3 = /* @__PURE__ */ new Map();
    for (const e of b5.data)
      current3.set(e.key, e);
    let changed = false;
    let totalSize = 0;
    const selections = [];
    for (const sel of newParams.selections) {
      const structure = dependencies[sel.ref].data;
      let recreate = false;
      if (cacheEntries.has(sel.key)) {
        const entry = cacheEntries.get(sel.key);
        if (StructureQueryHelper.isUnchanged(entry, sel.expression, structure) && current3.has(sel.key)) {
          const loci = current3.get(sel.key);
          if (loci.groupId !== sel.groupId) {
            loci.groupId = sel.groupId;
            changed = true;
          }
          entries3.set(sel.key, entry);
          selections.push(loci);
          totalSize += element_exports.Loci.size(loci.loci);
          continue;
        }
        if (entry.expression !== sel.expression) {
          recreate = true;
        } else {
          let update10 = false;
          if (!!newParams.isTransitive) {
            if (Structure.areUnitIdsAndIndicesEqual(entry.originalStructure, structure)) {
              const selection = StructureQueryHelper.run(entry, entry.originalStructure);
              entry.currentStructure = structure;
              entries3.set(sel.key, entry);
              const loci = element_exports.Loci.remap(StructureSelection.toLociWithSourceUnits(selection), structure);
              selections.push({ key: sel.key, structureRef: sel.ref, loci, groupId: sel.groupId });
              totalSize += element_exports.Loci.size(loci);
              changed = true;
            } else {
              update10 = true;
            }
          } else {
            update10 = true;
          }
          if (update10) {
            changed = true;
            const selection = StructureQueryHelper.updateStructure(entry, structure);
            entries3.set(sel.key, entry);
            const loci = StructureSelection.toLociWithSourceUnits(selection);
            selections.push({ key: sel.key, structureRef: sel.ref, loci, groupId: sel.groupId });
            totalSize += element_exports.Loci.size(loci);
          }
        }
      } else {
        recreate = true;
      }
      if (recreate) {
        changed = true;
        const { selection, entry } = StructureQueryHelper.createAndRun(structure, sel.expression);
        entries3.set(sel.key, entry);
        const loci = StructureSelection.toLociWithSourceUnits(selection);
        selections.push({ key: sel.key, structureRef: sel.ref, loci, groupId: sel.groupId });
        totalSize += element_exports.Loci.size(loci);
      }
    }
    if (!changed)
      return Transformer.UpdateResult.Unchanged;
    cache.entries = entries3;
    b5.data = selections;
    b5.label = `${newParams.label || "Multi-selection"}`;
    b5.description = `${selections.length} source(s), ${totalSize} element(s) total`;
    return Transformer.UpdateResult.Updated;
  }
});
var MultiStructureSelectionFromBundle = PluginStateTransform.BuiltIn({
  name: "structure-multi-selection-from-bundle",
  display: { name: "Multi-structure Measurement Selection", description: "Create selection object from multiple structures." },
  from: PluginStateObject.Root,
  to: PluginStateObject.Molecule.Structure.Selections,
  params: () => ({
    selections: ParamDefinition.ObjectList({
      key: ParamDefinition.Text(void 0, { description: "A unique key." }),
      ref: ParamDefinition.Text(),
      groupId: ParamDefinition.Optional(ParamDefinition.Text()),
      bundle: ParamDefinition.Value(element_exports.Bundle.Empty)
    }, (e) => e.ref, { isHidden: true }),
    isTransitive: ParamDefinition.Optional(ParamDefinition.Boolean(false, { isHidden: true, description: "Remap the selections from the original structure if structurally equivalent." })),
    label: ParamDefinition.Optional(ParamDefinition.Text("", { isHidden: true }))
  })
})({
  apply({ params, cache, dependencies }) {
    const entries3 = /* @__PURE__ */ new Map();
    const selections = [];
    let totalSize = 0;
    for (const sel of params.selections) {
      const source = dependencies[sel.ref].data;
      const loci = element_exports.Bundle.toLoci(sel.bundle, source);
      selections.push({ key: sel.key, structureRef: sel.ref, loci, groupId: sel.groupId });
      totalSize += element_exports.Loci.size(loci);
      entries3.set(sel.key, { source });
    }
    cache.entries = entries3;
    const props = { label: `${params.label || "Multi-selection"}`, description: `${params.selections.length} source(s), ${totalSize} element(s) total` };
    return new PluginStateObject.Molecule.Structure.Selections(selections, props);
  },
  update: ({ b: b5, oldParams, newParams, cache, dependencies }) => {
    if (!!oldParams.isTransitive !== !!newParams.isTransitive)
      return Transformer.UpdateResult.Recreate;
    const cacheEntries = cache.entries;
    const entries3 = /* @__PURE__ */ new Map();
    const prevBundles = /* @__PURE__ */ new Map();
    for (const sel of oldParams.selections) {
      prevBundles.set(sel.key, sel.bundle);
    }
    const current3 = /* @__PURE__ */ new Map();
    for (const e of b5.data)
      current3.set(e.key, e);
    let changed = false;
    let totalSize = 0;
    const selections = [];
    for (const sel of newParams.selections) {
      let recreate = false;
      if (cacheEntries.has(sel.key)) {
        const source = dependencies[sel.ref].data;
        const entry = cacheEntries.get(sel.key);
        const prev = prevBundles.get(sel.key);
        if (prev && source === entry.source && sel.bundle.hash === entry.source.hashCode && element_exports.Bundle.areEqual(sel.bundle, prev)) {
          const loci = current3.get(sel.key);
          if (loci.groupId !== sel.groupId) {
            loci.groupId = sel.groupId;
            changed = true;
          }
          entries3.set(sel.key, entry);
          selections.push(loci);
          totalSize += element_exports.Loci.size(loci.loci);
          continue;
        }
        recreate = true;
      } else {
        recreate = true;
      }
      if (recreate) {
        changed = true;
        const source = dependencies[sel.ref].data;
        const loci = element_exports.Bundle.toLoci(sel.bundle, source);
        selections.push({ key: sel.key, structureRef: sel.ref, loci, groupId: sel.groupId });
        totalSize += element_exports.Loci.size(loci);
        entries3.set(sel.key, { source });
      }
    }
    if (!changed)
      return Transformer.UpdateResult.Unchanged;
    cache.entries = entries3;
    b5.data = selections;
    b5.label = `${newParams.label || "Multi-selection"}`;
    b5.description = `${selections.length} source(s), ${totalSize} element(s) total`;
    return Transformer.UpdateResult.Updated;
  }
});
var StructureSelectionFromScript = PluginStateTransform.BuiltIn({
  name: "structure-selection-from-script",
  display: { name: "Selection", description: "Create a molecular structure from the specified script." },
  from: PluginStateObject.Molecule.Structure,
  to: PluginStateObject.Molecule.Structure,
  params: () => ({
    script: ParamDefinition.Script({ language: "mol-script", expression: "(sel.atom.atom-groups :residue-test (= atom.resname ALA))" }),
    label: ParamDefinition.Optional(ParamDefinition.Text(""))
  })
})({
  apply({ a: a5, params, cache }) {
    const { selection, entry } = StructureQueryHelper.createAndRun(a5.data, params.script);
    cache.entry = entry;
    const s = StructureSelection.unionStructure(selection);
    const props = { label: `${params.label || "Selection"}`, description: Structure.elementDescription(s) };
    return new PluginStateObject.Molecule.Structure(s, props);
  },
  update: ({ a: a5, b: b5, oldParams, newParams, cache }) => {
    if (!Script.areEqual(oldParams.script, newParams.script)) {
      return Transformer.UpdateResult.Recreate;
    }
    const entry = cache.entry;
    if (entry.currentStructure === a5.data) {
      return Transformer.UpdateResult.Unchanged;
    }
    const selection = StructureQueryHelper.updateStructure(entry, a5.data);
    StructureQueryHelper.updateStructureObject(b5, selection, newParams.label);
    return Transformer.UpdateResult.Updated;
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customPropertyDescriptors.dispose();
  }
});
var StructureSelectionFromBundle = PluginStateTransform.BuiltIn({
  name: "structure-selection-from-bundle",
  display: { name: "Selection", description: "Create a molecular structure from the specified structure-element bundle." },
  from: PluginStateObject.Molecule.Structure,
  to: PluginStateObject.Molecule.Structure,
  params: () => ({
    bundle: ParamDefinition.Value(element_exports.Bundle.Empty, { isHidden: true }),
    label: ParamDefinition.Optional(ParamDefinition.Text("", { isHidden: true }))
  })
})({
  apply({ a: a5, params, cache }) {
    if (params.bundle.hash !== a5.data.hashCode) {
      return StateObject.Null;
    }
    cache.source = a5.data;
    const s = element_exports.Bundle.toStructure(params.bundle, a5.data);
    if (s.elementCount === 0)
      return StateObject.Null;
    const props = { label: `${params.label || "Selection"}`, description: Structure.elementDescription(s) };
    return new PluginStateObject.Molecule.Structure(s, props);
  },
  update: ({ a: a5, b: b5, oldParams, newParams, cache }) => {
    if (!element_exports.Bundle.areEqual(oldParams.bundle, newParams.bundle)) {
      return Transformer.UpdateResult.Recreate;
    }
    if (newParams.bundle.hash !== a5.data.hashCode) {
      return Transformer.UpdateResult.Null;
    }
    if (cache.source === a5.data) {
      return Transformer.UpdateResult.Unchanged;
    }
    cache.source = a5.data;
    const s = element_exports.Bundle.toStructure(newParams.bundle, a5.data);
    if (s.elementCount === 0)
      return Transformer.UpdateResult.Null;
    b5.label = `${newParams.label || "Selection"}`;
    b5.description = Structure.elementDescription(s);
    b5.data = s;
    return Transformer.UpdateResult.Updated;
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customPropertyDescriptors.dispose();
  }
});
var StructureComplexElementTypes = {
  "polymer": "polymer",
  "protein": "protein",
  "nucleic": "nucleic",
  "water": "water",
  "branched": "branched",
  // = carbs
  "ligand": "ligand",
  "non-standard": "non-standard",
  "coarse": "coarse",
  // Legacy
  "atomic-sequence": "atomic-sequence",
  "atomic-het": "atomic-het",
  "spheres": "spheres"
};
var StructureComplexElementTypeTuples = ParamDefinition.objectToOptions(StructureComplexElementTypes);
var StructureComplexElement = PluginStateTransform.BuiltIn({
  name: "structure-complex-element",
  display: { name: "Complex Element", description: "Create a molecular structure from the specified model." },
  from: PluginStateObject.Molecule.Structure,
  to: PluginStateObject.Molecule.Structure,
  params: { type: ParamDefinition.Select("atomic-sequence", StructureComplexElementTypeTuples, { isHidden: true }) }
})({
  apply({ a: a5, params }) {
    let query, label2;
    switch (params.type) {
      case "polymer":
        query = StructureSelectionQueries.polymer.query;
        label2 = "Polymer";
        break;
      case "protein":
        query = StructureSelectionQueries.protein.query;
        label2 = "Protein";
        break;
      case "nucleic":
        query = StructureSelectionQueries.nucleic.query;
        label2 = "Nucleic";
        break;
      case "water":
        query = Queries.internal.water();
        label2 = "Water";
        break;
      case "branched":
        query = StructureSelectionQueries.branchedPlusConnected.query;
        label2 = "Branched";
        break;
      case "ligand":
        query = StructureSelectionQueries.ligandPlusConnected.query;
        label2 = "Ligand";
        break;
      case "non-standard":
        query = StructureSelectionQueries.nonStandardPolymer.query;
        label2 = "Non-standard";
        break;
      case "coarse":
        query = StructureSelectionQueries.coarse.query;
        label2 = "Coarse";
        break;
      case "atomic-sequence":
        query = Queries.internal.atomicSequence();
        label2 = "Sequence";
        break;
      case "atomic-het":
        query = Queries.internal.atomicHet();
        label2 = "HET Groups/Ligands";
        break;
      case "spheres":
        query = Queries.internal.spheres();
        label2 = "Coarse Spheres";
        break;
      default:
        assertUnreachable(params.type);
    }
    const result = query(new QueryContext(a5.data));
    const s = StructureSelection.unionStructure(result);
    if (s.elementCount === 0)
      return StateObject.Null;
    return new PluginStateObject.Molecule.Structure(s, { label: label2, description: Structure.elementDescription(s) });
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customPropertyDescriptors.dispose();
  }
});
var StructureComponent = PluginStateTransform.BuiltIn({
  name: "structure-component",
  display: { name: "Component", description: "A molecular structure component." },
  from: PluginStateObject.Molecule.Structure,
  to: PluginStateObject.Molecule.Structure,
  params: StructureComponentParams
})({
  apply({ a: a5, params, cache }) {
    return createStructureComponent(a5.data, params, cache);
  },
  update: ({ a: a5, b: b5, oldParams, newParams, cache }) => {
    return updateStructureComponent(a5.data, b5, oldParams, newParams, cache);
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customPropertyDescriptors.dispose();
  }
});
var CustomModelProperties = PluginStateTransform.BuiltIn({
  name: "custom-model-properties",
  display: { name: "Custom Model Properties" },
  isDecorator: true,
  from: PluginStateObject.Molecule.Model,
  to: PluginStateObject.Molecule.Model,
  params: (a5, ctx) => {
    return ctx.customModelProperties.getParams(a5 === null || a5 === void 0 ? void 0 : a5.data);
  }
})({
  apply({ a: a5, params }, ctx) {
    return Task.create("Custom Props", async (taskCtx) => {
      await attachModelProps(a5.data, ctx, taskCtx, params);
      return new PluginStateObject.Molecule.Model(a5.data, { label: a5.label, description: a5.description });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams }, ctx) {
    return Task.create("Custom Props", async (taskCtx) => {
      b5.data = a5.data;
      b5.label = a5.label;
      b5.description = a5.description;
      for (const name of oldParams.autoAttach) {
        const property = ctx.customModelProperties.get(name);
        if (!property)
          continue;
        a5.data.customProperties.reference(property.descriptor, false);
      }
      await attachModelProps(a5.data, ctx, taskCtx, newParams);
      return Transformer.UpdateResult.Updated;
    });
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customProperties.dispose();
  }
});
async function attachModelProps(model, ctx, taskCtx, params) {
  const propertyCtx = { runtime: taskCtx, assetManager: ctx.managers.asset, errorContext: ctx.errorContext };
  const { autoAttach, properties: properties4 } = params;
  for (const name of Object.keys(properties4)) {
    const property = ctx.customModelProperties.get(name);
    const props = properties4[name];
    if (autoAttach.includes(name) || property.isHidden) {
      try {
        await property.attach(propertyCtx, model, props, true);
      } catch (e) {
        ctx.log.warn(`Error attaching model prop '${name}': ${e}`);
      }
    } else {
      property.set(model, props);
    }
  }
}
var CustomStructureProperties = PluginStateTransform.BuiltIn({
  name: "custom-structure-properties",
  display: { name: "Custom Structure Properties" },
  isDecorator: true,
  from: PluginStateObject.Molecule.Structure,
  to: PluginStateObject.Molecule.Structure,
  params: (a5, ctx) => {
    return ctx.customStructureProperties.getParams(a5 === null || a5 === void 0 ? void 0 : a5.data.root);
  }
})({
  apply({ a: a5, params }, ctx) {
    return Task.create("Custom Props", async (taskCtx) => {
      await attachStructureProps(a5.data.root, ctx, taskCtx, params);
      return new PluginStateObject.Molecule.Structure(a5.data, { label: a5.label, description: a5.description });
    });
  },
  update({ a: a5, b: b5, oldParams, newParams }, ctx) {
    if (a5.data !== b5.data)
      return Transformer.UpdateResult.Recreate;
    return Task.create("Custom Props", async (taskCtx) => {
      b5.data = a5.data;
      b5.label = a5.label;
      b5.description = a5.description;
      for (const name of oldParams.autoAttach) {
        const property = ctx.customStructureProperties.get(name);
        if (!property)
          continue;
        a5.data.customPropertyDescriptors.reference(property.descriptor, false);
      }
      await attachStructureProps(a5.data.root, ctx, taskCtx, newParams);
      return Transformer.UpdateResult.Updated;
    });
  },
  dispose({ b: b5 }) {
    b5 === null || b5 === void 0 ? void 0 : b5.data.customPropertyDescriptors.dispose();
  }
});
async function attachStructureProps(structure, ctx, taskCtx, params) {
  const propertyCtx = { runtime: taskCtx, assetManager: ctx.managers.asset, errorContext: ctx.errorContext };
  const { autoAttach, properties: properties4 } = params;
  for (const name of Object.keys(properties4)) {
    const property = ctx.customStructureProperties.get(name);
    const props = properties4[name];
    if (autoAttach.includes(name) || property.isHidden) {
      try {
        await property.attach(propertyCtx, structure, props, true);
      } catch (e) {
        ctx.log.warn(`Error attaching structure prop '${name}': ${e}`);
      }
    } else {
      property.set(structure, props);
    }
  }
}
var ShapeFromPly = PluginStateTransform.BuiltIn({
  name: "shape-from-ply",
  display: { name: "Shape from PLY", description: "Create Shape from PLY data" },
  from: PluginStateObject.Format.Ply,
  to: PluginStateObject.Shape.Provider,
  params(a5) {
    return {
      transforms: ParamDefinition.Optional(ParamDefinition.Value([], { isHidden: true })),
      label: ParamDefinition.Optional(ParamDefinition.Text("", { isHidden: true }))
    };
  }
})({
  apply({ a: a5, params }) {
    return Task.create("Create shape from PLY", async (ctx) => {
      const shape = await shapeFromPly(a5.data, params).runInContext(ctx);
      const props = { label: params.label || "Shape" };
      return new PluginStateObject.Shape.Provider(shape, props);
    });
  }
});

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin/behavior/behavior.js
var PluginBehavior;
(function(PluginBehavior2) {
  class Root extends PluginStateObject.Create({ name: "Root", typeClass: "Root" }) {
  }
  PluginBehavior2.Root = Root;
  class Category extends PluginStateObject.Create({ name: "Category", typeClass: "Object" }) {
  }
  PluginBehavior2.Category = Category;
  class Behavior extends PluginStateObject.CreateBehavior({ name: "Behavior" }) {
  }
  PluginBehavior2.Behavior = Behavior;
  PluginBehavior2.Categories = {
    "common": "Common",
    "representation": "Representation",
    "interaction": "Interaction",
    "custom-props": "Custom Properties",
    "misc": "Miscellaneous"
  };
  PluginBehavior2.CreateCategory = PluginStateTransform.BuiltIn({
    name: "create-behavior-category",
    display: { name: "Behavior Category" },
    from: Root,
    to: Category,
    params: {
      label: ParamDefinition.Text("", { isHidden: true })
    }
  })({
    apply({ params }) {
      return new Category({}, { label: params.label });
    }
  });
  const categoryMap = /* @__PURE__ */ new Map();
  function getCategoryId(t2) {
    return categoryMap.get(t2.id);
  }
  PluginBehavior2.getCategoryId = getCategoryId;
  function create(params) {
    const t2 = PluginStateTransform.CreateBuiltIn({
      name: params.name,
      display: params.display,
      from: [Root],
      to: [Behavior],
      params: params.params,
      apply({ params: p }, ctx) {
        const label2 = params.label ? params.label(p) : { label: params.display.name, description: params.display.description };
        return new Behavior(new params.ctor(ctx, p), label2);
      },
      update({ b: b5, newParams }) {
        return Task.create("Update Behavior", async () => {
          if (!b5.data.update)
            return Transformer.UpdateResult.Unchanged;
          const updated = await b5.data.update(newParams);
          return updated ? Transformer.UpdateResult.Updated : Transformer.UpdateResult.Unchanged;
        });
      },
      canAutoUpdate: params.canAutoUpdate
    });
    categoryMap.set(t2.id, params.category);
    return t2;
  }
  PluginBehavior2.create = create;
  function simpleCommandHandler(cmd, action) {
    return class {
      register() {
        this.sub = cmd.subscribe(this.ctx, (data) => action(data, this.ctx));
      }
      dispose() {
        if (this.sub)
          this.sub.unsubscribe();
        this.sub = void 0;
      }
      // TODO can't be private due to bug with generating declerations, see https://github.com/Microsoft/TypeScript/issues/17293
      constructor(ctx) {
        this.ctx = ctx;
        this.sub = void 0;
      }
    };
  }
  PluginBehavior2.simpleCommandHandler = simpleCommandHandler;
  class Handler {
    subscribeCommand(cmd, action) {
      this.subs.push(cmd.subscribe(this.ctx, action));
    }
    subscribeObservable(o, action) {
      this.subs.push(o.subscribe(action));
    }
    track(sub) {
      this.subs.push(sub);
    }
    dispose() {
      for (const s of this.subs)
        s.unsubscribe();
      this.subs = [];
    }
    update(params) {
      if (shallowEqualObjects(params, this.params))
        return false;
      this.params = params;
      return true;
    }
    constructor(ctx, params) {
      this.ctx = ctx;
      this.params = params;
      this.subs = [];
    }
  }
  PluginBehavior2.Handler = Handler;
  class WithSubscribers {
    subscribeCommand(cmd, action) {
      this.subs.push(cmd.subscribe(this.plugin, action));
    }
    subscribeObservable(o, action) {
      const sub = o.subscribe(action);
      this.subs.push(sub);
      return {
        unsubscribe: () => {
          const idx = this.subs.indexOf(sub);
          if (idx >= 0) {
            this.subs.splice(idx, 1);
            sub.unsubscribe();
          }
        }
      };
    }
    dispose() {
      for (const s of this.subs)
        s.unsubscribe();
      this.subs = [];
    }
    constructor(plugin, params) {
      this.plugin = plugin;
      this.params = params;
      this.subs = [];
    }
  }
  PluginBehavior2.WithSubscribers = WithSubscribers;
})(PluginBehavior || (PluginBehavior = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/component.js
var PluginComponent = class {
  constructor() {
    this.subs = void 0;
  }
  subscribe(obs, action) {
    if (!obs)
      return { unsubscribe: () => {
      } };
    if (typeof this.subs === "undefined")
      this.subs = [];
    let sub = obs.subscribe(action);
    this.subs.push(sub);
    return {
      unsubscribe: () => {
        if (sub && this.subs && arraySetRemove(this.subs, sub)) {
          sub.unsubscribe();
          sub = void 0;
        }
      }
    };
  }
  get ev() {
    return this._ev || (this._ev = RxEventHelper.create());
  }
  dispose() {
    if (this._ev)
      this._ev.dispose();
    if (this.subs) {
      for (const s of this.subs)
        s.unsubscribe();
      this.subs = void 0;
    }
  }
};
var StatefulPluginComponent = class extends PluginComponent {
  updateState(...states) {
    const latest2 = this.state;
    const s = shallowMergeArray(latest2, states);
    if (s !== latest2) {
      this._state = s;
      return true;
    }
    return false;
  }
  get state() {
    return this._state;
  }
  constructor(initialState) {
    super();
    this._state = initialState;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin/version.js
var PLUGIN_VERSION = "4.18.0";
var PLUGIN_VERSION_DATE = new Date(typeof __MOLSTAR_DEBUG_TIMESTAMP__ !== "undefined" ? __MOLSTAR_DEBUG_TIMESTAMP__ : 1749415137622);

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/util.js
function setCanvasSize(canvas, width, height, scale = 1) {
  canvas.width = Math.round(window.devicePixelRatio * scale * width);
  canvas.height = Math.round(window.devicePixelRatio * scale * height);
  Object.assign(canvas.style, { width: `${width}px`, height: `${height}px` });
}
function resizeCanvas(canvas, container, scale = 1) {
  let width = window.innerWidth;
  let height = window.innerHeight;
  if (container !== document.body) {
    width = container.offsetWidth;
    height = container.offsetHeight;
  }
  setCanvasSize(canvas, width, height, scale);
}
function _canvasToBlob(canvas, callback, type, quality) {
  const bin = atob(canvas.toDataURL(type, quality).split(",")[1]);
  const len = bin.length;
  const len32 = len >> 2;
  const a8 = new Uint8Array(len);
  const a32 = new Uint32Array(a8.buffer, 0, len32);
  let j = 0;
  for (let i = 0; i < len32; ++i) {
    a32[i] = bin.charCodeAt(j++) | bin.charCodeAt(j++) << 8 | bin.charCodeAt(j++) << 16 | bin.charCodeAt(j++) << 24;
  }
  let tailLength = len & 3;
  while (tailLength--)
    a8[j] = bin.charCodeAt(j++);
  callback(new Blob([a8], { type: type || "image/png" }));
}
async function canvasToBlob(canvas, type, quality) {
  return new Promise((resolve, reject) => {
    const callback = (blob) => {
      if (blob)
        resolve(blob);
      else
        reject("no blob returned");
    };
    if (!HTMLCanvasElement.prototype.toBlob) {
      _canvasToBlob(canvas, callback, type, quality);
    } else {
      canvas.toBlob(callback, type, quality);
    }
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/manager/snapshots.js
var PluginStateSnapshotManager = class _PluginStateSnapshotManager extends StatefulPluginComponent {
  get current() {
    const id = this.state.current;
    return this.state.entries.find((e) => e.snapshot.id === id);
  }
  getIndex(e) {
    return this.state.entries.indexOf(e);
  }
  getEntry(id) {
    if (!id)
      return;
    return this.entryMap.get(id);
  }
  remove(id) {
    const e = this.entryMap.get(id);
    if (!e)
      return;
    if (e === null || e === void 0 ? void 0 : e.image)
      this.plugin.managers.asset.delete(e.image);
    this.entryMap.delete(id);
    this.updateState({
      current: this.state.current === id ? void 0 : this.state.current,
      entries: this.state.entries.delete(this.getIndex(e))
    });
    this.events.changed.next(void 0);
  }
  add(e) {
    this.entryMap.set(e.snapshot.id, e);
    this.updateState({ current: e.snapshot.id, entries: this.state.entries.push(e) });
    this.events.changed.next(void 0);
  }
  replace(id, snapshot, params) {
    var _a, _b, _c, _d;
    const old = this.getEntry(id);
    if (!old)
      return;
    this.defaultSnapshotId = void 0;
    if (old === null || old === void 0 ? void 0 : old.image)
      this.plugin.managers.asset.delete(old.image);
    const idx = this.getIndex(old);
    const e = _PluginStateSnapshotManager.Entry(snapshot, {
      key: (_a = params === null || params === void 0 ? void 0 : params.key) !== null && _a !== void 0 ? _a : old.key,
      name: (_b = params === null || params === void 0 ? void 0 : params.name) !== null && _b !== void 0 ? _b : old.name,
      description: (_c = params === null || params === void 0 ? void 0 : params.description) !== null && _c !== void 0 ? _c : old.description,
      descriptionFormat: (_d = params === null || params === void 0 ? void 0 : params.descriptionFormat) !== null && _d !== void 0 ? _d : old.descriptionFormat,
      image: params === null || params === void 0 ? void 0 : params.image
    });
    this.entryMap.set(snapshot.id, e);
    this.updateState({ current: e.snapshot.id, entries: this.state.entries.set(idx, e) });
    this.events.changed.next(void 0);
  }
  move(id, dir) {
    const len = this.state.entries.size;
    if (len < 2)
      return;
    const e = this.getEntry(id);
    if (!e)
      return;
    const from2 = this.getIndex(e);
    let to = (from2 + dir) % len;
    if (to < 0)
      to += len;
    const f = this.state.entries.get(to);
    const entries3 = this.state.entries.asMutable();
    entries3.set(to, e);
    entries3.set(from2, f);
    this.updateState({ current: e.snapshot.id, entries: entries3.asImmutable() });
    this.events.changed.next(void 0);
  }
  update(e, options) {
    var _a, _b, _c;
    const idx = this.getIndex(e);
    if (idx < 0)
      return;
    const entries3 = this.state.entries.set(idx, {
      ...e,
      key: ((_a = options.key) === null || _a === void 0 ? void 0 : _a.trim()) || void 0,
      name: ((_b = options.name) === null || _b === void 0 ? void 0 : _b.trim()) || void 0,
      description: ((_c = options.description) === null || _c === void 0 ? void 0 : _c.trim()) || void 0,
      descriptionFormat: options.descriptionFormat
    });
    this.updateState({ entries: entries3 });
    this.entryMap.set(e.snapshot.id, this.state.entries.get(idx));
    this.events.changed.next(void 0);
  }
  clear() {
    if (this.state.entries.size === 0)
      return;
    this.entryMap.forEach((e) => {
      if (e === null || e === void 0 ? void 0 : e.image)
        this.plugin.managers.asset.delete(e.image);
    });
    this.entryMap.clear();
    this.updateState({ current: void 0, entries: List() });
    this.events.changed.next(void 0);
  }
  applyKey(key2) {
    const e = this.state.entries.find((e2) => e2.key === key2);
    if (!e)
      return;
    this.updateState({ current: e.snapshot.id });
    this.events.changed.next(void 0);
    this.plugin.state.setSnapshot(e.snapshot);
  }
  setCurrent(id) {
    const e = this.getEntry(id);
    if (e) {
      this.updateState({ current: id });
      this.events.changed.next(void 0);
    }
    return e && e.snapshot;
  }
  getNextId(id, dir) {
    const len = this.state.entries.size;
    if (!id) {
      if (len === 0)
        return void 0;
      const idx2 = dir === -1 ? len - 1 : 0;
      return this.state.entries.get(idx2).snapshot.id;
    }
    const e = this.getEntry(id);
    if (!e)
      return;
    let idx = this.getIndex(e);
    if (idx < 0)
      return;
    idx = (idx + dir) % len;
    if (idx < 0)
      idx += len;
    return this.state.entries.get(idx).snapshot.id;
  }
  applyNext(dir) {
    const next = this.getNextId(this.state.current, dir);
    if (next) {
      const snapshot = this.setCurrent(next);
      if (snapshot)
        return this.plugin.state.setSnapshot(snapshot);
    }
  }
  async setStateSnapshot(snapshot) {
    if (snapshot.version !== PLUGIN_VERSION) {
    }
    this.clear();
    const entries3 = List().asMutable();
    for (const e of snapshot.entries) {
      this.entryMap.set(e.snapshot.id, e);
      entries3.push(e);
    }
    const current3 = snapshot.current ? snapshot.current : snapshot.entries.length > 0 ? snapshot.entries[0].snapshot.id : void 0;
    this.updateState({
      current: current3,
      entries: entries3.asImmutable(),
      isPlaying: false,
      nextSnapshotDelayInMs: snapshot.playback ? snapshot.playback.nextSnapshotDelayInMs : _PluginStateSnapshotManager.DefaultNextSnapshotDelayInMs
    });
    this.events.changed.next(void 0);
    if (!current3)
      return;
    const entry = this.getEntry(current3);
    const next = entry && entry.snapshot;
    if (!next)
      return;
    await this.plugin.state.setSnapshot(next);
    if (snapshot.playback && snapshot.playback.isPlaying)
      this.play(true);
    return next;
  }
  async syncCurrent(options) {
    var _a, _b;
    const isEmpty3 = this.state.entries.size === 0;
    const canReplace = this.state.entries.size === 1 && this.state.current && (!this.defaultSnapshotId || this.state.current === this.defaultSnapshotId);
    if (!isEmpty3 && !canReplace)
      return;
    const snapshot = this.plugin.state.getSnapshot(options === null || options === void 0 ? void 0 : options.params);
    const image = ((_b = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.image) !== null && _b !== void 0 ? _b : this.plugin.state.snapshotParams.value.image) ? await _PluginStateSnapshotManager.getCanvasImageAsset(this.plugin, `${snapshot.id}-image.png`) : void 0;
    if (isEmpty3) {
      this.add(_PluginStateSnapshotManager.Entry(snapshot, { name: options === null || options === void 0 ? void 0 : options.name, description: options === null || options === void 0 ? void 0 : options.description, descriptionFormat: options === null || options === void 0 ? void 0 : options.descriptionFormat, image }));
    } else if (canReplace) {
      const current3 = this.getEntry(this.state.current);
      if (current3 === null || current3 === void 0 ? void 0 : current3.image)
        this.plugin.managers.asset.delete(current3.image);
      this.replace(this.state.current, snapshot, { image });
    }
    this.defaultSnapshotId = snapshot.id;
  }
  async getStateSnapshot(options) {
    await this.syncCurrent(options);
    return {
      timestamp: +/* @__PURE__ */ new Date(),
      version: PLUGIN_VERSION,
      name: options && options.name,
      description: options && options.description,
      current: this.state.current,
      playback: {
        isPlaying: !!(options && options.playOnLoad),
        nextSnapshotDelayInMs: this.state.nextSnapshotDelayInMs
      },
      entries: this.state.entries.valueSeq().toArray()
    };
  }
  async serialize(options) {
    const json = JSON.stringify(await this.getStateSnapshot({ params: options === null || options === void 0 ? void 0 : options.params }), null, 2);
    if (!(options === null || options === void 0 ? void 0 : options.type) || options.type === "json" || options.type === "molj") {
      return new Blob([json], { type: "application/json;charset=utf-8" });
    } else {
      const state = new Uint8Array(utf8ByteCount(json));
      utf8Write(state, 0, json);
      const zipDataObj = {
        "state.json": state
      };
      const assets = [];
      for (const { asset, file } of this.plugin.managers.asset.assets) {
        assets.push([asset.id, asset]);
        zipDataObj[`assets/${asset.id}`] = new Uint8Array(await file.arrayBuffer());
      }
      if (assets.length > 0) {
        const index = JSON.stringify(assets, null, 2);
        const data = new Uint8Array(utf8ByteCount(index));
        utf8Write(data, 0, index);
        zipDataObj["assets.json"] = data;
      }
      const zipFile = await this.plugin.runTask(Zip(zipDataObj));
      return new Blob([zipFile], { type: "application/zip" });
    }
  }
  async open(file) {
    try {
      const fn = file.name.toLowerCase();
      if (fn.endsWith("json") || fn.endsWith("molj")) {
        const data = await this.plugin.runTask(readFromFile(file, "string"));
        const snapshot = JSON.parse(StringLike.toString(data));
        if (_PluginStateSnapshotManager.isStateSnapshot(snapshot)) {
          await this.setStateSnapshot(snapshot);
        } else if (_PluginStateSnapshotManager.isStateSnapshot(snapshot.data)) {
          await this.setStateSnapshot(snapshot.data);
        } else {
          await this.plugin.state.setSnapshot(snapshot);
        }
      } else {
        const data = await this.plugin.runTask(readFromFile(file, "zip"));
        const assetData = /* @__PURE__ */ Object.create(null);
        objectForEach(data, (v3, k) => {
          if (k === "state.json" || k === "assets.json")
            return;
          const name = k.substring(k.indexOf("/") + 1);
          assetData[name] = v3;
        });
        const stateFile = new File([data["state.json"]], "state.json");
        const snapshot = await this.plugin.runTask(readFromFile(stateFile, "json"));
        if (data["assets.json"]) {
          const file2 = new File([data["assets.json"]], "assets.json");
          const json = await this.plugin.runTask(readFromFile(file2, "json"));
          for (const [id, asset] of json) {
            this.plugin.managers.asset.set(asset, new File([assetData[id]], asset.name));
          }
        }
        await this.setStateSnapshot(snapshot);
      }
      this.events.opened.next(void 0);
    } catch (e) {
      console.error(e);
      this.plugin.log.error("Error reading state");
    }
  }
  play(delayFirst = false) {
    this.updateState({ isPlaying: true });
    if (delayFirst) {
      const e = this.getEntry(this.state.current);
      if (!e) {
        this.next();
        return;
      }
      this.events.changed.next(void 0);
      const snapshot = e.snapshot;
      const delay2 = typeof snapshot.durationInMs !== "undefined" ? snapshot.durationInMs : this.state.nextSnapshotDelayInMs;
      this.timeoutHandle = setTimeout(this.next, delay2);
    } else {
      this.next();
    }
  }
  stop() {
    this.updateState({ isPlaying: false });
    if (typeof this.timeoutHandle !== "undefined")
      clearTimeout(this.timeoutHandle);
    this.timeoutHandle = void 0;
    this.events.changed.next(void 0);
  }
  togglePlay() {
    if (this.state.isPlaying) {
      this.stop();
      this.plugin.managers.animation.stop();
    } else {
      this.play();
    }
  }
  dispose() {
    super.dispose();
    this.entryMap.clear();
  }
  constructor(plugin) {
    super({
      current: void 0,
      entries: List(),
      isPlaying: false,
      nextSnapshotDelayInMs: _PluginStateSnapshotManager.DefaultNextSnapshotDelayInMs
    });
    this.plugin = plugin;
    this.entryMap = /* @__PURE__ */ new Map();
    this.defaultSnapshotId = void 0;
    this.events = {
      changed: this.ev(),
      opened: this.ev()
    };
    this.timeoutHandle = void 0;
    this.next = async () => {
      this.timeoutHandle = void 0;
      const next = this.getNextId(this.state.current, 1);
      if (!next || next === this.state.current) {
        this.stop();
        return;
      }
      const snapshot = this.setCurrent(next);
      await this.plugin.state.setSnapshot(snapshot);
      const delay2 = typeof snapshot.durationInMs !== "undefined" ? snapshot.durationInMs : this.state.nextSnapshotDelayInMs;
      if (this.state.isPlaying)
        this.timeoutHandle = setTimeout(this.next, delay2);
    };
  }
};
PluginStateSnapshotManager.DefaultNextSnapshotDelayInMs = 1500;
(function(PluginStateSnapshotManager2) {
  function Entry(snapshot, params) {
    return { timestamp: +/* @__PURE__ */ new Date(), snapshot, ...params };
  }
  PluginStateSnapshotManager2.Entry = Entry;
  function isStateSnapshot(x) {
    const s = x;
    return !!s && !!s.timestamp && !!s.entries;
  }
  PluginStateSnapshotManager2.isStateSnapshot = isStateSnapshot;
  async function getCanvasImageAsset(ctx, name) {
    const task = Task.create("Render Screenshot", async (runtime) => {
      if (!ctx.helpers.viewportScreenshot)
        return;
      const p = await ctx.helpers.viewportScreenshot.getPreview(runtime, 512);
      if (!p)
        return;
      const blob = await canvasToBlob(p.canvas, "png");
      const file = new File([blob], name);
      const image = { kind: "file", id: UUID.create22(), name };
      ctx.managers.asset.set(image, file);
      return image;
    });
    return ctx.runTask(task);
  }
  PluginStateSnapshotManager2.getCanvasImageAsset = getCanvasImageAsset;
})(PluginStateSnapshotManager || (PluginStateSnapshotManager = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin/command.js
function PluginCommand() {
  const ret = (ctx, params) => ctx.commands.dispatch(ret, params || {});
  ret.subscribe = (ctx, action) => ctx.commands.subscribe(ret, action);
  ret.id = UUID.create22();
  return ret;
}
var PluginCommandManager = class {
  constructor() {
    this.subs = /* @__PURE__ */ new Map();
    this.disposing = false;
  }
  subscribe(cmd, action) {
    let actions = this.subs.get(cmd.id);
    if (!actions) {
      actions = [];
      this.subs.set(cmd.id, actions);
    }
    actions.push(action);
    return {
      unsubscribe: () => {
        const actions2 = this.subs.get(cmd.id);
        if (!actions2)
          return;
        const idx = actions2.indexOf(action);
        if (idx < 0)
          return;
        for (let i = idx + 1; i < actions2.length; i++) {
          actions2[i - 1] = actions2[i];
        }
        actions2.pop();
      }
    };
  }
  /** Resolves after all actions have completed */
  dispatch(cmd, params) {
    return new Promise((resolve, reject) => {
      if (this.disposing) {
        reject("disposed");
        return;
      }
      const actions = this.subs.get(cmd.id);
      if (!actions) {
        resolve();
        return;
      }
      this.resolve({ cmd, params, resolve, reject });
    });
  }
  dispose() {
    this.subs.clear();
  }
  async resolve(instance) {
    const actions = this.subs.get(instance.cmd.id);
    if (!actions) {
      instance.resolve();
      return;
    }
    try {
      for (const a5 of actions) {
        await a5(instance.params);
      }
      instance.resolve();
    } catch (e) {
      instance.reject(e);
    }
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin/commands.js
var PluginCommands = {
  State: {
    SetCurrentObject: PluginCommand(),
    ApplyAction: PluginCommand(),
    Update: PluginCommand(),
    RemoveObject: PluginCommand(),
    ToggleExpanded: PluginCommand(),
    ToggleVisibility: PluginCommand(),
    Snapshots: {
      Add: PluginCommand(),
      Replace: PluginCommand(),
      Move: PluginCommand(),
      Remove: PluginCommand(),
      Apply: PluginCommand(),
      Clear: PluginCommand(),
      Upload: PluginCommand(),
      Fetch: PluginCommand(),
      DownloadToFile: PluginCommand(),
      OpenFile: PluginCommand(),
      OpenUrl: PluginCommand()
    }
  },
  Interactivity: {
    Object: {
      Highlight: PluginCommand()
    },
    Structure: {
      Highlight: PluginCommand(),
      Select: PluginCommand()
    },
    ClearHighlights: PluginCommand()
  },
  Layout: {
    Update: PluginCommand()
  },
  Toast: {
    Show: PluginCommand(),
    Hide: PluginCommand()
  },
  Camera: {
    Reset: PluginCommand(),
    SetSnapshot: PluginCommand(),
    Focus: PluginCommand(),
    FocusObject: PluginCommand(),
    OrientAxes: PluginCommand(),
    ResetAxes: PluginCommand()
  },
  Canvas3D: {
    SetSettings: PluginCommand(),
    ResetSettings: PluginCommand()
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/chemistry/util.js
function typeSymbol(unit, index) {
  return unit.model.atomicHierarchy.atoms.type_symbol.value(unit.elements[index]);
}
function formalCharge(unit, index) {
  return unit.model.atomicHierarchy.atoms.pdbx_formal_charge.value(unit.elements[index]);
}
function atomId(unit, index) {
  return unit.model.atomicHierarchy.atoms.label_atom_id.value(unit.elements[index]);
}
function altLoc(unit, index) {
  return unit.model.atomicHierarchy.atoms.label_alt_id.value(unit.elements[index]);
}
function compId(unit, index) {
  return unit.model.atomicHierarchy.atoms.label_comp_id.value(unit.elements[index]);
}
function interBondCount(structure, unit, index) {
  let count3 = 0;
  const indices2 = structure.interUnitBonds.getEdgeIndices(index, unit.id);
  for (let i = 0, il = indices2.length; i < il; ++i) {
    const b5 = structure.interUnitBonds.edges[indices2[i]];
    if (BondType.isCovalent(b5.props.flag))
      count3 += 1;
  }
  return count3;
}
function intraBondCount(unit, index) {
  let count3 = 0;
  const { offset, edgeProps: { flags } } = unit.bonds;
  for (let i = offset[index], il = offset[index + 1]; i < il; ++i) {
    if (BondType.isCovalent(flags[i]))
      count3 += 1;
  }
  return count3;
}
function bondCount(structure, unit, index) {
  return interBondCount(structure, unit, index) + intraBondCount(unit, index);
}
function bondToElementCount(structure, unit, index, element) {
  let count3 = 0;
  eachBondedAtom(structure, unit, index, (unit2, index2) => {
    if (typeSymbol(unit2, index2) === element)
      count3 += 1;
  });
  return count3;
}
function intraConnectedTo(unit, indexA, indexB) {
  const { offset, b: b5, edgeProps: { flags } } = unit.bonds;
  BondType.is;
  for (let i = offset[indexA], il = offset[indexA + 1]; i < il; ++i) {
    if (b5[i] === indexB && BondType.isCovalent(flags[i]))
      return true;
  }
  return false;
}
function interConnectedTo(structure, unitA, indexA, unitB, indexB) {
  const b5 = structure.interUnitBonds.getEdge(indexA, unitA.id, indexB, unitB.id);
  return b5 && BondType.isCovalent(b5.props.flag);
}
function connectedTo(structure, unitA, indexA, unitB, indexB) {
  return unitA === unitB ? intraConnectedTo(unitA, indexA, indexB) : interConnectedTo(structure, unitA, indexA, unitB, indexB);
}
function eachInterBondedAtom(structure, unit, index, cb2) {
  const indices2 = structure.interUnitBonds.getEdgeIndices(index, unit.id);
  for (let i = 0, il = indices2.length; i < il; ++i) {
    const b5 = structure.interUnitBonds.edges[indices2[i]];
    const uB = structure.unitMap.get(b5.unitB);
    if (BondType.isCovalent(b5.props.flag))
      cb2(uB, b5.indexB);
  }
}
function eachIntraBondedAtom(unit, index, cb2) {
  const { offset, b: b5, edgeProps: { flags } } = unit.bonds;
  for (let i = offset[index], il = offset[index + 1]; i < il; ++i) {
    if (BondType.isCovalent(flags[i]))
      cb2(unit, b5[i]);
  }
}
function eachBondedAtom(structure, unit, index, cb2) {
  eachInterBondedAtom(structure, unit, index, cb2);
  eachIntraBondedAtom(unit, index, cb2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-model-props/computed/chemistry/functional-group.js
function isSulfonicAcid(structure, unit, index) {
  return typeSymbol(unit, index) === Elements.S && bondToElementCount(structure, unit, index, Elements.O) === 3;
}
function isSulfate(structure, unit, index) {
  return typeSymbol(unit, index) === Elements.S && bondToElementCount(structure, unit, index, Elements.O) === 4;
}
function isPhosphate(structure, unit, index) {
  return typeSymbol(unit, index) === Elements.P && bondToElementCount(structure, unit, index, Elements.O) === bondCount(structure, unit, index);
}
function isCarboxylate(structure, unit, index) {
  let terminalOxygenCount = 0;
  if (typeSymbol(unit, index) === Elements.C && bondToElementCount(structure, unit, index, Elements.O) === 2 && bondToElementCount(structure, unit, index, Elements.C) === 1) {
    eachBondedAtom(structure, unit, index, (unit2, index2) => {
      if (typeSymbol(unit2, index2) === Elements.O && bondCount(structure, unit2, index2) - bondToElementCount(structure, unit2, index2, Elements.H) === 1) {
        terminalOxygenCount += 1;
      }
    });
  }
  return terminalOxygenCount === 2;
}
function isGuanidine(structure, unit, index) {
  let terminalNitrogenCount = 0;
  if (typeSymbol(unit, index) === Elements.C && bondCount(structure, unit, index) === 3 && bondToElementCount(structure, unit, index, Elements.N) === 3) {
    eachBondedAtom(structure, unit, index, (unit2, index2) => {
      if (bondCount(structure, unit2, index2) - bondToElementCount(structure, unit2, index2, Elements.H) === 1) {
        terminalNitrogenCount += 1;
      }
    });
  }
  return terminalNitrogenCount === 2;
}
function isAcetamidine(structure, unit, index) {
  let terminalNitrogenCount = 0;
  if (typeSymbol(unit, index) === Elements.C && bondCount(structure, unit, index) === 3 && bondToElementCount(structure, unit, index, Elements.N) === 2 && bondToElementCount(structure, unit, index, Elements.C) === 1) {
    eachBondedAtom(structure, unit, index, (unit2, index2) => {
      if (bondCount(structure, unit2, index2) - bondToElementCount(structure, unit2, index2, Elements.H) === 1) {
        terminalNitrogenCount += 1;
      }
    });
  }
  return terminalNitrogenCount === 2;
}
var PolarElements = /* @__PURE__ */ new Set(["N", "O", "S", "F", "CL", "BR", "I"]);
function isPolar(element) {
  return PolarElements.has(element);
}
function hasPolarNeighbour(structure, unit, index) {
  let flag = false;
  eachBondedAtom(structure, unit, index, (unit2, index2) => {
    if (isPolar(typeSymbol(unit2, index2)))
      flag = true;
  });
  return flag;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/structure/visual/util/common.js
var m4toArray = Mat4.toArray;
function getResidueLoci(structure, unit, elementIndex) {
  const { elements, model } = unit;
  if (OrderedSet.indexOf(elements, elementIndex) !== -1) {
    const { index, offsets } = model.atomicHierarchy.residueAtomSegments;
    const rI = index[elementIndex];
    const _indices = [];
    for (let i = offsets[rI], il = offsets[rI + 1]; i < il; ++i) {
      const unitIndex = OrderedSet.indexOf(elements, i);
      if (unitIndex !== -1)
        _indices.push(unitIndex);
    }
    const indices2 = OrderedSet.ofSortedArray(SortedArray.ofSortedArray(_indices));
    return element_exports.Loci(structure, [{ unit, indices: indices2 }]);
  }
  return EmptyLoci;
}
function getAltResidueLoci(structure, unit, elementIndex) {
  const { elements, model } = unit;
  const { label_alt_id } = model.atomicHierarchy.atoms;
  const elementAltId = label_alt_id.value(elementIndex);
  if (OrderedSet.indexOf(elements, elementIndex) !== -1) {
    const { index } = model.atomicHierarchy.residueAtomSegments;
    const rI = index[elementIndex];
    return getAltResidueLociFromId(structure, unit, rI, elementAltId);
  }
  return element_exports.Loci(structure, []);
}
function getAltResidueLociFromId(structure, unit, residueIndex, elementAltId) {
  const { elements, model } = unit;
  const { label_alt_id } = model.atomicHierarchy.atoms;
  const { offsets } = model.atomicHierarchy.residueAtomSegments;
  const _indices = [];
  for (let i = offsets[residueIndex], il = offsets[residueIndex + 1]; i < il; ++i) {
    const unitIndex = OrderedSet.indexOf(elements, i);
    if (unitIndex !== -1) {
      const altId = label_alt_id.value(i);
      if (elementAltId === altId || altId === "") {
        _indices.push(unitIndex);
      }
    }
  }
  const indices2 = OrderedSet.ofSortedArray(SortedArray.ofSortedArray(_indices));
  return element_exports.Loci(structure, [{ unit, indices: indices2 }]);
}
function createUnitsTransform(structureGroup, includeParent, invariantBoundingSphere, cellSize, batchSize, transformData) {
  const { child } = structureGroup.structure;
  const units = includeParent && child ? structureGroup.group.units.filter((u) => child.unitMap.has(u.id)) : structureGroup.group.units;
  const unitCount = units.length;
  const n = unitCount * 16;
  const array = transformData && transformData.aTransform.ref.value.length >= n ? transformData.aTransform.ref.value : new Float32Array(n);
  for (let i = 0; i < unitCount; i++) {
    m4toArray(units[i].conformation.operator.matrix, array, i * 16);
  }
  return createTransform(array, unitCount, invariantBoundingSphere, cellSize, batchSize, transformData);
}
var UnitKindInfo = {
  "atomic": {},
  "spheres": {},
  "gaussians": {}
};
var UnitKindOptions = ParamDefinition.objectToOptions(UnitKindInfo);
function includesUnitKind(unitKinds, unit) {
  for (let i = 0, il = unitKinds.length; i < il; ++i) {
    if (Unit.isAtomic(unit) && unitKinds[i] === "atomic")
      return true;
    if (Unit.isSpheres(unit) && unitKinds[i] === "spheres")
      return true;
    if (Unit.isGaussians(unit) && unitKinds[i] === "gaussians")
      return true;
  }
  return false;
}
var DefaultMaxCells = 5e8;
function getVolumeSliceInfo(box2, resolution, maxCells = DefaultMaxCells) {
  const size = Box3D.size(Vec3(), box2);
  Vec3.ceil(size, size);
  size.sort((a5, b5) => b5 - a5);
  const maxAreaCells = Math.floor(Math.cbrt(maxCells) * Math.cbrt(maxCells));
  const area = size[0] * size[1];
  const areaCells = Math.ceil(area / (resolution * resolution));
  return { area, areaCells, maxAreaCells };
}
function ensureReasonableResolution(box2, props, maxCells = DefaultMaxCells) {
  const { area, areaCells, maxAreaCells } = getVolumeSliceInfo(box2, props.resolution, maxCells);
  const resolution = areaCells > maxAreaCells ? Math.sqrt(area / maxAreaCells) : props.resolution;
  return { ...props, resolution };
}
function getConformation(unit) {
  switch (unit.kind) {
    case Unit.Kind.Atomic:
      return unit.model.atomicConformation;
    case Unit.Kind.Spheres:
      return unit.model.coarseConformation.spheres;
    case Unit.Kind.Gaussians:
      return unit.model.coarseConformation.gaussians;
  }
}
var CommonSurfaceParams = {
  ignoreHydrogens: ParamDefinition.Boolean(false, { description: "Whether or not to include hydrogen atoms in the surface calculation." }),
  ignoreHydrogensVariant: ParamDefinition.Select("all", ParamDefinition.arrayToOptions(["all", "non-polar"])),
  traceOnly: ParamDefinition.Boolean(false, { description: "Whether or not to only use trace atoms in the surface calculation." }),
  includeParent: ParamDefinition.Boolean(false, { description: "Include elements of the parent structure in surface calculation to get a surface patch of the current structure." })
};
var DefaultCommonSurfaceProps = ParamDefinition.getDefaultValues(CommonSurfaceParams);
var v2 = Vec3();
function squaredDistance(x, y, z, center) {
  return Vec3.squaredDistance(Vec3.set(v2, x, y, z), center);
}
function filterUnitId(id, elements, indices2) {
  let start = 0;
  const end = elements.length;
  for (let i = 0, il = indices2.length; i < il; ++i) {
    const idx = SortedArray.indexOfInRange(elements, indices2[i], start, end);
    if (idx === -1) {
      id[i] = -2;
    } else {
      id[i] = idx;
      start = idx;
    }
  }
}
function getUnitConformationAndRadius(structure, unit, sizeTheme, props) {
  const { ignoreHydrogens, ignoreHydrogensVariant, traceOnly, includeParent } = props;
  const rootUnit = includeParent ? structure.root.unitMap.get(unit.id) : unit;
  const differentRoot = includeParent && rootUnit !== unit;
  const { x, y, z } = getConformation(rootUnit);
  const { elements } = rootUnit;
  const { center, radius: sphereRadius } = unit.boundary.sphere;
  const extraRadius = (4 + 1.5) * 2;
  const radiusSq = (sphereRadius + extraRadius) * (sphereRadius + extraRadius);
  let indices2;
  let id;
  if (ignoreHydrogens || traceOnly || differentRoot) {
    const _indices = [];
    const _id = [];
    for (let i = 0, il = elements.length; i < il; ++i) {
      const eI = elements[i];
      if (ignoreHydrogens && isHydrogen(structure, rootUnit, eI, ignoreHydrogensVariant))
        continue;
      if (traceOnly && !isTrace(rootUnit, eI))
        continue;
      if (differentRoot && squaredDistance(x[eI], y[eI], z[eI], center) > radiusSq)
        continue;
      _indices.push(eI);
      _id.push(i);
    }
    indices2 = SortedArray.ofSortedArray(_indices);
    id = _id;
  } else {
    indices2 = elements;
    id = fillSerial(new Int32Array(indices2.length));
  }
  if (includeParent && rootUnit !== unit) {
    filterUnitId(id, unit.elements, indices2);
  }
  const position = { indices: indices2, x, y, z, id };
  const boundary = differentRoot ? getBoundary(position) : unit.boundary;
  const l = element_exports.Location.create(structure, rootUnit);
  const radius = (index) => {
    l.element = index;
    return sizeTheme.size(l);
  };
  return { position, boundary, radius };
}
function getStructureConformationAndRadius(structure, sizeTheme, props) {
  const { ignoreHydrogens, ignoreHydrogensVariant, traceOnly, includeParent } = props;
  const differentRoot = includeParent && !!structure.parent;
  const l = element_exports.Location.create(structure.root);
  const { center, radius: sphereRadius } = structure.boundary.sphere;
  const extraRadius = (4 + 1.5) * 2;
  const radiusSq = (sphereRadius + extraRadius) * (sphereRadius + extraRadius);
  let xs;
  let ys;
  let zs;
  let rs;
  let id;
  let indices2;
  if (ignoreHydrogens || traceOnly || differentRoot) {
    const { getSerialIndex } = structure.serialMapping;
    const units = differentRoot ? structure.root.units : structure.units;
    const _xs = [];
    const _ys = [];
    const _zs = [];
    const _rs = [];
    const _id = [];
    for (let i = 0, il = units.length; i < il; ++i) {
      const unit = units[i];
      const { elements, conformation: c5 } = unit;
      const childUnit = structure.unitMap.get(unit.id);
      l.unit = unit;
      for (let j = 0, jl = elements.length; j < jl; ++j) {
        const eI = elements[j];
        if (ignoreHydrogens && isHydrogen(structure, unit, eI, ignoreHydrogensVariant))
          continue;
        if (traceOnly && !isTrace(unit, eI))
          continue;
        const _x = c5.x(eI), _y = c5.y(eI), _z = c5.z(eI);
        if (differentRoot && squaredDistance(_x, _y, _z, center) > radiusSq)
          continue;
        _xs.push(_x);
        _ys.push(_y);
        _zs.push(_z);
        l.element = eI;
        _rs.push(sizeTheme.size(l));
        if (differentRoot) {
          const idx = childUnit ? SortedArray.indexOf(childUnit.elements, eI) : -1;
          if (idx === -1) {
            _id.push(-2);
          } else {
            _id.push(getSerialIndex(childUnit, eI));
          }
        } else {
          _id.push(getSerialIndex(unit, eI));
        }
      }
    }
    xs = _xs, ys = _ys, zs = _zs, rs = _rs;
    id = _id;
    indices2 = OrderedSet.ofRange(0, id.length);
  } else {
    const { elementCount } = structure;
    const _xs = new Float32Array(elementCount);
    const _ys = new Float32Array(elementCount);
    const _zs = new Float32Array(elementCount);
    const _rs = new Float32Array(elementCount);
    for (let i = 0, m = 0, il = structure.units.length; i < il; ++i) {
      const unit = structure.units[i];
      const { elements, conformation: c5 } = unit;
      l.unit = unit;
      for (let j = 0, jl = elements.length; j < jl; ++j) {
        const eI = elements[j];
        const mj = m + j;
        _xs[mj] = c5.x(eI);
        _ys[mj] = c5.y(eI);
        _zs[mj] = c5.z(eI);
        l.element = eI;
        _rs[mj] = sizeTheme.size(l);
      }
      m += elements.length;
    }
    xs = _xs, ys = _ys, zs = _zs, rs = _rs;
    id = fillSerial(new Uint32Array(elementCount));
    indices2 = OrderedSet.ofRange(0, id.length);
  }
  const position = { indices: indices2, x: xs, y: ys, z: zs, id };
  const boundary = differentRoot ? getBoundary(position) : structure.boundary;
  const radius = (index) => rs[index];
  return { position, boundary, radius };
}
var _H = AtomicNumbers["H"];
function isHydrogen(structure, unit, element, variant) {
  if (Unit.isCoarse(unit))
    return false;
  if (unit.model.atomicHierarchy.derived.atom.atomicNumber[element] !== _H)
    return false;
  if (variant === "all")
    return true;
  const polar = hasPolarNeighbour(structure, unit, SortedArray.indexOf(unit.elements, element));
  if (polar && variant === "polar")
    return true;
  if (!polar && variant === "non-polar")
    return true;
  return false;
}
function isTrace(unit, element) {
  if (Unit.isCoarse(unit))
    return true;
  const atomId2 = unit.model.atomicHierarchy.atoms.label_atom_id.value(element);
  if (atomId2 === "CA" || atomId2 === "BB" || atomId2 === "P")
    return true;
  return false;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/structure/params.js
function getUnitKindsParam(defaultValue) {
  return ParamDefinition.MultiSelect(defaultValue, UnitKindOptions, { description: "For which kinds of units/chains to show the representation visuals." });
}
var StructureParams = {
  unitKinds: getUnitKindsParam(["atomic", "spheres"]),
  includeParent: ParamDefinition.Boolean(false, { isHidden: true })
};
var StructureMeshParams = { ...Mesh.Params };
var StructureSpheresParams = { ...Spheres.Params };
var StructureCylindersParams = { ...Cylinders.Params };
var StructurePointsParams = { ...Points.Params };
var StructureLinesParams = { ...Lines.Params };
var StructureTextParams = { ...Text.Params };
var StructureDirectVolumeParams = { ...DirectVolume.Params };
var StructureTextureMeshParams = { ...TextureMesh.Params };
var StructureImageParams = { ...Image2.Params };

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/structure/complex-visual.js
function createComplexRenderObject(structure, geometry, locationIt, theme, props, materialId) {
  const { createValues, createRenderableState } = Geometry.getUtils(geometry);
  const transform = createIdentityTransform();
  const values2 = createValues(geometry, transform, locationIt, theme, props);
  const state = createRenderableState(props);
  return createRenderObject(geometry.kind, values2, state, materialId);
}
function ComplexVisual(builder, materialId) {
  const { defaultProps, createGeometry, createLocationIterator, getLoci, eachLocation, setUpdateState, mustRecreate, processValues, dispose: dispose2 } = builder;
  const { updateValues, updateBoundingSphere, updateRenderableState, createPositionIterator } = builder.geometryUtils;
  const updateState = VisualUpdateState.create();
  const previousMark = { loci: EmptyLoci, action: MarkerAction.None, status: -1 };
  let renderObject;
  let newProps;
  let newTheme;
  let newStructure;
  let currentProps = Object.assign({}, defaultProps);
  let currentTheme = Theme.createEmpty();
  let currentStructure;
  let geometry;
  let geometryVersion = -1;
  let locationIt;
  let positionIt;
  function prepareUpdate(theme, props, structure) {
    if (!structure && !currentStructure) {
      throw new Error("missing structure");
    }
    newProps = Object.assign({}, currentProps, props);
    newTheme = theme;
    newStructure = structure;
    VisualUpdateState.reset(updateState);
    if (!renderObject || !currentStructure) {
      updateState.createNew = true;
      updateState.createGeometry = true;
      return;
    }
    setUpdateState(updateState, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure);
    if (!Structure.areEquivalent(newStructure, currentStructure)) {
      updateState.createGeometry = true;
    }
    if (!Structure.areHierarchiesEqual(newStructure, currentStructure)) {
      updateState.updateTransform = true;
      updateState.createGeometry = true;
    }
    if (!ColorTheme.areEqual(theme.color, currentTheme.color)) {
      updateState.updateColor = true;
    }
    if (!SizeTheme.areEqual(theme.size, currentTheme.size)) {
      updateState.updateSize = true;
    }
    if (!deepEqual(newProps.unitKinds, currentProps.unitKinds)) {
      updateState.createGeometry = true;
    }
    if (currentStructure.child !== newStructure.child) {
      updateState.createGeometry = true;
      updateState.updateTransform = true;
    }
    if (newProps.instanceGranularity !== currentProps.instanceGranularity) {
      updateState.updateTransform = true;
    }
    if (updateState.updateSize && !("uSize" in renderObject.values)) {
      updateState.createGeometry = true;
    }
    if (updateState.createGeometry) {
      updateState.updateColor = true;
      updateState.updateSize = true;
    }
  }
  function update10(newGeometry) {
    if (updateState.createNew) {
      locationIt = createLocationIterator(newStructure, newProps);
      if (newGeometry) {
        renderObject = createComplexRenderObject(newStructure, newGeometry, locationIt, newTheme, newProps, materialId);
        positionIt = createPositionIterator(newGeometry, renderObject.values);
      } else {
        throw new Error("expected geometry to be given");
      }
    } else {
      if (!renderObject) {
        throw new Error("expected renderObject to be available");
      }
      if (updateState.updateColor || updateState.updateSize || updateState.updateTransform) {
        locationIt = createLocationIterator(newStructure, newProps);
      }
      if (updateState.updateTransform) {
        const { instanceCount, groupCount } = locationIt;
        if (newProps.instanceGranularity) {
          createMarkers(instanceCount, "instance", renderObject.values);
        } else {
          createMarkers(instanceCount * groupCount, "groupInstance", renderObject.values);
        }
      }
      if (updateState.createGeometry) {
        if (newGeometry) {
          ValueCell.updateIfChanged(renderObject.values.drawCount, Geometry.getDrawCount(newGeometry));
          ValueCell.updateIfChanged(renderObject.values.uVertexCount, Geometry.getVertexCount(newGeometry));
          ValueCell.updateIfChanged(renderObject.values.uGroupCount, Geometry.getGroupCount(newGeometry));
        } else {
          throw new Error("expected geometry to be given");
        }
      }
      if (updateState.updateTransform || updateState.createGeometry) {
        updateBoundingSphere(renderObject.values, newGeometry || geometry);
        positionIt = createPositionIterator(geometry, renderObject.values);
      }
      if (updateState.updateSize) {
        if ("uSize" in renderObject.values) {
          createSizes(locationIt, newTheme.size, renderObject.values);
        }
      }
      if (updateState.updateColor) {
        createColors(locationIt, positionIt, newTheme.color, renderObject.values);
      }
      updateValues(renderObject.values, newProps);
      updateRenderableState(renderObject.state, newProps);
    }
    currentProps = newProps;
    currentTheme = newTheme;
    currentStructure = newStructure;
    if (newGeometry) {
      geometry = newGeometry;
      geometryVersion += 1;
    }
  }
  function lociIsSuperset(loci) {
    if (isEveryLoci(loci))
      return true;
    if (Structure.isLoci(loci) && Structure.areRootsEquivalent(loci.structure, currentStructure))
      return true;
    if (element_exports.Loci.is(loci) && Structure.areRootsEquivalent(loci.structure, currentStructure)) {
      if (element_exports.Loci.isWholeStructure(loci))
        return true;
    }
    return false;
  }
  function eachInstance(loci, structure, apply) {
    let changed = false;
    if (!element_exports.Loci.is(loci) && !Bond.isLoci(loci))
      return false;
    if (!Structure.areEquivalent(loci.structure, structure))
      return false;
    if (apply(Interval.ofSingleton(0)))
      changed = true;
    return changed;
  }
  function lociApply(loci, apply, isMarking) {
    if (lociIsSuperset(loci)) {
      if (currentProps.instanceGranularity) {
        return apply(Interval.ofBounds(0, locationIt.instanceCount));
      } else {
        return apply(Interval.ofBounds(0, locationIt.groupCount * locationIt.instanceCount));
      }
    } else {
      if (currentProps.instanceGranularity) {
        return eachInstance(loci, currentStructure, apply);
      } else {
        return eachLocation(loci, currentStructure, apply, isMarking);
      }
    }
  }
  function finalize3(ctx) {
    if (renderObject) {
      processValues === null || processValues === void 0 ? void 0 : processValues(renderObject.values, geometry, currentProps, currentTheme, ctx.webgl);
    }
  }
  return {
    get groupCount() {
      return locationIt ? locationIt.count : 0;
    },
    get renderObject() {
      return locationIt && locationIt.count ? renderObject : void 0;
    },
    get geometryVersion() {
      return geometryVersion;
    },
    createOrUpdate(ctx, theme, props = {}, structure) {
      prepareUpdate(theme, props, structure || currentStructure);
      if (updateState.createGeometry) {
        const newGeometry = createGeometry(ctx, newStructure, newTheme, newProps, geometry);
        if (isPromiseLike(newGeometry)) {
          return newGeometry.then((g) => {
            update10(g);
            finalize3(ctx);
          });
        }
        update10(newGeometry);
      } else {
        update10();
      }
      finalize3(ctx);
    },
    getLoci(pickingId) {
      return renderObject ? getLoci(pickingId, currentStructure, renderObject.id) : EmptyLoci;
    },
    eachLocation(cb2) {
      locationIt.reset();
      while (locationIt.hasNext) {
        const { location, isSecondary } = locationIt.move();
        cb2(location, isSecondary);
      }
    },
    mark(loci, action) {
      return Visual.mark(renderObject, loci, action, lociApply, previousMark);
    },
    setVisibility(visible) {
      Visual.setVisibility(renderObject, visible);
    },
    setAlphaFactor(alphaFactor) {
      Visual.setAlphaFactor(renderObject, alphaFactor);
    },
    setPickable(pickable) {
      Visual.setPickable(renderObject, pickable);
    },
    setColorOnly(colorOnly) {
      Visual.setColorOnly(renderObject, colorOnly);
    },
    setTransform(matrix, instanceMatrices) {
      Visual.setTransform(renderObject, matrix, instanceMatrices);
    },
    setOverpaint(overpaint, webgl) {
      const smoothing = { geometry, props: currentProps, webgl };
      Visual.setOverpaint(renderObject, overpaint, lociApply, true, smoothing);
    },
    setTransparency(transparency, webgl) {
      const smoothing = { geometry, props: currentProps, webgl };
      Visual.setTransparency(renderObject, transparency, lociApply, true, smoothing);
    },
    setEmissive(emissive, webgl) {
      const smoothing = { geometry, props: currentProps, webgl };
      Visual.setEmissive(renderObject, emissive, lociApply, true, smoothing);
    },
    setSubstance(substance, webgl) {
      const smoothing = { geometry, props: currentProps, webgl };
      Visual.setSubstance(renderObject, substance, lociApply, true, smoothing);
    },
    setClipping(clipping) {
      Visual.setClipping(renderObject, clipping, lociApply, true);
    },
    setThemeStrength(strength) {
      Visual.setThemeStrength(renderObject, strength);
    },
    destroy() {
      dispose2 === null || dispose2 === void 0 ? void 0 : dispose2(geometry);
      if (renderObject) {
        renderObject.state.disposed = true;
        renderObject = void 0;
      }
    },
    mustRecreate
  };
}
var ComplexMeshParams = { ...StructureMeshParams, ...StructureParams };
function ComplexMeshVisual(builder, materialId) {
  return ComplexVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.createGeometry = true;
    },
    geometryUtils: Mesh.Utils
  }, materialId);
}
var ComplexSpheresParams = { ...StructureSpheresParams, ...StructureParams };
function ComplexSpheresVisual(builder, materialId) {
  return ComplexVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.updateSize = true;
    },
    geometryUtils: Spheres.Utils
  }, materialId);
}
var ComplexCylindersParams = { ...StructureCylindersParams, ...StructureParams };
function ComplexCylindersVisual(builder, materialId) {
  return ComplexVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.updateSize = true;
    },
    geometryUtils: Cylinders.Utils
  }, materialId);
}
var ComplexPointsParams = { ...StructurePointsParams, ...StructureParams };
function ComplexPointsVisual(builder, materialId) {
  return ComplexVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.updateSize = true;
    },
    geometryUtils: Points.Utils
  }, materialId);
}
var ComplexLinesParams = { ...StructureLinesParams, ...StructureParams };
function ComplexLinesVisual(builder, materialId) {
  return ComplexVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.updateSize = true;
    },
    geometryUtils: Lines.Utils
  }, materialId);
}
var ComplexTextParams = { ...StructureTextParams, ...StructureParams };
function ComplexTextVisual(builder, materialId) {
  return ComplexVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.updateSize = true;
      if (newProps.background !== currentProps.background)
        state.createGeometry = true;
      if (newProps.backgroundMargin !== currentProps.backgroundMargin)
        state.createGeometry = true;
      if (newProps.tether !== currentProps.tether)
        state.createGeometry = true;
      if (newProps.tetherLength !== currentProps.tetherLength)
        state.createGeometry = true;
      if (newProps.tetherBaseWidth !== currentProps.tetherBaseWidth)
        state.createGeometry = true;
      if (newProps.attachment !== currentProps.attachment)
        state.createGeometry = true;
      if (newProps.fontFamily !== currentProps.fontFamily)
        state.createGeometry = true;
      if (newProps.fontQuality !== currentProps.fontQuality)
        state.createGeometry = true;
      if (newProps.fontStyle !== currentProps.fontStyle)
        state.createGeometry = true;
      if (newProps.fontVariant !== currentProps.fontVariant)
        state.createGeometry = true;
      if (newProps.fontWeight !== currentProps.fontWeight)
        state.createGeometry = true;
    },
    geometryUtils: Text.Utils
  }, materialId);
}
var ComplexDirectVolumeParams = { ...StructureDirectVolumeParams, ...StructureParams };
function ComplexDirectVolumeVisual(builder, materialId) {
  return ComplexVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.createGeometry = true;
    },
    geometryUtils: DirectVolume.Utils
  }, materialId);
}
var ComplexTextureMeshParams = { ...StructureTextureMeshParams, ...StructureParams };
function ComplexTextureMeshVisual(builder, materialId) {
  return ComplexVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.createGeometry = true;
    },
    geometryUtils: TextureMesh.Utils
  }, materialId);
}
var ComplexImageParams = { ...StructureImageParams, ...StructureParams };
function ComplexImageVisual(builder, materialId) {
  return ComplexVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructure, currentStructure);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.createGeometry = true;
    },
    geometryUtils: Image2.Utils
  }, materialId);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/structure/units-representation.js
function UnitsRepresentation(label2, ctx, getParams, visualCtor) {
  let version = 0;
  const { webgl } = ctx;
  const updated = new Subject();
  const materialId = getNextMaterialId();
  const renderObjects = [];
  const geometryState = new Representation.GeometryState();
  const _state = StructureRepresentationStateBuilder.create();
  let visuals = /* @__PURE__ */ new Map();
  let _structure;
  let _groups;
  let _params;
  let _props;
  let _theme = Theme.createEmpty();
  function createOrUpdate(props = {}, structure) {
    if (structure && structure !== _structure) {
      _params = getParams(ctx, structure);
      if (!_props)
        _props = ParamDefinition.getDefaultValues(_params);
    }
    _props = Object.assign({}, _props, props);
    return Task.create("Creating or updating UnitsRepresentation", async (runtime) => {
      var _a, _b, _c;
      if (!_structure && !structure) {
        throw new Error("missing structure");
      } else if (structure && !_structure) {
        _groups = structure.unitSymmetryGroups;
        for (let i = 0; i < _groups.length; i++) {
          const group = _groups[i];
          const visual = visualCtor(materialId, structure, _props, webgl);
          const promise = visual.createOrUpdate({ webgl, runtime }, _theme, _props, { group, structure });
          if (promise)
            await promise;
          setVisualState(visual, group, _state);
          visuals.set(group.hashCode, { visual, group });
          if (runtime.shouldUpdate)
            await runtime.update({ message: "Creating or updating UnitsVisual", current: i, max: _groups.length });
        }
      } else if (structure && (!Structure.areUnitIdsAndIndicesEqual(structure, _structure) || structure.child !== _structure.child)) {
        _groups = structure.unitSymmetryGroups;
        const oldVisuals = visuals;
        visuals = /* @__PURE__ */ new Map();
        for (let i = 0; i < _groups.length; i++) {
          const group = _groups[i];
          const visualGroup = oldVisuals.get(group.hashCode);
          if (visualGroup) {
            let { visual } = visualGroup;
            if ((_a = visual.mustRecreate) === null || _a === void 0 ? void 0 : _a.call(visual, { group, structure }, _props, webgl)) {
              visual.destroy();
              visual = visualCtor(materialId, structure, _props, webgl);
              const promise = visual.createOrUpdate({ webgl, runtime }, _theme, _props, { group, structure });
              if (promise)
                await promise;
              setVisualState(visual, group, _state);
            } else {
              const promise = visual.createOrUpdate({ webgl, runtime }, _theme, _props, { group, structure });
              if (promise)
                await promise;
            }
            visuals.set(group.hashCode, { visual, group });
            oldVisuals.delete(group.hashCode);
            if (visual.renderObject) {
              const arr = visual.renderObject.values.tMarker.ref.value.array;
              applyMarkerAction(arr, Interval.ofBounds(0, arr.length), MarkerAction.RemoveHighlight);
            }
          } else {
            const visual = visualCtor(materialId, structure, _props, webgl);
            const promise = visual.createOrUpdate({ webgl, runtime }, _theme, _props, { group, structure });
            if (promise)
              await promise;
            setVisualState(visual, group, _state);
            visuals.set(group.hashCode, { visual, group });
          }
          if (runtime.shouldUpdate)
            await runtime.update({ message: "Creating or updating UnitsVisual", current: i, max: _groups.length });
        }
        oldVisuals.forEach(({ visual }) => {
          visual.destroy();
        });
      } else if (structure && structure !== _structure && Structure.areUnitIdsAndIndicesEqual(structure, _structure)) {
        _groups = structure.unitSymmetryGroups;
        for (let i = 0; i < _groups.length; i++) {
          const group = _groups[i];
          const visualGroup = visuals.get(group.hashCode);
          if (visualGroup) {
            let { visual } = visualGroup;
            if ((_b = visual.mustRecreate) === null || _b === void 0 ? void 0 : _b.call(visual, { group, structure }, _props, ctx.webgl)) {
              visual.destroy();
              visual = visualCtor(materialId, structure, _props, ctx.webgl);
              visualGroup.visual = visual;
              const promise = visual.createOrUpdate({ webgl, runtime }, _theme, _props, { group, structure });
              if (promise)
                await promise;
              setVisualState(visual, group, _state);
            } else {
              const promise = visual.createOrUpdate({ webgl, runtime }, _theme, _props, { group, structure });
              if (promise)
                await promise;
            }
            visualGroup.group = group;
          } else {
            throw new Error(`expected to find visual for hashCode ${group.hashCode}`);
          }
          if (runtime.shouldUpdate)
            await runtime.update({ message: "Creating or updating UnitsVisual", current: i, max: _groups.length });
        }
      } else {
        const visualsList = [];
        visuals.forEach((vg) => visualsList.push(vg));
        for (let i = 0, il = visualsList.length; i < il; ++i) {
          let { visual, group } = visualsList[i];
          if ((_c = visual.mustRecreate) === null || _c === void 0 ? void 0 : _c.call(visual, { group, structure: _structure }, _props, ctx.webgl)) {
            visual.destroy();
            visual = visualCtor(materialId, _structure, _props, webgl);
            visualsList[i].visual = visual;
            const promise = visual.createOrUpdate({ webgl, runtime }, _theme, _props, { group, structure: _structure });
            if (promise)
              await promise;
            setVisualState(visual, group, _state);
          } else {
            const promise = visual.createOrUpdate({ webgl, runtime }, _theme, _props);
            if (promise)
              await promise;
          }
          if (runtime.shouldUpdate)
            await runtime.update({ message: "Creating or updating UnitsVisual", current: i, max: il });
        }
      }
      renderObjects.length = 0;
      visuals.forEach(({ visual }) => {
        if (visual.renderObject) {
          renderObjects.push(visual.renderObject);
          geometryState.add(visual.renderObject.id, visual.geometryVersion);
        }
      });
      geometryState.snapshot();
      if (structure)
        _structure = structure;
      updated.next(version++);
    });
  }
  function getLoci(pickingId) {
    let loci = EmptyLoci;
    visuals.forEach(({ visual }) => {
      const _loci = visual.getLoci(pickingId);
      if (!isEmptyLoci(_loci))
        loci = _loci;
    });
    return loci;
  }
  function eachLocation(cb2) {
    visuals.forEach(({ visual }) => {
      visual.eachLocation(cb2);
    });
  }
  function getAllLoci() {
    var _a;
    return [Structure.Loci((_a = _structure.child) !== null && _a !== void 0 ? _a : _structure)];
  }
  function mark(loci, action) {
    if (!_structure)
      return false;
    if (!MarkerActions.is(_state.markerActions, action))
      return false;
    if (Structure.isLoci(loci) || element_exports.Loci.is(loci) || Bond.isLoci(loci)) {
      if (!Structure.areRootsEquivalent(loci.structure, _structure))
        return false;
      loci = Loci.remap(loci, _structure);
      if (Structure.isLoci(loci) || element_exports.Loci.is(loci) && element_exports.Loci.isWholeStructure(loci)) {
        loci = EveryLoci;
      }
    } else if (!isEveryLoci(loci) && !isDataLoci(loci)) {
      return false;
    }
    if (Loci.isEmpty(loci))
      return false;
    let changed = false;
    visuals.forEach(({ visual }) => {
      changed = visual.mark(loci, action) || changed;
    });
    return changed;
  }
  function setVisualState(visual, group, state) {
    const { visible, alphaFactor, pickable, overpaint, transparency, emissive, substance, clipping, themeStrength, transform, unitTransforms } = state;
    if (visible !== void 0)
      visual.setVisibility(visible);
    if (alphaFactor !== void 0)
      visual.setAlphaFactor(alphaFactor);
    if (pickable !== void 0)
      visual.setPickable(pickable);
    if (overpaint !== void 0)
      visual.setOverpaint(overpaint, webgl);
    if (transparency !== void 0)
      visual.setTransparency(transparency, webgl);
    if (emissive !== void 0)
      visual.setEmissive(emissive, webgl);
    if (substance !== void 0)
      visual.setSubstance(substance, webgl);
    if (clipping !== void 0)
      visual.setClipping(clipping);
    if (themeStrength !== void 0)
      visual.setThemeStrength(themeStrength);
    if (transform !== void 0) {
      if (transform !== _state.transform || !Mat4.areEqual(transform, _state.transform, EPSILON)) {
        visual.setTransform(transform);
      }
    }
    if (unitTransforms !== void 0) {
      if (unitTransforms) {
        visual.setTransform(void 0, unitTransforms.getSymmetryGroupTransforms(group));
      } else if (unitTransforms !== _state.unitTransforms) {
        visual.setTransform(void 0, null);
      }
    }
  }
  function setState(state) {
    const { visible, alphaFactor, pickable, overpaint, transparency, emissive, substance, clipping, themeStrength, transform, unitTransforms, syncManually, markerActions } = state;
    const newState = {};
    if (visible !== void 0)
      newState.visible = visible;
    if (alphaFactor !== void 0)
      newState.alphaFactor = alphaFactor;
    if (pickable !== void 0)
      newState.pickable = pickable;
    if (overpaint !== void 0 && _structure) {
      newState.overpaint = Overpaint.remap(overpaint, _structure);
    }
    if (transparency !== void 0 && _structure) {
      newState.transparency = Transparency.remap(transparency, _structure);
    }
    if (emissive !== void 0 && _structure) {
      newState.emissive = Emissive.remap(emissive, _structure);
    }
    if (substance !== void 0 && _structure) {
      newState.substance = Substance.remap(substance, _structure);
    }
    if (clipping !== void 0 && _structure) {
      newState.clipping = Clipping.remap(clipping, _structure);
    }
    if (themeStrength !== void 0)
      newState.themeStrength = themeStrength;
    if (transform !== void 0 && !Mat4.areEqual(transform, _state.transform, EPSILON)) {
      newState.transform = transform;
    }
    if (unitTransforms !== _state.unitTransforms || (unitTransforms === null || unitTransforms === void 0 ? void 0 : unitTransforms.version) !== _state.unitTransformsVersion) {
      newState.unitTransforms = unitTransforms;
      _state.unitTransformsVersion = unitTransforms ? unitTransforms === null || unitTransforms === void 0 ? void 0 : unitTransforms.version : -1;
    }
    if (syncManually !== void 0)
      newState.syncManually = syncManually;
    if (markerActions !== void 0)
      newState.markerActions = markerActions;
    visuals.forEach(({ visual, group }) => setVisualState(visual, group, newState));
    StructureRepresentationStateBuilder.update(_state, newState);
  }
  function setTheme(theme) {
    _theme = theme;
  }
  function destroy() {
    visuals.forEach(({ visual }) => visual.destroy());
    visuals.clear();
  }
  return {
    label: label2,
    get groupCount() {
      let groupCount = 0;
      visuals.forEach(({ visual }) => {
        if (visual.renderObject)
          groupCount += visual.groupCount;
      });
      return groupCount;
    },
    get geometryVersion() {
      return geometryState.version;
    },
    get props() {
      return _props;
    },
    get params() {
      return _params;
    },
    get state() {
      return _state;
    },
    get theme() {
      return _theme;
    },
    renderObjects,
    updated,
    createOrUpdate,
    setState,
    setTheme,
    getLoci,
    getAllLoci,
    eachLocation,
    mark,
    destroy
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/structure/units-visual.js
function createUnitsRenderObject(structureGroup, geometry, locationIt, theme, props, materialId) {
  const { createValues, createRenderableState } = Geometry.getUtils(geometry);
  const transform = createUnitsTransform(structureGroup, props.includeParent, geometry.boundingSphere, props.cellSize, props.batchSize);
  const values2 = createValues(geometry, transform, locationIt, theme, props);
  const state = createRenderableState(props);
  return createRenderObject(geometry.kind, values2, state, materialId);
}
function UnitsVisual(builder, materialId) {
  const { defaultProps, createGeometry, createLocationIterator, getLoci, eachLocation, setUpdateState, initUpdateState, mustRecreate, processValues, dispose: dispose2 } = builder;
  const { createEmpty: createEmptyGeometry, updateValues, updateBoundingSphere, updateRenderableState, createPositionIterator } = builder.geometryUtils;
  const updateState = VisualUpdateState.create();
  const previousMark = { loci: EmptyLoci, action: MarkerAction.None, status: -1 };
  let renderObject;
  let newProps = Object.assign({}, defaultProps);
  let newTheme = Theme.createEmpty();
  let newStructureGroup;
  let currentProps;
  let currentTheme;
  let currentStructureGroup;
  let geometry;
  let geometryVersion = -1;
  let locationIt;
  let positionIt;
  function prepareUpdate(theme, props, structureGroup) {
    if (!structureGroup && !currentStructureGroup) {
      throw new Error("missing structureGroup");
    }
    newProps = props;
    newTheme = theme;
    newStructureGroup = structureGroup;
    VisualUpdateState.reset(updateState);
    if (!renderObject || !currentStructureGroup) {
      initUpdateState === null || initUpdateState === void 0 ? void 0 : initUpdateState(updateState, newProps, newTheme, newStructureGroup);
      updateState.createNew = true;
      updateState.createGeometry = true;
      return;
    }
    setUpdateState(updateState, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
    if (!Structure.areHierarchiesEqual(currentStructureGroup.structure, newStructureGroup.structure)) {
      updateState.updateTransform = true;
      updateState.updateColor = true;
      updateState.updateSize = true;
    }
    if (!ColorTheme.areEqual(newTheme.color, currentTheme.color)) {
      updateState.updateColor = true;
    }
    if (!SizeTheme.areEqual(newTheme.size, currentTheme.size)) {
      updateState.updateSize = true;
    }
    if (currentStructureGroup.structure.child !== newStructureGroup.structure.child) {
      updateState.createGeometry = true;
      updateState.updateTransform = true;
    }
    if (newProps.instanceGranularity !== currentProps.instanceGranularity || newProps.cellSize !== currentProps.cellSize || newProps.batchSize !== currentProps.batchSize) {
      updateState.updateTransform = true;
    }
    if (!deepEqual(newProps.unitKinds, currentProps.unitKinds)) {
      updateState.createGeometry = true;
    }
    if (newStructureGroup.group.transformHash !== currentStructureGroup.group.transformHash) {
      if (newStructureGroup.group.units.length !== currentStructureGroup.group.units.length || updateState.updateColor) {
        updateState.updateTransform = true;
      } else {
        updateState.updateMatrix = true;
      }
    }
    const newUnit = newStructureGroup.group.units[0];
    const currentUnit = currentStructureGroup.group.units[0];
    if (!Unit.areOperatorsEqual(newUnit, currentUnit)) {
      updateState.updateTransform = true;
    }
    if (!Unit.areConformationsEqual(newUnit, currentUnit)) {
      updateState.createGeometry = true;
    }
    if (updateState.updateTransform) {
      updateState.updateMatrix = true;
    }
    if (updateState.updateSize && !("uSize" in renderObject.values)) {
      updateState.createGeometry = true;
    }
    if (updateState.createGeometry || updateState.updateTransform) {
      if (currentStructureGroup.structure.hashCode !== newStructureGroup.structure.hashCode) {
        updateState.updateColor = true;
        updateState.updateSize = true;
      }
      if (newTheme.color.granularity.startsWith("vertex") || renderObject.values.dColorType.ref.value.startsWith("vertex") || newTheme.color.granularity.startsWith("volume") || renderObject.values.dColorType.ref.value.startsWith("volume")) {
        updateState.updateColor = true;
      }
    }
  }
  function update10(newGeometry) {
    if (updateState.createNew) {
      locationIt = createLocationIterator(newStructureGroup, newProps);
      if (newGeometry) {
        renderObject = createUnitsRenderObject(newStructureGroup, newGeometry, locationIt, newTheme, newProps, materialId);
        positionIt = createPositionIterator(newGeometry, renderObject.values);
      } else {
        throw new Error("expected geometry to be given");
      }
    } else {
      if (!renderObject) {
        throw new Error("expected renderObject to be available");
      }
      if (updateState.updateColor || updateState.updateSize || updateState.updateTransform) {
        locationIt = createLocationIterator(newStructureGroup, newProps);
      }
      if (updateState.updateTransform) {
        const { instanceCount, groupCount } = locationIt;
        if (newProps.instanceGranularity) {
          createMarkers(instanceCount, "instance", renderObject.values);
        } else {
          createMarkers(instanceCount * groupCount, "groupInstance", renderObject.values);
        }
      }
      if (updateState.updateMatrix) {
        createUnitsTransform(newStructureGroup, newProps.includeParent, (newGeometry === null || newGeometry === void 0 ? void 0 : newGeometry.boundingSphere) || renderObject.values.invariantBoundingSphere.ref.value, newProps.cellSize, newProps.batchSize, renderObject.values);
        if ("lodLevels" in renderObject.values) {
          ValueCell.update(renderObject.values.lodLevels, renderObject.values.lodLevels.ref.value);
        }
      }
      if (updateState.createGeometry) {
        if (newGeometry) {
          ValueCell.updateIfChanged(renderObject.values.drawCount, Geometry.getDrawCount(newGeometry));
          ValueCell.updateIfChanged(renderObject.values.uVertexCount, Geometry.getVertexCount(newGeometry));
          ValueCell.updateIfChanged(renderObject.values.uGroupCount, Geometry.getGroupCount(newGeometry));
        } else {
          throw new Error("expected geometry to be given");
        }
      }
      if (updateState.updateTransform || updateState.createGeometry) {
        updateBoundingSphere(renderObject.values, newGeometry || geometry);
        positionIt = createPositionIterator(newGeometry || geometry, renderObject.values);
      }
      if (updateState.updateSize) {
        if ("uSize" in renderObject.values) {
          createSizes(locationIt, newTheme.size, renderObject.values);
        }
      }
      if (updateState.updateColor) {
        createColors(locationIt, positionIt, newTheme.color, renderObject.values);
      }
      updateValues(renderObject.values, newProps);
      updateRenderableState(renderObject.state, newProps);
    }
    currentProps = newProps;
    currentTheme = newTheme;
    currentStructureGroup = newStructureGroup;
    if (newGeometry) {
      geometry = newGeometry;
      geometryVersion += 1;
    }
  }
  function _createGeometry(ctx, unit, structure, theme, props, geometry2) {
    return includesUnitKind(props.unitKinds, unit) ? createGeometry(ctx, unit, structure, theme, props, geometry2) : createEmptyGeometry(geometry2);
  }
  function lociIsSuperset(loci) {
    if (isEveryLoci(loci))
      return true;
    if (Structure.isLoci(loci) && Structure.areRootsEquivalent(loci.structure, currentStructureGroup.structure))
      return true;
    if (element_exports.Loci.is(loci) && Structure.areRootsEquivalent(loci.structure, currentStructureGroup.structure)) {
      if (element_exports.Loci.isWholeStructure(loci))
        return true;
    }
    return false;
  }
  function eachInstance(loci, structureGroup, apply) {
    let changed = false;
    if (Bond.isLoci(loci)) {
      const { structure, group } = structureGroup;
      if (!Structure.areEquivalent(loci.structure, structure))
        return false;
      for (const b5 of loci.bonds) {
        if (b5.aUnit !== b5.bUnit)
          continue;
        const unitIdx = group.unitIndexMap.get(b5.aUnit.id);
        if (unitIdx !== void 0) {
          if (apply(Interval.ofSingleton(unitIdx)))
            changed = true;
        }
      }
    } else if (element_exports.Loci.is(loci)) {
      const { structure, group } = structureGroup;
      if (!Structure.areEquivalent(loci.structure, structure))
        return false;
      for (const e of loci.elements) {
        const unitIdx = group.unitIndexMap.get(e.unit.id);
        if (unitIdx !== void 0) {
          if (apply(Interval.ofSingleton(unitIdx)))
            changed = true;
        }
      }
    }
    return changed;
  }
  function lociApply(loci, apply, isMarking) {
    if (lociIsSuperset(loci)) {
      if (currentProps.instanceGranularity) {
        return apply(Interval.ofBounds(0, locationIt.instanceCount));
      } else {
        return apply(Interval.ofBounds(0, locationIt.groupCount * locationIt.instanceCount));
      }
    } else {
      if (currentProps.instanceGranularity) {
        return eachInstance(loci, currentStructureGroup, apply);
      } else {
        return eachLocation(loci, currentStructureGroup, apply, isMarking);
      }
    }
  }
  function finalize3(ctx) {
    if (renderObject) {
      processValues === null || processValues === void 0 ? void 0 : processValues(renderObject.values, geometry, currentProps, currentTheme, ctx.webgl);
    }
  }
  return {
    get groupCount() {
      return locationIt ? locationIt.count : 0;
    },
    get renderObject() {
      return locationIt && locationIt.count ? renderObject : void 0;
    },
    get geometryVersion() {
      return geometryVersion;
    },
    createOrUpdate(ctx, theme, props, structureGroup) {
      prepareUpdate(theme, props, structureGroup || currentStructureGroup);
      if (updateState.createGeometry) {
        const newGeometry = _createGeometry(ctx, newStructureGroup.group.units[0], newStructureGroup.structure, newTheme, newProps, geometry);
        if (isPromiseLike(newGeometry)) {
          return newGeometry.then((g) => {
            update10(g);
            finalize3(ctx);
          });
        }
        update10(newGeometry);
      } else {
        update10();
      }
      finalize3(ctx);
    },
    getLoci(pickingId) {
      return renderObject ? getLoci(pickingId, currentStructureGroup, renderObject.id) : EmptyLoci;
    },
    eachLocation(cb2) {
      locationIt.reset();
      while (locationIt.hasNext) {
        const { location, isSecondary } = locationIt.move();
        cb2(location, isSecondary);
      }
    },
    mark(loci, action) {
      let hasInvariantId = true;
      if (element_exports.Loci.is(loci)) {
        hasInvariantId = false;
        const { invariantId } = currentStructureGroup.group.units[0];
        for (const e of loci.elements) {
          if (e.unit.invariantId === invariantId) {
            hasInvariantId = true;
            break;
          }
        }
      }
      return hasInvariantId ? Visual.mark(renderObject, loci, action, lociApply, previousMark) : false;
    },
    setVisibility(visible) {
      Visual.setVisibility(renderObject, visible);
    },
    setAlphaFactor(alphaFactor) {
      Visual.setAlphaFactor(renderObject, alphaFactor);
    },
    setPickable(pickable) {
      Visual.setPickable(renderObject, pickable);
    },
    setColorOnly(colorOnly) {
      Visual.setColorOnly(renderObject, colorOnly);
    },
    setTransform(matrix, instanceMatrices) {
      Visual.setTransform(renderObject, matrix, instanceMatrices);
    },
    setOverpaint(overpaint, webgl) {
      const smoothing = { geometry, props: currentProps, webgl };
      Visual.setOverpaint(renderObject, overpaint, lociApply, true, smoothing);
    },
    setTransparency(transparency, webgl) {
      const smoothing = { geometry, props: currentProps, webgl };
      Visual.setTransparency(renderObject, transparency, lociApply, true, smoothing);
    },
    setEmissive(emissive, webgl) {
      const smoothing = { geometry, props: currentProps, webgl };
      Visual.setEmissive(renderObject, emissive, lociApply, true, smoothing);
    },
    setSubstance(substance, webgl) {
      const smoothing = { geometry, props: currentProps, webgl };
      Visual.setSubstance(renderObject, substance, lociApply, true, smoothing);
    },
    setClipping(clipping) {
      Visual.setClipping(renderObject, clipping, lociApply, true);
    },
    setThemeStrength(strength) {
      Visual.setThemeStrength(renderObject, strength);
    },
    destroy() {
      dispose2 === null || dispose2 === void 0 ? void 0 : dispose2(geometry);
      if (renderObject) {
        renderObject.state.disposed = true;
        renderObject = void 0;
      }
    },
    mustRecreate
  };
}
var UnitsMeshParams = { ...StructureMeshParams, ...StructureParams };
function UnitsMeshVisual(builder, materialId) {
  return UnitsVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.createGeometry = true;
    },
    geometryUtils: Mesh.Utils
  }, materialId);
}
var UnitsSpheresParams = { ...StructureSpheresParams, ...StructureParams };
function UnitsSpheresVisual(builder, materialId) {
  return UnitsVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.updateSize = true;
    },
    geometryUtils: Spheres.Utils
  }, materialId);
}
var UnitsCylindersParams = { ...StructureCylindersParams, ...StructureParams };
function UnitsCylindersVisual(builder, materialId) {
  return UnitsVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.updateSize = true;
    },
    geometryUtils: Cylinders.Utils
  }, materialId);
}
var UnitsPointsParams = { ...StructurePointsParams, ...StructureParams };
function UnitsPointsVisual(builder, materialId) {
  return UnitsVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.updateSize = true;
    },
    geometryUtils: Points.Utils
  }, materialId);
}
var UnitsLinesParams = { ...StructureLinesParams, ...StructureParams };
function UnitsLinesVisual(builder, materialId) {
  return UnitsVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.updateSize = true;
    },
    geometryUtils: Lines.Utils
  }, materialId);
}
var UnitsTextParams = { ...StructureTextParams, ...StructureParams };
var UnitsDirectVolumeParams = { ...StructureDirectVolumeParams, ...StructureParams };
function UnitsDirectVolumeVisual(builder, materialId) {
  return UnitsVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.createGeometry = true;
    },
    geometryUtils: DirectVolume.Utils
  }, materialId);
}
var UnitsTextureMeshParams = { ...StructureTextureMeshParams, ...StructureParams };
function UnitsTextureMeshVisual(builder, materialId) {
  return UnitsVisual({
    ...builder,
    setUpdateState: (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) => {
      builder.setUpdateState(state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup);
      if (!SizeTheme.areEqual(newTheme.size, currentTheme.size))
        state.createGeometry = true;
    },
    geometryUtils: TextureMesh.Utils
  }, materialId);
}
var UnitsImageParams = { ...StructureImageParams, ...StructureParams };

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/structure/representation.js
var StructureRepresentationStateBuilder = {
  create: () => {
    return {
      ...Representation.createState(),
      unitTransforms: null,
      unitTransformsVersion: -1
    };
  },
  update: (state, update10) => {
    Representation.updateState(state, update10);
    if (update10.unitTransforms !== void 0)
      state.unitTransforms = update10.unitTransforms;
  }
};
function StructureRepresentationProvider(p) {
  return p;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-repr/structure/complex-representation.js
function ComplexRepresentation(label2, ctx, getParams, visualCtor) {
  let version = 0;
  const { webgl } = ctx;
  const updated = new Subject();
  const geometryState = new Representation.GeometryState();
  const materialId = getNextMaterialId();
  const renderObjects = [];
  const _state = StructureRepresentationStateBuilder.create();
  let visual;
  let _structure;
  let _params;
  let _props;
  let _theme = Theme.createEmpty();
  function createOrUpdate(props = {}, structure) {
    if (structure && structure !== _structure) {
      _params = getParams(ctx, structure);
      _structure = structure;
      if (!_props)
        _props = ParamDefinition.getDefaultValues(_params);
    }
    _props = Object.assign({}, _props, props);
    return Task.create("Creating or updating ComplexRepresentation", async (runtime) => {
      var _a;
      let newVisual = false;
      if (!visual) {
        visual = visualCtor(materialId, _structure, _props, webgl);
        newVisual = true;
      } else if ((_a = visual.mustRecreate) === null || _a === void 0 ? void 0 : _a.call(visual, _structure, _props, webgl)) {
        visual.destroy();
        visual = visualCtor(materialId, _structure, _props, webgl);
        newVisual = true;
      }
      const promise = visual.createOrUpdate({ webgl, runtime }, _theme, _props, structure);
      if (promise)
        await promise;
      if (newVisual)
        setState(_state);
      renderObjects.length = 0;
      if (visual && visual.renderObject) {
        renderObjects.push(visual.renderObject);
        geometryState.add(visual.renderObject.id, visual.geometryVersion);
      }
      geometryState.snapshot();
      version += 1;
      updated.next(version);
    });
  }
  function getLoci(pickingId) {
    return visual ? visual.getLoci(pickingId) : EmptyLoci;
  }
  function getAllLoci() {
    var _a;
    return [Structure.Loci((_a = _structure.child) !== null && _a !== void 0 ? _a : _structure)];
  }
  function eachLocation(cb2) {
    visual === null || visual === void 0 ? void 0 : visual.eachLocation(cb2);
  }
  function mark(loci, action) {
    if (!_structure)
      return false;
    if (!MarkerActions.is(_state.markerActions, action))
      return false;
    if (Structure.isLoci(loci) || element_exports.Loci.is(loci) || Bond.isLoci(loci)) {
      if (!Structure.areRootsEquivalent(loci.structure, _structure))
        return false;
      loci = Loci.remap(loci, _structure);
      if (Structure.isLoci(loci) || element_exports.Loci.is(loci) && element_exports.Loci.isWholeStructure(loci)) {
        loci = EveryLoci;
      }
    } else if (!isEveryLoci(loci) && !isDataLoci(loci)) {
      return false;
    }
    if (Loci.isEmpty(loci))
      return false;
    return visual ? visual.mark(loci, action) : false;
  }
  function setState(state) {
    StructureRepresentationStateBuilder.update(_state, state);
    if (state.visible !== void 0 && visual) {
      visual.setVisibility(state.visible && (_state.unitTransforms === null || _state.unitTransforms.isIdentity));
    }
    if (state.alphaFactor !== void 0 && visual)
      visual.setAlphaFactor(state.alphaFactor);
    if (state.pickable !== void 0 && visual)
      visual.setPickable(state.pickable);
    if (state.overpaint !== void 0 && visual) {
      const remappedOverpaint = Overpaint.remap(state.overpaint, _structure);
      visual.setOverpaint(remappedOverpaint, webgl);
    }
    if (state.transparency !== void 0 && visual) {
      const remappedTransparency = Transparency.remap(state.transparency, _structure);
      visual.setTransparency(remappedTransparency, webgl);
    }
    if (state.emissive !== void 0 && visual) {
      const remappedEmissive = Emissive.remap(state.emissive, _structure);
      visual.setEmissive(remappedEmissive, webgl);
    }
    if (state.substance !== void 0 && visual) {
      const remappedSubstance = Substance.remap(state.substance, _structure);
      visual.setSubstance(remappedSubstance, webgl);
    }
    if (state.clipping !== void 0 && visual) {
      const remappedClipping = Clipping.remap(state.clipping, _structure);
      visual.setClipping(remappedClipping);
    }
    if (state.themeStrength !== void 0 && visual)
      visual.setThemeStrength(state.themeStrength);
    if (state.transform !== void 0 && visual)
      visual.setTransform(state.transform);
    if (state.unitTransforms !== void 0 && visual) {
      visual.setVisibility(_state.visible && (state.unitTransforms === null || state.unitTransforms.isIdentity));
    }
  }
  function setTheme(theme) {
    _theme = theme;
  }
  function destroy() {
    if (visual)
      visual.destroy();
  }
  return {
    label: label2,
    get groupCount() {
      return visual ? visual.groupCount : 0;
    },
    get props() {
      return _props;
    },
    get params() {
      return _params;
    },
    get state() {
      return _state;
    },
    get theme() {
      return _theme;
    },
    get geometryVersion() {
      return geometryState.version;
    },
    renderObjects,
    updated,
    createOrUpdate,
    setState,
    setTheme,
    getLoci,
    getAllLoci,
    eachLocation,
    mark,
    destroy
  };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/camera/util.js
function Viewport() {
  return Viewport.zero();
}
(function(Viewport2) {
  function zero() {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  Viewport2.zero = zero;
  function create(x, y, width, height) {
    return { x, y, width, height };
  }
  Viewport2.create = create;
  function clone(viewport) {
    return { ...viewport };
  }
  Viewport2.clone = clone;
  function copy(target, source) {
    return Object.assign(target, source);
  }
  Viewport2.copy = copy;
  function set4(viewport, x, y, width, height) {
    viewport.x = x;
    viewport.y = y;
    viewport.width = width;
    viewport.height = height;
    return viewport;
  }
  Viewport2.set = set4;
  function toVec4(v4, viewport) {
    v4[0] = viewport.x;
    v4[1] = viewport.y;
    v4[2] = viewport.width;
    v4[3] = viewport.height;
    return v4;
  }
  Viewport2.toVec4 = toVec4;
  function equals3(a5, b5) {
    return a5.x === b5.x && a5.y === b5.y && a5.width === b5.width && a5.height === b5.height;
  }
  Viewport2.equals = equals3;
})(Viewport || (Viewport = {}));
var tmpVec42 = Vec4();
function cameraProject(out, point, viewport, projectionView) {
  const { x, y, width, height } = viewport;
  Vec4.set(tmpVec42, point[0], point[1], point[2], 1);
  Vec4.transformMat4(tmpVec42, tmpVec42, projectionView);
  const w = tmpVec42[3];
  if (w !== 0) {
    tmpVec42[0] /= w;
    tmpVec42[1] /= w;
    tmpVec42[2] /= w;
  }
  out[0] = (tmpVec42[0] + 1) * width * 0.5 + x;
  out[1] = (tmpVec42[1] + 1) * height * 0.5 + y;
  out[2] = (tmpVec42[2] + 1) * 0.5;
  out[3] = w === 0 ? 0 : 1 / w;
  return out;
}
function cameraUnproject(out, point, viewport, inverseProjectionView) {
  const { x, y, width, height } = viewport;
  const px = point[0] - x;
  const py = point[1] - y;
  const pz = point[2];
  out[0] = 2 * px / width - 1;
  out[1] = 2 * py / height - 1;
  out[2] = 2 * pz - 1;
  return Vec3.transformMat4(out, out, inverseProjectionView);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/input/input-observer.js
function getButtons(event) {
  if (typeof event === "object") {
    if ("buttons" in event) {
      return event.buttons;
    } else if ("which" in event) {
      const b5 = event.which;
      if (b5 === 2) {
        return 4;
      } else if (b5 === 3) {
        return 2;
      } else if (b5 > 0) {
        return 1 << b5 - 1;
      }
    }
  }
  return 0;
}
function getButton(event) {
  if (typeof event === "object") {
    if ("button" in event) {
      const b5 = event.button;
      if (b5 === 1) {
        return 4;
      } else if (b5 === 2) {
        return 2;
      } else if (b5 >= 0) {
        return 1 << b5;
      }
    }
  }
  return 0;
}
function getModifiers(event) {
  return {
    alt: "altKey" in event ? event.altKey : false,
    shift: "shiftKey" in event ? event.shiftKey : false,
    control: "ctrlKey" in event ? event.ctrlKey : false,
    meta: "metaKey" in event ? event.metaKey : false
  };
}
var DefaultInputObserverProps = {
  noScroll: true,
  noMiddleClickScroll: true,
  noContextMenu: true,
  noPinchZoom: true,
  noTextSelect: true,
  preventGestures: false,
  mask: (x, y) => true,
  pixelScale: 1
};
var ModifiersKeys;
(function(ModifiersKeys2) {
  ModifiersKeys2.None = create();
  function areEqual(a5, b5) {
    return a5.shift === b5.shift && a5.alt === b5.alt && a5.control === b5.control && a5.meta === b5.meta;
  }
  ModifiersKeys2.areEqual = areEqual;
  function areNone(a5) {
    return areEqual(a5, ModifiersKeys2.None);
  }
  ModifiersKeys2.areNone = areNone;
  function size(a5) {
    if (!a5)
      return 0;
    let ret = 0;
    if (!!a5.shift)
      ret++;
    if (!!a5.alt)
      ret++;
    if (!!a5.control)
      ret++;
    if (!!a5.meta)
      ret++;
    return ret;
  }
  ModifiersKeys2.size = size;
  function create(modifierKeys = {}) {
    return {
      shift: !!modifierKeys.shift,
      alt: !!modifierKeys.alt,
      control: !!modifierKeys.control,
      meta: !!modifierKeys.meta
    };
  }
  ModifiersKeys2.create = create;
})(ModifiersKeys || (ModifiersKeys = {}));
var ButtonsType;
(function(ButtonsType2) {
  ButtonsType2.has = BitFlags.has;
  ButtonsType2.create = BitFlags.create;
  let Flag;
  (function(Flag2) {
    Flag2[Flag2["None"] = 0] = "None";
    Flag2[Flag2["Primary"] = 1] = "Primary";
    Flag2[Flag2["Secondary"] = 2] = "Secondary";
    Flag2[Flag2["Auxilary"] = 4] = "Auxilary";
    Flag2[Flag2["Forth"] = 8] = "Forth";
    Flag2[Flag2["Five"] = 16] = "Five";
  })(Flag = ButtonsType2.Flag || (ButtonsType2.Flag = {}));
})(ButtonsType || (ButtonsType = {}));
var EmptyKeyInput = {
  key: "",
  code: "",
  modifiers: ModifiersKeys.None,
  x: -1,
  y: -1,
  pageX: -1,
  pageY: -1,
  preventDefault: noop
};
var DraggingState;
(function(DraggingState2) {
  DraggingState2[DraggingState2["Stopped"] = 0] = "Stopped";
  DraggingState2[DraggingState2["Started"] = 1] = "Started";
  DraggingState2[DraggingState2["Moving"] = 2] = "Moving";
})(DraggingState || (DraggingState = {}));
function createEvents() {
  return {
    drag: new Subject(),
    interactionEnd: new Subject(),
    click: new Subject(),
    move: new Subject(),
    wheel: new Subject(),
    pinch: new Subject(),
    gesture: new Subject(),
    resize: new Subject(),
    leave: new Subject(),
    enter: new Subject(),
    modifiers: new Subject(),
    key: new Subject(),
    keyUp: new Subject(),
    keyDown: new Subject(),
    lock: new Subject()
  };
}
var AllowedNonPrintableKeys = ["Backspace", "Delete"];
var InputObserver;
(function(InputObserver2) {
  function create(props = {}) {
    const { noScroll, noContextMenu } = { ...DefaultInputObserverProps, ...props };
    return {
      noScroll,
      noContextMenu,
      pointerLock: false,
      width: 0,
      height: 0,
      pixelRatio: 1,
      ...createEvents(),
      setPixelScale: noop,
      requestPointerLock: noop,
      exitPointerLock: noop,
      dispose: noop
    };
  }
  InputObserver2.create = create;
  function fromElement(element, props = {}) {
    let { noScroll, noMiddleClickScroll, noContextMenu, noPinchZoom, noTextSelect, mask, pixelScale, preventGestures } = { ...DefaultInputObserverProps, ...props };
    let width = element.clientWidth * pixelRatio();
    let height = element.clientHeight * pixelRatio();
    let isLocked = false;
    let lockedViewport = Viewport();
    const pointerDown = Vec2();
    const pointerStart = Vec2();
    const pointerEnd = Vec2();
    const pointerDelta = Vec2();
    const rectSize = Vec2();
    const modifierKeys = {
      shift: false,
      alt: false,
      control: false,
      meta: false
    };
    const position = {
      x: -1,
      y: -1,
      pageX: -1,
      pageY: -1
    };
    function pixelRatio() {
      return window.devicePixelRatio * pixelScale;
    }
    function getModifierKeys() {
      return { ...modifierKeys };
    }
    function getKeyOnElement(event) {
      return event.target === document.body || event.target === element;
    }
    let dragging = DraggingState.Stopped;
    let disposed = false;
    let buttons = ButtonsType.create(ButtonsType.Flag.None);
    let button = ButtonsType.Flag.None;
    let isInside = false;
    let hasMoved = false;
    let resizeObserver;
    if (typeof window.ResizeObserver !== "undefined") {
      resizeObserver = new window.ResizeObserver(onResize);
    }
    const events = createEvents();
    const { drag, interactionEnd, wheel, pinch, gesture, click, move, leave, enter, resize, modifiers, key: key2, keyUp, keyDown, lock } = events;
    attach();
    function attach() {
      element.addEventListener("contextmenu", onContextMenu, false);
      element.addEventListener("wheel", onMouseWheel, false);
      element.addEventListener("mousedown", onMouseDown, false);
      window.addEventListener("mousemove", onMouseMove, false);
      window.addEventListener("mouseup", onMouseUp, false);
      element.addEventListener("touchstart", onTouchStart, false);
      element.addEventListener("touchmove", onTouchMove, false);
      element.addEventListener("touchend", onTouchEnd, false);
      element.addEventListener("gesturechange", onGestureChange, false);
      element.addEventListener("gesturestart", onGestureStart, false);
      element.addEventListener("gestureend", onGestureEnd, false);
      window.addEventListener("blur", handleBlur);
      window.addEventListener("keyup", handleKeyUp, false);
      window.addEventListener("keydown", handleKeyDown, false);
      window.addEventListener("keypress", handleKeyPress, false);
      document.addEventListener("pointerlockchange", onPointerLockChange, false);
      document.addEventListener("pointerlockerror", onPointerLockError, false);
      if (resizeObserver != null) {
        resizeObserver.observe(element.parentElement);
      } else {
        window.addEventListener("resize", onResize, false);
      }
    }
    function dispose2() {
      if (disposed)
        return;
      disposed = true;
      element.removeEventListener("contextmenu", onContextMenu, false);
      element.removeEventListener("wheel", onMouseWheel, false);
      element.removeEventListener("mousedown", onMouseDown, false);
      window.removeEventListener("mousemove", onMouseMove, false);
      window.removeEventListener("mouseup", onMouseUp, false);
      element.removeEventListener("touchstart", onTouchStart, false);
      element.removeEventListener("touchmove", onTouchMove, false);
      element.removeEventListener("touchend", onTouchEnd, false);
      element.removeEventListener("gesturechange", onGestureChange, false);
      element.removeEventListener("gesturestart", onGestureStart, false);
      element.removeEventListener("gestureend", onGestureEnd, false);
      window.removeEventListener("blur", handleBlur);
      window.removeEventListener("keyup", handleKeyUp, false);
      window.removeEventListener("keydown", handleKeyDown, false);
      window.removeEventListener("keypress", handleKeyPress, false);
      document.removeEventListener("pointerlockchange", onPointerLockChange, false);
      document.removeEventListener("pointerlockerror", onPointerLockError, false);
      cross.remove();
      if (resizeObserver != null) {
        resizeObserver.unobserve(element.parentElement);
        resizeObserver.disconnect();
      } else {
        window.removeEventListener("resize", onResize, false);
      }
    }
    function onPointerLockChange() {
      if (element.ownerDocument.pointerLockElement === element) {
        isLocked = true;
      } else {
        isLocked = false;
      }
      toggleCross(isLocked);
      lock.next(isLocked);
    }
    function onPointerLockError() {
      console.error("Unable to use Pointer Lock API");
      isLocked = false;
      toggleCross(isLocked);
      lock.next(isLocked);
    }
    function onContextMenu(event) {
      if (!mask(event.clientX, event.clientY))
        return;
      if (noContextMenu) {
        event.preventDefault();
      }
    }
    function updateModifierKeys(event) {
      modifierKeys.alt = event.altKey;
      modifierKeys.shift = event.shiftKey;
      modifierKeys.control = event.ctrlKey;
      modifierKeys.meta = event.metaKey;
    }
    function handleBlur() {
      if (buttons || modifierKeys.shift || modifierKeys.alt || modifierKeys.meta || modifierKeys.control) {
        buttons = 0;
        modifierKeys.shift = modifierKeys.alt = modifierKeys.control = modifierKeys.meta = false;
      }
    }
    function handleKeyDown(event) {
      let changed = false;
      if (!modifierKeys.alt && event.altKey) {
        changed = true;
        modifierKeys.alt = true;
      }
      if (!modifierKeys.shift && event.shiftKey) {
        changed = true;
        modifierKeys.shift = true;
      }
      if (!modifierKeys.control && event.ctrlKey) {
        changed = true;
        modifierKeys.control = true;
      }
      if (!modifierKeys.meta && event.metaKey) {
        changed = true;
        modifierKeys.meta = true;
      }
      if (changed && isInside)
        modifiers.next(getModifierKeys());
      if (getKeyOnElement(event) && isInside) {
        keyDown.next({
          key: event.key,
          code: event.code,
          modifiers: getModifierKeys(),
          ...position,
          preventDefault: () => event.preventDefault()
        });
      }
    }
    function handleKeyUp(event) {
      let changed = false;
      if (modifierKeys.alt && !event.altKey) {
        changed = true;
        modifierKeys.alt = false;
      }
      if (modifierKeys.shift && !event.shiftKey) {
        changed = true;
        modifierKeys.shift = false;
      }
      if (modifierKeys.control && !event.ctrlKey) {
        changed = true;
        modifierKeys.control = false;
      }
      if (modifierKeys.meta && !event.metaKey) {
        changed = true;
        modifierKeys.meta = false;
      }
      if (changed && isInside)
        modifiers.next(getModifierKeys());
      if (AllowedNonPrintableKeys.includes(event.key))
        handleKeyPress(event);
      if (getKeyOnElement(event) && isInside) {
        keyUp.next({
          key: event.key,
          code: event.code,
          modifiers: getModifierKeys(),
          ...position,
          preventDefault: () => event.preventDefault()
        });
      }
    }
    function handleKeyPress(event) {
      if (!getKeyOnElement(event) || !isInside)
        return;
      key2.next({
        key: event.key,
        code: event.code,
        modifiers: getModifierKeys(),
        ...position,
        preventDefault: () => event.preventDefault()
      });
    }
    function getCenterTouch(ev) {
      const t0 = ev.touches[0];
      const t1 = ev.touches[1];
      return {
        clientX: (t0.clientX + t1.clientX) / 2,
        clientY: (t0.clientY + t1.clientY) / 2,
        pageX: (t0.pageX + t1.pageX) / 2,
        pageY: (t0.pageY + t1.pageY) / 2,
        target: ev.target
      };
    }
    function getTouchDistance(ev) {
      const dx = ev.touches[0].pageX - ev.touches[1].pageX;
      const dy = ev.touches[0].pageY - ev.touches[1].pageY;
      return Math.sqrt(dx * dx + dy * dy);
    }
    let singleTouchDistance = -1;
    let lastSingleTouch = void 0;
    const singleTouchPosition = Vec2(), singleTouchTmp = Vec2();
    function updateSingleTouchDistance(ev) {
      if (singleTouchDistance < 0)
        return;
      Vec2.set(singleTouchTmp, ev.touches[0].pageX, ev.touches[0].pageY);
      singleTouchDistance += Vec2.distance(singleTouchPosition, singleTouchTmp);
      Vec2.copy(singleTouchPosition, singleTouchTmp);
    }
    const firstTouchStart = Vec2();
    let firstTouchStartSet = false;
    let initialTouchDistance = 0, lastTouchFraction = 1;
    function onTouchStart(ev) {
      ev.preventDefault();
      lastSingleTouch = void 0;
      singleTouchDistance = -1;
      if (ev.touches.length === 1) {
        buttons = button = ButtonsType.Flag.Primary;
        singleTouchDistance = 0;
        Vec2.set(singleTouchPosition, ev.touches[0].pageX, ev.touches[0].pageY);
        lastSingleTouch = ev.touches[0];
        onPointerDown(ev.touches[0]);
        Vec2.copy(firstTouchStart, pointerStart);
        firstTouchStartSet = true;
      } else if (ev.touches.length === 2) {
        buttons = ButtonsType.Flag.Secondary | ButtonsType.Flag.Auxilary;
        button = ButtonsType.Flag.Secondary;
        updateModifierKeys(ev);
        lastTouchFraction = 1;
        initialTouchDistance = getTouchDistance(ev);
        const { pageX: centerPageX, pageY: centerPageY } = getPagePosition(getCenterTouch(ev));
        if (!firstTouchStartSet) {
          eventOffset(firstTouchStart, getCenterTouch(ev));
          firstTouchStartSet = true;
        }
        pinch.next({
          isStart: true,
          distance: initialTouchDistance,
          delta: 0,
          fraction: lastTouchFraction,
          fractionDelta: 0,
          startX: firstTouchStart[0],
          startY: firstTouchStart[1],
          centerPageX,
          centerPageY,
          buttons,
          button,
          modifiers: getModifierKeys()
        });
      } else if (ev.touches.length === 3) {
        buttons = button = ButtonsType.Flag.Forth;
        onPointerDown(getCenterTouch(ev));
      }
    }
    function onTouchEnd(ev) {
      endDrag();
      if (lastSingleTouch && singleTouchDistance <= 4) {
        const t2 = lastSingleTouch;
        if (!mask(t2.clientX, t2.clientY))
          return;
        eventOffset(singleTouchTmp, t2);
        const { pageX, pageY } = getPagePosition(t2);
        const [x, y] = singleTouchTmp;
        click.next({ x, y, pageX, pageY, buttons, button, modifiers: getModifierKeys() });
      }
      lastSingleTouch = void 0;
      firstTouchStartSet = false;
    }
    function onTouchMove(ev) {
      button = ButtonsType.Flag.None;
      if (noPinchZoom) {
        ev.preventDefault();
        ev.stopPropagation();
        if (ev.originalEvent) {
          ev.originalEvent.preventDefault();
          ev.originalEvent.stopPropagation();
        }
      }
      lastSingleTouch = void 0;
      if (ev.touches.length === 1) {
        buttons = ButtonsType.Flag.Primary;
        lastSingleTouch = ev.touches[0];
        updateSingleTouchDistance(ev);
        onPointerMove(ev.touches[0]);
      } else if (ev.touches.length === 2) {
        buttons = ButtonsType.Flag.Secondary | ButtonsType.Flag.Auxilary;
        button = ButtonsType.Flag.Secondary;
        updateModifierKeys(ev);
        const { pageX: centerPageX, pageY: centerPageY } = getPagePosition(getCenterTouch(ev));
        const distance = getTouchDistance(ev);
        const delta = initialTouchDistance - distance;
        const fraction = initialTouchDistance / distance;
        const fractionDelta = fraction - lastTouchFraction;
        lastTouchFraction = fraction;
        pinch.next({
          isStart: false,
          distance,
          delta,
          fraction,
          fractionDelta,
          startX: firstTouchStart[0],
          startY: firstTouchStart[1],
          centerPageX,
          centerPageY,
          buttons,
          button,
          modifiers: getModifierKeys()
        });
      } else if (ev.touches.length === 3) {
        buttons = ButtonsType.Flag.Forth;
        onPointerMove(getCenterTouch(ev));
      }
    }
    function onMouseDown(ev) {
      updateModifierKeys(ev);
      buttons = getButtons(ev);
      button = getButton(ev);
      if (noMiddleClickScroll && buttons === ButtonsType.Flag.Auxilary) {
        ev.preventDefault;
      }
      onPointerDown(ev);
    }
    function onMouseMove(ev) {
      updateModifierKeys(ev);
      buttons = getButtons(ev);
      button = ButtonsType.Flag.None;
      onPointerMove(ev);
    }
    function onMouseUp(ev) {
      updateModifierKeys(ev);
      buttons = getButtons(ev);
      button = getButton(ev);
      onPointerUp(ev);
      endDrag();
    }
    function endDrag() {
      interactionEnd.next(void 0);
    }
    function onPointerDown(ev) {
      if (!mask(ev.clientX, ev.clientY))
        return;
      eventOffset(pointerStart, ev);
      Vec2.copy(pointerDown, pointerStart);
      if (insideBounds(pointerStart)) {
        dragging = DraggingState.Started;
      }
    }
    function onPointerUp(ev) {
      dragging = DraggingState.Stopped;
      if (!mask(ev.clientX, ev.clientY))
        return;
      eventOffset(pointerEnd, ev);
      if (!hasMoved && Vec2.distance(pointerEnd, pointerDown) < 4) {
        const { pageX, pageY } = getPagePosition(ev);
        const [x, y] = pointerEnd;
        click.next({ x, y, pageX, pageY, buttons, button, modifiers: getModifierKeys() });
      }
      hasMoved = false;
    }
    function onPointerMove(ev) {
      var _a;
      eventOffset(pointerEnd, ev);
      const { pageX, pageY } = getPagePosition(ev);
      const [x, y] = pointerEnd;
      const { movementX, movementY } = ev;
      const inside = insideBounds(pointerEnd) && mask(ev.clientX, ev.clientY);
      if (isInside && !inside) {
        leave.next(void 0);
      } else if (!isInside && inside) {
        enter.next(void 0);
      }
      isInside = inside;
      position.x = x;
      position.y = y;
      position.pageX = pageX;
      position.pageY = pageY;
      move.next({ x, y, pageX, pageY, movementX, movementY, buttons, button, modifiers: getModifierKeys(), inside, onElement: ev.target === element });
      if (dragging === DraggingState.Stopped)
        return;
      if (noTextSelect) {
        (_a = ev.preventDefault) === null || _a === void 0 ? void 0 : _a.call(ev);
      }
      Vec2.div(pointerDelta, Vec2.sub(pointerDelta, pointerEnd, pointerStart), getClientSize(rectSize));
      if (Vec2.magnitude(pointerDelta) < EPSILON)
        return;
      const isStart = dragging === DraggingState.Started;
      if (isStart && !mask(ev.clientX, ev.clientY))
        return;
      if (Vec2.distance(pointerEnd, pointerDown) >= 4) {
        hasMoved = true;
      }
      const [dx, dy] = pointerDelta;
      drag.next({ x, y, dx, dy, pageX, pageY, buttons, button, modifiers: getModifierKeys(), isStart });
      Vec2.copy(pointerStart, pointerEnd);
      dragging = DraggingState.Moving;
    }
    function onMouseWheel(ev) {
      if (!mask(ev.clientX, ev.clientY))
        return;
      eventOffset(pointerEnd, ev);
      const { pageX, pageY } = getPagePosition(ev);
      const [x, y] = pointerEnd;
      if (noScroll) {
        ev.preventDefault();
      }
      const normalized2 = normalizeWheel(ev);
      buttons = button = ButtonsType.Flag.Auxilary;
      if (normalized2.dx || normalized2.dy || normalized2.dz) {
        wheel.next({ x, y, pageX, pageY, ...normalized2, buttons, button, modifiers: getModifierKeys() });
      }
    }
    function tryPreventGesture(ev) {
      var _a, _b;
      if (!preventGestures)
        return;
      ev.preventDefault();
      (_a = ev.stopImmediatePropagation) === null || _a === void 0 ? void 0 : _a.call(ev);
      (_b = ev.stopPropagation) === null || _b === void 0 ? void 0 : _b.call(ev);
    }
    let prevGestureScale = 0, prevGestureRotation = 0;
    function onGestureStart(ev) {
      tryPreventGesture(ev);
      prevGestureScale = ev.scale;
      prevGestureRotation = ev.rotation;
      gesture.next({ scale: ev.scale, rotation: ev.rotation, deltaRotation: 0, deltaScale: 0, isStart: true });
    }
    function gestureDelta(ev, isEnd) {
      gesture.next({
        scale: ev.scale,
        rotation: ev.rotation,
        deltaRotation: prevGestureRotation - ev.rotation,
        deltaScale: prevGestureScale - ev.scale,
        isEnd
      });
      prevGestureRotation = ev.rotation;
      prevGestureScale = ev.scale;
    }
    function onGestureChange(ev) {
      tryPreventGesture(ev);
      gestureDelta(ev);
    }
    function onGestureEnd(ev) {
      tryPreventGesture(ev);
      gestureDelta(ev, true);
    }
    function onResize() {
      width = element.clientWidth * pixelRatio();
      height = element.clientHeight * pixelRatio();
      resize.next({});
    }
    function insideBounds(pos) {
      if (element instanceof Window || element instanceof Document || element === document.body) {
        return true;
      } else {
        const rect = element.getBoundingClientRect();
        return pos[0] >= 0 && pos[1] >= 0 && pos[0] < rect.width && pos[1] < rect.height;
      }
    }
    function getClientSize(out) {
      out[0] = element.clientWidth;
      out[1] = element.clientHeight;
      return out;
    }
    function eventOffset(out, ev) {
      width = element.clientWidth * pixelRatio();
      height = element.clientHeight * pixelRatio();
      if (isLocked) {
        const pr = pixelRatio();
        out[0] = (lockedViewport.x + lockedViewport.width / 2) / pr;
        out[1] = (height - (lockedViewport.y + lockedViewport.height / 2)) / pr;
      } else {
        const rect = element.getBoundingClientRect();
        out[0] = (ev.clientX || 0) - rect.left;
        out[1] = (ev.clientY || 0) - rect.top;
      }
      return out;
    }
    function getPagePosition(ev) {
      if (isLocked) {
        return {
          pageX: Math.round(window.innerWidth / 2) + lockedViewport.x,
          pageY: Math.round(window.innerHeight / 2) + lockedViewport.y
        };
      } else {
        return {
          pageX: ev.pageX,
          pageY: ev.pageY
        };
      }
    }
    const crossWidth = 30;
    const cross = addCross();
    function addCross() {
      var _a;
      const cross2 = document.createElement("div");
      const b5 = "30%";
      const t2 = "10%";
      const c5 = `#000 ${b5}, #0000 0 calc(100% - ${b5}), #000 0`;
      const vline = `linear-gradient(0deg, ${c5}) 50%/${t2} 100% no-repeat`;
      const hline = `linear-gradient(90deg, ${c5}) 50%/100% ${t2} no-repeat`;
      const cdot = "radial-gradient(circle at 50%, #000 5%, #0000 5%)";
      Object.assign(cross2.style, {
        width: `${crossWidth}px`,
        aspectRatio: 1,
        background: `${vline}, ${hline}, ${cdot}`,
        display: "none",
        zIndex: 1e3,
        position: "absolute",
        mixBlendMode: "difference",
        filter: "invert(1)"
      });
      (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(cross2);
      return cross2;
    }
    function toggleCross(value) {
      cross.style.display = value ? "block" : "none";
      if (value) {
        const pr = pixelRatio();
        const offsetX = (lockedViewport.x + lockedViewport.width / 2) / pr;
        const offsetY = (lockedViewport.y + lockedViewport.height / 2) / pr;
        cross.style.width = `${crossWidth}px`;
        cross.style.left = `calc(${offsetX}px - ${crossWidth / 2}px)`;
        cross.style.bottom = `calc(${offsetY}px - ${crossWidth / 2}px)`;
      }
    }
    return {
      get noScroll() {
        return noScroll;
      },
      set noScroll(value) {
        noScroll = value;
      },
      get noContextMenu() {
        return noContextMenu;
      },
      set noContextMenu(value) {
        noContextMenu = value;
      },
      get width() {
        return width;
      },
      get height() {
        return height;
      },
      get pixelRatio() {
        return pixelRatio();
      },
      get pointerLock() {
        return isLocked;
      },
      ...events,
      setPixelScale: (value) => {
        pixelScale = value;
        width = element.clientWidth * pixelRatio();
        height = element.clientHeight * pixelRatio();
      },
      requestPointerLock: (viewport) => {
        lockedViewport = viewport;
        if (!isLocked) {
          element.requestPointerLock();
        }
      },
      exitPointerLock: () => {
        if (isLocked) {
          element.ownerDocument.exitPointerLock();
        }
      },
      dispose: dispose2
    };
  }
  InputObserver2.fromElement = fromElement;
})(InputObserver || (InputObserver = {}));
function normalizeWheel(event) {
  const PIXEL_STEP = 10;
  const LINE_HEIGHT = 40;
  const PAGE_HEIGHT = 800;
  let spinX = 0, spinY = 0, dx = 0, dy = 0, dz = 0;
  if ("detail" in event) {
    spinY = event.detail;
  }
  if ("wheelDelta" in event) {
    spinY = -event.wheelDelta / 120;
  }
  if ("wheelDeltaY" in event) {
    spinY = -event.wheelDeltaY / 120;
  }
  if ("wheelDeltaX" in event) {
    spinX = -event.wheelDeltaX / 120;
  }
  if ("axis" in event && event.axis === event.HORIZONTAL_AXIS) {
    spinX = spinY;
    spinY = 0;
  }
  dx = spinX * PIXEL_STEP;
  dy = spinY * PIXEL_STEP;
  if ("deltaY" in event) {
    dy = event.deltaY;
  }
  if ("deltaX" in event) {
    dx = event.deltaX;
  }
  if ("deltaZ" in event) {
    dz = event.deltaZ;
  }
  if ((dx || dy || dz) && event.deltaMode) {
    if (event.deltaMode === 1) {
      dx *= LINE_HEIGHT;
      dy *= LINE_HEIGHT;
      dz *= LINE_HEIGHT;
    } else {
      dx *= PAGE_HEIGHT;
      dy *= PAGE_HEIGHT;
      dz *= PAGE_HEIGHT;
    }
  }
  if (dx && !spinX) {
    spinX = dx < 1 ? -1 : 1;
  }
  if (dy && !spinY) {
    spinY = dy < 1 ? -1 : 1;
  }
  return { spinX, spinY, dx, dy, dz };
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/renderer.js
var PickType;
(function(PickType2) {
  PickType2[PickType2["None"] = 0] = "None";
  PickType2[PickType2["Object"] = 1] = "Object";
  PickType2[PickType2["Instance"] = 2] = "Instance";
  PickType2[PickType2["Group"] = 3] = "Group";
})(PickType || (PickType = {}));
var MarkingType;
(function(MarkingType2) {
  MarkingType2[MarkingType2["None"] = 0] = "None";
  MarkingType2[MarkingType2["Depth"] = 1] = "Depth";
  MarkingType2[MarkingType2["Mask"] = 2] = "Mask";
})(MarkingType || (MarkingType = {}));
var RendererParams = {
  backgroundColor: ParamDefinition.Color(Color(0), { description: "Background color of the 3D canvas" }),
  pickingAlphaThreshold: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }, { description: "The minimum opacity value needed for an object to be pickable." }),
  interiorDarkening: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }),
  interiorColorFlag: ParamDefinition.Boolean(true, { label: "Use Interior Color" }),
  interiorColor: ParamDefinition.Color(Color.fromNormalizedRgb(0.3, 0.3, 0.3)),
  colorMarker: ParamDefinition.Boolean(true, { description: "Enable color marker" }),
  highlightColor: ParamDefinition.Color(Color.fromNormalizedRgb(1, 0.4, 0.6)),
  selectColor: ParamDefinition.Color(Color.fromNormalizedRgb(0.2, 1, 0.1)),
  dimColor: ParamDefinition.Color(Color.fromNormalizedRgb(1, 1, 1)),
  highlightStrength: ParamDefinition.Numeric(0.3, { min: 0, max: 1, step: 0.1 }),
  selectStrength: ParamDefinition.Numeric(0.3, { min: 0, max: 1, step: 0.1 }),
  dimStrength: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.1 }),
  markerPriority: ParamDefinition.Select(1, [[1, "Highlight"], [2, "Select"]]),
  xrayEdgeFalloff: ParamDefinition.Numeric(1, { min: 0, max: 3, step: 0.1 }),
  celSteps: ParamDefinition.Numeric(5, { min: 2, max: 16, step: 1 }),
  exposure: ParamDefinition.Numeric(1, { min: 0, max: 3, step: 0.01 }),
  light: ParamDefinition.ObjectList({
    inclination: ParamDefinition.Numeric(150, { min: 0, max: 180, step: 1 }),
    azimuth: ParamDefinition.Numeric(320, { min: 0, max: 360, step: 1 }),
    color: ParamDefinition.Color(Color.fromNormalizedRgb(1, 1, 1)),
    intensity: ParamDefinition.Numeric(0.6, { min: 0, max: 5, step: 0.01 })
  }, (o) => Color.toHexString(o.color), { defaultValue: [{
    inclination: 150,
    azimuth: 320,
    color: Color.fromNormalizedRgb(1, 1, 1),
    intensity: 0.6
  }] }),
  ambientColor: ParamDefinition.Color(Color.fromNormalizedRgb(1, 1, 1)),
  ambientIntensity: ParamDefinition.Numeric(0.4, { min: 0, max: 2, step: 0.01 })
};
var tmpDir2 = Vec3();
var tmpColor = Vec3();
function getLight(props, light) {
  const count3 = props.length;
  const { direction, color } = light || {
    direction: new Array(count3 * 3).fill(0),
    color: new Array(count3 * 3).fill(0)
  };
  for (let i = 0; i < count3; ++i) {
    const p = props[i];
    Vec3.directionFromSpherical(tmpDir2, degToRad(p.inclination), degToRad(p.azimuth), 1);
    Vec3.toArray(tmpDir2, direction, i * 3);
    Vec3.scale(tmpColor, Color.toVec3Normalized(tmpColor, p.color), p.intensity);
    Vec3.toArray(tmpColor, color, i * 3);
  }
  return { count: count3, direction, color };
}
var Renderer;
(function(Renderer2) {
  let Flag;
  (function(Flag2) {
    Flag2[Flag2["None"] = 0] = "None";
    Flag2[Flag2["BlendedFront"] = 1] = "BlendedFront";
    Flag2[Flag2["BlendedBack"] = 2] = "BlendedBack";
  })(Flag || (Flag = {}));
  let Mask;
  (function(Mask2) {
    Mask2[Mask2["All"] = 0] = "All";
    Mask2[Mask2["Opaque"] = 1] = "Opaque";
    Mask2[Mask2["Transparent"] = 2] = "Transparent";
  })(Mask || (Mask = {}));
  function create(ctx, props = {}) {
    const { gl, state, stats } = ctx;
    const p = ParamDefinition.merge(RendererParams, ParamDefinition.getDefaultValues(RendererParams), props);
    const light = getLight(p.light);
    const viewport = Viewport();
    const drawingBufferSize = Vec2.create(gl.drawingBufferWidth, gl.drawingBufferHeight);
    const bgColor = Color.toVec3Normalized(Vec3(), p.backgroundColor);
    let transparentBackground = false;
    let isOccluded = null;
    const emptyDepthTexture = ctx.resources.texture("image-uint8", "rgba", "ubyte", "nearest");
    emptyDepthTexture.define(1, 1);
    emptyDepthTexture.load({ array: new Uint8Array([255, 255, 255, 255]), width: 1, height: 1 });
    const sharedTexturesList = [
      ["tDepth", emptyDepthTexture]
    ];
    const view = Mat4();
    const invView = Mat4();
    const modelView = Mat4();
    const invModelView = Mat4();
    const invProjection = Mat4();
    const modelViewProjection = Mat4();
    const invModelViewProjection = Mat4();
    const cameraDir = Vec3();
    const cameraPosition = Vec3();
    const cameraPlane = Plane3D();
    const viewOffset = Vec2();
    const frustum = Frustum3D();
    const ambientColor = Vec3();
    Vec3.scale(ambientColor, Color.toArrayNormalized(p.ambientColor, ambientColor, 0), p.ambientIntensity);
    const globalUniforms = {
      uDrawId: ValueCell.create(0),
      uModel: ValueCell.create(Mat4.identity()),
      uView: ValueCell.create(view),
      uInvView: ValueCell.create(invView),
      uModelView: ValueCell.create(modelView),
      uInvModelView: ValueCell.create(invModelView),
      uInvProjection: ValueCell.create(invProjection),
      uProjection: ValueCell.create(Mat4()),
      uModelViewProjection: ValueCell.create(modelViewProjection),
      uInvModelViewProjection: ValueCell.create(invModelViewProjection),
      uIsOrtho: ValueCell.create(1),
      uViewOffset: ValueCell.create(viewOffset),
      uPixelRatio: ValueCell.create(ctx.pixelRatio),
      uViewport: ValueCell.create(Viewport.toVec4(Vec4(), viewport)),
      uDrawingBufferSize: ValueCell.create(drawingBufferSize),
      uCameraPosition: ValueCell.create(cameraPosition),
      uCameraDir: ValueCell.create(cameraDir),
      uCameraPlane: ValueCell.create(Plane3D.toArray(cameraPlane, Vec4(), 0)),
      uNear: ValueCell.create(1),
      uFar: ValueCell.create(1e4),
      uFog: ValueCell.create(true),
      uFogNear: ValueCell.create(1),
      uFogFar: ValueCell.create(1e4),
      uFogColor: ValueCell.create(bgColor),
      uRenderMask: ValueCell.create(0),
      uMarkingDepthTest: ValueCell.create(false),
      uPickType: ValueCell.create(PickType.None),
      uMarkingType: ValueCell.create(MarkingType.None),
      uTransparentBackground: ValueCell.create(false),
      uLightDirection: ValueCell.create(light.direction),
      uLightColor: ValueCell.create(light.color),
      uAmbientColor: ValueCell.create(ambientColor),
      uPickingAlphaThreshold: ValueCell.create(p.pickingAlphaThreshold),
      uInteriorDarkening: ValueCell.create(p.interiorDarkening),
      uInteriorColorFlag: ValueCell.create(p.interiorColorFlag),
      uInteriorColor: ValueCell.create(Color.toVec3Normalized(Vec3(), p.interiorColor)),
      uHighlightColor: ValueCell.create(Color.toVec3Normalized(Vec3(), p.highlightColor)),
      uSelectColor: ValueCell.create(Color.toVec3Normalized(Vec3(), p.selectColor)),
      uDimColor: ValueCell.create(Color.toVec3Normalized(Vec3(), p.dimColor)),
      uHighlightStrength: ValueCell.create(p.highlightStrength),
      uSelectStrength: ValueCell.create(p.selectStrength),
      uDimStrength: ValueCell.create(p.dimStrength),
      uMarkerPriority: ValueCell.create(p.markerPriority),
      uMarkerAverage: ValueCell.create(0),
      uXrayEdgeFalloff: ValueCell.create(p.xrayEdgeFalloff),
      uCelSteps: ValueCell.create(p.celSteps),
      uExposure: ValueCell.create(p.exposure)
    };
    const globalUniformList = Object.entries(globalUniforms);
    let globalUniformsNeedUpdate = true;
    const renderObject = (r, variant, flag) => {
      var _a, _b, _c;
      if (r.state.disposed || !r.state.visible || !r.state.pickable && variant === "pick") {
        return;
      }
      if (!r.values.drawCount.ref.value) {
        return;
      }
      if (!Frustum3D.intersectsSphere3D(frustum, r.values.boundingSphere.ref.value)) {
        return;
      }
      const [minDistance, maxDistance] = r.values.uLod.ref.value;
      if (minDistance !== 0 || maxDistance !== 0) {
        const { center, radius } = r.values.boundingSphere.ref.value;
        const d3 = Plane3D.distanceToPoint(cameraPlane, center);
        if (d3 + radius < minDistance)
          return;
        if (d3 - radius > maxDistance)
          return;
      }
      if (isOccluded !== null && isOccluded(r.values.boundingSphere.ref.value)) {
        return;
      }
      const hasInstanceGrid = r.values.instanceGrid.ref.value.cellSize > 0;
      const hasMultipleInstances = r.values.uInstanceCount.ref.value > 1;
      if (hasInstanceGrid && (hasMultipleInstances || r.values.lodLevels)) {
        r.cull(cameraPlane, frustum, isOccluded, ctx.stats);
      } else {
        r.uncull();
      }
      let needUpdate = false;
      if (r.values.dLightCount.ref.value !== light.count) {
        ValueCell.update(r.values.dLightCount, light.count);
        needUpdate = true;
      }
      if (r.values.dColorMarker.ref.value !== p.colorMarker) {
        ValueCell.update(r.values.dColorMarker, p.colorMarker);
        needUpdate = true;
      }
      if (needUpdate)
        r.update();
      const program = r.getProgram(variant);
      if (state.currentProgramId !== program.id) {
        globalUniformsNeedUpdate = true;
        program.use();
      }
      if (globalUniformsNeedUpdate) {
        program.setUniforms(globalUniformList);
        program.bindTextures(sharedTexturesList, 0);
        globalUniformsNeedUpdate = false;
      }
      if (r.values.dGeometryType.ref.value === "directVolume") {
        if (variant !== "color") {
          return;
        }
        state.disable(gl.CULL_FACE);
        state.frontFace(gl.CCW);
      } else if (flag === Flag.BlendedFront) {
        state.enable(gl.CULL_FACE);
        if ((_a = r.values.dFlipSided) === null || _a === void 0 ? void 0 : _a.ref.value) {
          state.frontFace(gl.CW);
          state.cullFace(gl.FRONT);
        } else {
          state.frontFace(gl.CCW);
          state.cullFace(gl.BACK);
        }
      } else if (flag === Flag.BlendedBack) {
        state.enable(gl.CULL_FACE);
        if ((_b = r.values.dFlipSided) === null || _b === void 0 ? void 0 : _b.ref.value) {
          state.frontFace(gl.CW);
          state.cullFace(gl.BACK);
        } else {
          state.frontFace(gl.CCW);
          state.cullFace(gl.FRONT);
        }
      } else {
        if (r.values.uDoubleSided) {
          if (r.values.uDoubleSided.ref.value || r.values.hasReflection.ref.value) {
            state.disable(gl.CULL_FACE);
          } else {
            state.enable(gl.CULL_FACE);
          }
        } else {
          state.disable(gl.CULL_FACE);
        }
        if ((_c = r.values.dFlipSided) === null || _c === void 0 ? void 0 : _c.ref.value) {
          state.frontFace(gl.CW);
          state.cullFace(gl.FRONT);
        } else {
          state.frontFace(gl.CCW);
          state.cullFace(gl.BACK);
        }
      }
      r.render(variant, sharedTexturesList.length);
    };
    const update10 = (camera, scene) => {
      ValueCell.update(globalUniforms.uView, camera.view);
      ValueCell.update(globalUniforms.uInvView, Mat4.invert(invView, camera.view));
      ValueCell.update(globalUniforms.uProjection, camera.projection);
      ValueCell.update(globalUniforms.uInvProjection, Mat4.invert(invProjection, camera.projection));
      ValueCell.updateIfChanged(globalUniforms.uIsOrtho, camera.state.mode === "orthographic" ? 1 : 0);
      ValueCell.update(globalUniforms.uViewOffset, camera.viewOffset.enabled ? Vec2.set(viewOffset, camera.viewOffset.offsetX * 16, camera.viewOffset.offsetY * 16) : Vec2.set(viewOffset, 0, 0));
      ValueCell.update(globalUniforms.uCameraPosition, Vec3.copy(cameraPosition, camera.state.position));
      ValueCell.update(globalUniforms.uCameraDir, Vec3.normalize(cameraDir, Vec3.sub(cameraDir, camera.state.target, camera.state.position)));
      ValueCell.updateIfChanged(globalUniforms.uFar, camera.far);
      ValueCell.updateIfChanged(globalUniforms.uNear, camera.near);
      ValueCell.updateIfChanged(globalUniforms.uFog, camera.state.fog > 0);
      ValueCell.updateIfChanged(globalUniforms.uFogFar, camera.fogFar);
      ValueCell.updateIfChanged(globalUniforms.uFogNear, camera.fogNear);
      ValueCell.updateIfChanged(globalUniforms.uTransparentBackground, transparentBackground);
      Frustum3D.fromProjectionMatrix(frustum, camera.projectionView);
      Plane3D.copy(cameraPlane, frustum[Frustum3D.PlaneIndex.Near]);
      cameraPlane.constant -= Plane3D.distanceToPoint(cameraPlane, cameraPosition);
      ValueCell.update(globalUniforms.uCameraPlane, Plane3D.toArray(cameraPlane, globalUniforms.uCameraPlane.ref.value, 0));
      ValueCell.updateIfChanged(globalUniforms.uMarkerAverage, scene.markerAverage);
    };
    const updateInternal = (group, camera, depthTexture, renderMask, markingDepthTest) => {
      arrayMapUpsert(sharedTexturesList, "tDepth", depthTexture || emptyDepthTexture);
      ValueCell.update(globalUniforms.uModel, group.view);
      ValueCell.update(globalUniforms.uModelView, Mat4.mul(modelView, camera.view, group.view));
      ValueCell.update(globalUniforms.uInvModelView, Mat4.invert(invModelView, modelView));
      ValueCell.update(globalUniforms.uModelViewProjection, Mat4.mul(modelViewProjection, modelView, camera.projection));
      ValueCell.update(globalUniforms.uInvModelViewProjection, Mat4.invert(invModelViewProjection, modelViewProjection));
      ValueCell.updateIfChanged(globalUniforms.uRenderMask, renderMask);
      ValueCell.updateIfChanged(globalUniforms.uMarkingDepthTest, markingDepthTest);
      state.enable(gl.SCISSOR_TEST);
      state.colorMask(true, true, true, true);
      const { x, y, width, height } = viewport;
      state.viewport(x, y, width, height);
      state.scissor(x, y, width, height);
      globalUniformsNeedUpdate = true;
      state.currentRenderItemId = -1;
    };
    const checkOpaque = function(r) {
      var _a, _b, _c, _d;
      const alpha = clamp(r.values.alpha.ref.value * r.state.alphaFactor, 0, 1);
      const xrayShaded = ((_a = r.values.dXrayShaded) === null || _a === void 0 ? void 0 : _a.ref.value) === "on" || ((_b = r.values.dXrayShaded) === null || _b === void 0 ? void 0 : _b.ref.value) === "inverted";
      return alpha === 1 && r.values.transparencyAverage.ref.value !== 1 && r.values.dGeometryType.ref.value !== "directVolume" && ((_c = r.values.dPointStyle) === null || _c === void 0 ? void 0 : _c.ref.value) !== "fuzzy" && !xrayShaded || ((_d = r.values.dTransparentBackfaces) === null || _d === void 0 ? void 0 : _d.ref.value) === "opaque";
    };
    const checkTransparent = function(r) {
      var _a, _b, _c;
      const alpha = clamp(r.values.alpha.ref.value * r.state.alphaFactor, 0, 1);
      const xrayShaded = ((_a = r.values.dXrayShaded) === null || _a === void 0 ? void 0 : _a.ref.value) === "on" || ((_b = r.values.dXrayShaded) === null || _b === void 0 ? void 0 : _b.ref.value) === "inverted";
      return alpha < 1 && alpha !== 0 || r.values.transparencyAverage.ref.value > 0 || r.values.dGeometryType.ref.value === "directVolume" || ((_c = r.values.dPointStyle) === null || _c === void 0 ? void 0 : _c.ref.value) === "fuzzy" || r.values.dGeometryType.ref.value === "text" || r.values.dGeometryType.ref.value === "image" || xrayShaded;
    };
    const renderPick = (group, camera, variant, pickType) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderPick");
      state.disable(gl.BLEND);
      state.enable(gl.DEPTH_TEST);
      state.depthMask(true);
      updateInternal(group, camera, null, Mask.All, false);
      ValueCell.updateIfChanged(globalUniforms.uPickType, pickType);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        if (!renderables[i].state.colorOnly) {
          renderObject(renderables[i], variant, Flag.None);
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderPick");
    };
    const renderDepth = (group, camera) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderDepth");
      state.disable(gl.BLEND);
      state.enable(gl.DEPTH_TEST);
      state.depthMask(true);
      updateInternal(group, camera, null, Mask.All, false);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        renderObject(renderables[i], "depth", Flag.None);
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderDepth");
    };
    const renderDepthOpaque = (group, camera) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderDepthOpaque");
      state.disable(gl.BLEND);
      state.enable(gl.DEPTH_TEST);
      state.depthMask(true);
      updateInternal(group, camera, null, Mask.Opaque, false);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        if (checkOpaque(r)) {
          renderObject(r, "depth", Flag.None);
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderDepthOpaque");
    };
    const renderDepthOpaqueBack = (group, camera) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderDepthOpaqueBack");
      state.disable(gl.BLEND);
      state.enable(gl.DEPTH_TEST);
      state.depthMask(true);
      state.depthFunc(gl.GREATER);
      updateInternal(group, camera, null, Mask.Opaque, false);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        if (checkOpaque(r)) {
          renderObject(r, "depth", Flag.BlendedBack);
        }
      }
      state.depthFunc(gl.LESS);
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderDepthOpaqueBack");
    };
    const renderDepthTransparent = (group, camera, depthTexture) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderDepthTransparent");
      state.disable(gl.BLEND);
      state.enable(gl.DEPTH_TEST);
      state.depthMask(true);
      updateInternal(group, camera, depthTexture, Mask.Transparent, false);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        if (checkTransparent(r)) {
          renderObject(r, "depth", Flag.None);
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderDepthTransparent");
    };
    const renderMarkingDepth = (group, camera) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderMarkingDepth");
      state.disable(gl.BLEND);
      state.enable(gl.DEPTH_TEST);
      state.depthMask(true);
      updateInternal(group, camera, null, Mask.All, false);
      ValueCell.updateIfChanged(globalUniforms.uMarkingType, MarkingType.Depth);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        const alpha = clamp(r.values.alpha.ref.value * r.state.alphaFactor, 0, 1);
        if (alpha !== 0 && r.values.transparencyAverage.ref.value !== 1 && r.values.markerAverage.ref.value !== 1) {
          renderObject(renderables[i], "marking", Flag.None);
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderMarkingDepth");
    };
    const renderMarkingMask = (group, camera, depthTexture) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderMarkingMask");
      state.disable(gl.BLEND);
      state.enable(gl.DEPTH_TEST);
      state.depthMask(true);
      updateInternal(group, camera, depthTexture, Mask.All, !!depthTexture);
      ValueCell.updateIfChanged(globalUniforms.uMarkingType, MarkingType.Mask);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        if (r.values.markerAverage.ref.value > 0) {
          renderObject(renderables[i], "marking", Flag.None);
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderMarkingMask");
    };
    const renderEmissive = (group, camera) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderEmissive");
      state.disable(gl.BLEND);
      state.enable(gl.DEPTH_TEST);
      state.depthMask(true);
      updateInternal(group, camera, null, Mask.Opaque, false);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        if (checkOpaque(r)) {
          renderObject(r, "emissive", Flag.None);
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderEmissive");
    };
    const renderTracing = (group, camera) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderTracing");
      state.disable(gl.BLEND);
      state.enable(gl.DEPTH_TEST);
      state.depthMask(true);
      updateInternal(group, camera, null, Mask.Opaque, false);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        if (checkOpaque(r)) {
          renderObject(r, "tracing", Flag.None);
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderTracing");
    };
    const renderBlended = (scene, camera) => {
      if (scene.hasOpaque) {
        renderOpaque(scene, camera);
      }
      if (scene.opacityAverage < 1) {
        renderBlendedTransparent(scene, camera);
      }
    };
    const renderOpaque = (group, camera) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderOpaque");
      state.disable(gl.BLEND);
      state.enable(gl.DEPTH_TEST);
      state.depthMask(true);
      updateInternal(group, camera, null, Mask.Opaque, false);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        if (checkOpaque(r)) {
          renderObject(r, "color", Flag.None);
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderOpaque");
    };
    const renderBlendedTransparent = (group, camera) => {
      var _a, _b;
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderBlendedTransparent");
      if (transparentBackground) {
        state.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      } else {
        state.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      }
      state.enable(gl.BLEND);
      state.enable(gl.DEPTH_TEST);
      state.depthMask(false);
      updateInternal(group, camera, null, Mask.Transparent, false);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        if (checkTransparent(r)) {
          if ((_a = r.values.uDoubleSided) === null || _a === void 0 ? void 0 : _a.ref.value) {
            if (((_b = r.values.dTransparentBackfaces) === null || _b === void 0 ? void 0 : _b.ref.value) !== "opaque") {
              renderObject(r, "color", Flag.BlendedBack);
            }
            renderObject(r, "color", Flag.BlendedFront);
          } else {
            renderObject(r, "color", Flag.None);
          }
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderBlendedTransparent");
    };
    const renderVolume = (group, camera, depthTexture) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderVolume");
      state.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      state.enable(gl.BLEND);
      state.disable(gl.DEPTH_TEST);
      state.depthMask(false);
      updateInternal(group, camera, depthTexture, Mask.Transparent, false);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        if (r.values.dGeometryType.ref.value === "directVolume") {
          renderObject(r, "color", Flag.None);
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderVolume");
    };
    const renderWboitTransparent = (group, camera, depthTexture) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderWboitTransparent");
      updateInternal(group, camera, depthTexture, Mask.Transparent, false);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        if (checkTransparent(r)) {
          renderObject(r, "color", Flag.None);
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderWboitTransparent");
    };
    const renderDpoitTransparent = (group, camera, depthTexture, dpoitTextures) => {
      if (isTimingMode)
        ctx.timer.mark("Renderer.renderDpoitTransparent");
      state.enable(gl.BLEND);
      arrayMapUpsert(sharedTexturesList, "tDpoitDepth", dpoitTextures.depth);
      arrayMapUpsert(sharedTexturesList, "tDpoitFrontColor", dpoitTextures.frontColor);
      arrayMapUpsert(sharedTexturesList, "tDpoitBackColor", dpoitTextures.backColor);
      updateInternal(group, camera, depthTexture, Mask.Transparent, false);
      const { renderables } = group;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        const r = renderables[i];
        if (checkTransparent(r)) {
          renderObject(r, "color", Flag.None);
        }
      }
      if (isTimingMode)
        ctx.timer.markEnd("Renderer.renderDpoitTransparent");
    };
    return {
      clear: (toBackgroundColor, ignoreTransparentBackground, forceToTransparency) => {
        state.enable(gl.SCISSOR_TEST);
        state.enable(gl.DEPTH_TEST);
        state.colorMask(true, true, true, true);
        state.depthMask(true);
        if (forceToTransparency || transparentBackground && !ignoreTransparentBackground) {
          state.clearColor(0, 0, 0, 0);
        } else if (toBackgroundColor) {
          state.clearColor(bgColor[0], bgColor[1], bgColor[2], 1);
        } else {
          state.clearColor(1, 1, 1, 1);
        }
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      },
      clearDepth: (packed = false) => {
        state.enable(gl.SCISSOR_TEST);
        state.enable(gl.DEPTH_TEST);
        state.depthMask(true);
        if (packed) {
          state.colorMask(true, true, true, true);
          state.clearColor(1, 1, 1, 1);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        } else {
          gl.clear(gl.DEPTH_BUFFER_BIT);
        }
      },
      update: update10,
      renderPick,
      renderDepth,
      renderDepthOpaque,
      renderDepthOpaqueBack,
      renderDepthTransparent,
      renderMarkingDepth,
      renderMarkingMask,
      renderEmissive,
      renderTracing,
      renderBlended,
      renderOpaque,
      renderBlendedTransparent,
      renderVolume,
      renderWboitTransparent,
      renderDpoitTransparent,
      setProps: (props2) => {
        if (props2.backgroundColor !== void 0 && props2.backgroundColor !== p.backgroundColor) {
          p.backgroundColor = props2.backgroundColor;
          Color.toVec3Normalized(bgColor, p.backgroundColor);
          ValueCell.update(globalUniforms.uFogColor, Vec3.copy(globalUniforms.uFogColor.ref.value, bgColor));
        }
        if (props2.pickingAlphaThreshold !== void 0 && props2.pickingAlphaThreshold !== p.pickingAlphaThreshold) {
          p.pickingAlphaThreshold = props2.pickingAlphaThreshold;
          ValueCell.update(globalUniforms.uPickingAlphaThreshold, p.pickingAlphaThreshold);
        }
        if (props2.interiorDarkening !== void 0 && props2.interiorDarkening !== p.interiorDarkening) {
          p.interiorDarkening = props2.interiorDarkening;
          ValueCell.update(globalUniforms.uInteriorDarkening, p.interiorDarkening);
        }
        if (props2.interiorColorFlag !== void 0 && props2.interiorColorFlag !== p.interiorColorFlag) {
          p.interiorColorFlag = props2.interiorColorFlag;
          ValueCell.update(globalUniforms.uInteriorColorFlag, p.interiorColorFlag);
        }
        if (props2.interiorColor !== void 0 && props2.interiorColor !== p.interiorColor) {
          p.interiorColor = props2.interiorColor;
          ValueCell.update(globalUniforms.uInteriorColor, Color.toVec3Normalized(globalUniforms.uInteriorColor.ref.value, p.interiorColor));
        }
        if (props2.colorMarker !== void 0 && props2.colorMarker !== p.colorMarker) {
          p.colorMarker = props2.colorMarker;
        }
        if (props2.highlightColor !== void 0 && props2.highlightColor !== p.highlightColor) {
          p.highlightColor = props2.highlightColor;
          ValueCell.update(globalUniforms.uHighlightColor, Color.toVec3Normalized(globalUniforms.uHighlightColor.ref.value, p.highlightColor));
        }
        if (props2.selectColor !== void 0 && props2.selectColor !== p.selectColor) {
          p.selectColor = props2.selectColor;
          ValueCell.update(globalUniforms.uSelectColor, Color.toVec3Normalized(globalUniforms.uSelectColor.ref.value, p.selectColor));
        }
        if (props2.dimColor !== void 0 && props2.dimColor !== p.dimColor) {
          p.dimColor = props2.dimColor;
          ValueCell.update(globalUniforms.uDimColor, Color.toVec3Normalized(globalUniforms.uDimColor.ref.value, p.dimColor));
        }
        if (props2.highlightStrength !== void 0 && props2.highlightStrength !== p.highlightStrength) {
          p.highlightStrength = props2.highlightStrength;
          ValueCell.update(globalUniforms.uHighlightStrength, p.highlightStrength);
        }
        if (props2.selectStrength !== void 0 && props2.selectStrength !== p.selectStrength) {
          p.selectStrength = props2.selectStrength;
          ValueCell.update(globalUniforms.uSelectStrength, p.selectStrength);
        }
        if (props2.dimStrength !== void 0 && props2.dimStrength !== p.dimStrength) {
          p.dimStrength = props2.dimStrength;
          ValueCell.update(globalUniforms.uDimStrength, p.dimStrength);
        }
        if (props2.markerPriority !== void 0 && props2.markerPriority !== p.markerPriority) {
          p.markerPriority = props2.markerPriority;
          ValueCell.update(globalUniforms.uMarkerPriority, p.markerPriority);
        }
        if (props2.xrayEdgeFalloff !== void 0 && props2.xrayEdgeFalloff !== p.xrayEdgeFalloff) {
          p.xrayEdgeFalloff = props2.xrayEdgeFalloff;
          ValueCell.update(globalUniforms.uXrayEdgeFalloff, p.xrayEdgeFalloff);
        }
        if (props2.celSteps !== void 0 && props2.celSteps !== p.celSteps) {
          p.celSteps = props2.celSteps;
          ValueCell.update(globalUniforms.uCelSteps, p.celSteps);
        }
        if (props2.exposure !== void 0 && props2.exposure !== p.exposure) {
          p.exposure = props2.exposure;
          ValueCell.update(globalUniforms.uExposure, p.exposure);
        }
        if (props2.light !== void 0 && !deepEqual(props2.light, p.light)) {
          p.light = props2.light;
          Object.assign(light, getLight(props2.light, light));
          ValueCell.update(globalUniforms.uLightDirection, light.direction);
          ValueCell.update(globalUniforms.uLightColor, light.color);
        }
        if (props2.ambientColor !== void 0 && props2.ambientColor !== p.ambientColor) {
          p.ambientColor = props2.ambientColor;
          Vec3.scale(ambientColor, Color.toArrayNormalized(p.ambientColor, ambientColor, 0), p.ambientIntensity);
          ValueCell.update(globalUniforms.uAmbientColor, ambientColor);
        }
        if (props2.ambientIntensity !== void 0 && props2.ambientIntensity !== p.ambientIntensity) {
          p.ambientIntensity = props2.ambientIntensity;
          Vec3.scale(ambientColor, Color.toArrayNormalized(p.ambientColor, ambientColor, 0), p.ambientIntensity);
          ValueCell.update(globalUniforms.uAmbientColor, ambientColor);
        }
      },
      setViewport: (x, y, width, height) => {
        state.viewport(x, y, width, height);
        state.scissor(x, y, width, height);
        if (x !== viewport.x || y !== viewport.y || width !== viewport.width || height !== viewport.height) {
          Viewport.set(viewport, x, y, width, height);
          ValueCell.update(globalUniforms.uViewport, Vec4.set(globalUniforms.uViewport.ref.value, x, y, width, height));
        }
      },
      setTransparentBackground: (value) => {
        transparentBackground = value;
      },
      setDrawingBufferSize: (width, height) => {
        if (width !== drawingBufferSize[0] || height !== drawingBufferSize[1]) {
          ValueCell.update(globalUniforms.uDrawingBufferSize, Vec2.set(drawingBufferSize, width, height));
        }
      },
      setPixelRatio: (value) => {
        ValueCell.update(globalUniforms.uPixelRatio, value);
      },
      setOcclusionTest: (f) => {
        isOccluded = f;
      },
      props: p,
      get stats() {
        return {
          programCount: ctx.stats.resourceCounts.program,
          shaderCount: ctx.stats.resourceCounts.shader,
          attributeCount: ctx.stats.resourceCounts.attribute,
          elementsCount: ctx.stats.resourceCounts.elements,
          framebufferCount: ctx.stats.resourceCounts.framebuffer,
          renderbufferCount: ctx.stats.resourceCounts.renderbuffer,
          textureCount: ctx.stats.resourceCounts.texture,
          vertexArrayCount: ctx.stats.resourceCounts.vertexArray,
          drawCount: stats.drawCount,
          instanceCount: stats.instanceCount,
          instancedDrawCount: stats.instancedDrawCount
        };
      },
      get light() {
        return light;
      },
      get ambientColor() {
        return globalUniforms.uAmbientColor.ref.value;
      },
      dispose: () => {
      }
    };
  }
  Renderer2.create = create;
})(Renderer || (Renderer = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/binding.js
function Binding(triggers, action = "", description = "") {
  return Binding.create(triggers, action, description);
}
(function(Binding2) {
  function create(triggers, action = "", description = "") {
    return { triggers, action, description };
  }
  Binding2.create = create;
  function isBinding(x) {
    return !!x && Array.isArray(x.triggers) && typeof x.action === "string";
  }
  Binding2.isBinding = isBinding;
  Binding2.Empty = { triggers: [], action: "", description: "" };
  function isEmpty3(binding) {
    return binding.triggers.length === 0 || binding.triggers.every((t2) => t2.buttons === void 0 && t2.modifiers === void 0 && !t2.code);
  }
  Binding2.isEmpty = isEmpty3;
  function match(binding, buttons, modifiers) {
    return binding.triggers.some((t2) => Trigger2.match(t2, buttons, modifiers));
  }
  Binding2.match = match;
  function matchKey(binding, code, modifiers, key2) {
    return binding.triggers.some((t2) => Trigger2.matchKey(t2, code, modifiers, key2));
  }
  Binding2.matchKey = matchKey;
  function formatTriggers(binding) {
    return binding.triggers.map(Trigger2.format).join(" or ");
  }
  Binding2.formatTriggers = formatTriggers;
  function format(binding, name = "") {
    const help = binding.description || stringToWords(name);
    return interpolate(help, { triggers: "<i>" + formatTriggers(binding) + "</i>" });
  }
  Binding2.format = format;
  function Trigger2(buttons, modifiers) {
    return Trigger2.create(buttons, modifiers);
  }
  Binding2.Trigger = Trigger2;
  function TriggerKey(code, modifiers) {
    return Trigger2.create(void 0, modifiers, code);
  }
  Binding2.TriggerKey = TriggerKey;
  (function(Trigger3) {
    function create2(buttons, modifiers, code) {
      return { buttons, modifiers, code };
    }
    Trigger3.create = create2;
    Trigger3.Empty = {};
    function match2(trigger, buttons, modifiers) {
      const { buttons: b5, modifiers: m } = trigger;
      return b5 !== void 0 && (b5 === buttons || ButtonsType.has(b5, buttons)) && (!m || ModifiersKeys.areEqual(m, modifiers));
    }
    Trigger3.match = match2;
    function matchKey2(trigger, code, modifiers, key2) {
      const { modifiers: m, code: c5 } = trigger;
      return c5 !== void 0 && (c5 === code || c5.length === 1 && code.length === 4 && code.startsWith("Key") && !!key2 && key2.length === 1 && key2.toUpperCase() === c5.toUpperCase()) && (!m || ModifiersKeys.areEqual(m, modifiers));
    }
    Trigger3.matchKey = matchKey2;
    function format2(trigger) {
      const s = [];
      const b5 = formatButtons(trigger.buttons, trigger.code);
      if (b5)
        s.push(b5);
      const c5 = formatCode(trigger.code);
      if (c5)
        s.push(c5);
      const m = formatModifiers(trigger.modifiers);
      if (m)
        s.push(m);
      return s.join(" + ");
    }
    Trigger3.format = format2;
  })(Trigger2 = Binding2.Trigger || (Binding2.Trigger = {}));
})(Binding || (Binding = {}));
var B15 = ButtonsType;
function formatButtons(buttons, code) {
  const s = [];
  if (buttons === void 0 && !code) {
    s.push("any mouse button");
  } else if (buttons === 0) {
    s.push("mouse hover");
  } else if (buttons !== void 0) {
    if (B15.has(buttons, B15.Flag.Primary))
      s.push("left mouse button");
    if (B15.has(buttons, B15.Flag.Secondary))
      s.push("right mouse button");
    if (B15.has(buttons, B15.Flag.Auxilary))
      s.push("wheel/middle mouse button");
    if (B15.has(buttons, B15.Flag.Forth))
      s.push("three fingers");
  }
  return s.join(" + ");
}
function formatModifiers(modifiers, verbose) {
  const s = [];
  if (modifiers) {
    if (modifiers.alt)
      s.push("alt key");
    if (modifiers.control)
      s.push("control key");
    if (modifiers.meta)
      s.push("meta/command key");
    if (modifiers.shift)
      s.push("shift key");
    if (verbose && s.length === 0)
      s.push("no key");
  } else {
    if (verbose)
      s.push("any key");
  }
  return s.join(" + ");
}
function formatCode(code) {
  if (code === null || code === void 0 ? void 0 : code.startsWith("Key"))
    code = code.substring(3);
  return code && camelCaseToWords(code).toLowerCase();
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/controls/trackball.js
var B16 = ButtonsType;
var M = ModifiersKeys;
var Trigger = Binding.Trigger;
var Key = Binding.TriggerKey;
var DefaultTrackballBindings = {
  dragRotate: Binding([Trigger(B16.Flag.Primary, M.create())], "Rotate", "Drag using ${triggers}"),
  dragRotateZ: Binding([Trigger(B16.Flag.Primary, M.create({ shift: true, control: true }))], "Rotate around z-axis (roll)", "Drag using ${triggers}"),
  dragPan: Binding([
    Trigger(B16.Flag.Secondary, M.create()),
    Trigger(B16.Flag.Primary, M.create({ control: true }))
  ], "Pan", "Drag using ${triggers}"),
  dragZoom: Binding.Empty,
  dragFocus: Binding([Trigger(B16.Flag.Forth, M.create())], "Focus", "Drag using ${triggers}"),
  dragFocusZoom: Binding([Trigger(B16.Flag.Auxilary, M.create())], "Focus and zoom", "Drag using ${triggers}"),
  scrollZoom: Binding([Trigger(B16.Flag.Auxilary, M.create())], "Zoom", "Scroll using ${triggers}"),
  scrollFocus: Binding([Trigger(B16.Flag.Auxilary, M.create({ shift: true }))], "Clip", "Scroll using ${triggers}"),
  scrollFocusZoom: Binding.Empty,
  keyMoveForward: Binding([Key("KeyW")], "Move forward", "Press ${triggers}"),
  keyMoveBack: Binding([Key("KeyS")], "Move back", "Press ${triggers}"),
  keyMoveLeft: Binding([Key("KeyA")], "Move left", "Press ${triggers}"),
  keyMoveRight: Binding([Key("KeyD")], "Move right", "Press ${triggers}"),
  keyMoveUp: Binding([Key("KeyR")], "Move up", "Press ${triggers}"),
  keyMoveDown: Binding([Key("KeyF")], "Move down", "Press ${triggers}"),
  keyRollLeft: Binding([Key("KeyQ")], "Roll left", "Press ${triggers}"),
  keyRollRight: Binding([Key("KeyE")], "Roll right", "Press ${triggers}"),
  keyPitchUp: Binding([Key("ArrowUp", M.create({ shift: true }))], "Pitch up", "Press ${triggers}"),
  keyPitchDown: Binding([Key("ArrowDown", M.create({ shift: true }))], "Pitch down", "Press ${triggers}"),
  keyYawLeft: Binding([Key("ArrowLeft", M.create({ shift: true }))], "Yaw left", "Press ${triggers}"),
  keyYawRight: Binding([Key("ArrowRight", M.create({ shift: true }))], "Yaw right", "Press ${triggers}"),
  boostMove: Binding([Key("ShiftLeft")], "Boost move", "Press ${triggers}"),
  enablePointerLock: Binding([Key("Space", M.create({ control: true }))], "Enable pointer lock", "Press ${triggers}")
};
var TrackballControlsParams = {
  noScroll: ParamDefinition.Boolean(true, { isHidden: true }),
  rotateSpeed: ParamDefinition.Numeric(5, { min: 1, max: 10, step: 1 }),
  zoomSpeed: ParamDefinition.Numeric(7, { min: 1, max: 15, step: 1 }),
  panSpeed: ParamDefinition.Numeric(1, { min: 0.1, max: 5, step: 0.1 }),
  moveSpeed: ParamDefinition.Numeric(0.75, { min: 0.1, max: 3, step: 0.1 }),
  boostMoveFactor: ParamDefinition.Numeric(5, { min: 0.1, max: 10, step: 0.1 }),
  flyMode: ParamDefinition.Boolean(false),
  animate: ParamDefinition.MappedStatic("off", {
    off: ParamDefinition.EmptyGroup(),
    spin: ParamDefinition.Group({
      speed: ParamDefinition.Numeric(1, { min: -20, max: 20, step: 1 }, { description: "Rotation speed in radians per second" })
    }, { description: "Spin the 3D scene around the x-axis in view space" }),
    rock: ParamDefinition.Group({
      speed: ParamDefinition.Numeric(0.3, { min: -5, max: 5, step: 0.1 }),
      angle: ParamDefinition.Numeric(10, { min: 0, max: 90, step: 1 }, { description: "How many degrees to rotate in each direction." })
    }, { description: "Rock the 3D scene around the x-axis in view space" })
  }),
  staticMoving: ParamDefinition.Boolean(true, { isHidden: true }),
  dynamicDampingFactor: ParamDefinition.Numeric(0.2, {}, { isHidden: true }),
  minDistance: ParamDefinition.Numeric(0.01, {}, { isHidden: true }),
  maxDistance: ParamDefinition.Numeric(1e150, {}, { isHidden: true }),
  gestureScaleFactor: ParamDefinition.Numeric(1, {}, { isHidden: true }),
  maxWheelDelta: ParamDefinition.Numeric(0.02, {}, { isHidden: true }),
  bindings: ParamDefinition.Value(DefaultTrackballBindings, { isHidden: true }),
  /**
   * minDistance = minDistanceFactor * boundingSphere.radius + minDistancePadding
   * maxDistance = max(maxDistanceFactor * boundingSphere.radius, maxDistanceMin)
   */
  autoAdjustMinMaxDistance: ParamDefinition.MappedStatic("on", {
    off: ParamDefinition.EmptyGroup(),
    on: ParamDefinition.Group({
      minDistanceFactor: ParamDefinition.Numeric(0),
      minDistancePadding: ParamDefinition.Numeric(5),
      maxDistanceFactor: ParamDefinition.Numeric(10),
      maxDistanceMin: ParamDefinition.Numeric(20)
    })
  }, { isHidden: true })
};
var TrackballControls;
(function(TrackballControls2) {
  function create(input, camera, scene, props = {}) {
    const p = {
      ...ParamDefinition.getDefaultValues(TrackballControlsParams),
      ...props,
      // include default bindings for backwards state compatibility
      bindings: { ...DefaultTrackballBindings, ...props.bindings }
    };
    const b5 = p.bindings;
    const viewport = Viewport.clone(camera.viewport);
    let disposed = false;
    const dragSub = input.drag.subscribe(onDrag);
    const interactionEndSub = input.interactionEnd.subscribe(onInteractionEnd);
    const wheelSub = input.wheel.subscribe(onWheel);
    const pinchSub = input.pinch.subscribe(onPinch);
    const keyDownSub = input.keyDown.subscribe(onKeyDown);
    const keyUpSub = input.keyUp.subscribe(onKeyUp);
    const moveSub = input.move.subscribe(onMove);
    const lockSub = input.lock.subscribe(onLock);
    const leaveSub = input.leave.subscribe(onLeave);
    let _isInteracting = false;
    const lastPosition = Vec3();
    const _eye = Vec3();
    const _rotPrev = Vec2();
    const _rotCurr = Vec2();
    const _rotLastAxis = Vec3();
    let _rotLastAngle = 0;
    const _rollPrev = Vec2();
    const _rollCurr = Vec2();
    let _rollLastAngle = 0;
    let _pitchLastAngle = 0;
    let _yawLastAngle = 0;
    const _zoomStart = Vec2();
    const _zoomEnd = Vec2();
    const _focusStart = Vec2();
    const _focusEnd = Vec2();
    const _panStart = Vec2();
    const _panEnd = Vec2();
    const target0 = Vec3.clone(camera.target);
    const position0 = Vec3.clone(camera.position);
    const up0 = Vec3.clone(camera.up);
    const mouseOnScreenVec2 = Vec2();
    function getMouseOnScreen(pageX, pageY) {
      return Vec2.set(mouseOnScreenVec2, (pageX - viewport.x) / viewport.width, (pageY - viewport.y) / viewport.height);
    }
    const mouseOnCircleVec2 = Vec2();
    function getMouseOnCircle(pageX, pageY) {
      return Vec2.set(
        mouseOnCircleVec2,
        (pageX - viewport.width * 0.5 - viewport.x) / (viewport.width * 0.5),
        (viewport.height + 2 * (viewport.y - pageY)) / viewport.width
        // viewport.width intentional
      );
    }
    function getRotateFactor() {
      const aspectRatio = input.width / input.height || 1;
      return p.rotateSpeed * input.pixelRatio * aspectRatio;
    }
    const rotAxis = Vec3();
    const rotQuat = Quat();
    const rotEyeDir = Vec3();
    const rotObjUpDir = Vec3();
    const rotObjSideDir = Vec3();
    const rotMoveDir = Vec3();
    function rotateCamera() {
      const dx = _rotCurr[0] - _rotPrev[0];
      const dy = _rotCurr[1] - _rotPrev[1];
      Vec3.set(rotMoveDir, dx, dy, 0);
      const angle = Vec3.magnitude(rotMoveDir) * getRotateFactor();
      if (angle) {
        Vec3.sub(_eye, camera.position, camera.target);
        Vec3.normalize(rotEyeDir, _eye);
        Vec3.normalize(rotObjUpDir, camera.up);
        Vec3.normalize(rotObjSideDir, Vec3.cross(rotObjSideDir, rotObjUpDir, rotEyeDir));
        Vec3.setMagnitude(rotObjUpDir, rotObjUpDir, dy);
        Vec3.setMagnitude(rotObjSideDir, rotObjSideDir, dx);
        Vec3.add(rotMoveDir, rotObjUpDir, rotObjSideDir);
        Vec3.normalize(rotAxis, Vec3.cross(rotAxis, rotMoveDir, _eye));
        Quat.setAxisAngle(rotQuat, rotAxis, angle);
        Vec3.transformQuat(_eye, _eye, rotQuat);
        Vec3.transformQuat(camera.up, camera.up, rotQuat);
        Vec3.copy(_rotLastAxis, rotAxis);
        _rotLastAngle = angle;
      } else if (!p.staticMoving && _rotLastAngle) {
        _rotLastAngle *= Math.sqrt(1 - p.dynamicDampingFactor);
        Vec3.sub(_eye, camera.position, camera.target);
        Quat.setAxisAngle(rotQuat, _rotLastAxis, _rotLastAngle);
        Vec3.transformQuat(_eye, _eye, rotQuat);
        Vec3.transformQuat(camera.up, camera.up, rotQuat);
      }
      Vec2.copy(_rotPrev, _rotCurr);
    }
    const rollQuat = Quat();
    const rollDir = Vec3();
    function rollCamera() {
      const k = (keyState.rollRight - keyState.rollLeft) / 45;
      const dx = (_rollCurr[0] - _rollPrev[0]) * -Math.sign(_rollCurr[1]);
      const dy = (_rollCurr[1] - _rollPrev[1]) * -Math.sign(_rollCurr[0]);
      const angle = -p.rotateSpeed * (-dx + dy) + k;
      if (angle) {
        Vec3.normalize(rollDir, _eye);
        Quat.setAxisAngle(rollQuat, rollDir, angle);
        Vec3.transformQuat(camera.up, camera.up, rollQuat);
        _rollLastAngle = angle;
      } else if (!p.staticMoving && _rollLastAngle) {
        _rollLastAngle *= Math.sqrt(1 - p.dynamicDampingFactor);
        Vec3.normalize(rollDir, _eye);
        Quat.setAxisAngle(rollQuat, rollDir, _rollLastAngle);
        Vec3.transformQuat(camera.up, camera.up, rollQuat);
      }
      Vec2.copy(_rollPrev, _rollCurr);
    }
    const pitchQuat = Quat();
    const pitchDir = Vec3();
    function pitchCamera() {
      const m = (keyState.pitchUp - keyState.pitchDown) / (p.flyMode ? 360 : 90);
      const angle = -p.rotateSpeed * m;
      if (angle) {
        Vec3.cross(pitchDir, _eye, camera.up);
        Vec3.normalize(pitchDir, pitchDir);
        Quat.setAxisAngle(pitchQuat, pitchDir, angle);
        Vec3.transformQuat(_eye, _eye, pitchQuat);
        Vec3.transformQuat(camera.up, camera.up, pitchQuat);
        _pitchLastAngle = angle;
      } else if (!p.staticMoving && _pitchLastAngle) {
        _pitchLastAngle *= Math.sqrt(1 - p.dynamicDampingFactor);
        Vec3.cross(pitchDir, _eye, camera.up);
        Vec3.normalize(pitchDir, pitchDir);
        Quat.setAxisAngle(pitchQuat, pitchDir, _pitchLastAngle);
        Vec3.transformQuat(_eye, _eye, pitchQuat);
        Vec3.transformQuat(camera.up, camera.up, pitchQuat);
      }
    }
    const yawQuat = Quat();
    const yawDir = Vec3();
    function yawCamera() {
      const m = (keyState.yawRight - keyState.yawLeft) / (p.flyMode ? 360 : 90);
      const angle = -p.rotateSpeed * m;
      if (angle) {
        Vec3.normalize(yawDir, camera.up);
        Quat.setAxisAngle(yawQuat, yawDir, angle);
        Vec3.transformQuat(_eye, _eye, yawQuat);
        Vec3.transformQuat(camera.up, camera.up, yawQuat);
        _yawLastAngle = angle;
      } else if (!p.staticMoving && _yawLastAngle) {
        _yawLastAngle *= Math.sqrt(1 - p.dynamicDampingFactor);
        Vec3.normalize(yawDir, camera.up);
        Quat.setAxisAngle(yawQuat, yawDir, _yawLastAngle);
        Vec3.transformQuat(_eye, _eye, yawQuat);
        Vec3.transformQuat(camera.up, camera.up, yawQuat);
      }
    }
    function zoomCamera() {
      const factor = 1 + (_zoomEnd[1] - _zoomStart[1]) * p.zoomSpeed;
      if (factor !== 1 && factor > 0) {
        Vec3.scale(_eye, _eye, factor);
      }
      if (p.staticMoving) {
        Vec2.copy(_zoomStart, _zoomEnd);
      } else {
        _zoomStart[1] += (_zoomEnd[1] - _zoomStart[1]) * p.dynamicDampingFactor;
      }
    }
    function focusCamera() {
      const factor = (_focusEnd[1] - _focusStart[1]) * p.zoomSpeed;
      if (factor !== 0) {
        const radius = Math.max(1, camera.state.radius + camera.state.radius * factor);
        camera.setState({ radius });
      }
      if (p.staticMoving) {
        Vec2.copy(_focusStart, _focusEnd);
      } else {
        _focusStart[1] += (_focusEnd[1] - _focusStart[1]) * p.dynamicDampingFactor;
      }
    }
    const panMouseChange = Vec2();
    const panObjUp = Vec3();
    const panOffset = Vec3();
    function panCamera() {
      Vec2.sub(panMouseChange, Vec2.copy(panMouseChange, _panEnd), _panStart);
      if (Vec2.squaredMagnitude(panMouseChange)) {
        const factor = input.pixelRatio * p.panSpeed;
        panMouseChange[0] *= 1 / camera.zoom * camera.viewport.width * factor;
        panMouseChange[1] *= 1 / camera.zoom * camera.viewport.height * factor;
        Vec3.cross(panOffset, Vec3.copy(panOffset, _eye), camera.up);
        Vec3.setMagnitude(panOffset, panOffset, panMouseChange[0]);
        Vec3.setMagnitude(panObjUp, camera.up, panMouseChange[1]);
        Vec3.add(panOffset, panOffset, panObjUp);
        Vec3.add(camera.position, camera.position, panOffset);
        Vec3.add(camera.target, camera.target, panOffset);
        if (p.staticMoving) {
          Vec2.copy(_panStart, _panEnd);
        } else {
          Vec2.sub(panMouseChange, _panEnd, _panStart);
          Vec2.scale(panMouseChange, panMouseChange, p.dynamicDampingFactor);
          Vec2.add(_panStart, _panStart, panMouseChange);
        }
      }
    }
    const keyState = {
      moveUp: 0,
      moveDown: 0,
      moveLeft: 0,
      moveRight: 0,
      moveForward: 0,
      moveBack: 0,
      pitchUp: 0,
      pitchDown: 0,
      yawLeft: 0,
      yawRight: 0,
      rollLeft: 0,
      rollRight: 0,
      boostMove: 0
    };
    const moveDir = Vec3();
    const moveEye = Vec3();
    function moveCamera(deltaT) {
      Vec3.sub(moveEye, camera.position, camera.target);
      const minDistance = Math.max(camera.state.minNear, p.minDistance);
      Vec3.setMagnitude(moveEye, moveEye, minDistance);
      const moveSpeed = deltaT * (60 / 1e3) * p.moveSpeed * (keyState.boostMove === 1 ? p.boostMoveFactor : 1);
      if (keyState.moveForward === 1) {
        Vec3.normalize(moveDir, moveEye);
        Vec3.scaleAndSub(camera.position, camera.position, moveDir, moveSpeed);
        if (p.flyMode || input.pointerLock) {
          Vec3.sub(camera.target, camera.position, moveEye);
        }
      }
      if (keyState.moveBack === 1) {
        Vec3.normalize(moveDir, moveEye);
        Vec3.scaleAndAdd(camera.position, camera.position, moveDir, moveSpeed);
        if (p.flyMode || input.pointerLock) {
          Vec3.sub(camera.target, camera.position, moveEye);
        }
      }
      if (keyState.moveLeft === 1) {
        Vec3.cross(moveDir, moveEye, camera.up);
        Vec3.normalize(moveDir, moveDir);
        if (p.flyMode || input.pointerLock) {
          Vec3.scaleAndAdd(camera.position, camera.position, moveDir, moveSpeed);
          Vec3.sub(camera.target, camera.position, moveEye);
        } else {
          Vec3.scaleAndSub(camera.position, camera.position, moveDir, moveSpeed);
          Vec3.sub(camera.target, camera.position, _eye);
        }
      }
      if (keyState.moveRight === 1) {
        Vec3.cross(moveDir, moveEye, camera.up);
        Vec3.normalize(moveDir, moveDir);
        if (p.flyMode || input.pointerLock) {
          Vec3.scaleAndSub(camera.position, camera.position, moveDir, moveSpeed);
          Vec3.sub(camera.target, camera.position, moveEye);
        } else {
          Vec3.scaleAndAdd(camera.position, camera.position, moveDir, moveSpeed);
          Vec3.sub(camera.target, camera.position, _eye);
        }
      }
      if (keyState.moveUp === 1) {
        Vec3.normalize(moveDir, camera.up);
        if (p.flyMode || input.pointerLock) {
          Vec3.scaleAndAdd(camera.position, camera.position, moveDir, moveSpeed);
          Vec3.sub(camera.target, camera.position, moveEye);
        } else {
          Vec3.scaleAndSub(camera.position, camera.position, moveDir, moveSpeed);
          Vec3.sub(camera.target, camera.position, _eye);
        }
      }
      if (keyState.moveDown === 1) {
        Vec3.normalize(moveDir, camera.up);
        if (p.flyMode || input.pointerLock) {
          Vec3.scaleAndSub(camera.position, camera.position, moveDir, moveSpeed);
          Vec3.sub(camera.target, camera.position, moveEye);
        } else {
          Vec3.scaleAndAdd(camera.position, camera.position, moveDir, moveSpeed);
          Vec3.sub(camera.target, camera.position, _eye);
        }
      }
      if (p.flyMode || input.pointerLock) {
        const cameraDistance = Vec3.distance(camera.position, scene.boundingSphereVisible.center);
        camera.setState({ minFar: cameraDistance + scene.boundingSphereVisible.radius });
      }
    }
    function checkDistances() {
      const maxDistance = Math.min(Math.max(camera.state.radiusMax * 1e3, 0.01), p.maxDistance);
      if (Vec3.squaredMagnitude(_eye) > maxDistance * maxDistance) {
        Vec3.setMagnitude(_eye, _eye, maxDistance);
        Vec3.add(camera.position, camera.target, _eye);
        Vec2.copy(_zoomStart, _zoomEnd);
        Vec2.copy(_focusStart, _focusEnd);
      }
      if (Vec3.squaredMagnitude(_eye) < p.minDistance * p.minDistance) {
        Vec3.setMagnitude(_eye, _eye, p.minDistance);
        Vec3.add(camera.position, camera.target, _eye);
        Vec2.copy(_zoomStart, _zoomEnd);
        Vec2.copy(_focusStart, _focusEnd);
      }
    }
    function outsideViewport(x, y) {
      x *= input.pixelRatio;
      y *= input.pixelRatio;
      return x > viewport.x + viewport.width || input.height - y > viewport.y + viewport.height || x < viewport.x || input.height - y < viewport.y;
    }
    let lastUpdated = -1;
    function update10(t2) {
      if (lastUpdated === t2)
        return;
      const deltaT = t2 - lastUpdated;
      if (lastUpdated > 0) {
        if (p.animate.name === "spin")
          spin(deltaT);
        else if (p.animate.name === "rock")
          rock(deltaT);
      }
      Vec3.sub(_eye, camera.position, camera.target);
      rotateCamera();
      rollCamera();
      pitchCamera();
      yawCamera();
      zoomCamera();
      focusCamera();
      panCamera();
      Vec3.add(camera.position, camera.target, _eye);
      checkDistances();
      if (lastUpdated > 0) {
        moveCamera(Math.min(deltaT, 15 * 1e3 / 60));
      }
      Vec3.sub(_eye, camera.position, camera.target);
      checkDistances();
      if (Vec3.squaredDistance(lastPosition, camera.position) > EPSILON) {
        Vec3.copy(lastPosition, camera.position);
      }
      lastUpdated = t2;
    }
    function reset() {
      Vec3.copy(camera.target, target0);
      Vec3.copy(camera.position, position0);
      Vec3.copy(camera.up, up0);
      Vec3.sub(_eye, camera.position, camera.target);
      Vec3.copy(lastPosition, camera.position);
    }
    function onDrag({ x, y, pageX, pageY, buttons, modifiers, isStart }) {
      const isOutside = outsideViewport(x, y);
      if (isStart && isOutside)
        return;
      if (!isStart && !_isInteracting)
        return;
      _isInteracting = true;
      resetRock();
      const dragRotate = Binding.match(b5.dragRotate, buttons, modifiers);
      const dragRotateZ = Binding.match(b5.dragRotateZ, buttons, modifiers);
      const dragPan = Binding.match(b5.dragPan, buttons, modifiers);
      const dragZoom = Binding.match(b5.dragZoom, buttons, modifiers);
      const dragFocus = Binding.match(b5.dragFocus, buttons, modifiers);
      const dragFocusZoom = Binding.match(b5.dragFocusZoom, buttons, modifiers);
      getMouseOnCircle(pageX, pageY);
      getMouseOnScreen(pageX, pageY);
      const pr = input.pixelRatio;
      const vx = (x * pr - viewport.width / 2 - viewport.x) / viewport.width;
      const vy = -(input.height - y * pr - viewport.height / 2 - viewport.y) / viewport.height;
      if (isStart) {
        if (dragRotate) {
          Vec2.copy(_rotCurr, mouseOnCircleVec2);
          Vec2.copy(_rotPrev, _rotCurr);
        }
        if (dragRotateZ) {
          Vec2.set(_rollCurr, vx, vy);
          Vec2.copy(_rollPrev, _rollCurr);
        }
        if (dragZoom || dragFocusZoom) {
          Vec2.copy(_zoomStart, mouseOnScreenVec2);
          Vec2.copy(_zoomEnd, _zoomStart);
        }
        if (dragFocus) {
          Vec2.copy(_focusStart, mouseOnScreenVec2);
          Vec2.copy(_focusEnd, _focusStart);
        }
        if (dragPan) {
          Vec2.copy(_panStart, mouseOnScreenVec2);
          Vec2.copy(_panEnd, _panStart);
        }
      }
      if (dragRotate)
        Vec2.copy(_rotCurr, mouseOnCircleVec2);
      if (dragRotateZ)
        Vec2.set(_rollCurr, vx, vy);
      if (dragZoom || dragFocusZoom)
        Vec2.copy(_zoomEnd, mouseOnScreenVec2);
      if (dragFocus)
        Vec2.copy(_focusEnd, mouseOnScreenVec2);
      if (dragFocusZoom) {
        const dist = Vec3.distance(camera.state.position, camera.state.target);
        camera.setState({ radius: dist / 5 });
      }
      if (dragPan)
        Vec2.copy(_panEnd, mouseOnScreenVec2);
    }
    function onInteractionEnd() {
      _isInteracting = false;
    }
    function onWheel({ x, y, spinX, spinY, dz, buttons, modifiers }) {
      if (outsideViewport(x, y))
        return;
      let delta = absMax(spinX * 0.075, spinY * 0.075, dz * 1e-4);
      if (delta < -p.maxWheelDelta)
        delta = -p.maxWheelDelta;
      else if (delta > p.maxWheelDelta)
        delta = p.maxWheelDelta;
      if (Binding.match(b5.scrollZoom, buttons, modifiers)) {
        _zoomEnd[1] += delta;
      }
      if (Binding.match(b5.scrollFocus, buttons, modifiers)) {
        _focusEnd[1] += delta;
      }
    }
    function onPinch({ isStart, startX, startY, centerPageX, centerPageY, fractionDelta, buttons, modifiers }) {
      if (outsideViewport(startX, startY))
        return;
      const pan = Binding.match(b5.dragPan, buttons, modifiers);
      const zoom = Binding.match(b5.scrollZoom, buttons, modifiers);
      _isInteracting = pan || zoom;
      if (pan) {
        getMouseOnScreen(centerPageX, centerPageY);
        if (isStart) {
          Vec2.copy(_panStart, mouseOnScreenVec2);
          Vec2.copy(_panEnd, _panStart);
        } else {
          Vec2.copy(_panEnd, mouseOnScreenVec2);
        }
      }
      if (zoom) {
        _zoomEnd[1] += p.gestureScaleFactor * fractionDelta;
      }
    }
    function onMove({ movementX, movementY }) {
      if (!input.pointerLock || movementX === void 0 || movementY === void 0)
        return;
      const cx = viewport.width * 0.5 - viewport.x;
      const cy = viewport.height * 0.5 - viewport.y;
      Vec2.copy(_rotPrev, getMouseOnCircle(cx, cy));
      Vec2.copy(_rotCurr, getMouseOnCircle(movementX + cx, movementY + cy));
    }
    function onKeyDown({ modifiers, code, key: key2, x, y }) {
      if (outsideViewport(x, y))
        return;
      if (Binding.matchKey(b5.keyMoveForward, code, modifiers, key2)) {
        keyState.moveForward = 1;
      } else if (Binding.matchKey(b5.keyMoveBack, code, modifiers, key2)) {
        keyState.moveBack = 1;
      } else if (Binding.matchKey(b5.keyMoveLeft, code, modifiers, key2)) {
        keyState.moveLeft = 1;
      } else if (Binding.matchKey(b5.keyMoveRight, code, modifiers, key2)) {
        keyState.moveRight = 1;
      } else if (Binding.matchKey(b5.keyMoveUp, code, modifiers, key2)) {
        keyState.moveUp = 1;
      } else if (Binding.matchKey(b5.keyMoveDown, code, modifiers, key2)) {
        keyState.moveDown = 1;
      } else if (Binding.matchKey(b5.keyRollLeft, code, modifiers, key2)) {
        keyState.rollLeft = 1;
      } else if (Binding.matchKey(b5.keyRollRight, code, modifiers, key2)) {
        keyState.rollRight = 1;
      } else if (Binding.matchKey(b5.keyPitchUp, code, modifiers, key2)) {
        keyState.pitchUp = 1;
      } else if (Binding.matchKey(b5.keyPitchDown, code, modifiers, key2)) {
        keyState.pitchDown = 1;
      } else if (Binding.matchKey(b5.keyYawLeft, code, modifiers, key2)) {
        keyState.yawLeft = 1;
      } else if (Binding.matchKey(b5.keyYawRight, code, modifiers, key2)) {
        keyState.yawRight = 1;
      }
      if (Binding.matchKey(b5.boostMove, code, modifiers, key2)) {
        keyState.boostMove = 1;
      }
      if (Binding.matchKey(b5.enablePointerLock, code, modifiers, key2)) {
        input.requestPointerLock(viewport);
      }
    }
    function onKeyUp({ modifiers, code, key: key2, x, y }) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m2;
      if (outsideViewport(x, y))
        return;
      let isModifierCode = false;
      if (code.startsWith("Alt")) {
        isModifierCode = true;
        modifiers.alt = true;
      } else if (code.startsWith("Shift")) {
        isModifierCode = true;
        modifiers.shift = true;
      } else if (code.startsWith("Control")) {
        isModifierCode = true;
        modifiers.control = true;
      } else if (code.startsWith("Meta")) {
        isModifierCode = true;
        modifiers.meta = true;
      }
      const codes = [];
      if (isModifierCode) {
        if (keyState.moveForward)
          codes.push(((_a = b5.keyMoveForward.triggers[0]) === null || _a === void 0 ? void 0 : _a.code) || "");
        if (keyState.moveBack)
          codes.push(((_b = b5.keyMoveBack.triggers[0]) === null || _b === void 0 ? void 0 : _b.code) || "");
        if (keyState.moveLeft)
          codes.push(((_c = b5.keyMoveLeft.triggers[0]) === null || _c === void 0 ? void 0 : _c.code) || "");
        if (keyState.moveRight)
          codes.push(((_d = b5.keyMoveRight.triggers[0]) === null || _d === void 0 ? void 0 : _d.code) || "");
        if (keyState.moveUp)
          codes.push(((_e = b5.keyMoveUp.triggers[0]) === null || _e === void 0 ? void 0 : _e.code) || "");
        if (keyState.moveDown)
          codes.push(((_f = b5.keyMoveDown.triggers[0]) === null || _f === void 0 ? void 0 : _f.code) || "");
        if (keyState.rollLeft)
          codes.push(((_g = b5.keyRollLeft.triggers[0]) === null || _g === void 0 ? void 0 : _g.code) || "");
        if (keyState.rollRight)
          codes.push(((_h = b5.keyRollRight.triggers[0]) === null || _h === void 0 ? void 0 : _h.code) || "");
        if (keyState.pitchUp)
          codes.push(((_j = b5.keyPitchUp.triggers[0]) === null || _j === void 0 ? void 0 : _j.code) || "");
        if (keyState.pitchDown)
          codes.push(((_k = b5.keyPitchDown.triggers[0]) === null || _k === void 0 ? void 0 : _k.code) || "");
        if (keyState.yawLeft)
          codes.push(((_l = b5.keyYawLeft.triggers[0]) === null || _l === void 0 ? void 0 : _l.code) || "");
        if (keyState.yawRight)
          codes.push(((_m2 = b5.keyYawRight.triggers[0]) === null || _m2 === void 0 ? void 0 : _m2.code) || "");
      } else {
        codes.push(code);
      }
      for (const code2 of codes) {
        if (Binding.matchKey(b5.keyMoveForward, code2, modifiers, key2)) {
          keyState.moveForward = 0;
        } else if (Binding.matchKey(b5.keyMoveBack, code2, modifiers, key2)) {
          keyState.moveBack = 0;
        } else if (Binding.matchKey(b5.keyMoveLeft, code2, modifiers, key2)) {
          keyState.moveLeft = 0;
        } else if (Binding.matchKey(b5.keyMoveRight, code2, modifiers, key2)) {
          keyState.moveRight = 0;
        } else if (Binding.matchKey(b5.keyMoveUp, code2, modifiers, key2)) {
          keyState.moveUp = 0;
        } else if (Binding.matchKey(b5.keyMoveDown, code2, modifiers, key2)) {
          keyState.moveDown = 0;
        } else if (Binding.matchKey(b5.keyRollLeft, code2, modifiers, key2)) {
          keyState.rollLeft = 0;
        } else if (Binding.matchKey(b5.keyRollRight, code2, modifiers, key2)) {
          keyState.rollRight = 0;
        } else if (Binding.matchKey(b5.keyPitchUp, code2, modifiers, key2)) {
          keyState.pitchUp = 0;
        } else if (Binding.matchKey(b5.keyPitchDown, code2, modifiers, key2)) {
          keyState.pitchDown = 0;
        } else if (Binding.matchKey(b5.keyYawLeft, code2, modifiers, key2)) {
          keyState.yawLeft = 0;
        } else if (Binding.matchKey(b5.keyYawRight, code2, modifiers, key2)) {
          keyState.yawRight = 0;
        }
      }
      if (Binding.matchKey(b5.boostMove, code, modifiers, key2)) {
        keyState.boostMove = 0;
      }
    }
    function initCameraMove() {
      Vec3.sub(moveEye, camera.position, camera.target);
      const minDistance = Math.max(camera.state.minNear, p.minDistance);
      Vec3.setMagnitude(moveEye, moveEye, minDistance);
      Vec3.sub(camera.target, camera.position, moveEye);
      const cameraDistance = Vec3.distance(camera.position, scene.boundingSphereVisible.center);
      camera.setState({ minFar: cameraDistance + scene.boundingSphereVisible.radius });
    }
    function resetCameraMove() {
      const { center, radius } = scene.boundingSphereVisible;
      const cameraDistance = Vec3.distance(camera.position, center);
      if (cameraDistance > radius) {
        const focus = camera.getFocus(center, radius);
        camera.setState({ ...focus, minFar: 0 });
      } else {
        camera.setState({
          minFar: 0,
          radius: scene.boundingSphereVisible.radius
        });
      }
    }
    function onLock(isLocked) {
      if (isLocked) {
        initCameraMove();
      } else {
        resetCameraMove();
      }
    }
    function unsetKeyState() {
      keyState.moveForward = 0;
      keyState.moveBack = 0;
      keyState.moveLeft = 0;
      keyState.moveRight = 0;
      keyState.moveUp = 0;
      keyState.moveDown = 0;
      keyState.rollLeft = 0;
      keyState.rollRight = 0;
      keyState.pitchUp = 0;
      keyState.pitchDown = 0;
      keyState.yawLeft = 0;
      keyState.yawRight = 0;
      keyState.boostMove = 0;
    }
    function onLeave() {
      unsetKeyState();
    }
    function dispose2() {
      if (disposed)
        return;
      disposed = true;
      dragSub.unsubscribe();
      wheelSub.unsubscribe();
      pinchSub.unsubscribe();
      interactionEndSub.unsubscribe();
      keyDownSub.unsubscribe();
      keyUpSub.unsubscribe();
      moveSub.unsubscribe();
      lockSub.unsubscribe();
      leaveSub.unsubscribe();
    }
    const _spinSpeed = Vec2.create(5e-3, 0);
    function spin(deltaT) {
      if (p.animate.name !== "spin" || p.animate.params.speed === 0 || _isInteracting)
        return;
      const radPerMs = p.animate.params.speed / 1e3;
      _spinSpeed[0] = deltaT * radPerMs / getRotateFactor();
      Vec2.add(_rotCurr, _rotPrev, _spinSpeed);
    }
    let _rockPhase = 0;
    const _rockSpeed = Vec2.create(5e-3, 0);
    function rock(deltaT) {
      if (p.animate.name !== "rock" || p.animate.params.speed === 0 || _isInteracting)
        return;
      const dt = deltaT / 1e3 * p.animate.params.speed;
      const maxAngle = degToRad(p.animate.params.angle) / getRotateFactor();
      const angleA = Math.sin(_rockPhase * Math.PI * 2) * maxAngle;
      const angleB = Math.sin((_rockPhase + dt) * Math.PI * 2) * maxAngle;
      _rockSpeed[0] = angleB - angleA;
      Vec2.add(_rotCurr, _rotPrev, _rockSpeed);
      _rockPhase += dt;
      if (_rockPhase >= 1) {
        _rockPhase = 0;
      }
    }
    function resetRock() {
      _rockPhase = 0;
    }
    function start(t2) {
      lastUpdated = -1;
      update10(t2);
    }
    return {
      viewport,
      get isAnimating() {
        return p.animate.name !== "off";
      },
      get isMoving() {
        return keyState.moveForward === 1 || keyState.moveBack === 1 || keyState.moveLeft === 1 || keyState.moveRight === 1 || keyState.moveUp === 1 || keyState.moveDown === 1 || keyState.rollLeft === 1 || keyState.rollRight === 1 || keyState.pitchUp === 1 || keyState.pitchDown === 1 || keyState.yawLeft === 1 || keyState.yawRight === 1;
      },
      get props() {
        return p;
      },
      setProps: (props2) => {
        var _a;
        if (((_a = props2.animate) === null || _a === void 0 ? void 0 : _a.name) === "rock" && p.animate.name !== "rock") {
          resetRock();
        }
        if (props2.flyMode !== void 0 && props2.flyMode !== p.flyMode) {
          if (props2.flyMode) {
            initCameraMove();
          } else {
            resetCameraMove();
          }
        }
        Object.assign(p, props2);
        Object.assign(b5, props2.bindings);
      },
      start,
      update: update10,
      reset,
      dispose: dispose2
    };
  }
  TrackballControls2.create = create;
})(TrackballControls || (TrackballControls = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/object3d.js
var Object3D;
(function(Object3D2) {
  function create() {
    return {
      view: Mat4.identity(),
      position: Vec3.create(0, 0, 0),
      direction: Vec3.create(0, 0, -1),
      up: Vec3.create(0, 1, 0)
    };
  }
  Object3D2.create = create;
  const center = Vec3.zero();
  function update10(object3d) {
    Vec3.add(center, object3d.position, object3d.direction);
    Mat4.lookAt(object3d.view, object3d.position, center, object3d.up);
  }
  Object3D2.update = update10;
})(Object3D || (Object3D = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/commit-queue.js
var CommitQueue = class {
  constructor() {
    this.removeList = LinkedList();
    this.removeMap = /* @__PURE__ */ new Map();
    this.addList = LinkedList();
    this.addMap = /* @__PURE__ */ new Map();
  }
  get isEmpty() {
    return this.removeList.count === 0 && this.addList.count === 0;
  }
  get size() {
    return this.removeMap.size + this.addMap.size;
  }
  add(o) {
    if (this.removeMap.has(o)) {
      const a5 = this.removeMap.get(o);
      this.removeMap.delete(o);
      this.removeList.remove(a5);
    }
    if (this.addMap.has(o))
      return;
    const b5 = this.addList.addLast(o);
    this.addMap.set(o, b5);
  }
  remove(o) {
    if (this.addMap.has(o)) {
      const a5 = this.addMap.get(o);
      this.addMap.delete(o);
      this.addList.remove(a5);
    }
    if (this.removeMap.has(o))
      return;
    const b5 = this.removeList.addLast(o);
    this.removeMap.set(o, b5);
  }
  tryGetRemove() {
    const o = this.removeList.removeFirst();
    if (o)
      this.removeMap.delete(o);
    return o;
  }
  tryGetAdd() {
    const o = this.addList.removeFirst();
    if (o)
      this.addMap.delete(o);
    return o;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/scene.js
var boundaryHelper = new BoundaryHelper("98");
function calculateBoundingSphere(renderables, boundingSphere, onlyVisible) {
  boundaryHelper.reset();
  for (let i = 0, il = renderables.length; i < il; ++i) {
    if (onlyVisible && !renderables[i].state.visible)
      continue;
    if (!renderables[i].values.drawCount.ref.value)
      continue;
    const boundingSphere2 = renderables[i].values.boundingSphere.ref.value;
    if (!boundingSphere2.radius)
      continue;
    boundaryHelper.includeSphere(boundingSphere2);
  }
  boundaryHelper.finishedIncludeStep();
  for (let i = 0, il = renderables.length; i < il; ++i) {
    if (onlyVisible && !renderables[i].state.visible)
      continue;
    if (!renderables[i].values.drawCount.ref.value)
      continue;
    const boundingSphere2 = renderables[i].values.boundingSphere.ref.value;
    if (!boundingSphere2.radius)
      continue;
    boundaryHelper.radiusSphere(boundingSphere2);
  }
  return boundaryHelper.getSphere(boundingSphere);
}
function renderableSort(a5, b5) {
  const drawProgramIdA = a5.getProgram("color").id;
  const drawProgramIdB = b5.getProgram("color").id;
  const materialIdA = a5.materialId;
  const materialIdB = b5.materialId;
  if (drawProgramIdA !== drawProgramIdB) {
    return drawProgramIdA - drawProgramIdB;
  } else if (materialIdA !== materialIdB) {
    return materialIdA - materialIdB;
  } else {
    return a5.id - b5.id;
  }
}
var Scene;
(function(Scene2) {
  function create(ctx, transparency = "blended") {
    const renderableMap = /* @__PURE__ */ new Map();
    const renderables = [];
    const boundingSphere = Sphere3D();
    const boundingSphereVisible = Sphere3D();
    const primitives = [];
    const volumes = [];
    let boundingSphereDirty = true;
    let boundingSphereVisibleDirty = true;
    let markerAverageDirty = true;
    let emissiveAverageDirty = true;
    let opacityAverageDirty = true;
    let transparencyMinDirty = true;
    let hasOpaqueDirty = true;
    let markerAverage = 0;
    let emissiveAverage = 0;
    let opacityAverage = 0;
    let transparencyMin = 0;
    let hasOpaque = false;
    const object3d = Object3D.create();
    const { view, position, direction, up: up2 } = object3d;
    function add(o) {
      if (!renderableMap.has(o)) {
        const renderable = createRenderable2(ctx, o, transparency);
        renderables.push(renderable);
        if (o.type === "direct-volume") {
          volumes.push(renderable);
        } else {
          primitives.push(renderable);
        }
        renderableMap.set(o, renderable);
        boundingSphereDirty = true;
        boundingSphereVisibleDirty = true;
      } else {
        console.warn(`RenderObject with id '${o.id}' already present`);
      }
    }
    function remove3(o) {
      const renderable = renderableMap.get(o);
      if (renderable) {
        renderable.dispose();
        arraySetRemove(renderables, renderable);
        arraySetRemove(primitives, renderable);
        arraySetRemove(volumes, renderable);
        renderableMap.delete(o);
        boundingSphereDirty = true;
        boundingSphereVisibleDirty = true;
      }
    }
    const commitBulkSize = 100;
    function commit(maxTimeMs) {
      const start = now();
      let i = 0;
      while (true) {
        const o = commitQueue.tryGetRemove();
        if (!o)
          break;
        remove3(o);
        if (++i % commitBulkSize === 0 && now() - start > maxTimeMs)
          return false;
      }
      while (true) {
        const o = commitQueue.tryGetAdd();
        if (!o)
          break;
        add(o);
        if (++i % commitBulkSize === 0 && now() - start > maxTimeMs)
          return false;
      }
      renderables.sort(renderableSort);
      markerAverageDirty = true;
      emissiveAverageDirty = true;
      opacityAverageDirty = true;
      transparencyMinDirty = true;
      hasOpaqueDirty = true;
      return true;
    }
    const commitQueue = new CommitQueue();
    let visibleHash = -1;
    function computeVisibleHash() {
      let hash3 = 23;
      for (let i = 0, il = renderables.length; i < il; ++i) {
        if (!renderables[i].state.visible)
          continue;
        hash3 = 31 * hash3 + renderables[i].id | 0;
      }
      hash3 = hash1(hash3);
      if (hash3 === -1)
        hash3 = 0;
      return hash3;
    }
    function syncVisibility() {
      const newVisibleHash = computeVisibleHash();
      if (newVisibleHash !== visibleHash) {
        boundingSphereVisibleDirty = true;
        markerAverageDirty = true;
        emissiveAverageDirty = true;
        opacityAverageDirty = true;
        transparencyMinDirty = true;
        hasOpaqueDirty = true;
        visibleHash = newVisibleHash;
        return true;
      } else {
        return false;
      }
    }
    function calculateMarkerAverage() {
      if (primitives.length === 0)
        return 0;
      let count3 = 0;
      let markerAverage2 = 0;
      for (let i = 0, il = primitives.length; i < il; ++i) {
        if (!primitives[i].state.visible)
          continue;
        markerAverage2 += primitives[i].values.markerAverage.ref.value;
        count3 += 1;
      }
      return count3 > 0 ? markerAverage2 / count3 : 0;
    }
    function calculateEmissiveAverage() {
      if (primitives.length === 0)
        return 0;
      let count3 = 0;
      let emissiveAverage2 = 0;
      for (let i = 0, il = primitives.length; i < il; ++i) {
        if (!primitives[i].state.visible)
          continue;
        emissiveAverage2 += primitives[i].values.emissiveAverage.ref.value + primitives[i].values.uEmissive.ref.value;
        count3 += 1;
      }
      return count3 > 0 ? emissiveAverage2 / count3 : 0;
    }
    function calculateOpacityAverage() {
      var _a, _b, _c;
      if (primitives.length === 0)
        return 0;
      let count3 = 0;
      let opacityAverage2 = 0;
      for (let i = 0, il = primitives.length; i < il; ++i) {
        const p = primitives[i];
        if (!p.state.visible)
          continue;
        const alpha = clamp(p.values.alpha.ref.value * p.state.alphaFactor, 0, 1);
        const xray = ((_a = p.values.dXrayShaded) === null || _a === void 0 ? void 0 : _a.ref.value) === "on" || ((_b = p.values.dXrayShaded) === null || _b === void 0 ? void 0 : _b.ref.value) === "inverted" ? 0.5 : 1;
        const fuzzy = ((_c = p.values.dPointStyle) === null || _c === void 0 ? void 0 : _c.ref.value) === "fuzzy" ? 0.5 : 1;
        const text = p.values.dGeometryType.ref.value === "text" ? 0.5 : 1;
        const image = p.values.dGeometryType.ref.value === "image" ? 0.5 : 1;
        opacityAverage2 += (1 - p.values.transparencyAverage.ref.value) * alpha * xray * fuzzy * text * image;
        count3 += 1;
      }
      return count3 > 0 ? opacityAverage2 / count3 : 0;
    }
    function calculateTransparencyMin() {
      var _a, _b, _c;
      if (primitives.length === 0)
        return 1;
      let transparencyMin2 = 1;
      const transparenyValues = [];
      for (let i = 0, il = primitives.length; i < il; ++i) {
        const p = primitives[i];
        if (!p.state.visible)
          continue;
        transparenyValues.length = 0;
        const alpha = clamp(p.values.alpha.ref.value * p.state.alphaFactor, 0, 1);
        if (alpha < 1)
          transparenyValues.push(1 - alpha);
        if (((_a = p.values.dXrayShaded) === null || _a === void 0 ? void 0 : _a.ref.value) === "on" || ((_b = p.values.dXrayShaded) === null || _b === void 0 ? void 0 : _b.ref.value) === "inverted" || ((_c = p.values.dPointStyle) === null || _c === void 0 ? void 0 : _c.ref.value) === "fuzzy" || p.values.dGeometryType.ref.value === "text" || p.values.dGeometryType.ref.value === "image")
          transparenyValues.push(0.5);
        if (p.values.transparencyMin.ref.value > 0)
          transparenyValues.push(p.values.transparencyMin.ref.value);
        transparencyMin2 = Math.min(transparencyMin2, ...transparenyValues);
      }
      return transparencyMin2;
    }
    function calculateHasOpaque() {
      var _a;
      if (primitives.length === 0)
        return false;
      for (let i = 0, il = primitives.length; i < il; ++i) {
        const p = primitives[i];
        if (!p.state.visible)
          continue;
        if (p.state.opaque)
          return true;
        if (p.state.alphaFactor === 1 && p.values.alpha.ref.value === 1 && p.values.transparencyAverage.ref.value !== 1)
          return true;
        if (((_a = p.values.dTransparentBackfaces) === null || _a === void 0 ? void 0 : _a.ref.value) === "opaque")
          return true;
      }
      return false;
    }
    return {
      view,
      position,
      direction,
      up: up2,
      renderables,
      primitives: { view, position, direction, up: up2, renderables: primitives },
      volumes: { view, position, direction, up: up2, renderables: volumes },
      syncVisibility,
      setTransparency: (value) => {
        transparency = value;
        for (let i = 0, il = renderables.length; i < il; ++i) {
          renderables[i].setTransparency(value);
        }
      },
      update(objects, keepBoundingSphere) {
        var _a;
        Object3D.update(object3d);
        if (objects) {
          for (let i = 0, il = objects.length; i < il; ++i) {
            (_a = renderableMap.get(objects[i])) === null || _a === void 0 ? void 0 : _a.update();
          }
        } else {
          for (let i = 0, il = renderables.length; i < il; ++i) {
            renderables[i].update();
          }
        }
        if (!keepBoundingSphere) {
          boundingSphereDirty = true;
          boundingSphereVisibleDirty = true;
        } else {
          syncVisibility();
        }
        markerAverageDirty = true;
        emissiveAverageDirty = true;
        opacityAverageDirty = true;
        transparencyMinDirty = true;
        hasOpaqueDirty = true;
      },
      add: (o) => commitQueue.add(o),
      remove: (o) => commitQueue.remove(o),
      commit: (maxTime = Number.MAX_VALUE) => commit(maxTime),
      get commitQueueSize() {
        return commitQueue.size;
      },
      get needsCommit() {
        return !commitQueue.isEmpty;
      },
      has: (o) => {
        return renderableMap.has(o);
      },
      clear: () => {
        for (let i = 0, il = renderables.length; i < il; ++i) {
          renderables[i].dispose();
        }
        renderables.length = 0;
        primitives.length = 0;
        volumes.length = 0;
        renderableMap.clear();
        boundingSphereDirty = true;
        boundingSphereVisibleDirty = true;
      },
      forEach: (callbackFn) => {
        renderableMap.forEach(callbackFn);
      },
      get count() {
        return renderables.length;
      },
      get boundingSphere() {
        if (boundingSphereDirty) {
          calculateBoundingSphere(renderables, boundingSphere, false);
          boundingSphereDirty = false;
        }
        return boundingSphere;
      },
      get boundingSphereVisible() {
        if (boundingSphereVisibleDirty) {
          calculateBoundingSphere(renderables, boundingSphereVisible, true);
          boundingSphereVisibleDirty = false;
        }
        return boundingSphereVisible;
      },
      get markerAverage() {
        if (markerAverageDirty) {
          markerAverage = calculateMarkerAverage();
          markerAverageDirty = false;
        }
        return markerAverage;
      },
      get emissiveAverage() {
        if (emissiveAverageDirty) {
          emissiveAverage = calculateEmissiveAverage();
          emissiveAverageDirty = false;
        }
        return emissiveAverage;
      },
      get opacityAverage() {
        if (opacityAverageDirty) {
          opacityAverage = calculateOpacityAverage();
          opacityAverageDirty = false;
        }
        return opacityAverage;
      },
      get transparencyMin() {
        if (transparencyMinDirty) {
          transparencyMin = calculateTransparencyMin();
          transparencyMinDirty = false;
        }
        return transparencyMin;
      },
      get hasOpaque() {
        if (hasOpaqueDirty) {
          hasOpaque = calculateHasOpaque();
          hasOpaqueDirty = false;
        }
        return hasOpaque;
      }
    };
  }
  Scene2.create = create;
})(Scene || (Scene = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/camera/transition.js
var CameraTransitionManager = class _CameraTransitionManager {
  get source() {
    return this._source;
  }
  get target() {
    return this._target;
  }
  apply(to, durationMs = 0, transition) {
    if (!this.inTransition || durationMs > 0) {
      Camera.copySnapshot(this._source, this.camera.state);
    }
    if (!this.inTransition) {
      Camera.copySnapshot(this._target, this.camera.state);
    }
    Camera.copySnapshot(this._target, to);
    if (this._target.radius > this._target.radiusMax) {
      this._target.radius = this._target.radiusMax;
    }
    if (this._target.radius < 0.01)
      this._target.radius = 0.01;
    if (this._target.radiusMax < 0.01)
      this._target.radiusMax = 0.01;
    if (!this.inTransition && durationMs <= 0 || typeof to.mode !== "undefined" && to.mode !== this.camera.state.mode) {
      this.finish(this._target);
      return;
    }
    this.inTransition = true;
    this.func = transition || _CameraTransitionManager.defaultTransition;
    if (!this.inTransition || durationMs > 0) {
      this.start = this.t;
      this.durationMs = durationMs;
    }
  }
  tick(t2) {
    this.t = t2;
    this.update();
  }
  finish(to) {
    Camera.copySnapshot(this.camera.state, to);
    this.inTransition = false;
  }
  update() {
    if (!this.inTransition)
      return;
    const normalized2 = Math.min((this.t - this.start) / this.durationMs, 1);
    if (normalized2 === 1) {
      this.finish(this._target);
      return;
    }
    this.func(this._current, normalized2, this._source, this._target);
    Camera.copySnapshot(this.camera.state, this._current);
  }
  constructor(camera) {
    this.camera = camera;
    this.t = 0;
    this.func = _CameraTransitionManager.defaultTransition;
    this.start = 0;
    this.inTransition = false;
    this.durationMs = 0;
    this._source = Camera.createDefaultSnapshot();
    this._target = Camera.createDefaultSnapshot();
    this._current = Camera.createDefaultSnapshot();
  }
};
(function(CameraTransitionManager2) {
  const _rotUp = Quat.identity();
  const _rotDist = Quat.identity();
  const _sourcePosition = Vec3();
  const _targetPosition = Vec3();
  function defaultTransition(out, t2, source, target) {
    Camera.copySnapshot(out, target);
    Quat.slerp(_rotUp, Quat.Identity, Quat.rotationTo(_rotUp, source.up, target.up), t2);
    Vec3.transformQuat(out.up, source.up, _rotUp);
    Vec3.lerp(out.target, source.target, target.target, t2);
    const distSource = Vec3.distance(source.target, source.position);
    const distTarget = Vec3.distance(target.target, target.position);
    const dist = lerp(distSource, distTarget, t2);
    Vec3.sub(_sourcePosition, source.position, source.target);
    Vec3.normalize(_sourcePosition, _sourcePosition);
    Vec3.sub(_targetPosition, target.position, target.target);
    Vec3.normalize(_targetPosition, _targetPosition);
    Quat.rotationTo(_rotDist, _sourcePosition, _targetPosition);
    Quat.slerp(_rotDist, Quat.Identity, _rotDist, t2);
    Vec3.transformQuat(_sourcePosition, _sourcePosition, _rotDist);
    Vec3.scale(_sourcePosition, _sourcePosition, dist);
    Vec3.add(out.position, out.target, _sourcePosition);
    out.radius = lerp(source.radius, target.radius, t2);
    out.radiusMax = lerp(source.radiusMax, target.radiusMax, t2);
    out.fov = lerp(source.fov, target.fov, t2);
    out.fog = lerp(source.fog, target.fog, t2);
  }
  CameraTransitionManager2.defaultTransition = defaultTransition;
})(CameraTransitionManager || (CameraTransitionManager = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/camera.js
var tmpClip = Vec4();
var Camera = class _Camera {
  get position() {
    return this.state.position;
  }
  set position(v3) {
    Vec3.copy(this.state.position, v3);
  }
  get up() {
    return this.state.up;
  }
  set up(v3) {
    Vec3.copy(this.state.up, v3);
  }
  get target() {
    return this.state.target;
  }
  set target(v3) {
    Vec3.copy(this.state.target, v3);
  }
  update() {
    const snapshot = this.state;
    if (snapshot.radiusMax === 0) {
      return false;
    }
    const height = 2 * Math.tan(snapshot.fov / 2) * Vec3.distance(snapshot.position, snapshot.target);
    this.zoom = this.viewport.height / height;
    updateClip(this);
    switch (this.state.mode) {
      case "orthographic":
        updateOrtho(this);
        break;
      case "perspective":
        updatePers(this);
        break;
      default:
        assertUnreachable(this.state.mode);
    }
    const changed = !Mat4.areEqual(this.projection, this.prevProjection, EPSILON) || !Mat4.areEqual(this.view, this.prevView, EPSILON);
    if (changed) {
      Mat4.mul(this.projectionView, this.projection, this.view);
      if (!Mat4.tryInvert(this.inverseProjectionView, this.projectionView)) {
        Mat4.copy(this.view, this.prevView);
        Mat4.copy(this.projection, this.prevProjection);
        Mat4.mul(this.projectionView, this.projection, this.view);
        return false;
      }
      Mat4.copy(this.prevView, this.view);
      Mat4.copy(this.prevProjection, this.projection);
    }
    return changed;
  }
  setState(snapshot, durationMs) {
    this.transition.apply(snapshot, durationMs);
    this.stateChanged.next(snapshot);
  }
  getSnapshot() {
    return _Camera.copySnapshot(_Camera.createDefaultSnapshot(), this.state);
  }
  getTargetDistance(radius) {
    return _Camera.targetDistance(radius, this.state.mode, this.state.fov, this.viewport.width, this.viewport.height);
  }
  getFocus(target, radius, up2, dir, snapshot) {
    var _a, _b;
    const r = Math.max(radius, 0.01);
    const targetDistance = this.getTargetDistance(r);
    Vec3.sub(this.deltaDirection, (_a = snapshot === null || snapshot === void 0 ? void 0 : snapshot.target) !== null && _a !== void 0 ? _a : this.target, (_b = snapshot === null || snapshot === void 0 ? void 0 : snapshot.position) !== null && _b !== void 0 ? _b : this.position);
    if (dir)
      Vec3.matchDirection(this.deltaDirection, dir, this.deltaDirection);
    Vec3.setMagnitude(this.deltaDirection, this.deltaDirection, targetDistance);
    Vec3.sub(this.newPosition, target, this.deltaDirection);
    const state = _Camera.copySnapshot(_Camera.createDefaultSnapshot(), this.state);
    state.target = Vec3.clone(target);
    state.radius = r;
    state.position = Vec3.clone(this.newPosition);
    if (up2)
      Vec3.matchDirection(state.up, up2, state.up);
    return state;
  }
  getCenter(target, radius) {
    Vec3.sub(this.deltaDirection, this.target, this.position);
    Vec3.sub(this.newPosition, target, this.deltaDirection);
    const state = _Camera.copySnapshot(_Camera.createDefaultSnapshot(), this.state);
    state.target = Vec3.clone(target);
    state.position = Vec3.clone(this.newPosition);
    if (radius)
      state.radius = Math.max(radius, 0.01);
    return state;
  }
  getInvariantFocus(target, radius, up2, dir) {
    const r = Math.max(radius, 0.01);
    const targetDistance = this.getTargetDistance(r);
    Vec3.copy(this.deltaDirection, dir);
    Vec3.setMagnitude(this.deltaDirection, this.deltaDirection, targetDistance);
    Vec3.sub(this.newPosition, target, this.deltaDirection);
    const state = _Camera.copySnapshot(_Camera.createDefaultSnapshot(), this.state);
    state.target = Vec3.clone(target);
    state.radius = r;
    state.position = Vec3.clone(this.newPosition);
    Vec3.copy(state.up, up2);
    return state;
  }
  focus(target, radius, durationMs, up2, dir) {
    if (radius > 0) {
      this.setState(this.getFocus(target, radius, up2, dir), durationMs);
    }
  }
  center(target, durationMs) {
    this.setState(this.getCenter(target), durationMs);
  }
  /** Transform point into 2D window coordinates. */
  project(out, point) {
    return cameraProject(out, point, this.viewport, this.projectionView);
  }
  /**
   * Transform point from screen space to 3D coordinates.
   * The point must have `x` and `y` set to 2D window coordinates
   * and `z` between 0 (near) and 1 (far); the optional `w` is not used.
   */
  unproject(out, point) {
    return cameraUnproject(out, point, this.viewport, this.inverseProjectionView);
  }
  /** World space pixel size at given `point` */
  getPixelSize(point) {
    this.project(tmpClip, point);
    const w = tmpClip[3];
    const rx = this.viewport.width;
    const P00 = this.projection[0];
    return 2 / w / (rx * Math.abs(P00));
  }
  constructor(state, viewport = Viewport.create(0, 0, 128, 128)) {
    this.view = Mat4.identity();
    this.projection = Mat4.identity();
    this.projectionView = Mat4.identity();
    this.inverseProjectionView = Mat4.identity();
    this.state = _Camera.createDefaultSnapshot();
    this.viewOffset = _Camera.ViewOffset();
    this.near = 1;
    this.far = 1e4;
    this.fogNear = 5e3;
    this.fogFar = 1e4;
    this.zoom = 1;
    this.transition = new CameraTransitionManager(this);
    this.stateChanged = new BehaviorSubject(this.state);
    this.prevProjection = Mat4.identity();
    this.prevView = Mat4.identity();
    this.deltaDirection = Vec3();
    this.newPosition = Vec3();
    this.viewport = viewport;
    _Camera.copySnapshot(this.state, state);
  }
};
(function(Camera2) {
  function ViewOffset() {
    return {
      enabled: false,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    };
  }
  Camera2.ViewOffset = ViewOffset;
  function setViewOffset(out, fullWidth, fullHeight, offsetX, offsetY, width, height) {
    out.fullWidth = fullWidth;
    out.fullHeight = fullHeight;
    out.offsetX = offsetX;
    out.offsetY = offsetY;
    out.width = width;
    out.height = height;
  }
  Camera2.setViewOffset = setViewOffset;
  function copyViewOffset(out, view) {
    out.enabled = view.enabled;
    out.fullWidth = view.fullWidth;
    out.fullHeight = view.fullHeight;
    out.offsetX = view.offsetX;
    out.offsetY = view.offsetY;
    out.width = view.width;
    out.height = view.height;
  }
  Camera2.copyViewOffset = copyViewOffset;
  function targetDistance(radius, mode, fov, width, height) {
    const r = Math.max(radius, 0.01);
    const aspect = width / height;
    const aspectFactor = height < width ? 1 : aspect;
    if (mode === "orthographic")
      return Math.abs(r / aspectFactor / Math.tan(fov / 2));
    else
      return Math.abs(r / aspectFactor / Math.sin(fov / 2));
  }
  Camera2.targetDistance = targetDistance;
  function createDefaultSnapshot() {
    return {
      mode: "perspective",
      fov: Math.PI / 4,
      position: Vec3.create(0, 0, 100),
      up: Vec3.create(0, 1, 0),
      target: Vec3.create(0, 0, 0),
      radius: 0,
      radiusMax: 10,
      fog: 50,
      clipFar: true,
      minNear: 5,
      minFar: 0
    };
  }
  Camera2.createDefaultSnapshot = createDefaultSnapshot;
  function copySnapshot(out, source) {
    if (!source)
      return out;
    if (typeof source.mode !== "undefined")
      out.mode = source.mode;
    if (typeof source.fov !== "undefined")
      out.fov = source.fov;
    if (typeof source.position !== "undefined")
      Vec3.copy(out.position, source.position);
    if (typeof source.up !== "undefined")
      Vec3.copy(out.up, source.up);
    if (typeof source.target !== "undefined")
      Vec3.copy(out.target, source.target);
    if (typeof source.radius !== "undefined")
      out.radius = source.radius;
    if (typeof source.radiusMax !== "undefined")
      out.radiusMax = source.radiusMax;
    if (typeof source.fog !== "undefined")
      out.fog = source.fog;
    if (typeof source.clipFar !== "undefined")
      out.clipFar = source.clipFar;
    if (typeof source.minNear !== "undefined")
      out.minNear = source.minNear;
    if (typeof source.minFar !== "undefined")
      out.minFar = source.minFar;
    return out;
  }
  Camera2.copySnapshot = copySnapshot;
  function areSnapshotsEqual(a5, b5) {
    return a5.mode === b5.mode && a5.fov === b5.fov && a5.radius === b5.radius && a5.radiusMax === b5.radiusMax && a5.fog === b5.fog && a5.clipFar === b5.clipFar && a5.minNear === b5.minNear && a5.minFar === b5.minFar && Vec3.exactEquals(a5.position, b5.position) && Vec3.exactEquals(a5.up, b5.up) && Vec3.exactEquals(a5.target, b5.target);
  }
  Camera2.areSnapshotsEqual = areSnapshotsEqual;
})(Camera || (Camera = {}));
function updateOrtho(camera) {
  const { viewport, zoom, near, far, viewOffset } = camera;
  const fullLeft = -viewport.width / 2;
  const fullRight = viewport.width / 2;
  const fullTop = viewport.height / 2;
  const fullBottom = -viewport.height / 2;
  const dx = (fullRight - fullLeft) / (2 * zoom);
  const dy = (fullTop - fullBottom) / (2 * zoom);
  const cx = (fullRight + fullLeft) / 2;
  const cy = (fullTop + fullBottom) / 2;
  let left = cx - dx;
  let right = cx + dx;
  let top = cy + dy;
  let bottom = cy - dy;
  if (viewOffset.enabled) {
    const zoomW = zoom / (viewOffset.width / viewOffset.fullWidth);
    const zoomH = zoom / (viewOffset.height / viewOffset.fullHeight);
    const scaleW = (fullRight - fullLeft) / viewOffset.width;
    const scaleH = (fullTop - fullBottom) / viewOffset.height;
    left += scaleW * (viewOffset.offsetX / zoomW);
    right = left + scaleW * (viewOffset.width / zoomW);
    top -= scaleH * (viewOffset.offsetY / zoomH);
    bottom = top - scaleH * (viewOffset.height / zoomH);
  }
  Mat4.ortho(camera.projection, left, right, top, bottom, near, far);
  Mat4.lookAt(camera.view, camera.position, camera.target, camera.up);
}
function updatePers(camera) {
  const aspect = camera.viewport.width / camera.viewport.height;
  const { near, far, viewOffset } = camera;
  let top = near * Math.tan(0.5 * camera.state.fov);
  let height = 2 * top;
  let width = aspect * height;
  let left = -0.5 * width;
  if (viewOffset.enabled) {
    left += viewOffset.offsetX * width / viewOffset.fullWidth;
    top -= viewOffset.offsetY * height / viewOffset.fullHeight;
    width *= viewOffset.width / viewOffset.fullWidth;
    height *= viewOffset.height / viewOffset.fullHeight;
  }
  Mat4.perspective(camera.projection, left, left + width, top, top - height, near, far);
  Mat4.lookAt(camera.view, camera.position, camera.target, camera.up);
}
function updateClip(camera) {
  let { radius, radiusMax, mode, fog, clipFar, minNear, minFar } = camera.state;
  if (radius < 0.01)
    radius = 0.01;
  const normalizedFar = Math.max(clipFar ? radius : radiusMax, minFar);
  const cameraDistance = Vec3.distance(camera.position, camera.target);
  let near = cameraDistance - radius;
  let far = cameraDistance + normalizedFar;
  if (mode === "perspective") {
    near = Math.max(Math.min(radiusMax, minNear), near);
    far = Math.max(minNear, far);
  } else {
    near = Math.max(Math.min(radiusMax, minNear), near);
    far = Math.max(minNear, far);
  }
  if (near === far) {
    far = near + 0.01;
  }
  const fogNearFactor = -(50 - fog) / 50;
  const fogNear = cameraDistance - normalizedFar * fogNearFactor;
  const fogFar = far;
  camera.near = near;
  camera.far = far;
  camera.fogNear = fogNear;
  camera.fogFar = fogFar;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/helper/bounding-sphere-helper.js
var DebugHelperParams = {
  sceneBoundingSpheres: ParamDefinition.Boolean(false, { description: "Show full scene bounding spheres." }),
  visibleSceneBoundingSpheres: ParamDefinition.Boolean(false, { description: "Show visible scene bounding spheres." }),
  objectBoundingSpheres: ParamDefinition.Boolean(false, { description: "Show bounding spheres of visible render objects." }),
  instanceBoundingSpheres: ParamDefinition.Boolean(false, { description: "Show bounding spheres of visible instances." })
};
var BoundingSphereHelper = class {
  constructor(ctx, parent, props) {
    this.objectsData = /* @__PURE__ */ new Map();
    this.instancesData = /* @__PURE__ */ new Map();
    this.scene = Scene.create(ctx, "blended");
    this.parent = parent;
    this._props = { ...ParamDefinition.getDefaultValues(DebugHelperParams), ...props };
  }
  update() {
    const newSceneData = updateBoundingSphereData(this.scene, this.parent.boundingSphere, this.sceneData, ColorNames.lightgrey, sceneMaterialId);
    if (newSceneData)
      this.sceneData = newSceneData;
    const newVisibleSceneData = updateBoundingSphereData(this.scene, this.parent.boundingSphereVisible, this.visibleSceneData, ColorNames.black, visibleSceneMaterialId);
    if (newVisibleSceneData)
      this.visibleSceneData = newVisibleSceneData;
    this.parent.forEach((r, ro) => {
      const objectData = this.objectsData.get(ro);
      const newObjectData = updateBoundingSphereData(this.scene, r.values.boundingSphere.ref.value, objectData, ColorNames.tomato, objectMaterialId);
      if (newObjectData)
        this.objectsData.set(ro, newObjectData);
      const instanceData = this.instancesData.get(ro);
      const newInstanceData = updateBoundingSphereData(this.scene, r.values.invariantBoundingSphere.ref.value, instanceData, ColorNames.skyblue, instanceMaterialId, {
        aTransform: ro.values.aTransform,
        matrix: ro.values.matrix,
        transform: ro.values.transform,
        extraTransform: ro.values.extraTransform,
        uInstanceCount: ro.values.uInstanceCount,
        instanceCount: ro.values.instanceCount,
        aInstance: ro.values.aInstance,
        hasReflection: ro.values.hasReflection,
        instanceGrid: ro.values.instanceGrid
      });
      if (newInstanceData)
        this.instancesData.set(ro, newInstanceData);
    });
    this.objectsData.forEach((objectData, ro) => {
      if (!this.parent.has(ro)) {
        this.scene.remove(objectData.renderObject);
        this.objectsData.delete(ro);
      }
    });
    this.instancesData.forEach((instanceData, ro) => {
      if (!this.parent.has(ro)) {
        this.scene.remove(instanceData.renderObject);
        this.instancesData.delete(ro);
      }
    });
    this.scene.update(void 0, false);
    this.scene.commit();
  }
  syncVisibility() {
    if (this.sceneData) {
      this.sceneData.renderObject.state.visible = this._props.sceneBoundingSpheres;
    }
    if (this.visibleSceneData) {
      this.visibleSceneData.renderObject.state.visible = this._props.visibleSceneBoundingSpheres;
    }
    this.parent.forEach((_, ro) => {
      const objectData = this.objectsData.get(ro);
      if (objectData)
        objectData.renderObject.state.visible = ro.state.visible && this._props.objectBoundingSpheres;
      const instanceData = this.instancesData.get(ro);
      if (instanceData)
        instanceData.renderObject.state.visible = ro.state.visible && this._props.instanceBoundingSpheres;
    });
  }
  clear() {
    this.sceneData = void 0;
    this.objectsData.clear();
    this.scene.clear();
  }
  get isEnabled() {
    return this._props.sceneBoundingSpheres || this._props.visibleSceneBoundingSpheres || this._props.objectBoundingSpheres || this._props.instanceBoundingSpheres;
  }
  get props() {
    return this._props;
  }
  setProps(props) {
    Object.assign(this._props, props);
    if (this.isEnabled)
      this.update();
  }
};
function updateBoundingSphereData(scene, boundingSphere, data, color, materialId, transform) {
  if (!data || !Sphere3D.equals(data.boundingSphere, boundingSphere)) {
    const mesh = createBoundingSphereMesh(boundingSphere, data && data.mesh);
    const renderObject = data ? data.renderObject : createBoundingSphereRenderObject(mesh, color, materialId, transform);
    if (data) {
      ValueCell.updateIfChanged(renderObject.values.drawCount, Geometry.getDrawCount(mesh));
    } else {
      scene.add(renderObject);
    }
    return { boundingSphere: Sphere3D.clone(boundingSphere), renderObject, mesh };
  }
}
function createBoundingSphereMesh(boundingSphere, mesh) {
  const detail = 2;
  const vertexCount = sphereVertexCount(detail);
  const builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);
  if (boundingSphere.radius) {
    addSphere(builderState, boundingSphere.center, boundingSphere.radius, detail);
    if (Sphere3D.hasExtrema(boundingSphere)) {
      for (const e of boundingSphere.extrema)
        addSphere(builderState, e, 1, 0);
    }
  }
  return MeshBuilder.getMesh(builderState);
}
var sceneMaterialId = getNextMaterialId();
var visibleSceneMaterialId = getNextMaterialId();
var objectMaterialId = getNextMaterialId();
var instanceMaterialId = getNextMaterialId();
function createBoundingSphereRenderObject(mesh, color, materialId, transform) {
  const values2 = Mesh.Utils.createValuesSimple(mesh, { alpha: 0.1, doubleSided: false, cellSize: 0, batchSize: 0 }, color, 1, transform);
  return createRenderObject("mesh", values2, { disposed: false, visible: true, alphaFactor: 1, pickable: false, colorOnly: false, opaque: false, writeDepth: false }, materialId);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/helper/interaction-events.js
var InputEvent;
(function(InputEvent2) {
  InputEvent2[InputEvent2["Move"] = 0] = "Move";
  InputEvent2[InputEvent2["Click"] = 1] = "Click";
  InputEvent2[InputEvent2["Drag"] = 2] = "Drag";
})(InputEvent || (InputEvent = {}));
var tmpPosA = Vec3();
var tmpPos = Vec3();
var tmpNorm = Vec3();
var Canvas3dInteractionHelperParams = {
  maxFps: ParamDefinition.Numeric(30, { min: 10, max: 60, step: 10 }),
  preferAtomPixelPadding: ParamDefinition.Numeric(3, { min: 0, max: 20, step: 1 }, { description: "Number of extra pixels at which to prefer atoms over bonds." })
};
var Canvas3dInteractionHelper = class {
  setProps(props) {
    Object.assign(this.props, props);
  }
  identify(e, t2) {
    const xyChanged = this.startX !== this.endX || this.startY !== this.endY || this.input.pointerLock && !this.controls.isMoving;
    if (e === InputEvent.Drag) {
      if (xyChanged && !this.outsideViewport(this.startX, this.startY)) {
        this.events.drag.next({ current: this.prevLoci, buttons: this.buttons, button: this.button, modifiers: this.modifiers, pageStart: Vec2.create(this.startX, this.startY), pageEnd: Vec2.create(this.endX, this.endY) });
        this.startX = this.endX;
        this.startY = this.endY;
      }
      return;
    }
    if (xyChanged) {
      const pickData = this.canvasIdentify(this.endX, this.endY);
      this.id = pickData === null || pickData === void 0 ? void 0 : pickData.id;
      this.position = pickData === null || pickData === void 0 ? void 0 : pickData.position;
      this.startX = this.endX;
      this.startY = this.endY;
    }
    if (e === InputEvent.Click) {
      const loci2 = this.getLoci(this.id, this.position);
      this.events.click.next({ current: loci2, buttons: this.buttons, button: this.button, modifiers: this.modifiers, page: Vec2.create(this.endX, this.endY), position: this.position });
      this.prevLoci = loci2;
      return;
    }
    if (!this.inside || this.currentIdentifyT !== t2 || !xyChanged || this.outsideViewport(this.endX, this.endY))
      return;
    const loci = this.getLoci(this.id, this.position);
    this.events.hover.next({ current: loci, buttons: this.buttons, button: this.button, modifiers: this.modifiers, page: Vec2.create(this.endX, this.endY), position: this.position });
    this.prevLoci = loci;
  }
  tick(t2) {
    if (this.inside && t2 - this.prevT > 1e3 / this.props.maxFps) {
      this.prevT = t2;
      this.currentIdentifyT = t2;
      this.identify(this.isInteracting ? InputEvent.Drag : InputEvent.Move, t2);
    }
  }
  leave() {
    this.inside = false;
    if (!Representation.Loci.isEmpty(this.prevLoci)) {
      this.prevLoci = Representation.Loci.Empty;
      this.events.hover.next({ current: this.prevLoci, buttons: this.buttons, button: this.button, modifiers: this.modifiers });
    }
  }
  move(x, y, buttons, button, modifiers) {
    this.inside = true;
    this.buttons = buttons;
    this.button = button;
    this.modifiers = modifiers;
    this.endX = x;
    this.endY = y;
  }
  click(x, y, buttons, button, modifiers) {
    this.endX = x;
    this.endY = y;
    this.buttons = buttons;
    this.button = button;
    this.modifiers = modifiers;
    this.identify(InputEvent.Click, 0);
  }
  drag(x, y, buttons, button, modifiers) {
    this.endX = x;
    this.endY = y;
    this.buttons = buttons;
    this.button = button;
    this.modifiers = modifiers;
    this.identify(InputEvent.Drag, 0);
  }
  modify(modifiers) {
    if (ModifiersKeys.areEqual(modifiers, this.modifiers))
      return;
    this.modifiers = modifiers;
    this.events.hover.next({ current: this.prevLoci, buttons: this.buttons, button: this.button, modifiers: this.modifiers, page: Vec2.create(this.endX, this.endY), position: this.position });
  }
  outsideViewport(x, y) {
    const { input, camera: { viewport } } = this;
    x *= input.pixelRatio;
    y *= input.pixelRatio;
    return x > viewport.x + viewport.width || input.height - y > viewport.y + viewport.height || x < viewport.x || input.height - y < viewport.y;
  }
  getLoci(pickingId, position) {
    var _a;
    const { repr, loci } = this.lociGetter(pickingId);
    if (position && repr && Bond.isLoci(loci) && loci.bonds.length === 2) {
      const { aUnit, aIndex } = loci.bonds[0];
      aUnit.conformation.position(aUnit.elements[aIndex], tmpPosA);
      Vec3.sub(tmpNorm, this.camera.state.position, this.camera.state.target);
      Vec3.projectPointOnPlane(tmpPos, position, tmpNorm, tmpPosA);
      const pixelSize = this.camera.getPixelSize(tmpPos);
      let radius = repr.theme.size.size(loci.bonds[0]) * ((_a = repr.props.sizeFactor) !== null && _a !== void 0 ? _a : 1);
      if (repr.props.lineSizeAttenuation === false) {
        radius *= pixelSize / 2;
      }
      radius += this.props.preferAtomPixelPadding * pixelSize;
      if (Vec3.distance(tmpPos, tmpPosA) < radius) {
        return { repr, loci: Bond.toFirstStructureElementLoci(loci) };
      }
    }
    return { repr, loci };
  }
  dispose() {
    this.ev.dispose();
  }
  constructor(canvasIdentify, lociGetter, input, camera, controls, props = {}) {
    this.canvasIdentify = canvasIdentify;
    this.lociGetter = lociGetter;
    this.input = input;
    this.camera = camera;
    this.controls = controls;
    this.ev = RxEventHelper.create();
    this.events = {
      hover: this.ev(),
      drag: this.ev(),
      click: this.ev()
    };
    this.startX = -1;
    this.startY = -1;
    this.endX = -1;
    this.endY = -1;
    this.id = void 0;
    this.position = void 0;
    this.currentIdentifyT = 0;
    this.isInteracting = false;
    this.prevLoci = Representation.Loci.Empty;
    this.prevT = 0;
    this.inside = false;
    this.buttons = ButtonsType.create(0);
    this.button = ButtonsType.create(0);
    this.modifiers = ModifiersKeys.None;
    this.props = { ...ParamDefinition.getDefaultValues(Canvas3dInteractionHelperParams), ...props };
    input.drag.subscribe(({ x, y, buttons, button, modifiers }) => {
      this.isInteracting = true;
      this.drag(x, y, buttons, button, modifiers);
    });
    input.move.subscribe(({ x, y, inside, buttons, button, modifiers, onElement }) => {
      if (!inside || this.isInteracting)
        return;
      if (!onElement) {
        this.leave();
        return;
      }
      this.move(x, y, buttons, button, modifiers);
    });
    input.leave.subscribe(() => {
      this.leave();
    });
    input.click.subscribe(({ x, y, buttons, button, modifiers }) => {
      if (this.outsideViewport(x, y))
        return;
      this.click(x, y, buttons, button, modifiers);
    });
    input.interactionEnd.subscribe(() => {
      this.isInteracting = false;
    });
    input.modifiers.subscribe((modifiers) => {
      this.modify(modifiers);
    });
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/postprocessing.frag.js
var postprocessing_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

uniform sampler2D tSsaoDepth;
uniform sampler2D tSsaoDepthTransparent;
uniform sampler2D tColor;
uniform sampler2D tTransparentColor;
uniform sampler2D tDepthOpaque;
uniform sampler2D tDepthTransparent;
uniform sampler2D tShadows;
uniform sampler2D tOutlines;
uniform vec2 uTexSize;

uniform float uNear;
uniform float uFar;
uniform float uFogNear;
uniform float uFogFar;
uniform vec3 uFogColor;
uniform vec3 uOutlineColor;
uniform vec3 uOcclusionColor;
uniform bool uTransparentBackground;
uniform vec2 uOcclusionOffset;

#include common

float getViewZ(const in float depth) {
    #if dOrthographic == 1
        return orthographicDepthToViewZ(depth, uNear, uFar);
    #else
        return perspectiveDepthToViewZ(depth, uNear, uFar);
    #endif
}

float getDepthOpaque(const in vec2 coords) {
    #ifdef depthTextureSupport
        return texture2D(tDepthOpaque, coords).r;
    #else
        return unpackRGBAToDepth(texture2D(tDepthOpaque, coords));
    #endif
}

float getDepthTransparent(const in vec2 coords) {
    return unpackRGBAToDepthWithAlpha(texture2D(tDepthTransparent, coords)).x;
}

bool isBackground(const in float depth) {
    return depth > 0.999; // handle depth packing precision issues
}

int squaredOutlineScale = dOutlineScale * dOutlineScale;
float getOutline(const in vec2 coords, const in float opaqueDepth, const in float transparentDepth, out float closestTexel, out float isTransparent) {
    vec2 invTexSize = 1.0 / uTexSize;

    float outline = 1.0;
    closestTexel = 1.0;
    isTransparent = 0.0;
    for (int y = -dOutlineScale; y <= dOutlineScale; y++) {
        for (int x = -dOutlineScale; x <= dOutlineScale; x++) {
            if (x * x + y * y > squaredOutlineScale) {
                continue;
            }

            vec2 sampleCoords = coords + vec2(float(x), float(y)) * invTexSize;

            vec4 sampleOutlineCombined = texture2D(tOutlines, sampleCoords);
            float sampleOutline = sampleOutlineCombined.r;
            float sampleOutlineDepth = unpackRGToUnitInterval(sampleOutlineCombined.gb);

            if (sampleOutline == 0.0 && sampleOutlineDepth < closestTexel) {
                outline = 0.0;
                closestTexel = sampleOutlineDepth;
                isTransparent = sampleOutlineCombined.a;
            }
        }
    }
    return isTransparent == 0.0 ? outline : (closestTexel > opaqueDepth && closestTexel < transparentDepth) ? 1.0 : outline;
}

float getSsao(vec2 coords) {
    float rawSsao = unpackRGToUnitInterval(texture2D(tSsaoDepth, coords).xy);
    if (rawSsao > 0.999) {
        return 1.0;
    } else if (rawSsao > 0.001) {
        return rawSsao;
    }
    // treat values close to 0.0 as errors and return no occlusion
    return 1.0;
}

float getSsaoTransparent(vec2 coords) {
    float rawSsao = unpackRGToUnitInterval(texture2D(tSsaoDepthTransparent, coords).xy);
    if (rawSsao > 0.999) {
        return 1.0;
    } else if (rawSsao > 0.001) {
        return rawSsao;
    }
    // treat values close to 0.0 as errors and return no occlusion
    return 1.0;
}

void main(void) {
    vec2 coords = gl_FragCoord.xy / uTexSize;
    vec4 color = texture2D(tColor, coords);

    float opaqueDepth = getDepthOpaque(coords);
    float transparentDepth = 1.0;
    #ifdef dBlendTransparency
        bool blendTransparency = true;
        vec4 transparentColor = texture2D(tTransparentColor, coords);

        #if defined(dOutlineEnable) || defined(dOcclusionEnable) && defined(dOcclusionIncludeTransparency)
            transparentDepth = getDepthTransparent(coords);
        #endif
    #endif

    #if defined(dOcclusionEnable) || defined(dShadowEnable)
        bool isOpaqueBackground = isBackground(opaqueDepth);
        float viewDist = abs(getViewZ(opaqueDepth));
        float fogFactor = smoothstep(uFogNear, uFogFar, viewDist);
    #endif

    #if defined(dOcclusionEnable)
        if (!isOpaqueBackground) {
            float occlusionFactor = getSsao(coords + uOcclusionOffset);

            if (!uTransparentBackground) {
                color.rgb = mix(mix(uOcclusionColor, uFogColor, fogFactor), color.rgb, occlusionFactor);
            } else {
                color.rgb = mix(uOcclusionColor * (1.0 - fogFactor), color.rgb, occlusionFactor);
            }
        }
        #if defined(dBlendTransparency) && defined(dOcclusionIncludeTransparency)
            if (!isBackground(transparentDepth)) {
                float viewDist = abs(getViewZ(transparentDepth));
                float fogFactor = smoothstep(uFogNear, uFogFar, viewDist);
                float occlusionFactor = getSsaoTransparent(coords + uOcclusionOffset);
                transparentColor.rgb = mix(uOcclusionColor * (1.0 - fogFactor), transparentColor.rgb, occlusionFactor);
            }
        #endif
    #endif

    #ifdef dShadowEnable
        if (!isOpaqueBackground) {
            vec4 shadow = texture2D(tShadows, coords);
            if (!uTransparentBackground) {
                color.rgb = mix(mix(vec3(0), uFogColor, fogFactor), color.rgb, shadow.a);
            } else {
                color.rgb = mix(vec3(0) * (1.0 - fogFactor), color.rgb, shadow.a);
            }
        }
    #endif

    // outline needs to be handled after occlusion and shadow to keep them clean
    #ifdef dOutlineEnable
        float closestTexel;
        float isTransparentOutline;
        float outline = getOutline(coords, opaqueDepth, transparentDepth, closestTexel, isTransparentOutline);
        if (outline == 0.0) {
            float viewDist = abs(getViewZ(closestTexel));
            float fogFactor = smoothstep(uFogNear, uFogFar, viewDist);
            if (!uTransparentBackground) {
                    color.rgb = mix(uOutlineColor, uFogColor, fogFactor);
            } else {
                color.a = 1.0 - fogFactor;
                color.rgb = mix(uOutlineColor, vec3(0.0), fogFactor);
            }
            #ifdef dBlendTransparency
                if (isTransparentOutline == 1.0 || transparentDepth > closestTexel) {
                    blendTransparency = false;
                }
            #endif
        }
    #endif

    #ifdef dBlendTransparency
        if (blendTransparency) {
            float alpha = transparentColor.a;
            if (alpha != 0.0) {
                // blending
                color = transparentColor + color * (1.0 - alpha);
            }
        }
    #endif

    gl_FragColor = color;
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/fxaa.frag.js
var fxaa_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

uniform sampler2D tColor;
uniform vec2 uTexSizeInv;

// adapted from https://github.com/kosua20/Rendu
// MIT License Copyright (c) 2017 Simon Rodriguez

#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))

float rgb2luma(vec3 rgb){
    return sqrt(dot(rgb, vec3(0.299, 0.587, 0.114)));
}

float sampleLuma(vec2 uv) {
    return rgb2luma(texture2D(tColor, uv).rgb);
}

float sampleLuma(vec2 uv, float uOffset, float vOffset) {
    uv += uTexSizeInv * vec2(uOffset, vOffset);
    return sampleLuma(uv);
}

void main(void) {
    vec2 coords = gl_FragCoord.xy * uTexSizeInv;
    vec2 inverseScreenSize = uTexSizeInv;

    vec4 colorCenter = texture2D(tColor, coords);

    // Luma at the current fragment
    float lumaCenter = rgb2luma(colorCenter.rgb);

    // Luma at the four direct neighbours of the current fragment.
    float lumaDown = sampleLuma(coords, 0.0, -1.0);
    float lumaUp = sampleLuma(coords, 0.0, 1.0);
    float lumaLeft = sampleLuma(coords, -1.0, 0.0);
    float lumaRight = sampleLuma(coords, 1.0, 0.0);

    // Find the maximum and minimum luma around the current fragment.
    float lumaMin = min(lumaCenter, min(min(lumaDown, lumaUp), min(lumaLeft, lumaRight)));
    float lumaMax = max(lumaCenter, max(max(lumaDown, lumaUp), max(lumaLeft, lumaRight)));

    // Compute the delta.
    float lumaRange = lumaMax - lumaMin;

    // If the luma variation is lower that a threshold (or if we are in a really dark area),
    // we are not on an edge, don't perform any AA.
    if (lumaRange < max(dEdgeThresholdMin, lumaMax * dEdgeThresholdMax)) {
        gl_FragColor = colorCenter;
        return;
    }

    // Query the 4 remaining corners lumas.
    float lumaDownLeft = sampleLuma(coords, -1.0, -1.0);
    float lumaUpRight = sampleLuma(coords, 1.0, 1.0);
    float lumaUpLeft = sampleLuma(coords, -1.0, 1.0);
    float lumaDownRight = sampleLuma(coords, 1.0, -1.0);

    // Combine the four edges lumas (using intermediary variables for future computations
    // with the same values).
    float lumaDownUp = lumaDown + lumaUp;
    float lumaLeftRight = lumaLeft + lumaRight;

    // Same for corners
    float lumaLeftCorners = lumaDownLeft + lumaUpLeft;
    float lumaDownCorners = lumaDownLeft + lumaDownRight;
    float lumaRightCorners = lumaDownRight + lumaUpRight;
    float lumaUpCorners = lumaUpRight + lumaUpLeft;

    // Compute an estimation of the gradient along the horizontal and vertical axis.
    float edgeHorizontal = abs(-2.0 * lumaLeft + lumaLeftCorners) + abs(-2.0 * lumaCenter + lumaDownUp) * 2.0 + abs(-2.0 * lumaRight + lumaRightCorners);
    float edgeVertical = abs(-2.0 * lumaUp + lumaUpCorners) + abs(-2.0 * lumaCenter + lumaLeftRight) * 2.0 + abs(-2.0 * lumaDown + lumaDownCorners);

    // Is the local edge horizontal or vertical ?
    bool isHorizontal = (edgeHorizontal >= edgeVertical);

    // Choose the step size (one pixel) accordingly.
    float stepLength = isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;

    // Select the two neighboring texels lumas in the opposite direction to the local edge.
    float luma1 = isHorizontal ? lumaDown : lumaLeft;
    float luma2 = isHorizontal ? lumaUp : lumaRight;
    // Compute gradients in this direction.
    float gradient1 = luma1 - lumaCenter;
    float gradient2 = luma2 - lumaCenter;

    // Which direction is the steepest ?
    bool is1Steepest = abs(gradient1) >= abs(gradient2);

    // Gradient in the corresponding direction, normalized.
    float gradientScaled = 0.25 * max(abs(gradient1), abs(gradient2));

    // Average luma in the correct direction.
    float lumaLocalAverage = 0.0;
    if(is1Steepest){
        // Switch the direction
        stepLength = -stepLength;
        lumaLocalAverage = 0.5 * (luma1 + lumaCenter);
    } else {
        lumaLocalAverage = 0.5 * (luma2 + lumaCenter);
    }

    // Shift UV in the correct direction by half a pixel.
    vec2 currentUv = coords;
    if(isHorizontal){
        currentUv.y += stepLength * 0.5;
    } else {
        currentUv.x += stepLength * 0.5;
    }

    // Compute offset (for each iteration step) in the right direction.
    vec2 offset = isHorizontal ? vec2(inverseScreenSize.x, 0.0) : vec2(0.0, inverseScreenSize.y);
    // Compute UVs to explore on each side of the edge, orthogonally.
    // The QUALITY allows us to step faster.
    vec2 uv1 = currentUv - offset * QUALITY(0);
    vec2 uv2 = currentUv + offset * QUALITY(0);

    // Read the lumas at both current extremities of the exploration segment,
    // and compute the delta wrt to the local average luma.
    float lumaEnd1 = sampleLuma(uv1);
    float lumaEnd2 = sampleLuma(uv2);
    lumaEnd1 -= lumaLocalAverage;
    lumaEnd2 -= lumaLocalAverage;

    // If the luma deltas at the current extremities is larger than the local gradient,
    // we have reached the side of the edge.
    bool reached1 = abs(lumaEnd1) >= gradientScaled;
    bool reached2 = abs(lumaEnd2) >= gradientScaled;
    bool reachedBoth = reached1 && reached2;

    // If the side is not reached, we continue to explore in this direction.
    if(!reached1){
        uv1 -= offset * QUALITY(1);
    }
    if(!reached2){
        uv2 += offset * QUALITY(1);
    }

    // If both sides have not been reached, continue to explore.
    if(!reachedBoth){
        for(int i = 2; i < dIterations; i++){
            // If needed, read luma in 1st direction, compute delta.
            if(!reached1){
                lumaEnd1 = sampleLuma(uv1);
                lumaEnd1 = lumaEnd1 - lumaLocalAverage;
            }
            // If needed, read luma in opposite direction, compute delta.
            if(!reached2){
                lumaEnd2 = sampleLuma(uv2);
                lumaEnd2 = lumaEnd2 - lumaLocalAverage;
            }
            // If the luma deltas at the current extremities is larger than the local gradient,
            // we have reached the side of the edge.
            reached1 = abs(lumaEnd1) >= gradientScaled;
            reached2 = abs(lumaEnd2) >= gradientScaled;
            reachedBoth = reached1 && reached2;

            // If the side is not reached, we continue to explore in this direction,
            // with a variable quality.
            if(!reached1){
                uv1 -= offset * QUALITY(i);
            }
            if(!reached2){
                uv2 += offset * QUALITY(i);
            }

            // If both sides have been reached, stop the exploration.
            if(reachedBoth){
                break;
            }
        }
    }

    // Compute the distances to each side edge of the edge (!).
    float distance1 = isHorizontal ? (coords.x - uv1.x) : (coords.y - uv1.y);
    float distance2 = isHorizontal ? (uv2.x - coords.x) : (uv2.y - coords.y);

    // In which direction is the side of the edge closer ?
    bool isDirection1 = distance1 < distance2;
    float distanceFinal = min(distance1, distance2);

    // Thickness of the edge.
    float edgeThickness = (distance1 + distance2);

    // Is the luma at center smaller than the local average ?
    bool isLumaCenterSmaller = lumaCenter < lumaLocalAverage;

    // If the luma at center is smaller than at its neighbour,
    // the delta luma at each end should be positive (same variation).
    bool correctVariation1 = (lumaEnd1 < 0.0) != isLumaCenterSmaller;
    bool correctVariation2 = (lumaEnd2 < 0.0) != isLumaCenterSmaller;

    // Only keep the result in the direction of the closer side of the edge.
    bool correctVariation = isDirection1 ? correctVariation1 : correctVariation2;

    // UV offset: read in the direction of the closest side of the edge.
    float pixelOffset = - distanceFinal / edgeThickness + 0.5;

    // If the luma variation is incorrect, do not offset.
    float finalOffset = correctVariation ? pixelOffset : 0.0;

    // Sub-pixel shifting
    // Full weighted average of the luma over the 3x3 neighborhood.
    float lumaAverage = (1.0 / 12.0) * (2.0 * (lumaDownUp + lumaLeftRight) + lumaLeftCorners + lumaRightCorners);
    // Ratio of the delta between the global average and the center luma,
    // over the luma range in the 3x3 neighborhood.
    float subPixelOffset1 = clamp(abs(lumaAverage - lumaCenter) / lumaRange, 0.0, 1.0);
    float subPixelOffset2 = (-2.0 * subPixelOffset1 + 3.0) * subPixelOffset1 * subPixelOffset1;
    // Compute a sub-pixel offset based on this delta.
    float subPixelOffsetFinal = subPixelOffset2 * subPixelOffset2 * float(dSubpixelQuality);

    // Pick the biggest of the two offsets.
    finalOffset = max(finalOffset, subPixelOffsetFinal);

    // Compute the final UV coordinates.
    vec2 finalUv = coords;
    if(isHorizontal){
        finalUv.y += finalOffset * stepLength;
    } else {
        finalUv.x += finalOffset * stepLength;
    }

    // Read the color at the new UV coordinates, and use it.
    gl_FragColor = texture2D(tColor, finalUv);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/fxaa.js
var FxaaParams = {
  edgeThresholdMin: ParamDefinition.Numeric(0.0312, { min: 0.0312, max: 0.0833, step: 1e-4 }, { description: "Trims the algorithm from processing darks." }),
  edgeThresholdMax: ParamDefinition.Numeric(0.063, { min: 0.063, max: 0.333, step: 1e-3 }, { description: "The minimum amount of local contrast required to apply algorithm." }),
  iterations: ParamDefinition.Numeric(12, { min: 0, max: 16, step: 1 }, { description: "Number of edge exploration steps." }),
  subpixelQuality: ParamDefinition.Numeric(0.3, { min: 0, max: 1, step: 0.01 }, { description: "Choose the amount of sub-pixel aliasing removal." })
};
var FxaaPass = class {
  constructor(webgl, input) {
    this.webgl = webgl;
    this.renderable = getFxaaRenderable(webgl, input);
  }
  updateState(viewport) {
    const { gl, state } = this.webgl;
    state.enable(gl.SCISSOR_TEST);
    state.disable(gl.BLEND);
    state.disable(gl.DEPTH_TEST);
    state.depthMask(false);
    const { x, y, width, height } = viewport;
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    state.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  setSize(width, height) {
    ValueCell.update(this.renderable.values.uTexSizeInv, Vec2.set(this.renderable.values.uTexSizeInv.ref.value, 1 / width, 1 / height));
  }
  update(input, props) {
    const { values: values2 } = this.renderable;
    const { edgeThresholdMin, edgeThresholdMax, iterations, subpixelQuality } = props;
    let needsUpdate = false;
    if (values2.tColor.ref.value !== input) {
      ValueCell.update(this.renderable.values.tColor, input);
      needsUpdate = true;
    }
    if (values2.dEdgeThresholdMin.ref.value !== edgeThresholdMin)
      needsUpdate = true;
    ValueCell.updateIfChanged(values2.dEdgeThresholdMin, edgeThresholdMin);
    if (values2.dEdgeThresholdMax.ref.value !== edgeThresholdMax)
      needsUpdate = true;
    ValueCell.updateIfChanged(values2.dEdgeThresholdMax, edgeThresholdMax);
    if (values2.dIterations.ref.value !== iterations)
      needsUpdate = true;
    ValueCell.updateIfChanged(values2.dIterations, iterations);
    if (values2.dSubpixelQuality.ref.value !== subpixelQuality)
      needsUpdate = true;
    ValueCell.updateIfChanged(values2.dSubpixelQuality, subpixelQuality);
    if (needsUpdate) {
      this.renderable.update();
    }
  }
  render(viewport, target) {
    if (isTimingMode)
      this.webgl.timer.mark("FxaaPass.render");
    if (target) {
      target.bind();
    } else {
      this.webgl.unbindFramebuffer();
    }
    this.updateState(viewport);
    this.renderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("FxaaPass.render");
  }
};
var FxaaSchema = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "ubyte", "linear"),
  uTexSizeInv: UniformSpec("v2"),
  dEdgeThresholdMin: DefineSpec("number"),
  dEdgeThresholdMax: DefineSpec("number"),
  dIterations: DefineSpec("number"),
  dSubpixelQuality: DefineSpec("number")
};
var FxaaShaderCode = ShaderCode("fxaa", quad_vert, fxaa_frag);
function getFxaaRenderable(ctx, colorTexture) {
  const width = colorTexture.getWidth();
  const height = colorTexture.getHeight();
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(colorTexture),
    uTexSizeInv: ValueCell.create(Vec2.create(1 / width, 1 / height)),
    dEdgeThresholdMin: ValueCell.create(0.0312),
    dEdgeThresholdMax: ValueCell.create(0.125),
    dIterations: ValueCell.create(12),
    dSubpixelQuality: ValueCell.create(0.3)
  };
  const schema = { ...FxaaSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", FxaaShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/smaa/blend.vert.js
var blend_vert = `
precision highp float;

attribute vec2 aPosition;
uniform vec2 uQuadScale;

uniform vec2 uTexSizeInv;
uniform vec4 uViewport;

varying vec2 vUv;
varying vec4 vOffset[2];

void SMAANeighborhoodBlendingVS(vec2 texCoord) {
    vOffset[0] = texCoord.xyxy + uTexSizeInv.xyxy * vec4(-1.0, 0.0, 0.0, 1.0); // WebGL port note: Changed sign in W component
    vOffset[1] = texCoord.xyxy + uTexSizeInv.xyxy * vec4(1.0, 0.0, 0.0, -1.0); // WebGL port note: Changed sign in W component
}

void main() {
    vec2 scale = uViewport.zw * uTexSizeInv;
    vec2 shift = uViewport.xy * uTexSizeInv;
    vUv = (aPosition + 1.0) * 0.5 * scale + shift;
    SMAANeighborhoodBlendingVS(vUv);
    vec2 position = aPosition * uQuadScale - vec2(1.0, 1.0) + uQuadScale;
    gl_Position = vec4(position, 0.0, 1.0);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/smaa/blend.frag.js
var blend_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

uniform sampler2D tWeights;
uniform sampler2D tColor;
uniform vec2 uTexSizeInv;

varying vec2 vUv;
varying vec4 vOffset[2];

vec4 SMAANeighborhoodBlendingPS(vec2 texCoord, vec4 offset[2], sampler2D colorTex, sampler2D blendTex) {
    // Fetch the blending weights for current pixel:
    vec4 a;
    a.xz = texture2D(blendTex, texCoord).xz;
    a.y = texture2D(blendTex, offset[1].zw).g;
    a.w = texture2D(blendTex, offset[1].xy).a;

    // Is there any blending weight with a value greater than 0.0?
    if (dot(a, vec4(1.0, 1.0, 1.0, 1.0)) < 1e-5) {
        return texture2D(colorTex, texCoord, 0.0);
    } else {
        // Up to 4 lines can be crossing a pixel (one through each edge). We
        // favor blending by choosing the line with the maximum weight for each
        // direction:
        vec2 offset;
        offset.x = a.a > a.b ? a.a : -a.b; // left vs. right
        offset.y = a.g > a.r ? -a.g : a.r; // top vs. bottom // WebGL port note: Changed signs

        // Then we go in the direction that has the maximum weight:
        if (abs(offset.x) > abs(offset.y)) { // horizontal vs. vertical
            offset.y = 0.0;
        } else {
            offset.x = 0.0;
        }

        // Fetch the opposite color and lerp by hand:
        vec4 C = texture2D(colorTex, texCoord, 0.0);
        texCoord += sign(offset) * uTexSizeInv;
        vec4 Cop = texture2D(colorTex, texCoord, 0.0);
        float s = abs(offset.x) > abs(offset.y) ? abs(offset.x) : abs(offset.y);

        // WebGL port note: Added gamma correction
        C.xyz = pow(C.xyz, vec3(2.2));
        Cop.xyz = pow(Cop.xyz, vec3(2.2));
        vec4 mixed = mix(C, Cop, s);
        mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));

        return mixed;
    }
}

void main() {
    gl_FragColor = SMAANeighborhoodBlendingPS(vUv, vOffset, tColor, tWeights);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/smaa/weights.vert.js
var weights_vert = `
precision highp float;

attribute vec2 aPosition;
uniform vec2 uQuadScale;

uniform vec2 uTexSizeInv;
uniform vec4 uViewport;

varying vec2 vUv;
varying vec4 vOffset[3];
varying vec2 vPixCoord;

void SMAABlendingWeightCalculationVS(vec2 texCoord) {
    vPixCoord = texCoord / uTexSizeInv;

    // We will use these offsets for the searches later on (see @PSEUDO_GATHER4):
    vOffset[0] = texCoord.xyxy + uTexSizeInv.xyxy * vec4(-0.25, 0.125, 1.25, 0.125); // WebGL port note: Changed sign in Y and W components
    vOffset[1] = texCoord.xyxy + uTexSizeInv.xyxy * vec4(-0.125, 0.25, -0.125, -1.25); // WebGL port note: Changed sign in Y and W components

    // And these for the searches, they indicate the ends of the loops:
    vOffset[2] = vec4(vOffset[0].xz, vOffset[1].yw) + vec4(-2.0, 2.0, -2.0, 2.0) * uTexSizeInv.xxyy * float(dMaxSearchSteps);
}

void main() {
    vec2 scale = uViewport.zw * uTexSizeInv;
    vec2 shift = uViewport.xy * uTexSizeInv;
    vUv = (aPosition + 1.0) * 0.5 * scale + shift;
    SMAABlendingWeightCalculationVS(vUv);
    vec2 position = aPosition * uQuadScale - vec2(1.0, 1.0) + uQuadScale;
    gl_Position = vec4(position, 0.0, 1.0);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/smaa/weights.frag.js
var weights_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

#define SMAASampleLevelZeroOffset(tex, coord, offset) texture2D(tex, coord + float(offset) * uTexSizeInv, 0.0)

#define SMAA_AREATEX_MAX_DISTANCE 16
#define SMAA_AREATEX_PIXEL_SIZE (1.0 / vec2(160.0, 560.0))
#define SMAA_AREATEX_SUBTEX_SIZE (1.0 / 7.0)

uniform sampler2D tEdges;
uniform sampler2D tArea;
uniform sampler2D tSearch;
uniform vec2 uTexSizeInv;

varying vec2 vUv;
varying vec4 vOffset[3];
varying vec2 vPixCoord;

#if __VERSION__ == 100
    vec2 round(vec2 x) {
        return sign(x) * floor(abs(x) + 0.5);
    }
#endif

float SMAASearchLength(sampler2D searchTex, vec2 e, float bias, float scale) {
    // Not required if searchTex accesses are set to point:
    // float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);
    // e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +
    //     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;
    e.r = bias + e.r * scale;
    return 255.0 * texture2D(searchTex, e, 0.0).r;
}

float SMAASearchXLeft(sampler2D edgesTex, sampler2D searchTex, vec2 texCoord, float end) {
    /**
     * @PSEUDO_GATHER4
     * This texCoord has been offset by (-0.25, -0.125) in the vertex shader to
     * sample between edge, thus fetching four edges in a row.
     * Sampling with different offsets in each direction allows to disambiguate
     * which edges are active from the four fetched ones.
     */
    vec2 e = vec2(0.0, 1.0);

    for (int i = 0; i < dMaxSearchSteps; i++) { // WebGL port note: Changed while to for
        e = texture2D( edgesTex, texCoord, 0.0).rg;
        texCoord -= vec2(2.0, 0.0) * uTexSizeInv;
        if (!(texCoord.x > end && e.g > 0.8281 && e.r == 0.0)) break;
    }

    // We correct the previous (-0.25, -0.125) offset we applied:
    texCoord.x += 0.25 * uTexSizeInv.x;

    // The searches are bias by 1, so adjust the coords accordingly:
    texCoord.x += uTexSizeInv.x;

    // Disambiguate the length added by the last step:
    texCoord.x += 2.0 * uTexSizeInv.x; // Undo last step
    texCoord.x -= uTexSizeInv.x * SMAASearchLength(searchTex, e, 0.0, 0.5);

    return texCoord.x;
}

float SMAASearchXRight(sampler2D edgesTex, sampler2D searchTex, vec2 texCoord, float end) {
    vec2 e = vec2( 0.0, 1.0 );

    for (int i = 0; i < dMaxSearchSteps; i++) { // WebGL port note: Changed while to for
        e = texture2D(edgesTex, texCoord, 0.0).rg;
        texCoord += vec2(2.0, 0.0) * uTexSizeInv;
        if (!(texCoord.x < end && e.g > 0.8281 && e.r == 0.0)) break;
    }

    texCoord.x -= 0.25 * uTexSizeInv.x;
    texCoord.x -= uTexSizeInv.x;
    texCoord.x -= 2.0 * uTexSizeInv.x;
    texCoord.x += uTexSizeInv.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );

    return texCoord.x;
}

float SMAASearchYUp(sampler2D edgesTex, sampler2D searchTex, vec2 texCoord, float end) {
    vec2 e = vec2( 1.0, 0.0 );

    for (int i = 0; i < dMaxSearchSteps; i++) { // WebGL port note: Changed while to for
        e = texture2D(edgesTex, texCoord, 0.0).rg;
        texCoord += vec2(0.0, 2.0) * uTexSizeInv; // WebGL port note: Changed sign
        if (!(texCoord.y > end && e.r > 0.8281 && e.g == 0.0)) break;
    }

    texCoord.y -= 0.25 * uTexSizeInv.y; // WebGL port note: Changed sign
    texCoord.y -= uTexSizeInv.y; // WebGL port note: Changed sign
    texCoord.y -= 2.0 * uTexSizeInv.y; // WebGL port note: Changed sign
    texCoord.y += uTexSizeInv.y * SMAASearchLength(searchTex, e.gr, 0.0, 0.5); // WebGL port note: Changed sign

    return texCoord.y;
}

float SMAASearchYDown(sampler2D edgesTex, sampler2D searchTex, vec2 texCoord, float end) {
    vec2 e = vec2( 1.0, 0.0 );

    for (int i = 0; i < dMaxSearchSteps; i++) { // WebGL port note: Changed while to for
        e = texture2D(edgesTex, texCoord, 0.0).rg;
        texCoord -= vec2( 0.0, 2.0 ) * uTexSizeInv; // WebGL port note: Changed sign
        if (!(texCoord.y < end && e.r > 0.8281 && e.g == 0.0)) break;
    }

    texCoord.y += 0.25 * uTexSizeInv.y; // WebGL port note: Changed sign
    texCoord.y += uTexSizeInv.y; // WebGL port note: Changed sign
    texCoord.y += 2.0 * uTexSizeInv.y; // WebGL port note: Changed sign
    texCoord.y -= uTexSizeInv.y * SMAASearchLength(searchTex, e.gr, 0.5, 0.5); // WebGL port note: Changed sign

    return texCoord.y;
}

vec2 SMAAArea(sampler2D areaTex, vec2 dist, float e1, float e2, float offset) {
    // Rounding prevents precision errors of bilinear filtering:
    vec2 texCoord = float(SMAA_AREATEX_MAX_DISTANCE) * round(4.0 * vec2(e1, e2)) + dist;

    // We do a scale and bias for mapping to texel space:
    texCoord = SMAA_AREATEX_PIXEL_SIZE * texCoord + (0.5 * SMAA_AREATEX_PIXEL_SIZE);

    // Move to proper place, according to the subpixel offset:
    texCoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;

    return texture2D(areaTex, texCoord, 0.0).rg;
}

vec4 SMAABlendingWeightCalculationPS(vec2 texCoord, vec2 pixCoord, vec4 offset[3], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices) {
    vec4 weights = vec4(0.0, 0.0, 0.0, 0.0);

    vec2 e = texture2D(edgesTex, texCoord).rg;

    if (e.g > 0.0) { // Edge at north
        vec2 d;

        // Find the distance to the left:
        vec2 coords;
        coords.x = SMAASearchXLeft(edgesTex, searchTex, offset[0].xy, offset[2].x );
        coords.y = offset[1].y; // offset[1].y = texCoord.y - 0.25 * uTexSizeInv.y (@CROSSING_OFFSET)
        d.x = coords.x;

        // Now fetch the left crossing edges, two at a time using bilinear
        // filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to
        // discern what value each edge has:
        float e1 = texture2D(edgesTex, coords, 0.0).r;

        // Find the distance to the right:
        coords.x = SMAASearchXRight(edgesTex, searchTex, offset[0].zw, offset[2].y);
        d.y = coords.x;

        // We want the distances to be in pixel units (doing this here allow to
        // better interleave arithmetic and memory accesses):
        d = d / uTexSizeInv.x - pixCoord.x;

        // SMAAArea below needs a sqrt, as the areas texture is compressed
        // quadratically:
        vec2 sqrt_d = sqrt(abs(d));

        // Fetch the right crossing edges:
        coords.y -= 1.0 * uTexSizeInv.y; // WebGL port note: Added
        float e2 = SMAASampleLevelZeroOffset(edgesTex, coords, ivec2(1, 0)).r;

        // Ok, we know how this pattern looks like, now it is time for getting
        // the actual area:
        weights.rg = SMAAArea(areaTex, sqrt_d, e1, e2, float(subsampleIndices.y));
    }

    if (e.r > 0.0) { // Edge at west
        vec2 d;

        // Find the distance to the top:
        vec2 coords;

        coords.y = SMAASearchYUp(edgesTex, searchTex, offset[1].xy, offset[2].z );
        coords.x = offset[0].x; // offset[1].x = texCoord.x - 0.25 * uTexSizeInv.x;
        d.x = coords.y;

        // Fetch the top crossing edges:
        float e1 = texture2D(edgesTex, coords, 0.0).g;

        // Find the distance to the bottom:
        coords.y = SMAASearchYDown(edgesTex, searchTex, offset[1].zw, offset[2].w);
        d.y = coords.y;

        // We want the distances to be in pixel units:
        d = d / uTexSizeInv.y - pixCoord.y;

        // SMAAArea below needs a sqrt, as the areas texture is compressed
        // quadratically:
        vec2 sqrt_d = sqrt(abs(d));

        // Fetch the bottom crossing edges:
        coords.y -= 1.0 * uTexSizeInv.y; // WebGL port note: Added
        float e2 = SMAASampleLevelZeroOffset(edgesTex, coords, ivec2(0, 1)).g;

        // Get the area for this direction:
        weights.ba = SMAAArea(areaTex, sqrt_d, e1, e2, float(subsampleIndices.x));
    }

    return weights;
}

void main() {
    gl_FragColor = SMAABlendingWeightCalculationPS(vUv, vPixCoord, vOffset, tEdges, tArea, tSearch, ivec4(0.0));
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/smaa/edges.vert.js
var edges_vert = `
precision highp float;

attribute vec2 aPosition;
uniform vec2 uQuadScale;

uniform vec2 uTexSizeInv;
uniform vec4 uViewport;

varying vec2 vUv;
varying vec4 vOffset[3];

void SMAAEdgeDetectionVS(vec2 texCoord) {
    vOffset[0] = texCoord.xyxy + uTexSizeInv.xyxy * vec4(-1.0, 0.0, 0.0, 1.0); // WebGL port note: Changed sign in W component
    vOffset[1] = texCoord.xyxy + uTexSizeInv.xyxy * vec4(1.0, 0.0, 0.0, -1.0); // WebGL port note: Changed sign in W component
    vOffset[2] = texCoord.xyxy + uTexSizeInv.xyxy * vec4(-2.0, 0.0, 0.0, 2.0); // WebGL port note: Changed sign in W component
}

void main() {
    vec2 scale = uViewport.zw * uTexSizeInv;
    vec2 shift = uViewport.xy * uTexSizeInv;
    vUv = (aPosition + 1.0) * 0.5 * scale + shift;
    SMAAEdgeDetectionVS(vUv);
    vec2 position = aPosition * uQuadScale - vec2(1.0, 1.0) + uQuadScale;
    gl_Position = vec4(position, 0.0, 1.0);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/smaa/edges.frag.js
var edges_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

uniform sampler2D tColor;
uniform vec2 uTexSizeInv;

varying vec2 vUv;
varying vec4 vOffset[3];

vec4 SMAAColorEdgeDetectionPS(vec2 texcoord, vec4 offset[3], sampler2D colorTex) {
    vec2 threshold = vec2(dEdgeThreshold, dEdgeThreshold);

    // Calculate color deltas:
    vec4 delta;
    vec3 C = texture2D(colorTex, texcoord).rgb;

    vec3 Cleft = texture2D(colorTex, offset[0].xy).rgb;
    vec3 t = abs(C - Cleft);
    delta.x = max(max(t.r, t.g), t.b);

    vec3 Ctop = texture2D(colorTex, offset[0].zw).rgb;
    t = abs(C - Ctop);
    delta.y = max(max(t.r, t.g), t.b);

    // We do the usual threshold:
    vec2 edges = step(threshold, delta.xy);

    // Then discard if there is no edge:
    if (dot(edges, vec2(1.0, 1.0 )) == 0.0)
        discard;

    // Calculate right and bottom deltas:
    vec3 Cright = texture2D(colorTex, offset[1].xy).rgb;
    t = abs( C - Cright );
    delta.z = max(max(t.r, t.g), t.b);

    vec3 Cbottom  = texture2D(colorTex, offset[1].zw).rgb;
    t = abs(C - Cbottom);
    delta.w = max(max(t.r, t.g), t.b);

    // Calculate the maximum delta in the direct neighborhood:
    float maxDelta = max(max(max(delta.x, delta.y), delta.z), delta.w );

    // Calculate left-left and top-top deltas:
    vec3 Cleftleft  = texture2D(colorTex, offset[2].xy).rgb;
    t = abs( C - Cleftleft );
    delta.z = max(max(t.r, t.g), t.b);

    vec3 Ctoptop = texture2D(colorTex, offset[2].zw).rgb;
    t = abs(C - Ctoptop);
    delta.w = max(max(t.r, t.g), t.b);

    // Calculate the final maximum delta:
    maxDelta = max(max(maxDelta, delta.z), delta.w);

    // Local contrast adaptation in action:
    edges.xy *= step(0.5 * maxDelta, delta.xy);

    return vec4(edges, 0.0, 0.0);
}

void main() {
    gl_FragColor = SMAAColorEdgeDetectionPS(vUv, vOffset, tColor);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/smaa.js
var SmaaParams = {
  edgeThreshold: ParamDefinition.Numeric(0.1, { min: 0.05, max: 0.15, step: 0.01 }),
  maxSearchSteps: ParamDefinition.Numeric(16, { min: 0, max: 32, step: 1 })
};
var SmaaPass = class {
  get supported() {
    return this._supported;
  }
  constructor(webgl, input) {
    this.webgl = webgl;
    this._supported = false;
    if (typeof HTMLImageElement === "undefined") {
      if (isDebugMode)
        console.log(`Missing "HTMLImageElement" required for "SMAA"`);
      return;
    }
    const width = input.getWidth();
    const height = input.getHeight();
    this.edgesTarget = webgl.createRenderTarget(width, height, false, "uint8", "linear");
    this.weightsTarget = webgl.createRenderTarget(width, height, false, "uint8", "linear");
    this.edgesRenderable = getEdgesRenderable(webgl, input);
    this.weightsRenderable = getWeightsRenderable(webgl, this.edgesTarget.texture);
    this.blendRenderable = getBlendRenderable(webgl, input, this.weightsTarget.texture);
    this._supported = true;
  }
  updateState(viewport) {
    const { gl, state } = this.webgl;
    state.enable(gl.SCISSOR_TEST);
    state.disable(gl.BLEND);
    state.disable(gl.DEPTH_TEST);
    state.depthMask(false);
    const { x, y, width, height } = viewport;
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    state.colorMask(true, true, true, true);
    state.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    ValueCell.update(this.edgesRenderable.values.uViewport, Viewport.toVec4(this.edgesRenderable.values.uViewport.ref.value, viewport));
    ValueCell.update(this.weightsRenderable.values.uViewport, Viewport.toVec4(this.weightsRenderable.values.uViewport.ref.value, viewport));
    ValueCell.update(this.blendRenderable.values.uViewport, Viewport.toVec4(this.blendRenderable.values.uViewport.ref.value, viewport));
  }
  setSize(width, height) {
    const w = this.edgesTarget.getWidth();
    const h = this.edgesTarget.getHeight();
    if (width !== w || height !== h) {
      this.edgesTarget.setSize(width, height);
      this.weightsTarget.setSize(width, height);
      ValueCell.update(this.edgesRenderable.values.uTexSizeInv, Vec2.set(this.edgesRenderable.values.uTexSizeInv.ref.value, 1 / width, 1 / height));
      ValueCell.update(this.weightsRenderable.values.uTexSizeInv, Vec2.set(this.weightsRenderable.values.uTexSizeInv.ref.value, 1 / width, 1 / height));
      ValueCell.update(this.blendRenderable.values.uTexSizeInv, Vec2.set(this.blendRenderable.values.uTexSizeInv.ref.value, 1 / width, 1 / height));
    }
  }
  update(input, props) {
    let edgesNeedsUpdate = false;
    if (this.edgesRenderable.values.tColor.ref.value !== input) {
      ValueCell.update(this.edgesRenderable.values.tColor, input);
      edgesNeedsUpdate = true;
    }
    if (this.edgesRenderable.values.dEdgeThreshold.ref.value !== props.edgeThreshold) {
      ValueCell.update(this.edgesRenderable.values.dEdgeThreshold, props.edgeThreshold);
      edgesNeedsUpdate = true;
    }
    if (edgesNeedsUpdate)
      this.edgesRenderable.update();
    if (this.weightsRenderable.values.dMaxSearchSteps.ref.value !== props.maxSearchSteps) {
      ValueCell.update(this.weightsRenderable.values.dMaxSearchSteps, props.maxSearchSteps);
      this.weightsRenderable.update();
    }
    if (this.blendRenderable.values.tColor.ref.value !== input) {
      ValueCell.update(this.blendRenderable.values.tColor, input);
      this.blendRenderable.update();
    }
  }
  render(viewport, target) {
    if (isTimingMode)
      this.webgl.timer.mark("SmaaPass.render");
    this.edgesTarget.bind();
    this.updateState(viewport);
    this.edgesRenderable.render();
    this.weightsTarget.bind();
    this.updateState(viewport);
    this.weightsRenderable.render();
    if (target) {
      target.bind();
    } else {
      this.webgl.unbindFramebuffer();
    }
    this.updateState(viewport);
    this.blendRenderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("SmaaPass.render");
  }
};
var EdgesSchema = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "ubyte", "linear"),
  uTexSizeInv: UniformSpec("v2"),
  uViewport: UniformSpec("v4"),
  dEdgeThreshold: DefineSpec("number")
};
var EdgesShaderCode = ShaderCode("smaa-edges", edges_vert, edges_frag);
function getEdgesRenderable(ctx, colorTexture) {
  const width = colorTexture.getWidth();
  const height = colorTexture.getHeight();
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(colorTexture),
    uTexSizeInv: ValueCell.create(Vec2.create(1 / width, 1 / height)),
    uViewport: ValueCell.create(Vec4()),
    dEdgeThreshold: ValueCell.create(0.1)
  };
  const schema = { ...EdgesSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", EdgesShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var WeightsSchema = {
  ...QuadSchema,
  tEdges: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tArea: TextureSpec("texture", "rgb", "ubyte", "linear"),
  tSearch: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSizeInv: UniformSpec("v2"),
  uViewport: UniformSpec("v4"),
  dMaxSearchSteps: DefineSpec("number")
};
var WeightsShaderCode = ShaderCode("smaa-weights", weights_vert, weights_frag);
function getWeightsRenderable(ctx, edgesTexture) {
  const width = edgesTexture.getWidth();
  const height = edgesTexture.getHeight();
  const areaTexture = ctx.resources.texture("image-uint8", "rgb", "ubyte", "linear");
  const searchTexture = ctx.resources.texture("image-uint8", "rgba", "ubyte", "nearest");
  const values2 = {
    ...QuadValues,
    tEdges: ValueCell.create(edgesTexture),
    tArea: ValueCell.create(areaTexture),
    tSearch: ValueCell.create(searchTexture),
    uTexSizeInv: ValueCell.create(Vec2.create(1 / width, 1 / height)),
    uViewport: ValueCell.create(Vec4()),
    dMaxSearchSteps: ValueCell.create(16)
  };
  loadImageTexture(getAreaTexture(), values2.tArea, areaTexture);
  loadImageTexture(getSearchTexture(), values2.tSearch, searchTexture);
  const schema = { ...WeightsSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", WeightsShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var BlendSchema = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tWeights: TextureSpec("texture", "rgba", "ubyte", "linear"),
  uTexSizeInv: UniformSpec("v2"),
  uViewport: UniformSpec("v4")
};
var BlendShaderCode = ShaderCode("smaa-blend", blend_vert, blend_frag);
function getBlendRenderable(ctx, colorTexture, weightsTexture) {
  const width = colorTexture.getWidth();
  const height = colorTexture.getHeight();
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(colorTexture),
    tWeights: ValueCell.create(weightsTexture),
    uTexSizeInv: ValueCell.create(Vec2.create(1 / width, 1 / height)),
    uViewport: ValueCell.create(Vec4())
  };
  const schema = { ...BlendSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", BlendShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
function getAreaTexture() {
  return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=";
}
function getSearchTexture() {
  return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=";
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/background.frag.js
var background_frag = `
precision mediump float;
precision mediump samplerCube;
precision mediump sampler2D;

#if defined(dVariant_skybox)
    uniform samplerCube tSkybox;
    uniform mat4 uViewDirectionProjectionInverse;
    uniform float uBlur;
    uniform float uOpacity;
    uniform float uSaturation;
    uniform float uLightness;
    uniform mat3 uRotation;
#elif defined(dVariant_image)
    uniform sampler2D tImage;
    uniform vec2 uImageScale;
    uniform vec2 uImageOffset;
    uniform float uBlur;
    uniform float uOpacity;
    uniform float uSaturation;
    uniform float uLightness;
#elif defined(dVariant_horizontalGradient) || defined(dVariant_radialGradient)
    uniform vec3 uGradientColorA;
    uniform vec3 uGradientColorB;
    uniform float uGradientRatio;
#endif

uniform vec2 uTexSize;
uniform vec4 uViewport;
uniform bool uViewportAdjusted;
varying vec4 vPosition;

// TODO: add as general pp option to remove banding?
// Iestyn's RGB dither from http://alex.vlachos.com/graphics/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf
vec3 ScreenSpaceDither(vec2 vScreenPos) {
    vec3 vDither = vec3(dot(vec2(171.0, 231.0), vScreenPos.xy));
    vDither.rgb = fract(vDither.rgb / vec3(103.0, 71.0, 97.0));
    return vDither.rgb / 255.0;
}

vec3 saturateColor(vec3 c, float amount) {
    // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance
    const vec3 W = vec3(0.2125, 0.7154, 0.0721);
    vec3 intensity = vec3(dot(c, W));
    return mix(intensity, c, 1.0 + amount);
}

vec3 lightenColor(vec3 c, float amount) {
    return c + amount;
}

void main() {
    #if defined(dVariant_skybox)
        vec4 t = uViewDirectionProjectionInverse * vPosition;
        #ifdef enabledShaderTextureLod
            gl_FragColor = textureCubeLodEXT(tSkybox, uRotation * normalize(t.xyz / t.w), uBlur * 8.0);
        #else
            gl_FragColor = textureCube(tSkybox, uRotation * normalize(t.xyz / t.w));
        #endif
        gl_FragColor.a = uOpacity;
        gl_FragColor.rgb = lightenColor(saturateColor(gl_FragColor.rgb, uSaturation), uLightness);
    #elif defined(dVariant_image)
        vec2 coords;
        if (uViewportAdjusted) {
            coords = ((gl_FragCoord.xy - uViewport.xy) * (uTexSize / uViewport.zw) / uImageScale) + uImageOffset;
        } else {
            coords = (gl_FragCoord.xy / uImageScale) + uImageOffset;
        }
        #ifdef enabledShaderTextureLod
            gl_FragColor = texture2DLodEXT(tImage, vec2(coords.x, 1.0 - coords.y), uBlur * 8.0);
        #else
            gl_FragColor = texture2D(tImage, vec2(coords.x, 1.0 - coords.y));
        #endif
        gl_FragColor.a = uOpacity;
        gl_FragColor.rgb = lightenColor(saturateColor(gl_FragColor.rgb, uSaturation), uLightness);
    #elif defined(dVariant_horizontalGradient)
        float d;
        if (uViewportAdjusted) {
            d = ((gl_FragCoord.y - uViewport.y) * (uTexSize.y / uViewport.w) / uTexSize.y) + 1.0 - (uGradientRatio * 2.0);
        } else {
            d = (gl_FragCoord.y / uTexSize.y) + 1.0 - (uGradientRatio * 2.0);
        }
        gl_FragColor = vec4(mix(uGradientColorB, uGradientColorA, clamp(d, 0.0, 1.0)), 1.0);
        gl_FragColor.rgb += ScreenSpaceDither(gl_FragCoord.xy);
    #elif defined(dVariant_radialGradient)
        float d;
        if (uViewportAdjusted) {
            d = distance(vec2(0.5), (gl_FragCoord.xy - uViewport.xy) * (uTexSize / uViewport.zw) / uTexSize) + uGradientRatio - 0.5;
        } else {
            d = distance(vec2(0.5), gl_FragCoord.xy / uTexSize) + uGradientRatio - 0.5;
        }
        gl_FragColor = vec4(mix(uGradientColorB, uGradientColorA, 1.0 - clamp(d, 0.0, 1.0)), 1.0);
        gl_FragColor.rgb += ScreenSpaceDither(gl_FragCoord.xy);
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/background.vert.js
var background_vert = `
precision mediump float;

attribute vec2 aPosition;

varying vec4 vPosition;

void main() {
    vPosition = vec4(aPosition, 1.0, 1.0);
    gl_Position = vec4(aPosition, 1.0, 1.0);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/linear-algebra/3d/euler.js
function Euler() {
  return Euler.zero();
}
(function(Euler2) {
  function zero() {
    const ret = [0.1, 0, 0];
    ret[0] = 0;
    return ret;
  }
  Euler2.zero = zero;
  function create(x, y, z) {
    const out = zero();
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  Euler2.create = create;
  function set4(out, x, y, z) {
    out[0] = x;
    out[0] = y;
    out[0] = z;
    return out;
  }
  Euler2.set = set4;
  function clone(a5) {
    const out = zero();
    out[0] = a5[0];
    out[1] = a5[1];
    out[2] = a5[2];
    return out;
  }
  Euler2.clone = clone;
  function copy(out, a5) {
    out[0] = a5[0];
    out[1] = a5[1];
    out[2] = a5[2];
    return out;
  }
  Euler2.copy = copy;
  function fromMat4(out, m, order) {
    const m11 = m[0], m12 = m[4], m13 = m[8];
    const m21 = m[1], m22 = m[5], m23 = m[9];
    const m31 = m[2], m32 = m[6], m33 = m[10];
    switch (order) {
      case "XYZ":
        out[1] = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          out[0] = Math.atan2(-m23, m33);
          out[2] = Math.atan2(-m12, m11);
        } else {
          out[0] = Math.atan2(m32, m22);
          out[2] = 0;
        }
        break;
      case "YXZ":
        out[0] = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          out[1] = Math.atan2(m13, m33);
          out[2] = Math.atan2(m21, m22);
        } else {
          out[1] = Math.atan2(-m31, m11);
          out[2] = 0;
        }
        break;
      case "ZXY":
        out[0] = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          out[1] = Math.atan2(-m31, m33);
          out[2] = Math.atan2(-m12, m22);
        } else {
          out[1] = 0;
          out[2] = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        out[1] = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          out[0] = Math.atan2(m32, m33);
          out[2] = Math.atan2(m21, m11);
        } else {
          out[0] = 0;
          out[2] = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        out[2] = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          out[0] = Math.atan2(-m23, m22);
          out[1] = Math.atan2(-m31, m11);
        } else {
          out[0] = 0;
          out[1] = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        out[2] = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          out[0] = Math.atan2(m32, m22);
          out[1] = Math.atan2(m13, m11);
        } else {
          out[0] = Math.atan2(-m23, m33);
          out[1] = 0;
        }
        break;
      default:
        assertUnreachable(order);
    }
    return out;
  }
  Euler2.fromMat4 = fromMat4;
  const _mat42 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  function fromQuat(out, q, order) {
    Mat4.fromQuat(_mat42, q);
    return fromMat4(out, _mat42, order);
  }
  Euler2.fromQuat = fromQuat;
  function fromVec3(out, v3) {
    return set4(out, v3[0], v3[1], v3[2]);
  }
  Euler2.fromVec3 = fromVec3;
  function exactEquals(a5, b5) {
    return a5[0] === b5[0] && a5[1] === b5[1] && a5[2] === b5[2];
  }
  Euler2.exactEquals = exactEquals;
  function fromArray(e, array, offset) {
    e[0] = array[offset + 0];
    e[1] = array[offset + 1];
    e[2] = array[offset + 2];
    return e;
  }
  Euler2.fromArray = fromArray;
  function toArray3(e, out, offset) {
    out[offset + 0] = e[0];
    out[offset + 1] = e[1];
    out[offset + 2] = e[2];
    return out;
  }
  Euler2.toArray = toArray3;
})(Euler || (Euler = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/background.js
var SharedParams5 = {
  opacity: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.01 }),
  saturation: ParamDefinition.Numeric(0, { min: -1, max: 1, step: 0.01 }),
  lightness: ParamDefinition.Numeric(0, { min: -1, max: 1, step: 0.01 })
};
var SkyboxParams = {
  faces: ParamDefinition.MappedStatic("urls", {
    urls: ParamDefinition.Group({
      nx: ParamDefinition.Text("", { label: "Negative X / Left" }),
      ny: ParamDefinition.Text("", { label: "Negative Y / Bottom" }),
      nz: ParamDefinition.Text("", { label: "Negative Z / Back" }),
      px: ParamDefinition.Text("", { label: "Positive X / Right" }),
      py: ParamDefinition.Text("", { label: "Positive Y / Top" }),
      pz: ParamDefinition.Text("", { label: "Positive Z / Front" })
    }, { isExpanded: true, label: "URLs" }),
    files: ParamDefinition.Group({
      nx: ParamDefinition.File({ label: "Negative X / Left", accept: "image/*" }),
      ny: ParamDefinition.File({ label: "Negative Y / Bottom", accept: "image/*" }),
      nz: ParamDefinition.File({ label: "Negative Z / Back", accept: "image/*" }),
      px: ParamDefinition.File({ label: "Positive X / Right", accept: "image/*" }),
      py: ParamDefinition.File({ label: "Positive Y / Top", accept: "image/*" }),
      pz: ParamDefinition.File({ label: "Positive Z / Front", accept: "image/*" })
    }, { isExpanded: true, label: "Files" })
  }),
  blur: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.01 }, { description: 'Note, this only works in WebGL2 or when "EXT_shader_texture_lod" is available.' }),
  rotation: ParamDefinition.Group({
    x: ParamDefinition.Numeric(0, { min: 0, max: 360, step: 1 }, { immediateUpdate: true }),
    y: ParamDefinition.Numeric(0, { min: 0, max: 360, step: 1 }, { immediateUpdate: true }),
    z: ParamDefinition.Numeric(0, { min: 0, max: 360, step: 1 }, { immediateUpdate: true })
  }),
  ...SharedParams5
};
var ImageParams = {
  source: ParamDefinition.MappedStatic("url", {
    url: ParamDefinition.Text(""),
    file: ParamDefinition.File({ accept: "image/*" })
  }),
  blur: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.01 }, { description: 'Note, this only works in WebGL2 or with power-of-two images and when "EXT_shader_texture_lod" is available.' }),
  ...SharedParams5,
  coverage: ParamDefinition.Select("viewport", ParamDefinition.arrayToOptions(["viewport", "canvas"]))
};
var HorizontalGradientParams = {
  topColor: ParamDefinition.Color(Color(14540253)),
  bottomColor: ParamDefinition.Color(Color(15658734)),
  ratio: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }),
  coverage: ParamDefinition.Select("viewport", ParamDefinition.arrayToOptions(["viewport", "canvas"]))
};
var RadialGradientParams = {
  centerColor: ParamDefinition.Color(Color(14540253)),
  edgeColor: ParamDefinition.Color(Color(15658734)),
  ratio: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }),
  coverage: ParamDefinition.Select("viewport", ParamDefinition.arrayToOptions(["viewport", "canvas"]))
};
var BackgroundParams = {
  variant: ParamDefinition.MappedStatic("off", {
    off: ParamDefinition.EmptyGroup(),
    skybox: ParamDefinition.Group(SkyboxParams, { isExpanded: true }),
    image: ParamDefinition.Group(ImageParams, { isExpanded: true }),
    horizontalGradient: ParamDefinition.Group(HorizontalGradientParams, { isExpanded: true }),
    radialGradient: ParamDefinition.Group(RadialGradientParams, { isExpanded: true })
  }, { label: "Environment" })
};
var BackgroundPass = class {
  constructor(webgl, assetManager, width, height) {
    this.webgl = webgl;
    this.assetManager = assetManager;
    this.camera = new Camera();
    this.target = Vec3();
    this.position = Vec3();
    this.dir = Vec3();
    this.bgColor = Vec3();
    this.renderable = getBackgroundRenderable(webgl, width, height);
  }
  setSize(width, height) {
    const [w, h] = this.renderable.values.uTexSize.ref.value;
    if (width !== w || height !== h) {
      ValueCell.update(this.renderable.values.uTexSize, Vec2.set(this.renderable.values.uTexSize.ref.value, width, height));
    }
  }
  clearSkybox() {
    if (this.skybox !== void 0) {
      this.skybox.texture.destroy();
      this.skybox.assets.forEach((a5) => this.assetManager.release(a5));
      this.skybox = void 0;
    }
  }
  updateSkybox(camera, props, onload) {
    var _a;
    const tf = (_a = this.skybox) === null || _a === void 0 ? void 0 : _a.props.faces;
    const f = props.faces.params;
    if (!f.nx || !f.ny || !f.nz || !f.px || !f.py || !f.pz) {
      this.clearSkybox();
      onload === null || onload === void 0 ? void 0 : onload(false);
      return;
    }
    if (!this.skybox || !tf || !areSkyboxTexturePropsEqual(props.faces, this.skybox.props.faces)) {
      this.clearSkybox();
      const { texture, assets } = getSkyboxTexture(this.webgl, this.assetManager, props.faces, (errored) => {
        if (this.skybox)
          this.skybox.loaded = !errored;
        onload === null || onload === void 0 ? void 0 : onload(true);
      });
      this.skybox = { texture, props: { ...props }, assets, loaded: false };
      ValueCell.update(this.renderable.values.tSkybox, texture);
      this.renderable.update();
    } else {
      onload === null || onload === void 0 ? void 0 : onload(false);
    }
    if (!this.skybox)
      return;
    let cam = camera;
    if (camera.state.mode === "orthographic") {
      this.camera.setState({ ...camera.state, mode: "perspective" });
      this.camera.update();
      cam = this.camera;
    }
    const m = this.renderable.values.uViewDirectionProjectionInverse.ref.value;
    Vec3.sub(this.dir, cam.state.position, cam.state.target);
    Vec3.setMagnitude(this.dir, this.dir, 0.1);
    Vec3.copy(this.position, this.dir);
    Mat4.lookAt(m, this.position, this.target, cam.state.up);
    Mat4.mul(m, cam.projection, m);
    Mat4.invert(m, m);
    ValueCell.update(this.renderable.values.uViewDirectionProjectionInverse, m);
    const r = this.renderable.values.uRotation.ref.value;
    Mat3.fromEuler(r, Euler.create(degToRad(props.rotation.x), degToRad(props.rotation.y), degToRad(props.rotation.z)), "XYZ");
    ValueCell.update(this.renderable.values.uRotation, r);
    ValueCell.updateIfChanged(this.renderable.values.uBlur, props.blur);
    ValueCell.updateIfChanged(this.renderable.values.uOpacity, props.opacity);
    ValueCell.updateIfChanged(this.renderable.values.uSaturation, props.saturation);
    ValueCell.updateIfChanged(this.renderable.values.uLightness, props.lightness);
    ValueCell.updateIfChanged(this.renderable.values.dVariant, "skybox");
    this.renderable.update();
  }
  clearImage() {
    if (this.image !== void 0) {
      this.image.texture.destroy();
      this.assetManager.release(this.image.asset);
      this.image = void 0;
    }
  }
  updateImage(props, onload) {
    if (!props.source.params) {
      this.clearImage();
      onload === null || onload === void 0 ? void 0 : onload(false);
      return;
    }
    if (!this.image || !this.image.props.source.params || !areImageTexturePropsEqual(props.source, this.image.props.source)) {
      this.clearImage();
      const { texture, asset } = getImageTexture(this.webgl, this.assetManager, props.source, (errored) => {
        if (this.image)
          this.image.loaded = !errored;
        onload === null || onload === void 0 ? void 0 : onload(true);
      });
      this.image = { texture, props: { ...props }, asset, loaded: false };
      ValueCell.update(this.renderable.values.tImage, texture);
      this.renderable.update();
    } else {
      onload === null || onload === void 0 ? void 0 : onload(false);
    }
    if (!this.image)
      return;
    ValueCell.updateIfChanged(this.renderable.values.uBlur, props.blur);
    ValueCell.updateIfChanged(this.renderable.values.uOpacity, props.opacity);
    ValueCell.updateIfChanged(this.renderable.values.uSaturation, props.saturation);
    ValueCell.updateIfChanged(this.renderable.values.uLightness, props.lightness);
    ValueCell.updateIfChanged(this.renderable.values.uViewportAdjusted, props.coverage === "viewport" ? true : false);
    ValueCell.updateIfChanged(this.renderable.values.dVariant, "image");
    this.renderable.update();
  }
  updateImageScaling() {
    var _a, _b;
    const v3 = this.renderable.values;
    const [w, h] = v3.uTexSize.ref.value;
    const iw = ((_a = this.image) === null || _a === void 0 ? void 0 : _a.texture.getWidth()) || 0;
    const ih = ((_b = this.image) === null || _b === void 0 ? void 0 : _b.texture.getHeight()) || 0;
    const r = w / h;
    const ir = iw / ih;
    if (r < ir) {
      ValueCell.update(v3.uImageScale, Vec2.set(v3.uImageScale.ref.value, iw * h / ih, h));
    } else {
      ValueCell.update(v3.uImageScale, Vec2.set(v3.uImageScale.ref.value, w, ih * w / iw));
    }
    const [rw, rh] = v3.uImageScale.ref.value;
    const sr = rw / rh;
    if (sr > r) {
      ValueCell.update(v3.uImageOffset, Vec2.set(v3.uImageOffset.ref.value, (1 - r / sr) / 2, 0));
    } else {
      ValueCell.update(v3.uImageOffset, Vec2.set(v3.uImageOffset.ref.value, 0, (1 - sr / r) / 2));
    }
  }
  updateGradient(colorA, colorB, ratio, variant, viewportAdjusted) {
    ValueCell.update(this.renderable.values.uGradientColorA, Color.toVec3Normalized(this.renderable.values.uGradientColorA.ref.value, colorA));
    ValueCell.update(this.renderable.values.uGradientColorB, Color.toVec3Normalized(this.renderable.values.uGradientColorB.ref.value, colorB));
    ValueCell.updateIfChanged(this.renderable.values.uGradientRatio, ratio);
    ValueCell.updateIfChanged(this.renderable.values.uViewportAdjusted, viewportAdjusted);
    ValueCell.updateIfChanged(this.renderable.values.dVariant, variant);
    this.renderable.update();
  }
  update(camera, props, onload) {
    if (props.variant.name === "off") {
      this.clearSkybox();
      this.clearImage();
      onload === null || onload === void 0 ? void 0 : onload(false);
      return;
    } else if (props.variant.name === "skybox") {
      this.clearImage();
      this.updateSkybox(camera, props.variant.params, onload);
    } else if (props.variant.name === "image") {
      this.clearSkybox();
      this.updateImage(props.variant.params, onload);
    } else if (props.variant.name === "horizontalGradient") {
      this.clearSkybox();
      this.clearImage();
      this.updateGradient(props.variant.params.topColor, props.variant.params.bottomColor, props.variant.params.ratio, props.variant.name, props.variant.params.coverage === "viewport" ? true : false);
      onload === null || onload === void 0 ? void 0 : onload(false);
    } else if (props.variant.name === "radialGradient") {
      this.clearSkybox();
      this.clearImage();
      this.updateGradient(props.variant.params.centerColor, props.variant.params.edgeColor, props.variant.params.ratio, props.variant.name, props.variant.params.coverage === "viewport" ? true : false);
      onload === null || onload === void 0 ? void 0 : onload(false);
    }
    const { x, y, width, height } = camera.viewport;
    ValueCell.update(this.renderable.values.uViewport, Vec4.set(this.renderable.values.uViewport.ref.value, x, y, width, height));
  }
  isEnabled(props) {
    return !!(this.skybox && this.skybox.loaded || this.image && this.image.loaded || props.variant.name === "horizontalGradient" || props.variant.name === "radialGradient");
  }
  isReady() {
    return !!(this.skybox && this.skybox.loaded || this.image && this.image.loaded || this.renderable.values.dVariant.ref.value === "horizontalGradient" || this.renderable.values.dVariant.ref.value === "radialGradient");
  }
  clear(props, transparentBackground, backgroundColor) {
    const { gl, state } = this.webgl;
    if (this.isEnabled(props)) {
      if (transparentBackground) {
        state.clearColor(0, 0, 0, 0);
      } else {
        Color.toVec3Normalized(this.bgColor, backgroundColor);
        state.clearColor(this.bgColor[0], this.bgColor[1], this.bgColor[2], 1);
      }
      gl.clear(gl.COLOR_BUFFER_BIT);
      state.enable(gl.BLEND);
      state.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    } else {
      state.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
    }
  }
  render(props) {
    if (!this.isEnabled(props) || !this.isReady())
      return;
    if (this.renderable.values.dVariant.ref.value === "image") {
      this.updateImageScaling();
    }
    if (isTimingMode)
      this.webgl.timer.mark("BackgroundPass.render");
    this.renderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("BackgroundPass.render");
  }
  dispose() {
    this.clearSkybox();
    this.clearImage();
  }
};
var SkyboxName = "background-skybox";
function getCubeAssets(assetManager, faces) {
  if (faces.name === "urls") {
    return {
      nx: Asset.getUrlAsset(assetManager, faces.params.nx),
      ny: Asset.getUrlAsset(assetManager, faces.params.ny),
      nz: Asset.getUrlAsset(assetManager, faces.params.nz),
      px: Asset.getUrlAsset(assetManager, faces.params.px),
      py: Asset.getUrlAsset(assetManager, faces.params.py),
      pz: Asset.getUrlAsset(assetManager, faces.params.pz)
    };
  } else {
    return {
      nx: faces.params.nx,
      ny: faces.params.ny,
      nz: faces.params.nz,
      px: faces.params.px,
      py: faces.params.py,
      pz: faces.params.pz
    };
  }
}
function getCubeFaces(assetManager, cubeAssets) {
  const resolve = (asset) => {
    return assetManager.resolve(asset, "binary").run().then((a5) => new Blob([a5.data]));
  };
  return {
    nx: resolve(cubeAssets.nx),
    ny: resolve(cubeAssets.ny),
    nz: resolve(cubeAssets.nz),
    px: resolve(cubeAssets.px),
    py: resolve(cubeAssets.py),
    pz: resolve(cubeAssets.pz)
  };
}
function getSkyboxHash(faces) {
  var _a, _b, _c, _d, _e, _f;
  if (faces.name === "urls") {
    return `${SkyboxName}_${faces.params.nx}|${faces.params.ny}|${faces.params.nz}|${faces.params.px}|${faces.params.py}|${faces.params.pz}`;
  } else {
    return `${SkyboxName}_${(_a = faces.params.nx) === null || _a === void 0 ? void 0 : _a.id}|${(_b = faces.params.ny) === null || _b === void 0 ? void 0 : _b.id}|${(_c = faces.params.nz) === null || _c === void 0 ? void 0 : _c.id}|${(_d = faces.params.px) === null || _d === void 0 ? void 0 : _d.id}|${(_e = faces.params.py) === null || _e === void 0 ? void 0 : _e.id}|${(_f = faces.params.pz) === null || _f === void 0 ? void 0 : _f.id}`;
  }
}
function areSkyboxTexturePropsEqual(facesA, facesB) {
  return getSkyboxHash(facesA) === getSkyboxHash(facesB);
}
function getSkyboxTexture(ctx, assetManager, faces, onload) {
  const cubeAssets = getCubeAssets(assetManager, faces);
  const cubeFaces = getCubeFaces(assetManager, cubeAssets);
  const assets = [cubeAssets.nx, cubeAssets.ny, cubeAssets.nz, cubeAssets.px, cubeAssets.py, cubeAssets.pz];
  if (typeof HTMLImageElement === "undefined") {
    console.error(`Missing "HTMLImageElement" required for background skybox`);
    onload === null || onload === void 0 ? void 0 : onload(true);
    return { texture: createNullTexture(), assets };
  }
  const texture = ctx.resources.cubeTexture(cubeFaces, true, onload);
  return { texture, assets };
}
var ImageName = "background-image";
function getImageHash(source) {
  var _a;
  if (source.name === "url") {
    return `${ImageName}_${source.params}`;
  } else {
    return `${ImageName}_${(_a = source.params) === null || _a === void 0 ? void 0 : _a.id}`;
  }
}
function areImageTexturePropsEqual(sourceA, sourceB) {
  return getImageHash(sourceA) === getImageHash(sourceB);
}
function getImageTexture(ctx, assetManager, source, onload) {
  const asset = source.name === "url" ? Asset.getUrlAsset(assetManager, source.params) : source.params;
  if (typeof HTMLImageElement === "undefined") {
    console.error(`Missing "HTMLImageElement" required for background image`);
    onload === null || onload === void 0 ? void 0 : onload(true);
    return { texture: createNullTexture(), asset };
  }
  const texture = ctx.resources.texture("image-uint8", "rgba", "ubyte", "linear");
  const img = new Image();
  img.onload = () => {
    texture.load(img);
    if (ctx.isWebGL2 || isPowerOfTwo(img.width) && isPowerOfTwo(img.height)) {
      texture.mipmap();
    }
    onload === null || onload === void 0 ? void 0 : onload();
  };
  img.onerror = () => {
    onload === null || onload === void 0 ? void 0 : onload(true);
  };
  assetManager.resolve(asset, "binary").run().then((a5) => {
    const blob = new Blob([a5.data]);
    img.src = URL.createObjectURL(blob);
  });
  return { texture, asset };
}
var BackgroundSchema = {
  drawCount: ValueSpec("number"),
  instanceCount: ValueSpec("number"),
  aPosition: AttributeSpec("float32", 2, 0),
  tSkybox: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tImage: TextureSpec("texture", "rgba", "ubyte", "linear"),
  uImageScale: UniformSpec("v2"),
  uImageOffset: UniformSpec("v2"),
  uTexSize: UniformSpec("v2"),
  uViewport: UniformSpec("v4"),
  uViewportAdjusted: UniformSpec("b"),
  uViewDirectionProjectionInverse: UniformSpec("m4"),
  uGradientColorA: UniformSpec("v3"),
  uGradientColorB: UniformSpec("v3"),
  uGradientRatio: UniformSpec("f"),
  uBlur: UniformSpec("f"),
  uOpacity: UniformSpec("f"),
  uSaturation: UniformSpec("f"),
  uLightness: UniformSpec("f"),
  uRotation: UniformSpec("m3"),
  dVariant: DefineSpec("string", ["skybox", "image", "verticalGradient", "horizontalGradient", "radialGradient"])
};
var SkyboxShaderCode = ShaderCode("background", background_vert, background_frag, {
  shaderTextureLod: "optional"
});
function getBackgroundRenderable(ctx, width, height) {
  const values2 = {
    drawCount: ValueCell.create(6),
    instanceCount: ValueCell.create(1),
    aPosition: ValueCell.create(QuadPositions),
    tSkybox: ValueCell.create(createNullTexture()),
    tImage: ValueCell.create(createNullTexture()),
    uImageScale: ValueCell.create(Vec2()),
    uImageOffset: ValueCell.create(Vec2()),
    uTexSize: ValueCell.create(Vec2.create(width, height)),
    uViewport: ValueCell.create(Vec4()),
    uViewportAdjusted: ValueCell.create(true),
    uViewDirectionProjectionInverse: ValueCell.create(Mat4()),
    uGradientColorA: ValueCell.create(Vec3()),
    uGradientColorB: ValueCell.create(Vec3()),
    uGradientRatio: ValueCell.create(0.5),
    uBlur: ValueCell.create(0),
    uOpacity: ValueCell.create(1),
    uSaturation: ValueCell.create(0),
    uLightness: ValueCell.create(0),
    uRotation: ValueCell.create(Mat3.identity()),
    dVariant: ValueCell.create("skybox")
  };
  const schema = { ...BackgroundSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", SkyboxShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/cas.frag.js
var cas_frag = `
precision mediump float;
precision mediump sampler2D;

uniform sampler2D tColor;
uniform vec2 uTexSizeInv;

uniform float uSharpness;

// adapted from https://www.shadertoy.com/view/stXSWB

/*
* FidelityFX Super Resolution scales up a low resolution
* image, while adding fine detail.
*
* MIT Open License
*
* https://gpuopen.com/fsr
*
* Left: FSR processed
* Right: Original texture, bilinear interpolation
*
* Mouse at top: Sharpness 0 stops (maximum)
* Mouse at bottom: Sharpness 2 stops (minimum)
*
* It works in two passes-
*   EASU upsamples the image with a clamped Lanczos kernel.
*   RCAS sharpens the image at the target resolution.
*
* I needed to make a few changes to improve readability and
* WebGL compatibility in an algorithm I don't fully understand.
* Expect bugs.
*
* Shader not currently running for WebGL1 targets (eg. mobile Safari)
*
* There is kind of no point to using FSR in Shadertoy, as it renders buffers
* at full target resolution. But this might be useful for WebGL based demos
* running smaller-than-target render buffers.
*
* For sharpening with a full resolution render buffer,
* FidelityFX CAS is a better option.
* https://www.shadertoy.com/view/ftsXzM
*
* For readability and compatibility, these optimisations have been removed:
*   * Fast approximate inverse and inversesqrt
*   * textureGather fetches (not WebGL compatible)
*   * Multiplying by reciprocal instead of division
*
* Apologies to AMD for the numerous slowdowns and errors I have introduced.
*
*/

/***** RCAS *****/
#define FSR_RCAS_LIMIT (0.25-(1.0/16.0))

// Input callback prototypes that need to be implemented by calling shader
vec4 FsrRcasLoadF(vec2 p);
//------------------------------------------------------------------------------------------------------------------------------
void FsrRcasCon(
    out float con,
    // The scale is {0.0 := maximum, to N>0, where N is the number of stops (halving) of the reduction of sharpness}.
    float sharpness
) {
    // Transform from stops to linear value.
    con = exp2(-sharpness);
}

vec3 FsrRcasF(
    vec2 ip, // Integer pixel position in output.
    float con
) {
    // Constant generated by RcasSetup().
    // Algorithm uses minimal 3x3 pixel neighborhood.
    //    b
    //  d e f
    //    h
    vec2 sp = vec2(ip);
    vec3 b = FsrRcasLoadF(sp + vec2( 0,-1)).rgb;
    vec3 d = FsrRcasLoadF(sp + vec2(-1, 0)).rgb;
    vec3 e = FsrRcasLoadF(sp).rgb;
    vec3 f = FsrRcasLoadF(sp + vec2( 1, 0)).rgb;
    vec3 h = FsrRcasLoadF(sp + vec2( 0, 1)).rgb;

    // Luma times 2.
    float bL = b.g + .5 * (b.b + b.r);
    float dL = d.g + .5 * (d.b + d.r);
    float eL = e.g + .5 * (e.b + e.r);
    float fL = f.g + .5 * (f.b + f.r);
    float hL = h.g + .5 * (h.b + h.r);

    // Noise detection.
    #ifdef dDenoise
        float nz = .25 * (bL + dL + fL + hL) - eL;
        nz=clamp(
            abs(nz)
            /(
                max(max(bL,dL),max(eL,max(fL,hL)))
                -min(min(bL,dL),min(eL,min(fL,hL)))
            ),
            0., 1.
        );
        nz=1.-.5*nz;
    #endif

    // Min and max of ring.
    vec3 mn4 = min(b, min(f, h));
    vec3 mx4 = max(b, max(f, h));

    // Immediate constants for peak range.
    vec2 peakC = vec2(1., -4.);

    // Limiters, these need to be high precision RCPs.
    vec3 hitMin = mn4 / (4. * mx4);
    vec3 hitMax = (peakC.x - mx4) / (4.* mn4 + peakC.y);
    vec3 lobeRGB = max(-hitMin, hitMax);
    float lobe = max(
        -FSR_RCAS_LIMIT,
        min(max(lobeRGB.r, max(lobeRGB.g, lobeRGB.b)), 0.)
    )*con;

    // Apply noise removal.
    #ifdef dDenoise
        lobe *= nz;
    #endif

    // Resolve, which needs the medium precision rcp approximation to avoid visible tonality changes.
    return (lobe * (b + d + h + f) + e) / (4. * lobe + 1.);
}


vec4 FsrRcasLoadF(vec2 p) {
    return texture2D(tColor, p * uTexSizeInv);
}

void main() {
    // Set up constants
    float con;
    FsrRcasCon(con, uSharpness);

    // Perform RCAS pass
    vec3 col = FsrRcasF(gl_FragCoord.xy, con);

    gl_FragColor = vec4(col, FsrRcasLoadF(gl_FragCoord.xy).a);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/cas.js
var CasParams = {
  sharpness: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.05 }),
  denoise: ParamDefinition.Boolean(true)
};
var CasPass = class {
  constructor(webgl, input) {
    this.webgl = webgl;
    this.renderable = getCasRenderable(webgl, input);
  }
  updateState(viewport) {
    const { gl, state } = this.webgl;
    state.enable(gl.SCISSOR_TEST);
    state.disable(gl.BLEND);
    state.disable(gl.DEPTH_TEST);
    state.depthMask(false);
    const { x, y, width, height } = viewport;
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    state.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  setSize(width, height) {
    ValueCell.update(this.renderable.values.uTexSizeInv, Vec2.set(this.renderable.values.uTexSizeInv.ref.value, 1 / width, 1 / height));
  }
  update(input, props) {
    const { values: values2 } = this.renderable;
    const { sharpness, denoise } = props;
    let needsUpdate = false;
    if (values2.tColor.ref.value !== input) {
      ValueCell.update(this.renderable.values.tColor, input);
      needsUpdate = true;
    }
    ValueCell.updateIfChanged(values2.uSharpness, 2 - 2 * Math.pow(sharpness, 0.25));
    if (values2.dDenoise.ref.value !== denoise)
      needsUpdate = true;
    ValueCell.updateIfChanged(values2.dDenoise, denoise);
    if (needsUpdate) {
      this.renderable.update();
    }
  }
  render(viewport, target) {
    if (isTimingMode)
      this.webgl.timer.mark("CasPass.render");
    if (target) {
      target.bind();
    } else {
      this.webgl.unbindFramebuffer();
    }
    this.updateState(viewport);
    this.renderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("CasPass.render");
  }
};
var CasSchema = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "ubyte", "linear"),
  uTexSizeInv: UniformSpec("v2"),
  uSharpness: UniformSpec("f"),
  dDenoise: DefineSpec("boolean")
};
var CasShaderCode = ShaderCode("cas", quad_vert, cas_frag);
function getCasRenderable(ctx, colorTexture) {
  const width = colorTexture.getWidth();
  const height = colorTexture.getHeight();
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(colorTexture),
    uTexSizeInv: ValueCell.create(Vec2.create(1 / width, 1 / height)),
    uSharpness: ValueCell.create(0.5),
    dDenoise: ValueCell.create(true)
  };
  const schema = { ...CasSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", CasShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/dof.frag.js
var dof_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

#include common

uniform sampler2D tColor;
uniform sampler2D tDepthOpaque;
uniform sampler2D tDepthTransparent;

uniform vec2 uTexSize;
uniform vec4 uBounds;

uniform float uBlurSpread;
uniform float uInFocus;
uniform float uPPM;

uniform float uNear; // Near plane
uniform float uFar;  // Far plane

uniform mat4 uInvProjection; // Inverse projection
uniform mat4 uProjection; // projection

uniform int uMode; // 0-planar, 1-spherical
uniform vec3 uCenter; // Center of focus sphere in view space

// Function to convert depth value from depth buffer to view space Z
float getViewZ(const in float depth) {
    #if dOrthographic == 1
        return orthographicDepthToViewZ(depth, uNear, uFar);
    #else
        return perspectiveDepthToViewZ(depth, uNear, uFar);
    #endif
}

// Retrieve depth from opaque depth texture
float getDepthOpaque(const in vec2 coords) {
    #ifdef depthTextureSupport
        return texture2D(tDepthOpaque, coords).r;
    #else
        return unpackRGBAToDepth(texture2D(tDepthOpaque, coords));
    #endif
}

// Retrieve depth from transparent depth texture
float getDepthTransparent(const in vec2 coords) {
    return unpackRGBAToDepthWithAlpha(texture2D(tDepthTransparent, coords)).x;
}

bool isBackground(const in float depth) {
    return depth == 1.0;
}

float getDepth(const in vec2 coords) {
    return min(getDepthOpaque(coords), getDepthTransparent(coords));
}

float getCOC(vec2 uv) {
    float depth = getDepth(uv);
    float viewDist = getViewZ(depth);
    vec3 aposition = screenSpaceToViewSpace(vec3(uv.xy, depth), uInvProjection);
    float focusDist = length(aposition - uCenter);
    float coc = 0.0;  // Circle of Confusion
    if (uMode == 0) { // planar Depth of field
        coc = (abs(viewDist) - uInFocus) / uPPM;  //focus distance, focus range
    } else if(uMode == 1) { // spherical Depth of field
        coc = focusDist / uPPM ;
    }
    coc = clamp(coc, -1.0, 1.0);
    return coc;
}

// Simple box blur for blurring the image
vec3 getBlurredImage(vec2 coords) {
    vec4 blurColor = vec4(0);
    vec2 texelSize = vec2(1.0 / uTexSize.x, 1.0 / uTexSize.y);
    float count = 0.0;
    for (int x = 0; x < int(dBlurSize); x++) {
        for (int y = 0; y < int(dBlurSize); y++) {
            vec2 offset = vec2(float(x) - float(dBlurSize) / 2.0, float(y) - float(dBlurSize) / 2.0);
            vec2 uvPixel = coords.xy + offset * texelSize * uBlurSpread;
            float coc = getCOC(uvPixel);
            coc = smoothstep(0.0, 1.0, abs(coc));
            // mix blurColor with new color with weight coc
            blurColor.rgb = blurColor.rgb + texture2D(tColor, uvPixel).xyz * coc;
            count+=coc;
        }
    }
    blurColor = blurColor / count;
    return blurColor.rgb;
}

// simplification from https://catlikecoding.com/unity/tutorials/advanced-rendering/depth-of-field/
void main() {
    vec2 uv = gl_FragCoord.xy / uTexSize;
    vec4 color = texture2D(tColor, uv);
    float depth = getDepth(uv);

    float viewDist = getViewZ(depth);

    vec3 aposition = screenSpaceToViewSpace(vec3(uv.xy, depth), uInvProjection);
    float focusDist = length(aposition - uCenter);
    vec3 blurColor = getBlurredImage(uv);

    float coc = getCOC(uv); // Circle of Confusion

    // for debugging the coc
    // color.rgb = (coc < 0.0) ? (1.0 - abs(coc)) * vec3(1.0,0.0,0.0) : vec3(0.0, 1.0 - coc, 0.0) ;//mix(color.rgb, blurColor.rgb, abs(coc));
    color.rgb = mix(color.rgb, blurColor, smoothstep(0.0, 1.0, abs(coc))); // Smooth blending based on CoC
    gl_FragColor = color;
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/dof.js
var DofParams = {
  blurSize: ParamDefinition.Numeric(9, { min: 1, max: 32, step: 1 }),
  blurSpread: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 }),
  inFocus: ParamDefinition.Numeric(0, { min: -5e3, max: 5e3, step: 1 }, { description: "Distance from the scene center that will be in focus" }),
  PPM: ParamDefinition.Numeric(20, { min: 0, max: 5e3, step: 0.1 }, { description: "Size of the area that will be in focus" }),
  center: ParamDefinition.Select("camera-target", ParamDefinition.arrayToOptions(["scene-center", "camera-target"])),
  mode: ParamDefinition.Select("plane", ParamDefinition.arrayToOptions(["plane", "sphere"]))
};
var DofPass = class {
  static isEnabled(props) {
    return props.dof.name !== "off";
  }
  constructor(webgl, width, height) {
    this.webgl = webgl;
    this.target = webgl.createRenderTarget(width, height, false);
    const nullTexture = createNullTexture();
    this.renderable = getDofRenderable(webgl, nullTexture, nullTexture, nullTexture);
  }
  updateState(viewport) {
    const { gl, state } = this.webgl;
    state.enable(gl.SCISSOR_TEST);
    state.disable(gl.BLEND);
    state.disable(gl.DEPTH_TEST);
    state.depthMask(false);
    const { x, y, width, height } = viewport;
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    state.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  setSize(width, height) {
    const w = this.target.texture.getWidth();
    const h = this.target.texture.getHeight();
    if (width !== w || height !== h) {
      this.target.setSize(width, height);
      ValueCell.update(this.renderable.values.uTexSize, Vec2.set(this.renderable.values.uTexSize.ref.value, width, height));
    }
  }
  update(camera, input, depthOpaque, depthTransparent, props, sphere) {
    let needsUpdate = false;
    if (this.renderable.values.tColor.ref.value !== input) {
      ValueCell.update(this.renderable.values.tColor, input);
      needsUpdate = true;
    }
    if (this.renderable.values.tDepthOpaque.ref.value !== depthOpaque) {
      ValueCell.update(this.renderable.values.tDepthOpaque, depthOpaque);
      needsUpdate = true;
    }
    if (this.renderable.values.tDepthTransparent.ref.value !== depthTransparent) {
      ValueCell.update(this.renderable.values.tDepthTransparent, depthTransparent);
      needsUpdate = true;
    }
    const orthographic = camera.state.mode === "orthographic" ? 1 : 0;
    const invProjection = this.renderable.values.uInvProjection.ref.value;
    Mat4.invert(invProjection, camera.projection);
    const [w, h] = this.renderable.values.uTexSize.ref.value;
    const v3 = camera.viewport;
    ValueCell.update(this.renderable.values.uProjection, camera.projection);
    ValueCell.update(this.renderable.values.uInvProjection, invProjection);
    ValueCell.update(this.renderable.values.uMode, props.mode === "sphere" ? 1 : 0);
    Vec4.set(this.renderable.values.uBounds.ref.value, v3.x / w, v3.y / h, (v3.x + v3.width) / w, (v3.y + v3.height) / h);
    ValueCell.update(this.renderable.values.uBounds, this.renderable.values.uBounds.ref.value);
    ValueCell.updateIfChanged(this.renderable.values.uNear, camera.near);
    ValueCell.updateIfChanged(this.renderable.values.uFar, camera.far);
    ValueCell.updateIfChanged(this.renderable.values.dOrthographic, orthographic);
    const blurSize = Math.round(props.blurSize * this.webgl.pixelRatio);
    if (this.renderable.values.dBlurSize.ref.value !== blurSize) {
      ValueCell.update(this.renderable.values.dBlurSize, blurSize);
      needsUpdate = true;
    }
    const wolrdCenter = props.center === "scene-center" ? sphere.center : camera.state.target;
    const distance = Vec3.distance(camera.state.position, wolrdCenter);
    const inFocus = distance + props.inFocus;
    ValueCell.updateIfChanged(this.renderable.values.uInFocus, inFocus);
    const center = this.renderable.values.uCenter.ref.value;
    Vec3.transformMat4(center, wolrdCenter, camera.view);
    ValueCell.update(this.renderable.values.uCenter, center);
    ValueCell.updateIfChanged(this.renderable.values.uBlurSpread, props.blurSpread);
    ValueCell.updateIfChanged(this.renderable.values.uPPM, props.PPM);
    if (needsUpdate) {
      this.renderable.update();
    }
  }
  render(viewport, target) {
    if (isTimingMode)
      this.webgl.timer.mark("DofPass.render");
    if (target) {
      target.bind();
    } else {
      this.webgl.unbindFramebuffer();
    }
    this.updateState(viewport);
    this.renderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("DofPass.render");
  }
};
var DofSchema = {
  ...QuadSchema,
  tDepthOpaque: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tDepthTransparent: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tColor: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSize: UniformSpec("v2"),
  uProjection: UniformSpec("m4"),
  uInvProjection: UniformSpec("m4"),
  uBounds: UniformSpec("v4"),
  uCenter: UniformSpec("v3"),
  uMode: UniformSpec("i"),
  dOrthographic: DefineSpec("number"),
  uNear: UniformSpec("f"),
  uFar: UniformSpec("f"),
  dBlurSize: DefineSpec("number"),
  uBlurSpread: UniformSpec("f"),
  uInFocus: UniformSpec("f"),
  uPPM: UniformSpec("f")
};
var DofShaderCode = ShaderCode("dof", quad_vert, dof_frag);
function getDofRenderable(ctx, colorTexture, depthTextureOpaque, depthTextureTransparent) {
  const width = colorTexture.getWidth();
  const height = colorTexture.getHeight();
  const values2 = {
    ...QuadValues,
    tDepthOpaque: ValueCell.create(depthTextureOpaque),
    tDepthTransparent: ValueCell.create(depthTextureTransparent),
    tColor: ValueCell.create(colorTexture),
    uTexSize: ValueCell.create(Vec2.create(width, height)),
    uProjection: ValueCell.create(Mat4.identity()),
    uInvProjection: ValueCell.create(Mat4.identity()),
    uBounds: ValueCell.create(Vec4()),
    uCenter: ValueCell.create(Vec3()),
    uMode: ValueCell.create(0),
    dOrthographic: ValueCell.create(0),
    uNear: ValueCell.create(1),
    uFar: ValueCell.create(1e4),
    dBlurSize: ValueCell.create(5),
    uBlurSpread: ValueCell.create(300),
    uInFocus: ValueCell.create(20),
    uPPM: ValueCell.create(20)
  };
  const schema = { ...DofSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", DofShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/bloom/composite.frag.js
var composite_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

uniform vec2 uTexSizeInv;

uniform sampler2D tBlur1;
uniform sampler2D tBlur2;
uniform sampler2D tBlur3;
uniform sampler2D tBlur4;
uniform sampler2D tBlur5;
uniform float uBloomStrength;
uniform float uBloomRadius;
uniform float uBloomFactors[5];
uniform vec3 uBloomTints[5];

float lerpBloomFactor(const in float factor) {
    float mirrorFactor = 1.2 - factor;
    return mix(factor, mirrorFactor, uBloomRadius);
}

void main(void) {
    vec2 coords = gl_FragCoord.xy * uTexSizeInv;

    gl_FragColor = uBloomStrength * (
        lerpBloomFactor(uBloomFactors[0]) * vec4(uBloomTints[0], 1.0) * texture2D(tBlur1, coords) +
        lerpBloomFactor(uBloomFactors[1]) * vec4(uBloomTints[1], 1.0) * texture2D(tBlur2, coords) +
        lerpBloomFactor(uBloomFactors[2]) * vec4(uBloomTints[2], 1.0) * texture2D(tBlur3, coords) +
        lerpBloomFactor(uBloomFactors[3]) * vec4(uBloomTints[3], 1.0) * texture2D(tBlur4, coords) +
        lerpBloomFactor(uBloomFactors[4]) * vec4(uBloomTints[4], 1.0) * texture2D(tBlur5, coords)
    );
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/bloom/luminosity.frag.js
var luminosity_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

uniform sampler2D tColor;
uniform sampler2D tEmissive;
uniform sampler2D tDepth;
uniform vec2 uTexSizeInv;

uniform vec3 uDefaultColor;
uniform float uDefaultOpacity;
uniform float uLuminosityThreshold;
uniform float uSmoothWidth;

#include common

float getDepth(const in vec2 coords) {
    #ifdef depthTextureSupport
        return texture2D(tDepth, coords).r;
    #else
        return unpackRGBAToDepth(texture2D(tDepth, coords));
    #endif
}

bool isBackground(const in float depth) {
    return depth == 1.0;
}

void main(void) {
    vec2 coords = gl_FragCoord.xy * uTexSizeInv;
    vec4 texel = texture2D(tColor, coords);
    float emissive = texture2D(tEmissive, coords).a;
    float depth = getDepth(coords);

    if (isBackground(depth)) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        return;
    }

    vec4 outputColor = vec4(uDefaultColor.rgb, uDefaultOpacity);

    #if defined(dMode_luminosity)
        vec3 luma = vec3(0.299, 0.587, 0.114);
        float v = dot(texel.xyz, luma);
        float alpha = smoothstep(uLuminosityThreshold, uLuminosityThreshold + uSmoothWidth, v);

        gl_FragColor = mix(outputColor, texel, alpha);
    #elif defined(dMode_emissive)
        gl_FragColor = mix(outputColor, texel, emissive);
    #endif
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/bloom/blur.frag.js
var blur_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

uniform sampler2D tInput;
uniform vec2 uTexSizeInv;

uniform vec2 uDirection;
uniform float uGaussianCoefficients[dKernelRadius];

void main(void) {
    vec2 coords = gl_FragCoord.xy * uTexSizeInv;
    float weightSum = uGaussianCoefficients[0];
    vec4 diffuseSum = texture2D(tInput, coords) * weightSum;

    for(int i = 1; i < dKernelRadius; ++i) {
        float x = float(i);
        float w = uGaussianCoefficients[i];
        vec2 offset = uDirection * uTexSizeInv * x;
        vec4 sample1 = texture2D(tInput, coords + offset);
        vec4 sample2 = texture2D(tInput, coords - offset);
        diffuseSum += (sample1 + sample2) * w;
        weightSum += 2.0 * w;
    }

    gl_FragColor = diffuseSum / weightSum;
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/bloom.js
var MipCount = 5;
var BloomParams = {
  strength: ParamDefinition.Numeric(1, { min: 0, max: 3, step: 0.1 }),
  radius: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.01 }),
  threshold: ParamDefinition.Numeric(0, { min: 0, max: 1, step: 0.01 }, { description: "Luminosity threshold", hideIf: (p) => p.mode === "emissive" }),
  mode: ParamDefinition.Select("emissive", [["luminosity", "Luminosity"], ["emissive", "Emissive"]])
};
var BloomPass = class {
  static isEnabled(props) {
    return props.bloom.name === "on";
  }
  constructor(webgl, width, height) {
    this.webgl = webgl;
    this.horizontalBlurTargets = [];
    this.verticalBlurTargets = [];
    this.emissiveTarget = webgl.createRenderTarget(width, height, true, "uint8", "linear", "rgba");
    this.luminosityTarget = webgl.createRenderTarget(width, height, false, "uint8", "linear");
    this.compositeTarget = webgl.createRenderTarget(width, height, false, "uint8", "linear");
    let blurWidth = Math.round(width / 2);
    let blurHeight = Math.round(height / 2);
    for (let i = 0; i < MipCount; ++i) {
      this.horizontalBlurTargets[i] = webgl.createRenderTarget(blurWidth, blurHeight, false, "uint8", "linear");
      this.verticalBlurTargets[i] = webgl.createRenderTarget(blurWidth, blurHeight, false, "uint8", "linear");
      blurWidth = Math.round(blurWidth / 2);
      blurHeight = Math.round(blurHeight / 2);
    }
    const nullTexture = createNullTexture();
    this.luminosityRenderable = getLuminosityRenderable(webgl, nullTexture, nullTexture, nullTexture);
    this.blurRenderable = getBlurRenderable(webgl, nullTexture);
    this.compositeRenderable = getCompositeRenderable(webgl, width, height, this.verticalBlurTargets[0].texture, this.verticalBlurTargets[1].texture, this.verticalBlurTargets[2].texture, this.verticalBlurTargets[3].texture, this.verticalBlurTargets[4].texture);
    this.copyRenderable = createCopyRenderable(webgl, this.compositeTarget.texture);
  }
  setSize(width, height) {
    const w = this.luminosityTarget.getWidth();
    const h = this.luminosityTarget.getHeight();
    if (width !== w || height !== h) {
      this.emissiveTarget.setSize(width, height);
      this.luminosityTarget.setSize(width, height);
      this.compositeTarget.setSize(width, height);
      let blurWidth = Math.round(width / 2);
      let blurHeight = Math.round(height / 2);
      for (let i = 0; i < MipCount; ++i) {
        this.horizontalBlurTargets[i].setSize(blurWidth, blurHeight);
        this.verticalBlurTargets[i].setSize(blurWidth, blurHeight);
        blurWidth = Math.round(blurWidth / 2);
        blurHeight = Math.round(blurHeight / 2);
      }
      ValueCell.update(this.luminosityRenderable.values.uTexSizeInv, Vec2.set(this.compositeRenderable.values.uTexSizeInv.ref.value, 1 / width, 1 / height));
      ValueCell.update(this.compositeRenderable.values.uTexSizeInv, Vec2.set(this.compositeRenderable.values.uTexSizeInv.ref.value, 1 / width, 1 / height));
      ValueCell.update(this.copyRenderable.values.uTexSize, Vec2.set(this.copyRenderable.values.uTexSize.ref.value, width, height));
    }
  }
  update(input, emissive, depth, props) {
    let luminosityNeedsUpdate = false;
    if (this.luminosityRenderable.values.tColor.ref.value !== input) {
      ValueCell.update(this.luminosityRenderable.values.tColor, input);
      luminosityNeedsUpdate = true;
    }
    if (this.luminosityRenderable.values.tEmissive.ref.value !== emissive) {
      ValueCell.update(this.luminosityRenderable.values.tEmissive, emissive);
      luminosityNeedsUpdate = true;
    }
    if (this.luminosityRenderable.values.tDepth.ref.value !== depth) {
      ValueCell.update(this.luminosityRenderable.values.tDepth, depth);
      luminosityNeedsUpdate = true;
    }
    if (this.luminosityRenderable.values.dMode.ref.value !== props.mode) {
      ValueCell.update(this.luminosityRenderable.values.dMode, props.mode);
      luminosityNeedsUpdate = true;
    }
    ValueCell.updateIfChanged(this.luminosityRenderable.values.uLuminosityThreshold, props.threshold);
    if (luminosityNeedsUpdate) {
      this.luminosityRenderable.update();
    }
    let blurNeedsUpdate = false;
    if (this.blurRenderable.values.tInput.ref.value !== input) {
      ValueCell.update(this.blurRenderable.values.tInput, input);
      blurNeedsUpdate = true;
    }
    if (blurNeedsUpdate) {
      this.blurRenderable.update();
    }
    ValueCell.update(this.compositeRenderable.values.uBloomRadius, props.radius);
    ValueCell.update(this.compositeRenderable.values.uBloomStrength, props.strength);
  }
  render(viewport, target) {
    if (isTimingMode)
      this.webgl.timer.mark("BloomPass.render");
    const { gl, state } = this.webgl;
    const { x, y, width, height } = viewport;
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    state.enable(gl.SCISSOR_TEST);
    state.disable(gl.BLEND);
    state.disable(gl.DEPTH_TEST);
    state.depthMask(false);
    this.luminosityTarget.bind();
    this.luminosityRenderable.render();
    for (let i = 0; i < MipCount; ++i) {
      const blurWidth = this.horizontalBlurTargets[i].getWidth();
      const blurHeight = this.horizontalBlurTargets[i].getHeight();
      state.viewport(0, 0, blurWidth, blurHeight);
      state.scissor(0, 0, blurWidth, blurHeight);
      ValueCell.update(this.blurRenderable.values.dKernelRadius, BlurKernelSizes[i]);
      ValueCell.update(this.blurRenderable.values.uGaussianCoefficients, getBlurCoefficients(BlurKernelSizes[i]));
      ValueCell.update(this.blurRenderable.values.uTexSizeInv, Vec2.set(this.blurRenderable.values.uTexSizeInv.ref.value, 1 / blurWidth, 1 / blurHeight));
      this.horizontalBlurTargets[i].bind();
      ValueCell.update(this.blurRenderable.values.tInput, i === 0 ? this.luminosityTarget.texture : this.verticalBlurTargets[i - 1].texture);
      ValueCell.update(this.blurRenderable.values.uDirection, BlurDirectionX);
      this.blurRenderable.update();
      this.blurRenderable.render();
      this.verticalBlurTargets[i].bind();
      ValueCell.update(this.blurRenderable.values.tInput, this.horizontalBlurTargets[i].texture);
      ValueCell.update(this.blurRenderable.values.uDirection, BlurDirectionY);
      this.blurRenderable.update();
      this.blurRenderable.render();
    }
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    this.compositeTarget.bind();
    this.compositeRenderable.update();
    this.compositeRenderable.render();
    if (target) {
      target.bind();
    } else {
      this.webgl.unbindFramebuffer();
    }
    state.enable(gl.BLEND);
    state.blendFunc(gl.ONE, gl.ONE);
    this.copyRenderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("BloomPass.render");
  }
};
var LuminositySchema = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tEmissive: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tDepth: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSizeInv: UniformSpec("v2"),
  uDefaultColor: UniformSpec("v3"),
  uDefaultOpacity: UniformSpec("f"),
  uLuminosityThreshold: UniformSpec("f"),
  uSmoothWidth: UniformSpec("f"),
  dMode: DefineSpec("string", ["luminosity", "emissive"])
};
var LuminosityShaderCode = ShaderCode("Bloom Luminosity", quad_vert, luminosity_frag);
function getLuminosityRenderable(ctx, colorTexture, emissiveTexture, depthTexture) {
  const width = colorTexture.getWidth();
  const height = colorTexture.getHeight();
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(colorTexture),
    tEmissive: ValueCell.create(emissiveTexture),
    tDepth: ValueCell.create(depthTexture),
    uTexSizeInv: ValueCell.create(Vec2.create(1 / width, 1 / height)),
    uDefaultColor: ValueCell.create(Vec3()),
    uDefaultOpacity: ValueCell.create(0),
    uLuminosityThreshold: ValueCell.create(0),
    uSmoothWidth: ValueCell.create(1),
    dMode: ValueCell.create("emissive")
  };
  const schema = { ...LuminositySchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", LuminosityShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
function _getBlurCoefficients(kernelRadius) {
  const coefficients = [];
  for (let i = 0; i < kernelRadius; ++i) {
    coefficients.push(0.39894 * Math.exp(-0.5 * i * i / (kernelRadius * kernelRadius)) / kernelRadius);
  }
  return coefficients;
}
var getBlurCoefficients = memoize1(_getBlurCoefficients);
var BlurKernelSizes = [3, 5, 7, 9, 11];
var BlurDirectionX = Vec2.create(1, 0);
var BlurDirectionY = Vec2.create(0, 1);
var BlurSchema = {
  ...QuadSchema,
  tInput: TextureSpec("texture", "rgba", "ubyte", "linear"),
  uTexSizeInv: UniformSpec("v2"),
  uDirection: UniformSpec("v2"),
  uGaussianCoefficients: UniformSpec("f[]"),
  dKernelRadius: DefineSpec("number")
};
var BlurShaderCode = ShaderCode("Bloom Blur", quad_vert, blur_frag);
function getBlurRenderable(ctx, inputTexture) {
  const width = inputTexture.getWidth();
  const height = inputTexture.getHeight();
  const values2 = {
    ...QuadValues,
    tInput: ValueCell.create(inputTexture),
    uTexSizeInv: ValueCell.create(Vec2.create(1 / width, 1 / height)),
    uDirection: ValueCell.create(Vec2()),
    uGaussianCoefficients: ValueCell.create([]),
    dKernelRadius: ValueCell.create(BlurKernelSizes[0])
  };
  const schema = { ...BlurSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", BlurShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var CompositeSchema = {
  ...QuadSchema,
  tBlur1: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tBlur2: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tBlur3: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tBlur4: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tBlur5: TextureSpec("texture", "rgba", "ubyte", "linear"),
  uTexSizeInv: UniformSpec("v2"),
  uBloomStrength: UniformSpec("f"),
  uBloomRadius: UniformSpec("f"),
  uBloomFactors: UniformSpec("f[]"),
  uBloomTints: UniformSpec("v3[]")
};
var CompositeShaderCode = ShaderCode("Bloom Composite", quad_vert, composite_frag);
function getCompositeRenderable(ctx, width, height, blurTexture1, blurTexture2, blurTexture3, blurTexture4, blurTexture5) {
  const values2 = {
    ...QuadValues,
    uTexSizeInv: ValueCell.create(Vec2.create(width, height)),
    tBlur1: ValueCell.create(blurTexture1),
    tBlur2: ValueCell.create(blurTexture2),
    tBlur3: ValueCell.create(blurTexture3),
    tBlur4: ValueCell.create(blurTexture4),
    tBlur5: ValueCell.create(blurTexture5),
    uBloomStrength: ValueCell.create(1),
    uBloomRadius: ValueCell.create(0),
    uBloomFactors: ValueCell.create([1, 0.8, 0.6, 0.4, 0.2]),
    uBloomTints: ValueCell.create(new Array(5 * 3).fill(1))
  };
  const schema = { ...CompositeSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", CompositeShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/outlines.frag.js
var outlines_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

uniform sampler2D tDepthOpaque;
uniform sampler2D tDepthTransparent;
uniform vec2 uTexSize;

uniform float uNear;
uniform float uFar;
uniform mat4 uInvProjection;

uniform float uOutlineThreshold;

#include common

float getViewZ(const in float depth) {
    #if dOrthographic == 1
        return orthographicDepthToViewZ(depth, uNear, uFar);
    #else
        return perspectiveDepthToViewZ(depth, uNear, uFar);
    #endif
}

float getDepthOpaque(const in vec2 coords) {
    #ifdef depthTextureSupport
        return texture2D(tDepthOpaque, coords).r;
    #else
        return unpackRGBAToDepth(texture2D(tDepthOpaque, coords));
    #endif
}

float getDepthTransparent(const in vec2 coords) {
    #ifdef dTransparentOutline
        return unpackRGBAToDepthWithAlpha(texture2D(tDepthTransparent, coords)).x;
    #else
        return 1.0;
    #endif
}

bool isBackground(const in float depth) {
    return depth == 1.0;
}

float getPixelSize(const in vec2 coords, const in float depth) {
    vec3 viewPos0 = screenSpaceToViewSpace(vec3(coords, depth), uInvProjection);
    vec3 viewPos1 = screenSpaceToViewSpace(vec3(coords + vec2(1.0, 0.0) / uTexSize, depth), uInvProjection);
    return distance(viewPos0, viewPos1);
}

void main(void) {
    float backgroundViewZ = 2.0 * uFar;

    vec2 coords = gl_FragCoord.xy / uTexSize;
    vec2 invTexSize = 1.0 / uTexSize;

    float selfDepthOpaque = getDepthOpaque(coords);
    float selfViewZOpaque = isBackground(selfDepthOpaque) ? backgroundViewZ : getViewZ(selfDepthOpaque);
    float pixelSizeOpaque = getPixelSize(coords, selfDepthOpaque) * uOutlineThreshold;

    float selfDepthTransparent = getDepthTransparent(coords);
    float selfViewZTransparent = isBackground(selfDepthTransparent) ? backgroundViewZ : getViewZ(selfDepthTransparent);
    float pixelSizeTransparent = getPixelSize(coords, selfDepthTransparent) * uOutlineThreshold;

    float outline = 1.0;
    float bestDepth = 1.0;
    float transparentFlag = 0.0;

    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            vec2 sampleCoords = coords + vec2(float(x), float(y)) * invTexSize;

            float sampleDepthOpaque = getDepthOpaque(sampleCoords);
            float sampleDepthTransparent = getDepthTransparent(sampleCoords);

            float sampleViewZOpaque = isBackground(sampleDepthOpaque) ? backgroundViewZ : getViewZ(sampleDepthOpaque);
            if (abs(selfViewZOpaque - sampleViewZOpaque) > pixelSizeOpaque && selfDepthOpaque > sampleDepthOpaque && sampleDepthOpaque <= bestDepth) {
                outline = 0.0;
                bestDepth = sampleDepthOpaque;
            }

            if (sampleDepthTransparent < sampleDepthOpaque) {
                float sampleViewZTransparent = isBackground(sampleDepthTransparent) ? backgroundViewZ : getViewZ(sampleDepthTransparent);
                if (abs(selfViewZTransparent - sampleViewZTransparent) > pixelSizeTransparent && selfDepthTransparent > sampleDepthTransparent && sampleDepthTransparent <= bestDepth) {
                    outline = 0.0;
                    bestDepth = sampleDepthTransparent;
                    transparentFlag = 1.0;
                }
            }
        }
    }

    gl_FragColor = vec4(outline, packUnitIntervalToRG(bestDepth), transparentFlag);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/outline.js
var OutlineParams = {
  scale: ParamDefinition.Numeric(1, { min: 1, max: 5, step: 1 }),
  threshold: ParamDefinition.Numeric(0.33, { min: 0.01, max: 1, step: 0.01 }),
  color: ParamDefinition.Color(Color(0)),
  includeTransparent: ParamDefinition.Boolean(true, { description: "Whether to show outline for transparent objects" })
};
var OutlinePass = class {
  static isEnabled(props) {
    return props.outline.name !== "off";
  }
  constructor(webgl, width, height, depthTextureTransparent, depthTextureOpaque) {
    this.webgl = webgl;
    this.target = webgl.createRenderTarget(width, height, false);
    this.renderable = getOutlinesRenderable(webgl, depthTextureOpaque, depthTextureTransparent, true);
  }
  setSize(width, height) {
    const [w, h] = this.renderable.values.uTexSize.ref.value;
    if (width !== w || height !== h) {
      this.target.setSize(width, height);
      ValueCell.update(this.renderable.values.uTexSize, Vec2.set(this.renderable.values.uTexSize.ref.value, width, height));
    }
  }
  update(camera, props, depthTextureTransparent, depthTextureOpaque) {
    var _a;
    let needsUpdate = false;
    const orthographic = camera.state.mode === "orthographic" ? 1 : 0;
    const invProjection = this.renderable.values.uInvProjection.ref.value;
    Mat4.invert(invProjection, camera.projection);
    const transparentOutline = (_a = props.includeTransparent) !== null && _a !== void 0 ? _a : true;
    const outlineScale = Math.max(1, Math.round(props.scale * this.webgl.pixelRatio)) - 1;
    const outlineThreshold = 50 * props.threshold * this.webgl.pixelRatio;
    ValueCell.updateIfChanged(this.renderable.values.uNear, camera.near);
    ValueCell.updateIfChanged(this.renderable.values.uFar, camera.far);
    ValueCell.update(this.renderable.values.uInvProjection, invProjection);
    if (this.renderable.values.dTransparentOutline.ref.value !== transparentOutline) {
      needsUpdate = true;
      ValueCell.update(this.renderable.values.dTransparentOutline, transparentOutline);
    }
    if (this.renderable.values.dOrthographic.ref.value !== orthographic) {
      needsUpdate = true;
      ValueCell.update(this.renderable.values.dOrthographic, orthographic);
    }
    ValueCell.updateIfChanged(this.renderable.values.uOutlineThreshold, outlineThreshold);
    if (this.renderable.values.tDepthTransparent.ref.value !== depthTextureTransparent) {
      needsUpdate = true;
      ValueCell.update(this.renderable.values.tDepthTransparent, depthTextureTransparent);
    }
    if (this.renderable.values.tDepthOpaque.ref.value !== depthTextureOpaque) {
      needsUpdate = true;
      ValueCell.update(this.renderable.values.tDepthOpaque, depthTextureOpaque);
    }
    if (needsUpdate) {
      this.renderable.update();
    }
    return { transparentOutline, outlineScale };
  }
  render() {
    if (isTimingMode)
      this.webgl.timer.mark("OutlinePass.render");
    this.target.bind();
    this.renderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("OutlinePass.render");
  }
};
var OutlinesSchema = {
  ...QuadSchema,
  tDepthOpaque: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tDepthTransparent: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSize: UniformSpec("v2"),
  dOrthographic: DefineSpec("number"),
  uNear: UniformSpec("f"),
  uFar: UniformSpec("f"),
  uInvProjection: UniformSpec("m4"),
  uOutlineThreshold: UniformSpec("f"),
  dTransparentOutline: DefineSpec("boolean")
};
function getOutlinesRenderable(ctx, depthTextureOpaque, depthTextureTransparent, transparentOutline) {
  const width = depthTextureOpaque.getWidth();
  const height = depthTextureOpaque.getHeight();
  const values2 = {
    ...QuadValues,
    tDepthOpaque: ValueCell.create(depthTextureOpaque),
    tDepthTransparent: ValueCell.create(depthTextureTransparent),
    uTexSize: ValueCell.create(Vec2.create(width, height)),
    dOrthographic: ValueCell.create(0),
    uNear: ValueCell.create(1),
    uFar: ValueCell.create(1e4),
    uInvProjection: ValueCell.create(Mat4.identity()),
    uOutlineThreshold: ValueCell.create(0.33),
    dTransparentOutline: ValueCell.create(transparentOutline)
  };
  const schema = { ...OutlinesSchema };
  const shaderCode = ShaderCode("outlines", quad_vert, outlines_frag);
  const renderItem = createComputeRenderItem(ctx, "triangles", shaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/shadows.frag.js
var shadows_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

#include common

uniform sampler2D tDepth;
uniform vec2 uTexSize;
uniform vec4 uBounds;

uniform float uNear;
uniform float uFar;

#if dLightCount != 0
    uniform vec3 uLightDirection[dLightCount];
    uniform vec3 uLightColor[dLightCount];
#endif
uniform vec3 uAmbientColor;

uniform mat4 uProjection;
uniform mat4 uInvProjection;

uniform float uMaxDistance;
uniform float uTolerance;

bool isBackground(const in float depth) {
    return depth == 1.0;
}

bool outsideBounds(const in vec2 p) {
    return p.x < uBounds.x || p.y < uBounds.y || p.x > uBounds.z || p.y > uBounds.w;
}

float getViewZ(const in float depth) {
    #if dOrthographic == 1
        return orthographicDepthToViewZ(depth, uNear, uFar);
    #else
        return perspectiveDepthToViewZ(depth, uNear, uFar);
    #endif
}

float getDepth(const in vec2 coords) {
    #ifdef depthTextureSupport
        return texture2D(tDepth, coords).r;
    #else
        return unpackRGBAToDepth(texture2D(tDepth, coords));
    #endif
}

float screenFade(const in vec2 coords) {
    vec2 c = (coords - uBounds.xy) / (uBounds.zw - uBounds.xy);
    vec2 fade = max(12.0 * abs(c - 0.5) - 5.0, vec2(0.0));
    return saturate(1.0 - dot(fade, fade));
}

// based on https://panoskarabelas.com/posts/screen_space_shadows/
vec3 screenSpaceShadow(const in vec3 position, const in vec3 lightDirection, const in vec3 lightColor, const in float stepLength) {
    // Ray position and direction (in view-space)
    vec3 rayPos = position;
    vec3 rayDir = -lightDirection;

    // Compute ray step
    vec3 rayStep = rayDir * stepLength;

    // Ray march towards the light
    vec4 rayCoords = vec4(0.0);
    for (int i = 0; i < dSteps; ++i) {
        // Step the ray
        rayPos += rayStep;

        rayCoords = uProjection * vec4(rayPos, 1.0);
        rayCoords.xyz = (rayCoords.xyz / rayCoords.w) * 0.5 + 0.5;

        if (outsideBounds(rayCoords.xy)) {
            return lightColor;
        }

        // Compute the difference between the ray's and the camera's depth
        float depth = getDepth(rayCoords.xy);
        float viewZ = getViewZ(depth);
        float zDelta = rayPos.z - viewZ;

        if (zDelta < uTolerance) {
            // Fade out as we approach the edges of the screen
            return mix(vec3(0.0), lightColor, 1.0 - screenFade(rayCoords.xy));
        }
    }

    return lightColor;
}

void main(void) {
    vec2 invTexSize = 1.0 / uTexSize;
    vec2 selfCoords = gl_FragCoord.xy * invTexSize;

    float selfDepth = getDepth(selfCoords);

    if (isBackground(selfDepth)) {
        gl_FragColor = vec4(0.0);
        return;
    }

    vec3 selfViewPos = screenSpaceToViewSpace(vec3(selfCoords, selfDepth), uInvProjection);
    float stepLength = uMaxDistance / float(dSteps);

    float l = length(uAmbientColor);
    float a = l;
    #if dLightCount != 0
        vec3 s;
        #pragma unroll_loop_start
        for (int i = 0; i < dLightCount; ++i) {
            s = screenSpaceShadow(selfViewPos, uLightDirection[i], uLightColor[i], stepLength);
            l += length(s);
            a += length(uLightColor[i]);
        }
        #pragma unroll_loop_end
    #endif

    gl_FragColor = vec4(l / a);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/shadow.js
var ShadowParams = {
  steps: ParamDefinition.Numeric(1, { min: 1, max: 64, step: 1 }),
  maxDistance: ParamDefinition.Numeric(3, { min: 0, max: 256, step: 1 }),
  tolerance: ParamDefinition.Numeric(1, { min: 0, max: 10, step: 0.1 })
};
var ShadowPass = class {
  static isEnabled(props) {
    return props.shadow.name !== "off";
  }
  constructor(webgl, width, height, depthTextureOpaque) {
    this.webgl = webgl;
    this.target = webgl.createRenderTarget(width, height, false);
    this.renderable = getShadowsRenderable(webgl, depthTextureOpaque);
  }
  setSize(width, height) {
    const [w, h] = this.renderable.values.uTexSize.ref.value;
    if (width !== w || height !== h) {
      this.target.setSize(width, height);
      ValueCell.update(this.renderable.values.uTexSize, Vec2.set(this.renderable.values.uTexSize.ref.value, width, height));
    }
  }
  update(camera, light, ambientColor, props) {
    let needsUpdateShadows = false;
    const orthographic = camera.state.mode === "orthographic" ? 1 : 0;
    const invProjection = Mat4.identity();
    Mat4.invert(invProjection, camera.projection);
    const [w, h] = this.renderable.values.uTexSize.ref.value;
    const v3 = camera.viewport;
    ValueCell.update(this.renderable.values.uProjection, camera.projection);
    ValueCell.update(this.renderable.values.uInvProjection, invProjection);
    Vec4.set(this.renderable.values.uBounds.ref.value, v3.x / w, v3.y / h, (v3.x + v3.width) / w, (v3.y + v3.height) / h);
    ValueCell.update(this.renderable.values.uBounds, this.renderable.values.uBounds.ref.value);
    ValueCell.updateIfChanged(this.renderable.values.uNear, camera.near);
    ValueCell.updateIfChanged(this.renderable.values.uFar, camera.far);
    if (this.renderable.values.dOrthographic.ref.value !== orthographic) {
      ValueCell.update(this.renderable.values.dOrthographic, orthographic);
      needsUpdateShadows = true;
    }
    ValueCell.updateIfChanged(this.renderable.values.uMaxDistance, props.maxDistance);
    ValueCell.updateIfChanged(this.renderable.values.uTolerance, props.tolerance);
    if (this.renderable.values.dSteps.ref.value !== props.steps) {
      ValueCell.update(this.renderable.values.dSteps, props.steps);
      needsUpdateShadows = true;
    }
    ValueCell.update(this.renderable.values.uLightDirection, light.direction);
    ValueCell.update(this.renderable.values.uLightColor, light.color);
    if (this.renderable.values.dLightCount.ref.value !== light.count) {
      ValueCell.update(this.renderable.values.dLightCount, light.count);
      needsUpdateShadows = true;
    }
    ValueCell.update(this.renderable.values.uAmbientColor, ambientColor);
    if (needsUpdateShadows) {
      this.renderable.update();
    }
  }
  render() {
    if (isTimingMode)
      this.webgl.timer.mark("ShadowPass.render");
    this.target.bind();
    this.renderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("ShadowPass.render");
  }
};
var ShadowsSchema = {
  ...QuadSchema,
  tDepth: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSize: UniformSpec("v2"),
  uProjection: UniformSpec("m4"),
  uInvProjection: UniformSpec("m4"),
  uBounds: UniformSpec("v4"),
  dOrthographic: DefineSpec("number"),
  uNear: UniformSpec("f"),
  uFar: UniformSpec("f"),
  dSteps: DefineSpec("number"),
  uMaxDistance: UniformSpec("f"),
  uTolerance: UniformSpec("f"),
  uLightDirection: UniformSpec("v3[]"),
  uLightColor: UniformSpec("v3[]"),
  dLightCount: DefineSpec("number"),
  uAmbientColor: UniformSpec("v3")
};
function getShadowsRenderable(ctx, depthTexture) {
  const width = depthTexture.getWidth();
  const height = depthTexture.getHeight();
  const values2 = {
    ...QuadValues,
    tDepth: ValueCell.create(depthTexture),
    uTexSize: ValueCell.create(Vec2.create(width, height)),
    uProjection: ValueCell.create(Mat4.identity()),
    uInvProjection: ValueCell.create(Mat4.identity()),
    uBounds: ValueCell.create(Vec4()),
    dOrthographic: ValueCell.create(0),
    uNear: ValueCell.create(1),
    uFar: ValueCell.create(1e4),
    dSteps: ValueCell.create(1),
    uMaxDistance: ValueCell.create(3),
    uTolerance: ValueCell.create(1),
    uLightDirection: ValueCell.create([]),
    uLightColor: ValueCell.create([]),
    dLightCount: ValueCell.create(0),
    uAmbientColor: ValueCell.create(Vec3())
  };
  const schema = { ...ShadowsSchema };
  const shaderCode = ShaderCode("shadows", quad_vert, shadows_frag);
  const renderItem = createComputeRenderItem(ctx, "triangles", shaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/ssao.frag.js
var ssao_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

#include common


uniform sampler2D tDepth;
uniform sampler2D tDepthHalf;
uniform sampler2D tDepthQuarter;

#if defined(dIncludeTransparent)
    uniform sampler2D tDepthTransparent;
    uniform sampler2D tDepthHalfTransparent;
    uniform sampler2D tDepthQuarterTransparent;
#endif

uniform int uTransparencyFlag;

uniform vec2 uTexSize;
uniform vec4 uBounds;

uniform vec3 uSamples[dNSamples];

uniform mat4 uProjection;
uniform mat4 uInvProjection;

#ifdef dMultiScale
    uniform float uLevelRadius[dLevels];
    uniform float uLevelBias[dLevels];
    uniform float uNearThreshold;
    uniform float uFarThreshold;
#else
    uniform float uRadius;
#endif
uniform float uBias;

float smootherstep(float edge0, float edge1, float x) {
    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);
}

float noise(const in vec2 coords) {
    float a = 12.9898;
    float b = 78.233;
    float c = 43758.5453;
    float dt = dot(coords, vec2(a,b));
    float sn = mod(dt, PI);
    return abs(fract(sin(sn) * c)); // is abs necessary?
}

vec2 getNoiseVec2(const in vec2 coords) {
    return vec2(noise(coords), noise(coords + vec2(PI, 2.71828)));
}

bool isBackground(const in float depth) {
    return depth > 0.999; // handle precision issues with packed depth
}

float getDepth(const in vec2 coords, const in int transparentFlag) {
    vec2 c = vec2(clamp(coords.x, uBounds.x, uBounds.z), clamp(coords.y, uBounds.y, uBounds.w));
    if (transparentFlag == 1){
        #if defined(dIncludeTransparent)
            return unpackRGBAToDepthWithAlpha(texture2D(tDepthTransparent, c)).x;
        #else
            return 1.0;
        #endif
    } else {
        #ifdef depthTextureSupport
            return texture2D(tDepth, c).r;
        #else
            return unpackRGBAToDepth(texture2D(tDepth, c));
        #endif
    }
}

#if defined(dIncludeTransparent)
    vec2 getDepthTransparentWithAlpha(const in vec2 coords){
        vec2 c = vec2(clamp(coords.x, uBounds.x, uBounds.z), clamp(coords.y, uBounds.y, uBounds.w));
        return unpackRGBAToDepthWithAlpha(texture2D(tDepthTransparent, c));
    }
#endif

#define dQuarterThreshold 0.1
#define dHalfThreshold 0.05

float getMappedDepth(const in vec2 coords, const in vec2 selfCoords) {
    vec2 c = vec2(clamp(coords.x, uBounds.x, uBounds.z), clamp(coords.y, uBounds.y, uBounds.w));
    float d = distance(coords, selfCoords);
    #ifdef depthTextureSupport
        if (d > dQuarterThreshold) {
            return texture2D(tDepthQuarter, c).r;
        } else if (d > dHalfThreshold) {
            return texture2D(tDepthHalf, c).r;
        } else {
            return texture2D(tDepth, c).r;
        }
    #else
        if (d > dQuarterThreshold) {
            return unpackRGBAToDepth(texture2D(tDepthQuarter, c));
        } else if (d > dHalfThreshold) {
            return unpackRGBAToDepth(texture2D(tDepthHalf, c));
        } else {
            return unpackRGBAToDepth(texture2D(tDepth, c));
        }
    #endif
}

#if defined(dIncludeTransparent)
    vec2 getMappedDepthTransparentWithAlpha(const in vec2 coords, const in vec2 selfCoords) {
        vec2 c = vec2(clamp(coords.x, uBounds.x, uBounds.z), clamp(coords.y, uBounds.y, uBounds.w));
        float d = distance(coords, selfCoords);
        if (d > dQuarterThreshold) {
            return unpackRGBAToDepthWithAlpha(texture2D(tDepthQuarterTransparent, c));
        } else if (d > dHalfThreshold) {
            return unpackRGBAToDepthWithAlpha(texture2D(tDepthHalfTransparent, c));
        } else {
            return unpackRGBAToDepthWithAlpha(texture2D(tDepthTransparent, c));
        }
    }
#endif

// adapted from https://gist.github.com/bgolus/a07ed65602c009d5e2f753826e8078a0
vec3 viewNormalAtPixelPositionAccurate(const in vec2 vpos, const in int transparentFlag) {
    // current pixel's depth
    float c = getDepth(vpos, transparentFlag);

    // get current pixel's view space position
    vec3 viewSpacePos_c = screenSpaceToViewSpace(vec3(vpos, c), uInvProjection);

    // get view space position at 1 pixel offsets in each major direction
    vec3 viewSpacePos_l = screenSpaceToViewSpace(vec3(vpos + vec2(-1.0, 0.0) / uTexSize, getDepth(vpos + vec2(-1.0, 0.0) / uTexSize, transparentFlag)), uInvProjection);
    vec3 viewSpacePos_r = screenSpaceToViewSpace(vec3(vpos + vec2( 1.0, 0.0) / uTexSize, getDepth(vpos + vec2( 1.0, 0.0) / uTexSize, transparentFlag)), uInvProjection);
    vec3 viewSpacePos_d = screenSpaceToViewSpace(vec3(vpos + vec2( 0.0,-1.0) / uTexSize, getDepth(vpos + vec2( 0.0,-1.0) / uTexSize, transparentFlag)), uInvProjection);
    vec3 viewSpacePos_u = screenSpaceToViewSpace(vec3(vpos + vec2( 0.0, 1.0) / uTexSize, getDepth(vpos + vec2( 0.0, 1.0) / uTexSize, transparentFlag)), uInvProjection);

    // get the difference between the current and each offset position
    vec3 l = viewSpacePos_c - viewSpacePos_l;
    vec3 r = viewSpacePos_r - viewSpacePos_c;
    vec3 d = viewSpacePos_c - viewSpacePos_d;
    vec3 u = viewSpacePos_u - viewSpacePos_c;

    // get depth values at 1 & 2 pixels offsets from current along the horizontal axis
    vec4 H = vec4(
        getDepth(vpos + vec2(-1.0, 0.0) / uTexSize, transparentFlag),
        getDepth(vpos + vec2( 1.0, 0.0) / uTexSize, transparentFlag),
        getDepth(vpos + vec2(-2.0, 0.0) / uTexSize, transparentFlag),
        getDepth(vpos + vec2( 2.0, 0.0) / uTexSize, transparentFlag)
    );

    // get depth values at 1 & 2 pixels offsets from current along the vertical axis
    vec4 V = vec4(
        getDepth(vpos + vec2(0.0,-1.0) / uTexSize, transparentFlag),
        getDepth(vpos + vec2(0.0, 1.0) / uTexSize, transparentFlag),
        getDepth(vpos + vec2(0.0,-2.0) / uTexSize, transparentFlag),
        getDepth(vpos + vec2(0.0, 2.0) / uTexSize, transparentFlag)
    );

    // current pixel's depth difference from slope of offset depth samples
    // differs from original article because we're using non-linear depth values
    // see article's comments
    vec2 he = abs((2.0 * H.xy - H.zw) - c);
    vec2 ve = abs((2.0 * V.xy - V.zw) - c);

    // pick horizontal and vertical diff with the smallest depth difference from slopes
    vec3 hDeriv = he.x < he.y ? l : r;
    vec3 vDeriv = ve.x < ve.y ? d : u;

    // get view space normal from the cross product of the best derivatives
    vec3 viewNormal = normalize(cross(hDeriv, vDeriv));

    return viewNormal;
}

float getPixelSize(const in vec2 coords, const in float depth) {
    vec3 viewPos0 = screenSpaceToViewSpace(vec3(coords, depth), uInvProjection);
    vec3 viewPos1 = screenSpaceToViewSpace(vec3(coords + vec2(1.0, 0.0) / uTexSize, depth), uInvProjection);
    return distance(viewPos0, viewPos1);
}

// StarCraft II Ambient Occlusion by [Filion and McNaughton 2008]
void main(void) {
    vec2 invTexSize = 1.0 / uTexSize;
    vec2 selfCoords = gl_FragCoord.xy * invTexSize;
    float selfDepth = getDepth(selfCoords, uTransparencyFlag);
    vec2 selfPackedDepth = packUnitIntervalToRG(selfDepth);

    if (isBackground(selfDepth)) {
        gl_FragColor = vec4(packUnitIntervalToRG(1.0), selfPackedDepth);
        return;
    }

    vec3 selfViewNormal = viewNormalAtPixelPositionAccurate(selfCoords, uTransparencyFlag);
    vec3 selfViewPos = screenSpaceToViewSpace(vec3(selfCoords, selfDepth), uInvProjection);

    vec3 randomVec = normalize(vec3(getNoiseVec2(selfCoords) * 2.0 - 1.0, 0.0));
    vec3 tangent = normalize(randomVec - selfViewNormal * dot(randomVec, selfViewNormal));
    vec3 bitangent = cross(selfViewNormal, tangent);
    mat3 TBN = mat3(tangent, bitangent, selfViewNormal);

    float occlusion = 0.0;
    #ifdef dMultiScale
        float pixelSize = getPixelSize(selfCoords, selfDepth);

        for(int l = 0; l < dLevels; l++) {
            // TODO: smooth transition
            if (pixelSize * uNearThreshold > uLevelRadius[l]) continue;
            if (pixelSize * uFarThreshold < uLevelRadius[l]) continue;

            float levelOcclusion = 0.0;
            for(int i = 0; i < dNSamples; i++) {
                // get sample position:
                vec3 sampleViewPos = TBN * uSamples[i];
                sampleViewPos = selfViewPos + sampleViewPos * uLevelRadius[l];

                // project sample position:
                vec4 offset = vec4(sampleViewPos, 1.0);
                offset = uProjection * offset;
                offset.xyz = (offset.xyz / offset.w) * 0.5 + 0.5;

                // get sample depth:
                float sampleOcc = 0.0;
                #ifdef dIllumination
                    if (uTransparencyFlag == 1) {
                #endif
                    float sampleDepth = getMappedDepth(offset.xy, selfCoords);
                    float sampleViewZ = screenSpaceToViewSpace(vec3(offset.xy, sampleDepth), uInvProjection).z;

                    sampleOcc = step(sampleViewPos.z + 0.025, sampleViewZ) * smootherstep(0.0, 1.0, uLevelRadius[l] / abs(selfViewPos.z - sampleViewZ)) * uLevelBias[l];
                #ifdef dIllumination
                    }
                #endif
                #if defined(dIncludeTransparent)
                    vec2 sampleDepthWithAlpha = getMappedDepthTransparentWithAlpha(offset.xy, selfCoords);
                    if (!isBackground(sampleDepthWithAlpha.x)) {
                        float sampleViewZ = screenSpaceToViewSpace(vec3(offset.xy, sampleDepthWithAlpha.x), uInvProjection).z;
                        sampleOcc = max(sampleOcc, step(sampleViewPos.z + 0.025, sampleViewZ) * smootherstep(0.0, 1.0, uLevelRadius[l] / abs(selfViewPos.z - sampleViewZ)) * uLevelBias[l] * sampleDepthWithAlpha.y);
                    }
                #endif

                levelOcclusion += sampleOcc;
            }
            occlusion = max(occlusion, levelOcclusion);
        }
    #else
        for(int i = 0; i < dNSamples; i++) {
            vec3 sampleViewPos = TBN * uSamples[i];
            sampleViewPos = selfViewPos + sampleViewPos * uRadius;

            vec4 offset = vec4(sampleViewPos, 1.0);
            offset = uProjection * offset;
            offset.xyz = (offset.xyz / offset.w) * 0.5 + 0.5;

            float sampleOcc = 0.0;
            #ifdef dIllumination
                if (uTransparencyFlag == 1) {
            #endif
                    // NOTE: using getMappedDepth here causes issues on some mobile devices
                    float sampleDepth = getDepth(offset.xy, 0);
                    float sampleViewZ = screenSpaceToViewSpace(vec3(offset.xy, sampleDepth), uInvProjection).z;

                    sampleOcc = step(sampleViewPos.z + 0.025, sampleViewZ) * smootherstep(0.0, 1.0, uRadius / abs(selfViewPos.z - sampleViewZ));
            #ifdef dIllumination
                }
            #endif
            #if defined(dIncludeTransparent)
                vec2 sampleDepthWithAlpha = getDepthTransparentWithAlpha(offset.xy);
                if (!isBackground(sampleDepthWithAlpha.x)) {
                    float sampleViewZ = screenSpaceToViewSpace(vec3(offset.xy, sampleDepthWithAlpha.x), uInvProjection).z;
                    sampleOcc = max(sampleOcc, step(sampleViewPos.z + 0.025, sampleViewZ) * smootherstep(0.0, 1.0, uRadius / abs(selfViewPos.z - sampleViewZ)) * sampleDepthWithAlpha.y);
                }
            #endif

            occlusion += sampleOcc;
        }
    #endif
    occlusion = 1.0 - (uBias * occlusion / float(dNSamples));

    vec2 packedOcclusion = packUnitIntervalToRG(clamp(occlusion, 0.01, 1.0));

    gl_FragColor = vec4(packedOcclusion, selfPackedDepth);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/ssao-blur.frag.js
var ssaoBlur_frag = `
precision highp float;
precision highp int;
precision highp sampler2D;

uniform sampler2D tSsaoDepth;
uniform vec2 uTexSize;
uniform vec4 uBounds;

uniform float uKernel[dOcclusionKernelSize];
uniform float uBlurDepthBias;

uniform float uBlurDirectionX;
uniform float uBlurDirectionY;

uniform mat4 uInvProjection;
uniform float uNear;
uniform float uFar;

#include common

float getViewZ(const in float depth) {
    #if dOrthographic == 1
        return orthographicDepthToViewZ(depth, uNear, uFar);
    #else
        return perspectiveDepthToViewZ(depth, uNear, uFar);
    #endif
}

bool isBackground(const in float depth) {
    // checking for 1.0 is not enough, because of precision issues
    return depth >= 0.999;
}

bool isNearClip(const in float depth) {
    return depth == 0.0;
}

bool outsideBounds(const in vec2 p) {
    return p.x < uBounds.x || p.y < uBounds.y || p.x > uBounds.z || p.y > uBounds.w;
}

float getPixelSize(const in vec2 coords, const in float depth) {
    vec3 viewPos0 = screenSpaceToViewSpace(vec3(coords, depth), uInvProjection);
    vec3 viewPos1 = screenSpaceToViewSpace(vec3(coords + vec2(1.0, 0.0) / uTexSize, depth), uInvProjection);
    return distance(viewPos0, viewPos1);
}

void main(void) {
    vec2 coords = gl_FragCoord.xy / uTexSize;

    vec2 packedDepth = texture2D(tSsaoDepth, coords).zw;

    if (outsideBounds(coords)) {
        gl_FragColor = vec4(packUnitIntervalToRG(1.0), packedDepth);
        return;
    }

    float selfDepth = unpackRGToUnitInterval(packedDepth);
    // (if background and if second pass) or if near clip
    if ((isBackground(selfDepth) && uBlurDirectionY != 0.0) || isNearClip(selfDepth)) {
        gl_FragColor = vec4(packUnitIntervalToRG(1.0), packedDepth);
        return;
    }

    float selfViewZ = getViewZ(selfDepth);
    float pixelSize = getPixelSize(coords, selfDepth);

    vec2 offset = vec2(uBlurDirectionX, uBlurDirectionY) / uTexSize;

    float sum = 0.0;
    float kernelSum = 0.0;
    // only if kernelSize is odd
    for (int i = -dOcclusionKernelSize / 2; i <= dOcclusionKernelSize / 2; i++) {
        if (abs(float(i)) > 1.0 && abs(float(i)) * pixelSize > 0.8) continue;

        vec2 sampleCoords = coords + float(i) * offset;
        if (outsideBounds(sampleCoords)) {
            continue;
        }

        vec4 sampleSsaoDepth = texture2D(tSsaoDepth, sampleCoords);

        float sampleDepth = unpackRGToUnitInterval(sampleSsaoDepth.zw);
        if (isBackground(sampleDepth) || isNearClip(sampleDepth)) {
            continue;
        }

        float sampleViewZ = getViewZ(sampleDepth);
        if (abs(selfViewZ - sampleViewZ) >= uBlurDepthBias) {
            continue;
        }

        float kernel = uKernel[int(abs(float(i)))]; // abs is not defined for int in webgl1
        float sampleValue = unpackRGToUnitInterval(sampleSsaoDepth.xy);

        sum += kernel * sampleValue;
        kernelSum += kernel;
    }
    gl_FragColor = vec4(packUnitIntervalToRG(sum / kernelSum), packedDepth);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/ssao.js
var SsaoParams = {
  samples: ParamDefinition.Numeric(32, { min: 1, max: 256, step: 1 }),
  multiScale: ParamDefinition.MappedStatic("off", {
    on: ParamDefinition.Group({
      levels: ParamDefinition.ObjectList({
        radius: ParamDefinition.Numeric(5, { min: 0, max: 20, step: 0.1 }, { description: "Final occlusion radius is 2^x" }),
        bias: ParamDefinition.Numeric(1, { min: 0, max: 3, step: 0.1 })
      }, (o) => `${o.radius}, ${o.bias}`, { defaultValue: [
        { radius: 2, bias: 1 },
        { radius: 5, bias: 1 },
        { radius: 8, bias: 1 },
        { radius: 11, bias: 1 }
      ] }),
      nearThreshold: ParamDefinition.Numeric(10, { min: 0, max: 50, step: 1 }),
      farThreshold: ParamDefinition.Numeric(1500, { min: 0, max: 1e4, step: 100 })
    }),
    off: ParamDefinition.Group({})
  }, { cycle: true }),
  radius: ParamDefinition.Numeric(5, { min: 0, max: 20, step: 0.1 }, { description: "Final occlusion radius is 2^x", hideIf: (p) => (p === null || p === void 0 ? void 0 : p.multiScale.name) === "on" }),
  bias: ParamDefinition.Numeric(0.8, { min: 0, max: 3, step: 0.1 }),
  blurKernelSize: ParamDefinition.Numeric(15, { min: 1, max: 25, step: 2 }),
  blurDepthBias: ParamDefinition.Numeric(0.5, { min: 0, max: 1, step: 0.01 }),
  resolutionScale: ParamDefinition.Numeric(1, { min: 0.1, max: 1, step: 0.05 }, { description: "Adjust resolution of occlusion calculation" }),
  color: ParamDefinition.Color(Color(0)),
  transparentThreshold: ParamDefinition.Numeric(0.4, { min: 0, max: 1, step: 0.05 })
};
function getLevels(props, levels) {
  const count3 = props.length;
  const { radius, bias } = levels || {
    radius: new Array(count3 * 3).fill(0),
    bias: new Array(count3 * 3).fill(0)
  };
  props = props.slice().sort((a5, b5) => a5.radius - b5.radius);
  for (let i = 0; i < count3; ++i) {
    const p = props[i];
    radius[i] = Math.pow(2, p.radius);
    bias[i] = p.bias;
  }
  return { count: count3, radius, bias };
}
var SsaoPass = class _SsaoPass {
  static isEnabled(props) {
    return props.occlusion.name !== "off";
  }
  static isTransparentEnabled(scene, props) {
    return scene.opacityAverage < 1 && scene.transparencyMin < props.transparentThreshold;
  }
  calcSsaoScale(resolutionScale) {
    return Math.min(1, 1 / this.webgl.pixelRatio) * resolutionScale;
  }
  getDepthTexture() {
    return this.ssaoScale === 1 ? this.depthTextureOpaque : this.downsampledDepthTargetOpaque.texture;
  }
  getTransparentDepthTexture() {
    return this.ssaoScale === 1 ? this.depthTextureTransparent : this.downsampledDepthTargetTransparent.texture;
  }
  constructor(webgl, width, height, packedDepth, depthTextureOpaque, depthTextureTransparent) {
    this.webgl = webgl;
    const { textureFloatLinear } = webgl.extensions;
    this.depthTextureOpaque = depthTextureOpaque;
    this.depthTextureTransparent = depthTextureTransparent;
    this.nSamples = 1;
    this.blurKernelSize = 1;
    this.ssaoScale = this.calcSsaoScale(1);
    this.texSize = [width, height];
    this.levels = [];
    this.framebuffer = webgl.resources.framebuffer();
    this.blurFirstPassFramebuffer = webgl.resources.framebuffer();
    this.blurSecondPassFramebuffer = webgl.resources.framebuffer();
    const sw = Math.floor(width * this.ssaoScale);
    const sh = Math.floor(height * this.ssaoScale);
    const hw = Math.max(1, Math.floor(sw * 0.5));
    const hh = Math.max(1, Math.floor(sh * 0.5));
    const qw = Math.max(1, Math.floor(sw * 0.25));
    const qh = Math.max(1, Math.floor(sh * 0.25));
    const filter4 = textureFloatLinear ? "linear" : "nearest";
    this.downsampledDepthTargetOpaque = packedDepth ? webgl.createRenderTarget(sw, sh, false, "uint8", "linear", "rgba") : webgl.createRenderTarget(sw, sh, false, "float32", filter4, webgl.isWebGL2 ? "alpha" : "rgba");
    this.downsampleDepthRenderableOpaque = createCopyRenderable(webgl, depthTextureOpaque);
    const depthTexture = this.getDepthTexture();
    this.depthHalfTargetOpaque = packedDepth ? webgl.createRenderTarget(hw, hh, false, "uint8", "linear", "rgba") : webgl.createRenderTarget(hw, hh, false, "float32", filter4, webgl.isWebGL2 ? "alpha" : "rgba");
    this.depthHalfRenderableOpaque = createCopyRenderable(webgl, depthTexture);
    this.depthQuarterTargetOpaque = packedDepth ? webgl.createRenderTarget(qw, qh, false, "uint8", "linear", "rgba") : webgl.createRenderTarget(qw, qh, false, "float32", filter4, webgl.isWebGL2 ? "alpha" : "rgba");
    this.depthQuarterRenderableOpaque = createCopyRenderable(webgl, this.depthHalfTargetOpaque.texture);
    this.downsampledDepthTargetTransparent = webgl.createRenderTarget(sw, sh, false, "uint8", "linear", "rgba");
    this.downsampleDepthRenderableTransparent = createCopyRenderable(webgl, depthTextureTransparent);
    const transparentDepthTexture = this.getTransparentDepthTexture();
    this.depthHalfTargetTransparent = webgl.createRenderTarget(hw, hh, false, "uint8", "linear", "rgba");
    this.depthHalfRenderableTransparent = createCopyRenderable(webgl, transparentDepthTexture);
    this.depthQuarterTargetTransparent = webgl.createRenderTarget(qw, qh, false, "uint8", "linear", "rgba");
    this.depthQuarterRenderableTransparent = createCopyRenderable(webgl, this.depthHalfTargetTransparent.texture);
    this.ssaoDepthTexture = webgl.resources.texture("image-uint8", "rgba", "ubyte", "linear");
    this.ssaoDepthTexture.define(sw, sh);
    this.ssaoDepthTexture.attachFramebuffer(this.framebuffer, "color0");
    this.ssaoDepthTransparentTexture = webgl.resources.texture("image-uint8", "rgba", "ubyte", "linear");
    this.ssaoDepthTransparentTexture.define(sw, sh);
    this.depthBlurProxyTexture = webgl.resources.texture("image-uint8", "rgba", "ubyte", "linear");
    this.depthBlurProxyTexture.define(sw, sh);
    this.depthBlurProxyTexture.attachFramebuffer(this.blurFirstPassFramebuffer, "color0");
    this.renderable = getSsaoRenderable(webgl, depthTexture, this.depthHalfTargetOpaque.texture, this.depthQuarterTargetOpaque.texture, transparentDepthTexture, this.depthHalfTargetTransparent.texture, this.depthQuarterTargetTransparent.texture);
    this.blurFirstPassRenderable = getSsaoBlurRenderable(webgl, this.ssaoDepthTransparentTexture, "horizontal");
    this.blurSecondPassRenderable = getSsaoBlurRenderable(webgl, this.depthBlurProxyTexture, "vertical");
  }
  setSize(width, height) {
    const [w, h] = this.texSize;
    const ssaoScale = this.calcSsaoScale(1);
    if (width !== w || height !== h || this.ssaoScale !== ssaoScale) {
      this.texSize.splice(0, 2, width, height);
      const sw = Math.floor(width * this.ssaoScale);
      const sh = Math.floor(height * this.ssaoScale);
      this.ssaoDepthTexture.define(sw, sh);
      this.ssaoDepthTransparentTexture.define(sw, sh);
      this.depthBlurProxyTexture.define(sw, sh);
      const hw = Math.max(1, Math.floor(sw * 0.5));
      const hh = Math.max(1, Math.floor(sh * 0.5));
      const qw = Math.max(1, Math.floor(sw * 0.25));
      const qh = Math.max(1, Math.floor(sh * 0.25));
      this.downsampledDepthTargetOpaque.setSize(sw, sh);
      this.depthHalfTargetOpaque.setSize(hw, hh);
      this.depthQuarterTargetOpaque.setSize(qw, qh);
      ValueCell.update(this.downsampleDepthRenderableOpaque.values.uTexSize, Vec2.set(this.downsampleDepthRenderableOpaque.values.uTexSize.ref.value, sw, sh));
      ValueCell.update(this.depthHalfRenderableOpaque.values.uTexSize, Vec2.set(this.depthHalfRenderableOpaque.values.uTexSize.ref.value, hw, hh));
      ValueCell.update(this.depthQuarterRenderableOpaque.values.uTexSize, Vec2.set(this.depthQuarterRenderableOpaque.values.uTexSize.ref.value, qw, qh));
      this.downsampledDepthTargetTransparent.setSize(sw, sh);
      this.depthHalfTargetTransparent.setSize(hw, hh);
      this.depthQuarterTargetTransparent.setSize(qw, qh);
      ValueCell.update(this.downsampleDepthRenderableTransparent.values.uTexSize, Vec2.set(this.downsampleDepthRenderableTransparent.values.uTexSize.ref.value, sw, sh));
      ValueCell.update(this.depthHalfRenderableTransparent.values.uTexSize, Vec2.set(this.depthHalfRenderableTransparent.values.uTexSize.ref.value, hw, hh));
      ValueCell.update(this.depthQuarterRenderableTransparent.values.uTexSize, Vec2.set(this.depthQuarterRenderableTransparent.values.uTexSize.ref.value, qw, qh));
      ValueCell.update(this.renderable.values.uTexSize, Vec2.set(this.renderable.values.uTexSize.ref.value, sw, sh));
      ValueCell.update(this.blurFirstPassRenderable.values.uTexSize, Vec2.set(this.blurFirstPassRenderable.values.uTexSize.ref.value, sw, sh));
      ValueCell.update(this.blurSecondPassRenderable.values.uTexSize, Vec2.set(this.blurSecondPassRenderable.values.uTexSize.ref.value, sw, sh));
      const depthTexture = this.getDepthTexture();
      const transparentDepthTexture = this.getTransparentDepthTexture();
      ValueCell.update(this.depthHalfRenderableOpaque.values.tColor, depthTexture);
      ValueCell.update(this.depthHalfRenderableTransparent.values.tColor, transparentDepthTexture);
      ValueCell.update(this.renderable.values.tDepth, depthTexture);
      ValueCell.update(this.renderable.values.tDepthTransparent, transparentDepthTexture);
      this.depthHalfRenderableOpaque.update();
      this.depthHalfRenderableTransparent.update();
      this.renderable.update();
    }
  }
  reset() {
    this.ssaoDepthTexture.attachFramebuffer(this.framebuffer, "color0");
    this.depthBlurProxyTexture.attachFramebuffer(this.blurFirstPassFramebuffer, "color0");
  }
  update(camera, scene, props, illuminationMode = false) {
    let needsUpdateSsao = false;
    let needsUpdateSsaoBlur = false;
    let needsUpdateDepthHalf = false;
    const orthographic = camera.state.mode === "orthographic" ? 1 : 0;
    const invProjection = Mat4.identity();
    Mat4.invert(invProjection, camera.projection);
    const [w, h] = this.texSize;
    const v3 = camera.viewport;
    ValueCell.update(this.renderable.values.uProjection, camera.projection);
    ValueCell.update(this.renderable.values.uInvProjection, invProjection);
    const b5 = this.renderable.values.uBounds;
    const s = this.ssaoScale;
    Vec4.set(b5.ref.value, Math.floor(v3.x * s) / (w * s), Math.floor(v3.y * s) / (h * s), Math.ceil((v3.x + v3.width) * s) / (w * s), Math.ceil((v3.y + v3.height) * s) / (h * s));
    ValueCell.update(b5, b5.ref.value);
    ValueCell.update(this.blurFirstPassRenderable.values.uBounds, b5.ref.value);
    ValueCell.update(this.blurSecondPassRenderable.values.uBounds, b5.ref.value);
    ValueCell.updateIfChanged(this.blurFirstPassRenderable.values.uNear, camera.near);
    ValueCell.updateIfChanged(this.blurSecondPassRenderable.values.uNear, camera.near);
    ValueCell.updateIfChanged(this.blurFirstPassRenderable.values.uFar, camera.far);
    ValueCell.updateIfChanged(this.blurSecondPassRenderable.values.uFar, camera.far);
    ValueCell.update(this.blurFirstPassRenderable.values.uInvProjection, invProjection);
    ValueCell.update(this.blurSecondPassRenderable.values.uInvProjection, invProjection);
    ValueCell.update(this.blurFirstPassRenderable.values.uBlurDepthBias, props.blurDepthBias);
    ValueCell.update(this.blurSecondPassRenderable.values.uBlurDepthBias, props.blurDepthBias);
    if (this.blurFirstPassRenderable.values.dOrthographic.ref.value !== orthographic) {
      needsUpdateSsaoBlur = true;
      ValueCell.update(this.blurFirstPassRenderable.values.dOrthographic, orthographic);
      ValueCell.update(this.blurSecondPassRenderable.values.dOrthographic, orthographic);
    }
    const includeTransparent = _SsaoPass.isTransparentEnabled(scene, props);
    if (this.renderable.values.dIncludeTransparent.ref.value !== includeTransparent) {
      needsUpdateSsao = true;
      ValueCell.update(this.renderable.values.dIncludeTransparent, includeTransparent);
    }
    if (this.renderable.values.dIllumination.ref.value !== illuminationMode) {
      needsUpdateSsao = true;
      ValueCell.update(this.renderable.values.dIllumination, illuminationMode);
    }
    if (this.nSamples !== props.samples) {
      needsUpdateSsao = true;
      this.nSamples = props.samples;
      ValueCell.update(this.renderable.values.uSamples, getSamples2(this.nSamples));
      ValueCell.updateIfChanged(this.renderable.values.dNSamples, this.nSamples);
    }
    const multiScale = props.multiScale.name === "on";
    if (this.renderable.values.dMultiScale.ref.value !== multiScale) {
      needsUpdateSsao = true;
      ValueCell.update(this.renderable.values.dMultiScale, multiScale);
    }
    if (props.multiScale.name === "on") {
      const mp = props.multiScale.params;
      if (!deepEqual(this.levels, mp.levels)) {
        needsUpdateSsao = true;
        this.levels = mp.levels;
        const levels = getLevels(mp.levels);
        ValueCell.updateIfChanged(this.renderable.values.dLevels, levels.count);
        ValueCell.update(this.renderable.values.uLevelRadius, levels.radius);
        ValueCell.update(this.renderable.values.uLevelBias, levels.bias);
      }
      ValueCell.updateIfChanged(this.renderable.values.uNearThreshold, mp.nearThreshold);
      ValueCell.updateIfChanged(this.renderable.values.uFarThreshold, mp.farThreshold);
    } else {
      ValueCell.updateIfChanged(this.renderable.values.uRadius, Math.pow(2, props.radius));
    }
    ValueCell.updateIfChanged(this.renderable.values.uBias, props.bias);
    if (this.blurKernelSize !== props.blurKernelSize) {
      needsUpdateSsaoBlur = true;
      this.blurKernelSize = props.blurKernelSize;
      const kernel = getBlurKernel(this.blurKernelSize);
      ValueCell.update(this.blurFirstPassRenderable.values.uKernel, kernel);
      ValueCell.update(this.blurSecondPassRenderable.values.uKernel, kernel);
      ValueCell.update(this.blurFirstPassRenderable.values.dOcclusionKernelSize, this.blurKernelSize);
      ValueCell.update(this.blurSecondPassRenderable.values.dOcclusionKernelSize, this.blurKernelSize);
    }
    const ssaoScale = this.calcSsaoScale(props.resolutionScale);
    if (this.ssaoScale !== ssaoScale) {
      needsUpdateSsao = true;
      needsUpdateDepthHalf = true;
      this.ssaoScale = ssaoScale;
      const sw = Math.floor(w * this.ssaoScale);
      const sh = Math.floor(h * this.ssaoScale);
      this.ssaoDepthTexture.define(sw, sh);
      this.ssaoDepthTransparentTexture.define(sw, sh);
      this.depthBlurProxyTexture.define(sw, sh);
      const hw = Math.floor(sw * 0.5);
      const hh = Math.floor(sh * 0.5);
      const qw = Math.floor(sw * 0.25);
      const qh = Math.floor(sh * 0.25);
      this.downsampledDepthTargetOpaque.setSize(sw, sh);
      this.depthHalfTargetOpaque.setSize(hw, hh);
      this.depthQuarterTargetOpaque.setSize(qw, qh);
      const depthTexture = this.getDepthTexture();
      ValueCell.update(this.depthHalfRenderableOpaque.values.tColor, depthTexture);
      ValueCell.update(this.renderable.values.tDepth, depthTexture);
      ValueCell.update(this.renderable.values.tDepthHalf, this.depthHalfTargetOpaque.texture);
      ValueCell.update(this.renderable.values.tDepthQuarter, this.depthQuarterTargetOpaque.texture);
      ValueCell.update(this.downsampleDepthRenderableOpaque.values.uTexSize, Vec2.set(this.downsampleDepthRenderableOpaque.values.uTexSize.ref.value, sw, sh));
      ValueCell.update(this.depthHalfRenderableOpaque.values.uTexSize, Vec2.set(this.depthHalfRenderableOpaque.values.uTexSize.ref.value, hw, hh));
      ValueCell.update(this.depthQuarterRenderableOpaque.values.uTexSize, Vec2.set(this.depthQuarterRenderableOpaque.values.uTexSize.ref.value, qw, qh));
      this.downsampledDepthTargetTransparent.setSize(sw, sh);
      this.depthHalfTargetTransparent.setSize(hw, hh);
      this.depthQuarterTargetTransparent.setSize(qw, qh);
      const transparentDepthTexture = this.getTransparentDepthTexture();
      ValueCell.update(this.depthHalfRenderableTransparent.values.tColor, transparentDepthTexture);
      ValueCell.update(this.renderable.values.tDepthTransparent, transparentDepthTexture);
      ValueCell.update(this.renderable.values.tDepthHalfTransparent, this.depthHalfTargetTransparent.texture);
      ValueCell.update(this.renderable.values.tDepthQuarterTransparent, this.depthQuarterTargetTransparent.texture);
      ValueCell.update(this.downsampleDepthRenderableTransparent.values.uTexSize, Vec2.set(this.downsampleDepthRenderableTransparent.values.uTexSize.ref.value, sw, sh));
      ValueCell.update(this.depthHalfRenderableTransparent.values.uTexSize, Vec2.set(this.depthHalfRenderableTransparent.values.uTexSize.ref.value, hw, hh));
      ValueCell.update(this.depthQuarterRenderableTransparent.values.uTexSize, Vec2.set(this.depthQuarterRenderableTransparent.values.uTexSize.ref.value, qw, qh));
      ValueCell.update(this.renderable.values.uTexSize, Vec2.set(this.renderable.values.uTexSize.ref.value, sw, sh));
      ValueCell.update(this.blurFirstPassRenderable.values.uTexSize, Vec2.set(this.blurFirstPassRenderable.values.uTexSize.ref.value, sw, sh));
      ValueCell.update(this.blurSecondPassRenderable.values.uTexSize, Vec2.set(this.blurSecondPassRenderable.values.uTexSize.ref.value, sw, sh));
    }
    if (needsUpdateSsao) {
      this.renderable.update();
    }
    if (needsUpdateSsaoBlur) {
      this.blurFirstPassRenderable.update();
      this.blurSecondPassRenderable.update();
    }
    if (needsUpdateDepthHalf) {
      this.depthHalfRenderableOpaque.update();
      this.depthHalfRenderableTransparent.update();
    }
  }
  render(camera) {
    if (isTimingMode)
      this.webgl.timer.mark("SSAO.render");
    const { state } = this.webgl;
    const { x, y, width, height } = camera.viewport;
    const includeTransparent = this.renderable.values.dIncludeTransparent.ref.value;
    const multiScale = this.renderable.values.dMultiScale.ref.value;
    const sx = Math.floor(x * this.ssaoScale);
    const sy = Math.floor(y * this.ssaoScale);
    const sw = Math.ceil(width * this.ssaoScale);
    const sh = Math.ceil(height * this.ssaoScale);
    state.viewport(sx, sy, sw, sh);
    state.scissor(sx, sy, sw, sh);
    if (this.ssaoScale < 1) {
      if (isTimingMode)
        this.webgl.timer.mark("SSAO.downsample");
      this.downsampledDepthTargetOpaque.bind();
      this.downsampleDepthRenderableOpaque.render();
      if (includeTransparent) {
        this.downsampledDepthTargetTransparent.bind();
        this.downsampleDepthRenderableTransparent.render();
      }
      if (isTimingMode)
        this.webgl.timer.markEnd("SSAO.downsample");
    }
    if (isTimingMode)
      this.webgl.timer.mark("SSAO.half");
    if (multiScale) {
      this.depthHalfTargetOpaque.bind();
      this.depthHalfRenderableOpaque.render();
    }
    if (multiScale && includeTransparent) {
      this.depthHalfTargetTransparent.bind();
      this.depthHalfRenderableTransparent.render();
    }
    if (isTimingMode)
      this.webgl.timer.markEnd("SSAO.half");
    if (isTimingMode)
      this.webgl.timer.mark("SSAO.quarter");
    if (multiScale) {
      this.depthQuarterTargetOpaque.bind();
      this.depthQuarterRenderableOpaque.render();
    }
    if (multiScale && includeTransparent) {
      this.depthQuarterTargetTransparent.bind();
      this.depthQuarterRenderableTransparent.render();
    }
    if (isTimingMode)
      this.webgl.timer.markEnd("SSAO.quarter");
    if (isTimingMode)
      this.webgl.timer.mark("SSAO.opaque");
    this.ssaoDepthTexture.attachFramebuffer(this.framebuffer, "color0");
    ValueCell.update(this.renderable.values.uTransparencyFlag, 0);
    this.framebuffer.bind();
    this.renderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("SSAO.opaque");
    if (isTimingMode)
      this.webgl.timer.mark("SSAO.blurOpaque");
    ValueCell.update(this.blurFirstPassRenderable.values.tSsaoDepth, this.ssaoDepthTexture);
    this.blurFirstPassRenderable.update();
    this.blurFirstPassFramebuffer.bind();
    this.blurFirstPassRenderable.render();
    this.ssaoDepthTexture.attachFramebuffer(this.blurSecondPassFramebuffer, "color0");
    this.blurSecondPassFramebuffer.bind();
    this.blurSecondPassRenderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("SSAO.blurOpaque");
    if (includeTransparent) {
      if (isTimingMode)
        this.webgl.timer.mark("SSAO.transparent ");
      this.ssaoDepthTransparentTexture.attachFramebuffer(this.framebuffer, "color0");
      ValueCell.update(this.renderable.values.uTransparencyFlag, 1);
      this.framebuffer.bind();
      this.renderable.render();
      if (isTimingMode)
        this.webgl.timer.markEnd("SSAO.transparent ");
      if (isTimingMode)
        this.webgl.timer.mark("SSAO.blurTransparent ");
      ValueCell.update(this.blurFirstPassRenderable.values.tSsaoDepth, this.ssaoDepthTransparentTexture);
      this.blurFirstPassRenderable.update();
      this.blurFirstPassFramebuffer.bind();
      this.blurFirstPassRenderable.render();
      this.ssaoDepthTransparentTexture.attachFramebuffer(this.blurSecondPassFramebuffer, "color0");
      this.blurSecondPassFramebuffer.bind();
      this.blurSecondPassRenderable.render();
      if (isTimingMode)
        this.webgl.timer.markEnd("SSAO.blurTransparent ");
    }
    if (isTimingMode)
      this.webgl.timer.markEnd("SSAO.render");
  }
};
var SsaoSchema = {
  ...QuadSchema,
  tDepth: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tDepthHalf: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tDepthQuarter: TextureSpec("texture", "rgba", "ubyte", "linear"),
  dIllumination: DefineSpec("boolean"),
  uTransparencyFlag: UniformSpec("i"),
  dIncludeTransparent: DefineSpec("boolean"),
  tDepthTransparent: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tDepthHalfTransparent: TextureSpec("texture", "rgba", "ubyte", "linear"),
  tDepthQuarterTransparent: TextureSpec("texture", "rgba", "ubyte", "linear"),
  uSamples: UniformSpec("v3[]"),
  dNSamples: DefineSpec("number"),
  uProjection: UniformSpec("m4"),
  uInvProjection: UniformSpec("m4"),
  uBounds: UniformSpec("v4"),
  uTexSize: UniformSpec("v2"),
  uRadius: UniformSpec("f"),
  uBias: UniformSpec("f"),
  dMultiScale: DefineSpec("boolean"),
  dLevels: DefineSpec("number"),
  uLevelRadius: UniformSpec("f[]"),
  uLevelBias: UniformSpec("f[]"),
  uNearThreshold: UniformSpec("f"),
  uFarThreshold: UniformSpec("f")
};
function getSsaoRenderable(ctx, depthTexture, depthHalfTexture, depthQuarterTexture, transparentDepthTexture, transparentDepthHalfTexture, transparentDepthQuarterTexture) {
  const values2 = {
    ...QuadValues,
    tDepth: ValueCell.create(depthTexture),
    tDepthHalf: ValueCell.create(depthHalfTexture),
    tDepthQuarter: ValueCell.create(depthQuarterTexture),
    dIllumination: ValueCell.create(false),
    dIncludeTransparent: ValueCell.create(true),
    uTransparencyFlag: ValueCell.create(0),
    tDepthTransparent: ValueCell.create(transparentDepthTexture),
    tDepthHalfTransparent: ValueCell.create(transparentDepthHalfTexture),
    tDepthQuarterTransparent: ValueCell.create(transparentDepthQuarterTexture),
    uSamples: ValueCell.create(getSamples2(32)),
    dNSamples: ValueCell.create(32),
    uProjection: ValueCell.create(Mat4.identity()),
    uInvProjection: ValueCell.create(Mat4.identity()),
    uBounds: ValueCell.create(Vec4()),
    uTexSize: ValueCell.create(Vec2.create(ctx.gl.drawingBufferWidth, ctx.gl.drawingBufferHeight)),
    uRadius: ValueCell.create(Math.pow(2, 5)),
    uBias: ValueCell.create(0.8),
    dMultiScale: ValueCell.create(false),
    dLevels: ValueCell.create(3),
    uLevelRadius: ValueCell.create([Math.pow(2, 2), Math.pow(2, 5), Math.pow(2, 8)]),
    uLevelBias: ValueCell.create([0.8, 0.8, 0.8]),
    uNearThreshold: ValueCell.create(10),
    uFarThreshold: ValueCell.create(1500)
  };
  const schema = { ...SsaoSchema };
  const shaderCode = ShaderCode("ssao", quad_vert, ssao_frag);
  const renderItem = createComputeRenderItem(ctx, "triangles", shaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var SsaoBlurSchema = {
  ...QuadSchema,
  tSsaoDepth: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSize: UniformSpec("v2"),
  uKernel: UniformSpec("f[]"),
  dOcclusionKernelSize: DefineSpec("number"),
  uBlurDepthBias: UniformSpec("f"),
  uBlurDirectionX: UniformSpec("f"),
  uBlurDirectionY: UniformSpec("f"),
  uInvProjection: UniformSpec("m4"),
  uNear: UniformSpec("f"),
  uFar: UniformSpec("f"),
  uBounds: UniformSpec("v4"),
  dOrthographic: DefineSpec("number")
};
function getSsaoBlurRenderable(ctx, ssaoDepthTexture, direction) {
  const values2 = {
    ...QuadValues,
    tSsaoDepth: ValueCell.create(ssaoDepthTexture),
    uTexSize: ValueCell.create(Vec2.create(ssaoDepthTexture.getWidth(), ssaoDepthTexture.getHeight())),
    uKernel: ValueCell.create(getBlurKernel(15)),
    dOcclusionKernelSize: ValueCell.create(15),
    uBlurDepthBias: ValueCell.create(0.5),
    uBlurDirectionX: ValueCell.create(direction === "horizontal" ? 1 : 0),
    uBlurDirectionY: ValueCell.create(direction === "vertical" ? 1 : 0),
    uInvProjection: ValueCell.create(Mat4.identity()),
    uNear: ValueCell.create(0),
    uFar: ValueCell.create(1e4),
    uBounds: ValueCell.create(Vec4()),
    dOrthographic: ValueCell.create(0)
  };
  const schema = { ...SsaoBlurSchema };
  const shaderCode = ShaderCode("ssao_blur", quad_vert, ssaoBlur_frag);
  const renderItem = createComputeRenderItem(ctx, "triangles", shaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
function getBlurKernel(kernelSize) {
  const sigma = kernelSize / 3;
  const halfKernelSize = Math.floor((kernelSize + 1) / 2);
  const kernel = [];
  for (let x = 0; x < halfKernelSize; x++) {
    kernel.push(1 / (Math.sqrt(2 * Math.PI) * sigma) * Math.exp(-x * x / (2 * sigma * sigma)));
  }
  return kernel;
}
var RandomHemisphereVector = [];
for (let i = 0; i < 256; i++) {
  const v3 = Vec3();
  v3[0] = Math.random() * 2 - 1;
  v3[1] = Math.random() * 2 - 1;
  v3[2] = Math.random();
  Vec3.normalize(v3, v3);
  Vec3.scale(v3, v3, Math.random());
  RandomHemisphereVector.push(v3);
}
function getSamples2(nSamples) {
  const samples = [];
  for (let i = 0; i < nSamples; i++) {
    let scale = (i * i + 2 * i + 1) / (nSamples * nSamples);
    scale = 0.1 + scale * (1 - 0.1);
    samples.push(RandomHemisphereVector[i][0] * scale);
    samples.push(RandomHemisphereVector[i][1] * scale);
    samples.push(RandomHemisphereVector[i][2] * scale);
  }
  return samples;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/postprocessing.js
var PostprocessingSchema = {
  ...QuadSchema,
  tSsaoDepth: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tSsaoDepthTransparent: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tColor: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tTransparentColor: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  dBlendTransparency: DefineSpec("boolean"),
  tDepthOpaque: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tDepthTransparent: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tShadows: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tOutlines: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSize: UniformSpec("v2"),
  dOrthographic: DefineSpec("number"),
  uNear: UniformSpec("f"),
  uFar: UniformSpec("f"),
  uFogNear: UniformSpec("f"),
  uFogFar: UniformSpec("f"),
  uFogColor: UniformSpec("v3"),
  uOutlineColor: UniformSpec("v3"),
  uOcclusionColor: UniformSpec("v3"),
  uTransparentBackground: UniformSpec("b"),
  dOcclusionEnable: DefineSpec("boolean"),
  dOcclusionSingleDepth: DefineSpec("boolean"),
  dOcclusionIncludeOpacity: DefineSpec("boolean"),
  dOcclusionIncludeTransparency: DefineSpec("boolean"),
  uOcclusionOffset: UniformSpec("v2"),
  dShadowEnable: DefineSpec("boolean"),
  dOutlineEnable: DefineSpec("boolean"),
  dOutlineScale: DefineSpec("number"),
  dTransparentOutline: DefineSpec("boolean")
};
function getPostprocessingRenderable(ctx, colorTexture, transparentColorTexture, depthTextureOpaque, depthTextureTransparent, shadowsTexture, outlinesTexture, ssaoDepthTexture, ssaoDepthTransparentTexture, transparentOutline) {
  const values2 = {
    ...QuadValues,
    tSsaoDepth: ValueCell.create(ssaoDepthTexture),
    tSsaoDepthTransparent: ValueCell.create(ssaoDepthTransparentTexture),
    tColor: ValueCell.create(colorTexture),
    tTransparentColor: ValueCell.create(transparentColorTexture),
    dBlendTransparency: ValueCell.create(true),
    tDepthOpaque: ValueCell.create(depthTextureOpaque),
    tDepthTransparent: ValueCell.create(depthTextureTransparent),
    tShadows: ValueCell.create(shadowsTexture),
    tOutlines: ValueCell.create(outlinesTexture),
    uTexSize: ValueCell.create(Vec2.create(colorTexture.getWidth(), colorTexture.getHeight())),
    dOrthographic: ValueCell.create(0),
    uNear: ValueCell.create(1),
    uFar: ValueCell.create(1e4),
    uFogNear: ValueCell.create(1e4),
    uFogFar: ValueCell.create(1e4),
    uFogColor: ValueCell.create(Vec3.create(1, 1, 1)),
    uOutlineColor: ValueCell.create(Vec3.create(0, 0, 0)),
    uOcclusionColor: ValueCell.create(Vec3.create(0, 0, 0)),
    uTransparentBackground: ValueCell.create(false),
    dOcclusionEnable: ValueCell.create(true),
    dOcclusionSingleDepth: ValueCell.create(false),
    dOcclusionIncludeOpacity: ValueCell.create(true),
    dOcclusionIncludeTransparency: ValueCell.create(false),
    uOcclusionOffset: ValueCell.create(Vec2.create(0, 0)),
    dShadowEnable: ValueCell.create(false),
    dOutlineEnable: ValueCell.create(false),
    dOutlineScale: ValueCell.create(1),
    dTransparentOutline: ValueCell.create(transparentOutline)
  };
  const schema = { ...PostprocessingSchema };
  const shaderCode = ShaderCode("postprocessing", quad_vert, postprocessing_frag);
  const renderItem = createComputeRenderItem(ctx, "triangles", shaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var PostprocessingParams = {
  occlusion: ParamDefinition.MappedStatic("on", {
    on: ParamDefinition.Group(SsaoParams),
    off: ParamDefinition.Group({})
  }, { cycle: true, description: "Darken occluded crevices with the ambient occlusion effect" }),
  shadow: ParamDefinition.MappedStatic("off", {
    on: ParamDefinition.Group(ShadowParams),
    off: ParamDefinition.Group({})
  }, { cycle: true, description: "Simplistic shadows" }),
  outline: ParamDefinition.MappedStatic("off", {
    on: ParamDefinition.Group(OutlineParams),
    off: ParamDefinition.Group({})
  }, { cycle: true, description: "Draw outline around 3D objects" }),
  dof: ParamDefinition.MappedStatic("off", {
    on: ParamDefinition.Group(DofParams),
    off: ParamDefinition.Group({})
  }, { cycle: true, description: "DOF" }),
  antialiasing: ParamDefinition.MappedStatic("smaa", {
    fxaa: ParamDefinition.Group(FxaaParams),
    smaa: ParamDefinition.Group(SmaaParams),
    off: ParamDefinition.Group({})
  }, { options: [["fxaa", "FXAA"], ["smaa", "SMAA"], ["off", "Off"]], description: "Smooth pixel edges" }),
  sharpening: ParamDefinition.MappedStatic("off", {
    on: ParamDefinition.Group(CasParams),
    off: ParamDefinition.Group({})
  }, { cycle: true, description: "Contrast Adaptive Sharpening" }),
  background: ParamDefinition.Group(BackgroundParams, { isFlat: true }),
  bloom: ParamDefinition.MappedStatic("on", {
    on: ParamDefinition.Group(BloomParams),
    off: ParamDefinition.Group({})
  }, { cycle: true, description: "Bloom" })
};
var PostprocessingPass = class _PostprocessingPass {
  static isEnabled(props) {
    return SsaoPass.isEnabled(props) || ShadowPass.isEnabled(props) || OutlinePass.isEnabled(props) || props.background.variant.name !== "off";
  }
  static isTransparentDepthRequired(scene, props) {
    return DofPass.isEnabled(props) || OutlinePass.isEnabled(props) && _PostprocessingPass.isTransparentOutlineEnabled(props) || SsaoPass.isEnabled(props) && _PostprocessingPass.isTransparentSsaoEnabled(scene, props);
  }
  static isTransparentOutlineEnabled(props) {
    var _a;
    return OutlinePass.isEnabled(props) && ((_a = props.outline.params.includeTransparent) !== null && _a !== void 0 ? _a : true);
  }
  static isTransparentSsaoEnabled(scene, props) {
    return SsaoPass.isEnabled(props) && SsaoPass.isTransparentEnabled(scene, props.occlusion.params);
  }
  static isSsaoEnabled(props) {
    return SsaoPass.isEnabled(props);
  }
  constructor(webgl, assetManager, drawPass) {
    this.webgl = webgl;
    this.drawPass = drawPass;
    this.occlusionOffset = [0, 0];
    this.transparentBackground = false;
    const { colorTarget, transparentColorTarget, depthTextureOpaque, depthTextureTransparent, packedDepth } = drawPass;
    const width = colorTarget.getWidth();
    const height = colorTarget.getHeight();
    this.target = webgl.createRenderTarget(width, height, false, "uint8", "linear");
    this.ssao = new SsaoPass(webgl, width, height, packedDepth, depthTextureOpaque, depthTextureTransparent);
    this.shadow = new ShadowPass(webgl, width, height, depthTextureOpaque);
    this.outline = new OutlinePass(webgl, width, height, depthTextureTransparent, depthTextureOpaque);
    this.renderable = getPostprocessingRenderable(webgl, colorTarget.texture, transparentColorTarget.texture, depthTextureOpaque, depthTextureTransparent, this.shadow.target.texture, this.outline.target.texture, this.ssao.ssaoDepthTexture, this.ssao.ssaoDepthTransparentTexture, true);
    this.background = new BackgroundPass(webgl, assetManager, width, height);
  }
  setSize(width, height) {
    const [w, h] = this.renderable.values.uTexSize.ref.value;
    if (width !== w || height !== h) {
      this.target.setSize(width, height);
      ValueCell.update(this.renderable.values.uTexSize, Vec2.set(this.renderable.values.uTexSize.ref.value, width, height));
    }
    this.ssao.setSize(width, height);
    this.shadow.setSize(width, height);
    this.outline.setSize(width, height);
    this.background.setSize(width, height);
  }
  reset() {
    this.ssao.reset();
  }
  updateState(camera, scene, transparentBackground, backgroundColor, props, light, ambientColor) {
    let needsUpdateMain = false;
    const orthographic = camera.state.mode === "orthographic" ? 1 : 0;
    const outlinesEnabled = OutlinePass.isEnabled(props);
    const shadowsEnabled = ShadowPass.isEnabled(props);
    const occlusionEnabled = SsaoPass.isEnabled(props);
    if (occlusionEnabled) {
      const params = props.occlusion.params;
      this.ssao.update(camera, scene, params);
      const includeTransparency = SsaoPass.isTransparentEnabled(scene, params);
      if (this.renderable.values.dOcclusionIncludeTransparency.ref.value !== includeTransparency) {
        needsUpdateMain = true;
        ValueCell.update(this.renderable.values.dOcclusionIncludeTransparency, includeTransparency);
      }
      ValueCell.update(this.renderable.values.uOcclusionColor, Color.toVec3Normalized(this.renderable.values.uOcclusionColor.ref.value, params.color));
    }
    if (shadowsEnabled) {
      this.shadow.update(camera, light, ambientColor, props.shadow.params);
    }
    if (outlinesEnabled) {
      const outlineProps = props.outline.params;
      const { transparentOutline, outlineScale } = this.outline.update(camera, outlineProps, this.drawPass.depthTextureTransparent, this.drawPass.depthTextureOpaque);
      ValueCell.update(this.renderable.values.uOutlineColor, Color.toVec3Normalized(this.renderable.values.uOutlineColor.ref.value, outlineProps.color));
      if (this.renderable.values.dOutlineScale.ref.value !== outlineScale) {
        needsUpdateMain = true;
        ValueCell.update(this.renderable.values.dOutlineScale, outlineScale);
      }
      if (this.renderable.values.dTransparentOutline.ref.value !== transparentOutline) {
        needsUpdateMain = true;
        ValueCell.update(this.renderable.values.dTransparentOutline, transparentOutline);
      }
    }
    ValueCell.updateIfChanged(this.renderable.values.uFar, camera.far);
    ValueCell.updateIfChanged(this.renderable.values.uNear, camera.near);
    ValueCell.updateIfChanged(this.renderable.values.uFogFar, camera.fogFar);
    ValueCell.updateIfChanged(this.renderable.values.uFogNear, camera.fogNear);
    ValueCell.update(this.renderable.values.uFogColor, Color.toVec3Normalized(this.renderable.values.uFogColor.ref.value, backgroundColor));
    ValueCell.updateIfChanged(this.renderable.values.uTransparentBackground, transparentBackground);
    if (this.renderable.values.dOrthographic.ref.value !== orthographic) {
      needsUpdateMain = true;
      ValueCell.update(this.renderable.values.dOrthographic, orthographic);
    }
    if (this.renderable.values.dOutlineEnable.ref.value !== outlinesEnabled) {
      needsUpdateMain = true;
      ValueCell.update(this.renderable.values.dOutlineEnable, outlinesEnabled);
    }
    if (this.renderable.values.dShadowEnable.ref.value !== shadowsEnabled) {
      needsUpdateMain = true;
      ValueCell.update(this.renderable.values.dShadowEnable, shadowsEnabled);
    }
    if (this.renderable.values.dOcclusionEnable.ref.value !== occlusionEnabled) {
      needsUpdateMain = true;
      ValueCell.update(this.renderable.values.dOcclusionEnable, occlusionEnabled);
    }
    const blendTransparency = scene.opacityAverage < 1;
    if (this.renderable.values.dBlendTransparency.ref.value !== blendTransparency) {
      needsUpdateMain = true;
      ValueCell.update(this.renderable.values.dBlendTransparency, blendTransparency);
    }
    if (needsUpdateMain) {
      this.renderable.update();
    }
    const { gl, state } = this.webgl;
    state.enable(gl.SCISSOR_TEST);
    state.disable(gl.BLEND);
    state.disable(gl.DEPTH_TEST);
    state.depthMask(false);
  }
  setOcclusionOffset(x, y) {
    this.occlusionOffset[0] = x;
    this.occlusionOffset[1] = y;
    ValueCell.update(this.renderable.values.uOcclusionOffset, Vec2.set(this.renderable.values.uOcclusionOffset.ref.value, x, y));
  }
  setTransparentBackground(value) {
    this.transparentBackground = value;
  }
  render(camera, scene, toDrawingBuffer, transparentBackground, backgroundColor, props, light, ambientColor) {
    if (isTimingMode)
      this.webgl.timer.mark("PostprocessingPass.render");
    this.updateState(camera, scene, transparentBackground, backgroundColor, props, light, ambientColor);
    const { state } = this.webgl;
    const { x, y, width, height } = camera.viewport;
    if (props.occlusion.name === "on" && this.occlusionOffset[0] === 0 && this.occlusionOffset[1] === 0) {
      this.ssao.render(camera);
    }
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    if (props.outline.name === "on") {
      this.outline.render();
    }
    if (props.shadow.name === "on") {
      this.shadow.render();
    }
    if (toDrawingBuffer) {
      this.webgl.unbindFramebuffer();
    } else {
      this.target.bind();
    }
    this.background.update(camera, props.background);
    this.background.clear(props.background, this.transparentBackground, backgroundColor);
    this.background.render(props.background);
    this.renderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("PostprocessingPass.render");
  }
};
var AntialiasingPass = class {
  static isEnabled(props) {
    return props.antialiasing.name !== "off";
  }
  constructor(webgl, width, height) {
    this.target = webgl.createRenderTarget(width, height, false);
    this.internalTarget = webgl.createRenderTarget(width, height, false);
    this.fxaa = new FxaaPass(webgl, this.target.texture);
    this.smaa = new SmaaPass(webgl, this.target.texture);
    this.cas = new CasPass(webgl, this.target.texture);
  }
  setSize(width, height) {
    const w = this.target.texture.getWidth();
    const h = this.target.texture.getHeight();
    if (width !== w || height !== h) {
      this.target.setSize(width, height);
      this.internalTarget.setSize(width, height);
      this.fxaa.setSize(width, height);
      if (this.smaa.supported)
        this.smaa.setSize(width, height);
      this.cas.setSize(width, height);
    }
  }
  _renderFxaa(camera, input, target, props) {
    if (props.antialiasing.name !== "fxaa")
      return;
    this.fxaa.update(input, props.antialiasing.params);
    this.fxaa.render(camera.viewport, target);
  }
  _renderSmaa(camera, input, target, props) {
    if (props.antialiasing.name !== "smaa")
      return;
    this.smaa.update(input, props.antialiasing.params);
    this.smaa.render(camera.viewport, target);
  }
  _renderAntialiasing(camera, input, target, props) {
    if (props.antialiasing.name === "fxaa") {
      this._renderFxaa(camera, input, target, props);
    } else if (props.antialiasing.name === "smaa") {
      this._renderSmaa(camera, input, target, props);
    }
  }
  _renderCas(camera, input, target, props) {
    if (props.sharpening.name !== "on")
      return;
    if (props.antialiasing.name !== "off")
      input = this.internalTarget.texture;
    this.cas.update(input, props.sharpening.params);
    this.cas.render(camera.viewport, target);
  }
  render(camera, input, toDrawingBuffer, props) {
    if (props.antialiasing.name === "off" && props.sharpening.name === "off")
      return;
    if (props.antialiasing.name === "smaa" && !this.smaa.supported) {
      console.error('SMAA not supported, missing "HTMLImageElement"');
      return;
    }
    const target = toDrawingBuffer === true ? void 0 : toDrawingBuffer === false ? this.target : toDrawingBuffer;
    if (props.sharpening.name === "off") {
      this._renderAntialiasing(camera, input, target, props);
    } else if (props.antialiasing.name === "off") {
      this._renderCas(camera, input, target, props);
    } else {
      this._renderAntialiasing(camera, input, this.internalTarget, props);
      this._renderCas(camera, input, target, props);
    }
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/compose.frag.js
var compose_frag = `
precision highp float;
precision highp sampler2D;

uniform sampler2D tColor;
uniform vec2 uTexSize;
uniform float uWeight;

void main() {
    vec2 coords = gl_FragCoord.xy / uTexSize;
    gl_FragColor = texture2D(tColor, coords) * uWeight;
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/multi-sample.js
var ComposeSchema = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSize: UniformSpec("v2"),
  uWeight: UniformSpec("f")
};
var ComposeShaderCode = ShaderCode("compose", quad_vert, compose_frag);
function getComposeRenderable(ctx, colorTexture) {
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(colorTexture),
    uTexSize: ValueCell.create(Vec2.create(colorTexture.getWidth(), colorTexture.getHeight())),
    uWeight: ValueCell.create(1)
  };
  const schema = { ...ComposeSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", ComposeShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var MultiSampleParams = {
  mode: ParamDefinition.Select("temporal", [["off", "Off"], ["on", "On"], ["temporal", "Temporal"]]),
  sampleLevel: ParamDefinition.Numeric(2, { min: 0, max: 5, step: 1 }, { description: "Take level^2 samples." }),
  reduceFlicker: ParamDefinition.Boolean(true, { description: 'Reduce flicker in "temporal" mode.' }),
  reuseOcclusion: ParamDefinition.Boolean(true, { description: "Reuse occlusion data. It is faster but has some artefacts." })
};
var MultiSamplePass = class {
  static isEnabled(props) {
    return props.mode !== "off";
  }
  constructor(webgl, drawPass) {
    this.webgl = webgl;
    this.drawPass = drawPass;
    const { colorBufferFloat, textureFloat, colorBufferHalfFloat, textureHalfFloat } = webgl.extensions;
    const width = drawPass.colorTarget.getWidth();
    const height = drawPass.colorTarget.getHeight();
    this.colorTarget = webgl.createRenderTarget(width, height, false);
    const type = colorBufferHalfFloat && textureHalfFloat ? "fp16" : colorBufferFloat && textureFloat ? "float32" : "uint8";
    this.composeTarget = webgl.createRenderTarget(width, height, false, type);
    this.holdTarget = webgl.createRenderTarget(width, height, false);
    this.compose = getComposeRenderable(webgl, drawPass.colorTarget.texture);
  }
  syncSize() {
    const width = this.drawPass.colorTarget.getWidth();
    const height = this.drawPass.colorTarget.getHeight();
    const [w, h] = this.compose.values.uTexSize.ref.value;
    if (width !== w || height !== h) {
      this.colorTarget.setSize(width, height);
      this.composeTarget.setSize(width, height);
      this.holdTarget.setSize(width, height);
      ValueCell.update(this.compose.values.uTexSize, Vec2.set(this.compose.values.uTexSize.ref.value, width, height));
    }
  }
  render(sampleIndex, ctx, props, toDrawingBuffer, forceOn) {
    if (props.multiSample.mode === "temporal" && !forceOn) {
      return this.renderTemporalMultiSample(sampleIndex, ctx, props, toDrawingBuffer);
    } else {
      this.renderMultiSample(ctx, toDrawingBuffer, props);
      return -2;
    }
  }
  bindOutputTarget(toDrawingBuffer) {
    if (toDrawingBuffer) {
      this.webgl.unbindFramebuffer();
    } else {
      this.colorTarget.bind();
    }
  }
  renderMultiSample(ctx, toDrawingBuffer, props) {
    const { camera } = ctx;
    const { compose, composeTarget, drawPass, webgl } = this;
    const { gl, state } = webgl;
    if (isTimingMode)
      webgl.timer.mark("MultiSamplePass.renderMultiSample");
    const offsetList = JitterVectors[Math.max(0, Math.min(props.multiSample.sampleLevel, 5))];
    const { x, y, width, height } = camera.viewport;
    const baseSampleWeight = 1 / offsetList.length;
    const roundingRange = 1 / 32;
    camera.viewOffset.enabled = true;
    ValueCell.update(compose.values.tColor, drawPass.getColorTarget(props.postprocessing).texture);
    compose.update();
    for (let i = 0; i < offsetList.length; ++i) {
      const offset = offsetList[i];
      Camera.setViewOffset(camera.viewOffset, width, height, offset[0], offset[1], width, height);
      camera.update();
      const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsetList.length;
      const sampleWeight = baseSampleWeight + roundingRange * uniformCenteredDistribution;
      ValueCell.update(compose.values.uWeight, sampleWeight);
      if (i === 0 || !props.multiSample.reuseOcclusion) {
        drawPass.postprocessing.setOcclusionOffset(0, 0);
      } else {
        drawPass.postprocessing.setOcclusionOffset(offset[0] / width, offset[1] / height);
      }
      drawPass.render(ctx, props, false);
      composeTarget.bind();
      state.enable(gl.BLEND);
      state.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      state.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
      state.disable(gl.DEPTH_TEST);
      state.depthMask(false);
      state.viewport(x, y, width, height);
      state.scissor(x, y, width, height);
      if (i === 0) {
        state.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      compose.render();
    }
    drawPass.postprocessing.setOcclusionOffset(0, 0);
    ValueCell.update(compose.values.uWeight, 1);
    ValueCell.update(compose.values.tColor, composeTarget.texture);
    compose.update();
    this.bindOutputTarget(toDrawingBuffer);
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    state.disable(gl.BLEND);
    compose.render();
    camera.viewOffset.enabled = false;
    camera.update();
    if (isTimingMode)
      webgl.timer.markEnd("MultiSamplePass.renderMultiSample");
  }
  renderTemporalMultiSample(sampleIndex, ctx, props, toDrawingBuffer) {
    const { camera } = ctx;
    const { compose, composeTarget, holdTarget, drawPass, webgl } = this;
    const { gl, state } = webgl;
    if (isTimingMode)
      webgl.timer.mark("MultiSamplePass.renderTemporalMultiSample");
    const offsetList = JitterVectors[Math.max(0, Math.min(props.multiSample.sampleLevel, 5))];
    if (sampleIndex === -2 || sampleIndex >= offsetList.length)
      return -2;
    const { x, y, width, height } = camera.viewport;
    const sampleWeight = 1 / offsetList.length;
    if (sampleIndex === -1) {
      drawPass.render(ctx, props, false);
      ValueCell.update(compose.values.uWeight, 1);
      ValueCell.update(compose.values.tColor, drawPass.getColorTarget(props.postprocessing).texture);
      compose.update();
      holdTarget.bind();
      state.disable(gl.BLEND);
      state.disable(gl.DEPTH_TEST);
      state.depthMask(false);
      state.viewport(x, y, width, height);
      state.scissor(x, y, width, height);
      compose.render();
      sampleIndex += 1;
    } else {
      camera.viewOffset.enabled = true;
      ValueCell.update(compose.values.tColor, drawPass.getColorTarget(props.postprocessing).texture);
      ValueCell.update(compose.values.uWeight, sampleWeight);
      compose.update();
      const numSamplesPerFrame = Math.pow(2, Math.max(0, props.multiSample.sampleLevel - 2));
      for (let i = 0; i < numSamplesPerFrame; ++i) {
        const offset = offsetList[sampleIndex];
        Camera.setViewOffset(camera.viewOffset, width, height, offset[0], offset[1], width, height);
        camera.update();
        if (sampleIndex === 0 || !props.multiSample.reuseOcclusion) {
          drawPass.postprocessing.setOcclusionOffset(0, 0);
        } else {
          drawPass.postprocessing.setOcclusionOffset(offset[0] / width, offset[1] / height);
        }
        drawPass.render(ctx, props, false);
        composeTarget.bind();
        state.enable(gl.BLEND);
        state.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        state.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
        state.disable(gl.DEPTH_TEST);
        state.depthMask(false);
        state.viewport(x, y, width, height);
        state.scissor(x, y, width, height);
        if (sampleIndex === 0) {
          state.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
        }
        compose.render();
        sampleIndex += 1;
        if (sampleIndex >= offsetList.length)
          break;
      }
    }
    drawPass.postprocessing.setOcclusionOffset(0, 0);
    this.bindOutputTarget(toDrawingBuffer);
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    const accumulationWeight = sampleIndex * sampleWeight;
    if (accumulationWeight > 0) {
      ValueCell.update(compose.values.uWeight, 1);
      ValueCell.update(compose.values.tColor, composeTarget.texture);
      compose.update();
      state.disable(gl.BLEND);
      compose.render();
    }
    if (accumulationWeight < 1) {
      ValueCell.update(compose.values.uWeight, 1 - accumulationWeight);
      ValueCell.update(compose.values.tColor, holdTarget.texture);
      compose.update();
      if (accumulationWeight === 0)
        state.disable(gl.BLEND);
      else
        state.enable(gl.BLEND);
      compose.render();
    }
    camera.viewOffset.enabled = false;
    camera.update();
    if (isTimingMode)
      webgl.timer.markEnd("MultiSamplePass.renderTemporalMultiSample");
    return sampleIndex >= offsetList.length ? -2 : sampleIndex;
  }
};
var JitterVectors = [
  [
    [0, 0]
  ],
  [
    [0, 0],
    [-4, -4]
  ],
  [
    [0, 0],
    [6, -2],
    [-6, 2],
    [2, 6]
  ],
  [
    [0, 0],
    [-1, 3],
    [5, 1],
    [-3, -5],
    [-5, 5],
    [-7, -1],
    [3, 7],
    [7, -7]
  ],
  [
    [0, 0],
    [-1, -3],
    [-3, 2],
    [4, -1],
    [-5, -2],
    [2, 5],
    [5, 3],
    [3, -5],
    [-2, 6],
    [0, -7],
    [-4, -6],
    [-6, 4],
    [-8, 0],
    [7, -4],
    [6, 7],
    [-7, -8]
  ],
  [
    [0, 0],
    [-7, -5],
    [-3, -5],
    [-5, -4],
    [-1, -4],
    [-2, -2],
    [-6, -1],
    [-4, 0],
    [-7, 1],
    [-1, 2],
    [-6, 3],
    [-3, 3],
    [-7, 6],
    [-3, 6],
    [-5, 7],
    [-1, 7],
    [5, -7],
    [1, -6],
    [6, -5],
    [4, -4],
    [2, -3],
    [7, -2],
    [1, -1],
    [4, -1],
    [2, 1],
    [6, 2],
    [0, 4],
    [4, 4],
    [2, 5],
    [7, 5],
    [5, 6],
    [3, 7]
  ]
];
JitterVectors.forEach((offsetList) => {
  offsetList.forEach((offset) => {
    offset[0] *= 0.0625;
    offset[1] *= 0.0625;
  });
});
var MultiSampleHelper = class {
  update(changed, props) {
    if (changed)
      this.sampleIndex = -1;
    return props.mode === "temporal" ? this.sampleIndex !== -2 : false;
  }
  /** Return `true` while more samples are needed */
  render(ctx, props, toDrawingBuffer, forceOn) {
    this.sampleIndex = this.multiSamplePass.render(this.sampleIndex, ctx, props, toDrawingBuffer, !!forceOn);
    return this.sampleIndex < 0;
  }
  constructor(multiSamplePass) {
    this.multiSamplePass = multiSamplePass;
    this.sampleIndex = -2;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/camera/stereo.js
var StereoCameraParams = {
  eyeSeparation: ParamDefinition.Numeric(0.062, { min: 0.02, max: 0.1, step: 1e-3 }, { description: "Distance between left and right camera." }),
  focus: ParamDefinition.Numeric(10, { min: 1, max: 20, step: 0.1 }, { description: "Apparent object distance." })
};
var DefaultStereoCameraProps = ParamDefinition.getDefaultValues(StereoCameraParams);
var StereoCamera = class {
  get viewport() {
    return this.parent.viewport;
  }
  get viewOffset() {
    return this.parent.viewOffset;
  }
  constructor(parent, props = {}) {
    this.parent = parent;
    this.left = new EyeCamera();
    this.right = new EyeCamera();
    this.props = { ...DefaultStereoCameraProps, ...props };
  }
  setProps(props) {
    Object.assign(this.props, props);
  }
  update() {
    this.parent.update();
    update9(this.parent, this.props, this.left, this.right);
  }
};
(function(StereoCamera2) {
  function is3(camera) {
    return "left" in camera && "right" in camera;
  }
  StereoCamera2.is = is3;
})(StereoCamera || (StereoCamera = {}));
var EyeCamera = class {
  constructor() {
    this.viewport = Viewport.create(0, 0, 0, 0);
    this.view = Mat4();
    this.projection = Mat4();
    this.projectionView = Mat4();
    this.inverseProjectionView = Mat4();
    this.state = Camera.createDefaultSnapshot();
    this.viewOffset = Camera.ViewOffset();
    this.far = 0;
    this.near = 0;
    this.fogFar = 0;
    this.fogNear = 0;
  }
};
var eyeLeft = Mat4.identity();
var eyeRight = Mat4.identity();
function update9(camera, props, left, right) {
  Viewport.copy(left.viewport, camera.viewport);
  Mat4.copy(left.view, camera.view);
  Mat4.copy(left.projection, camera.projection);
  Camera.copySnapshot(left.state, camera.state);
  Camera.copyViewOffset(left.viewOffset, camera.viewOffset);
  left.far = camera.far;
  left.near = camera.near;
  left.fogFar = camera.fogFar;
  left.fogNear = camera.fogNear;
  Viewport.copy(right.viewport, camera.viewport);
  Mat4.copy(right.view, camera.view);
  Mat4.copy(right.projection, camera.projection);
  Camera.copySnapshot(right.state, camera.state);
  Camera.copyViewOffset(right.viewOffset, camera.viewOffset);
  right.far = camera.far;
  right.near = camera.near;
  right.fogFar = camera.fogFar;
  right.fogNear = camera.fogNear;
  const w = Math.floor(camera.viewport.width / 2);
  const aspect = w / camera.viewport.height;
  left.viewport.width = w;
  right.viewport.x += w;
  right.viewport.width -= w;
  const eyeSepHalf = props.eyeSeparation / 2;
  const eyeSepOnProjection = eyeSepHalf * camera.near / props.focus;
  const ymax = camera.near * Math.tan(camera.state.fov * 0.5);
  let xmin, xmax;
  eyeLeft[12] = -eyeSepHalf;
  eyeRight[12] = eyeSepHalf;
  xmin = -ymax * aspect + eyeSepOnProjection;
  xmax = ymax * aspect + eyeSepOnProjection;
  left.projection[0] = 2 * camera.near / (xmax - xmin);
  left.projection[8] = (xmax + xmin) / (xmax - xmin);
  Mat4.mul(left.view, left.view, eyeLeft);
  Mat4.mul(left.projectionView, left.projection, left.view);
  Mat4.invert(left.inverseProjectionView, left.projectionView);
  xmin = -ymax * aspect - eyeSepOnProjection;
  xmax = ymax * aspect - eyeSepOnProjection;
  right.projection[0] = 2 * camera.near / (xmax - xmin);
  right.projection[8] = (xmax + xmin) / (xmax - xmin);
  Mat4.mul(right.view, right.view, eyeRight);
  Mat4.mul(right.projectionView, right.projection, right.view);
  Mat4.invert(right.inverseProjectionView, right.projectionView);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/pick.js
var NullId = Math.pow(2, 24) - 2;
var PickPass = class {
  constructor(webgl, drawPass, pickScale) {
    this.webgl = webgl;
    this.drawPass = drawPass;
    this.pickScale = pickScale;
    const pickRatio = pickScale / webgl.pixelRatio;
    this.pickWidth = Math.ceil(drawPass.colorTarget.getWidth() * pickRatio);
    this.pickHeight = Math.ceil(drawPass.colorTarget.getHeight() * pickRatio);
    const { resources, extensions: { drawBuffers }, gl } = webgl;
    if (drawBuffers) {
      this.objectPickTexture = resources.texture("image-uint8", "rgba", "ubyte", "nearest");
      this.objectPickTexture.define(this.pickWidth, this.pickHeight);
      this.instancePickTexture = resources.texture("image-uint8", "rgba", "ubyte", "nearest");
      this.instancePickTexture.define(this.pickWidth, this.pickHeight);
      this.groupPickTexture = resources.texture("image-uint8", "rgba", "ubyte", "nearest");
      this.groupPickTexture.define(this.pickWidth, this.pickHeight);
      this.depthPickTexture = resources.texture("image-uint8", "rgba", "ubyte", "nearest");
      this.depthPickTexture.define(this.pickWidth, this.pickHeight);
      this.framebuffer = resources.framebuffer();
      this.objectPickFramebuffer = resources.framebuffer();
      this.instancePickFramebuffer = resources.framebuffer();
      this.groupPickFramebuffer = resources.framebuffer();
      this.depthPickFramebuffer = resources.framebuffer();
      this.framebuffer.bind();
      drawBuffers.drawBuffers([
        drawBuffers.COLOR_ATTACHMENT0,
        drawBuffers.COLOR_ATTACHMENT1,
        drawBuffers.COLOR_ATTACHMENT2,
        drawBuffers.COLOR_ATTACHMENT3
      ]);
      this.objectPickTexture.attachFramebuffer(this.framebuffer, "color0");
      this.instancePickTexture.attachFramebuffer(this.framebuffer, "color1");
      this.groupPickTexture.attachFramebuffer(this.framebuffer, "color2");
      this.depthPickTexture.attachFramebuffer(this.framebuffer, "color3");
      this.depthRenderbuffer = isWebGL2(gl) ? resources.renderbuffer("depth32f", "depth", this.pickWidth, this.pickHeight) : resources.renderbuffer("depth16", "depth", this.pickWidth, this.pickHeight);
      this.depthRenderbuffer.attachFramebuffer(this.framebuffer);
      this.objectPickTexture.attachFramebuffer(this.objectPickFramebuffer, "color0");
      this.instancePickTexture.attachFramebuffer(this.instancePickFramebuffer, "color0");
      this.groupPickTexture.attachFramebuffer(this.groupPickFramebuffer, "color0");
      this.depthPickTexture.attachFramebuffer(this.depthPickFramebuffer, "color0");
    } else {
      this.objectPickTarget = webgl.createRenderTarget(this.pickWidth, this.pickHeight);
      this.instancePickTarget = webgl.createRenderTarget(this.pickWidth, this.pickHeight);
      this.groupPickTarget = webgl.createRenderTarget(this.pickWidth, this.pickHeight);
      this.depthPickTarget = webgl.createRenderTarget(this.pickWidth, this.pickHeight);
    }
  }
  get pickRatio() {
    return this.pickScale / this.webgl.pixelRatio;
  }
  setPickScale(pickScale) {
    this.pickScale = pickScale;
    this.syncSize();
  }
  bindObject() {
    if (this.webgl.extensions.drawBuffers) {
      this.objectPickFramebuffer.bind();
    } else {
      this.objectPickTarget.bind();
    }
  }
  bindInstance() {
    if (this.webgl.extensions.drawBuffers) {
      this.instancePickFramebuffer.bind();
    } else {
      this.instancePickTarget.bind();
    }
  }
  bindGroup() {
    if (this.webgl.extensions.drawBuffers) {
      this.groupPickFramebuffer.bind();
    } else {
      this.groupPickTarget.bind();
    }
  }
  bindDepth() {
    if (this.webgl.extensions.drawBuffers) {
      this.depthPickFramebuffer.bind();
    } else {
      this.depthPickTarget.bind();
    }
  }
  get drawingBufferHeight() {
    return this.drawPass.colorTarget.getHeight();
  }
  syncSize() {
    const pickRatio = this.pickScale / this.webgl.pixelRatio;
    const pickWidth = Math.ceil(this.drawPass.colorTarget.getWidth() * pickRatio);
    const pickHeight = Math.ceil(this.drawPass.colorTarget.getHeight() * pickRatio);
    if (pickWidth !== this.pickWidth || pickHeight !== this.pickHeight) {
      this.pickWidth = pickWidth;
      this.pickHeight = pickHeight;
      if (this.webgl.extensions.drawBuffers) {
        this.objectPickTexture.define(this.pickWidth, this.pickHeight);
        this.instancePickTexture.define(this.pickWidth, this.pickHeight);
        this.groupPickTexture.define(this.pickWidth, this.pickHeight);
        this.depthPickTexture.define(this.pickWidth, this.pickHeight);
        this.depthRenderbuffer.setSize(this.pickWidth, this.pickHeight);
      } else {
        this.objectPickTarget.setSize(this.pickWidth, this.pickHeight);
        this.instancePickTarget.setSize(this.pickWidth, this.pickHeight);
        this.groupPickTarget.setSize(this.pickWidth, this.pickHeight);
        this.depthPickTarget.setSize(this.pickWidth, this.pickHeight);
      }
    }
  }
  reset() {
    const { drawBuffers } = this.webgl.extensions;
    if (drawBuffers) {
      this.framebuffer.bind();
      drawBuffers.drawBuffers([
        drawBuffers.COLOR_ATTACHMENT0,
        drawBuffers.COLOR_ATTACHMENT1,
        drawBuffers.COLOR_ATTACHMENT2,
        drawBuffers.COLOR_ATTACHMENT3
      ]);
      this.objectPickTexture.attachFramebuffer(this.framebuffer, "color0");
      this.instancePickTexture.attachFramebuffer(this.framebuffer, "color1");
      this.groupPickTexture.attachFramebuffer(this.framebuffer, "color2");
      this.depthPickTexture.attachFramebuffer(this.framebuffer, "color3");
      this.depthRenderbuffer.attachFramebuffer(this.framebuffer);
      this.objectPickTexture.attachFramebuffer(this.objectPickFramebuffer, "color0");
      this.instancePickTexture.attachFramebuffer(this.instancePickFramebuffer, "color0");
      this.groupPickTexture.attachFramebuffer(this.groupPickFramebuffer, "color0");
      this.depthPickTexture.attachFramebuffer(this.depthPickFramebuffer, "color0");
    }
  }
  renderVariant(renderer, camera, scene, helper, variant, pickType) {
    renderer.clear(false);
    renderer.update(camera, scene);
    renderer.renderPick(scene.primitives, camera, variant, pickType);
    if (helper.handle.isEnabled) {
      renderer.renderPick(helper.handle.scene, camera, variant, pickType);
    }
    if (helper.camera.isEnabled) {
      helper.camera.update(camera);
      renderer.update(helper.camera.camera, helper.camera.scene);
      renderer.renderPick(helper.camera.scene, helper.camera.camera, variant, pickType);
    }
  }
  render(renderer, camera, scene, helper) {
    if (this.webgl.extensions.drawBuffers) {
      this.framebuffer.bind();
      this.renderVariant(renderer, camera, scene, helper, "pick", PickType.None);
    } else {
      this.objectPickTarget.bind();
      this.renderVariant(renderer, camera, scene, helper, "pick", PickType.Object);
      this.instancePickTarget.bind();
      this.renderVariant(renderer, camera, scene, helper, "pick", PickType.Instance);
      this.groupPickTarget.bind();
      this.renderVariant(renderer, camera, scene, helper, "pick", PickType.Group);
      this.depthPickTarget.bind();
      this.renderVariant(renderer, camera, scene, helper, "depth", PickType.None);
    }
  }
};
var PickHelper = class {
  setupBuffers() {
    const bufferSize = this.pickWidth * this.pickHeight * 4;
    if (!this.objectBuffer || this.objectBuffer.length !== bufferSize) {
      this.objectBuffer = new Uint8Array(bufferSize);
      this.instanceBuffer = new Uint8Array(bufferSize);
      this.groupBuffer = new Uint8Array(bufferSize);
      this.depthBuffer = new Uint8Array(bufferSize);
    }
  }
  setViewport(x, y, width, height) {
    Viewport.set(this.viewport, x, y, width, height);
    this.update();
  }
  setPickPadding(pickPadding) {
    if (this.pickPadding !== pickPadding) {
      this.pickPadding = pickPadding;
      this.update();
    }
  }
  update() {
    const { x, y, width, height } = this.viewport;
    this.pickRatio = this.pickPass.pickRatio;
    this.pickX = Math.ceil(x * this.pickRatio);
    this.pickY = Math.ceil(y * this.pickRatio);
    const pickWidth = Math.floor(width * this.pickRatio);
    const pickHeight = Math.floor(height * this.pickRatio);
    if (pickWidth !== this.pickWidth || pickHeight !== this.pickHeight) {
      this.pickWidth = pickWidth;
      this.pickHeight = pickHeight;
      this.halfPickWidth = Math.floor(this.pickWidth / 2);
      this.setupBuffers();
    }
    this.spiral = spiral2d(Math.ceil(this.pickRatio * this.pickPadding));
    this.dirty = true;
  }
  syncBuffers() {
    if (isTimingMode)
      this.webgl.timer.mark("PickHelper.syncBuffers");
    const { pickX, pickY, pickWidth, pickHeight } = this;
    this.pickPass.bindObject();
    this.webgl.readPixels(pickX, pickY, pickWidth, pickHeight, this.objectBuffer);
    this.pickPass.bindInstance();
    this.webgl.readPixels(pickX, pickY, pickWidth, pickHeight, this.instanceBuffer);
    this.pickPass.bindGroup();
    this.webgl.readPixels(pickX, pickY, pickWidth, pickHeight, this.groupBuffer);
    this.pickPass.bindDepth();
    this.webgl.readPixels(pickX, pickY, pickWidth, pickHeight, this.depthBuffer);
    if (isTimingMode)
      this.webgl.timer.markEnd("PickHelper.syncBuffers");
  }
  getBufferIdx(x, y) {
    return (y * this.pickWidth + x) * 4;
  }
  getDepth(x, y) {
    const idx = this.getBufferIdx(x, y);
    const b5 = this.depthBuffer;
    return unpackRGBAToDepth(b5[idx], b5[idx + 1], b5[idx + 2], b5[idx + 3]);
  }
  getId(x, y, buffer2) {
    const idx = this.getBufferIdx(x, y);
    return unpackRGBToInt(buffer2[idx], buffer2[idx + 1], buffer2[idx + 2]);
  }
  render(camera) {
    if (isTimingMode)
      this.webgl.timer.mark("PickHelper.render", { captureStats: true });
    const { pickX, pickY, pickWidth, pickHeight, halfPickWidth } = this;
    const { renderer, scene, helper } = this;
    renderer.setTransparentBackground(false);
    renderer.setDrawingBufferSize(pickWidth, pickHeight);
    renderer.setPixelRatio(this.pickRatio);
    if (StereoCamera.is(camera)) {
      renderer.setViewport(pickX, pickY, halfPickWidth, pickHeight);
      this.pickPass.render(renderer, camera.left, scene, helper);
      renderer.setViewport(pickX + halfPickWidth, pickY, pickWidth - halfPickWidth, pickHeight);
      this.pickPass.render(renderer, camera.right, scene, helper);
    } else {
      renderer.setViewport(pickX, pickY, pickWidth, pickHeight);
      this.pickPass.render(renderer, camera, scene, helper);
    }
    this.dirty = false;
    if (isTimingMode)
      this.webgl.timer.markEnd("PickHelper.render");
  }
  identifyInternal(x, y, camera) {
    if (this.pickRatio !== this.pickPass.pickRatio) {
      this.update();
    }
    const { webgl, pickRatio } = this;
    if (webgl.isContextLost)
      return;
    x *= webgl.pixelRatio;
    y *= webgl.pixelRatio;
    y = this.pickPass.drawingBufferHeight - y;
    const { viewport } = this;
    if (x < viewport.x || y < viewport.y || x > viewport.x + viewport.width || y > viewport.y + viewport.height)
      return;
    if (this.dirty) {
      if (isTimingMode)
        this.webgl.timer.mark("PickHelper.identify");
      this.render(camera);
      this.syncBuffers();
      if (isTimingMode)
        this.webgl.timer.markEnd("PickHelper.identify");
    }
    const xv = x - viewport.x;
    const yv = y - viewport.y;
    const xp = Math.floor(xv * pickRatio);
    const yp = Math.floor(yv * pickRatio);
    const objectId = this.getId(xp, yp, this.objectBuffer);
    if (objectId === -1 || objectId === NullId)
      return;
    const instanceId = this.getId(xp, yp, this.instanceBuffer);
    if (instanceId === -1 || instanceId === NullId)
      return;
    const groupId = this.getId(xp, yp, this.groupBuffer);
    if (groupId === -1 || groupId === NullId)
      return;
    const z = this.getDepth(xp, yp);
    const position = Vec3.create(x, y, z);
    if (StereoCamera.is(camera)) {
      const halfWidth = Math.floor(viewport.width / 2);
      if (x > viewport.x + halfWidth) {
        position[0] = viewport.x + (xv - halfWidth) * 2;
        cameraUnproject(position, position, viewport, camera.right.inverseProjectionView);
      } else {
        position[0] = viewport.x + xv * 2;
        cameraUnproject(position, position, viewport, camera.left.inverseProjectionView);
      }
    } else {
      cameraUnproject(position, position, viewport, camera.inverseProjectionView);
    }
    return { id: { objectId, instanceId, groupId }, position };
  }
  identify(x, y, camera) {
    for (const d3 of this.spiral) {
      const pickData = this.identifyInternal(x + d3[0], y + d3[1], camera);
      if (pickData)
        return pickData;
    }
  }
  constructor(webgl, renderer, scene, helper, pickPass, viewport, pickPadding = 1) {
    this.webgl = webgl;
    this.renderer = renderer;
    this.scene = scene;
    this.helper = helper;
    this.pickPass = pickPass;
    this.pickPadding = pickPadding;
    this.dirty = true;
    this.viewport = Viewport();
    this.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/evaluate-wboit.frag.js
var evaluateWboit_frag = `
precision highp float;

uniform sampler2D tWboitA;
uniform sampler2D tWboitB;
uniform vec2 uTexSize;

void main() {
    vec2 coords = gl_FragCoord.xy / uTexSize;

    vec4 accum = texture2D(tWboitA, coords);
    float r = 1.0 - accum.a;

    accum.a = texture2D(tWboitB, coords).r;
    // divisor needs to allow very small values for nice fading
    gl_FragColor = vec4(accum.rgb / clamp(accum.a, 0.00000001, 50000.0), r);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/wboit.js
var EvaluateWboitSchema = {
  ...QuadSchema,
  tWboitA: TextureSpec("texture", "rgba", "float", "nearest"),
  tWboitB: TextureSpec("texture", "rgba", "float", "nearest"),
  uTexSize: UniformSpec("v2")
};
var EvaluateWboitShaderCode = ShaderCode("evaluate-wboit", quad_vert, evaluateWboit_frag);
function getEvaluateWboitRenderable(ctx, wboitATexture, wboitBTexture) {
  const values2 = {
    ...QuadValues,
    tWboitA: ValueCell.create(wboitATexture),
    tWboitB: ValueCell.create(wboitBTexture),
    uTexSize: ValueCell.create(Vec2.create(wboitATexture.getWidth(), wboitATexture.getHeight()))
  };
  const schema = { ...EvaluateWboitSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", EvaluateWboitShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var WboitPass = class _WboitPass {
  get supported() {
    return this._supported;
  }
  bind() {
    const { state, gl } = this.webgl;
    this.framebuffer.bind();
    state.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    state.disable(gl.DEPTH_TEST);
    state.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
    state.enable(gl.BLEND);
  }
  render() {
    if (isTimingMode)
      this.webgl.timer.mark("WboitPass.render");
    const { state, gl } = this.webgl;
    state.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    state.enable(gl.BLEND);
    this.renderable.update();
    this.renderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("WboitPass.render");
  }
  setSize(width, height) {
    const [w, h] = this.renderable.values.uTexSize.ref.value;
    if (width !== w || height !== h) {
      this.textureA.define(width, height);
      this.textureB.define(width, height);
      this.depthRenderbuffer.setSize(width, height);
      ValueCell.update(this.renderable.values.uTexSize, Vec2.set(this.renderable.values.uTexSize.ref.value, width, height));
    }
  }
  reset() {
    if (this._supported)
      this._init();
  }
  _init() {
    const { extensions: { drawBuffers } } = this.webgl;
    this.framebuffer.bind();
    drawBuffers.drawBuffers([
      drawBuffers.COLOR_ATTACHMENT0,
      drawBuffers.COLOR_ATTACHMENT1
    ]);
    this.textureA.attachFramebuffer(this.framebuffer, "color0");
    this.textureB.attachFramebuffer(this.framebuffer, "color1");
    this.depthRenderbuffer.attachFramebuffer(this.framebuffer);
  }
  static isSupported(webgl) {
    const { extensions: { drawBuffers, textureFloat, colorBufferFloat, depthTexture } } = webgl;
    if (!textureFloat || !colorBufferFloat || !depthTexture || !drawBuffers) {
      if (isDebugMode) {
        const missing = [];
        if (!textureFloat)
          missing.push("textureFloat");
        if (!colorBufferFloat)
          missing.push("colorBufferFloat");
        if (!depthTexture)
          missing.push("depthTexture");
        if (!drawBuffers)
          missing.push("drawBuffers");
        console.log(`Missing "${missing.join('", "')}" extensions required for "wboit"`);
      }
      return false;
    } else {
      return true;
    }
  }
  constructor(webgl, width, height) {
    this.webgl = webgl;
    this._supported = false;
    if (!_WboitPass.isSupported(webgl))
      return;
    const { resources, gl } = webgl;
    this.textureA = resources.texture("image-float32", "rgba", "float", "nearest");
    this.textureA.define(width, height);
    this.textureB = resources.texture("image-float32", "rgba", "float", "nearest");
    this.textureB.define(width, height);
    this.depthRenderbuffer = isWebGL2(gl) ? resources.renderbuffer("depth32f", "depth", width, height) : resources.renderbuffer("depth16", "depth", width, height);
    this.renderable = getEvaluateWboitRenderable(webgl, this.textureA, this.textureB);
    this.framebuffer = resources.framebuffer();
    this._supported = true;
    this._init();
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/evaluate-dpoit.frag.js
var evaluateDpoit_frag = `
precision highp float;

uniform sampler2D tDpoitFrontColor;
uniform vec2 uTexSize;

void main() {
    vec2 coords = gl_FragCoord.xy / uTexSize;
    gl_FragColor = texture2D(tDpoitFrontColor, coords);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/blend-back-dpoit.frag.js
var blendBackDpoit_frag = `
    precision highp float;

    uniform sampler2D tDpoitBackColor;
    uniform vec2 uTexSize;

    void main() {
        vec2 coords = gl_FragCoord.xy / uTexSize;
        gl_FragColor = texture2D(tDpoitBackColor, coords);
        if (gl_FragColor.a == 0.0) {
            discard;
        }
    }
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/dpoit.js
var BlendBackDpoitSchema = {
  ...QuadSchema,
  tDpoitBackColor: TextureSpec("texture", "rgba", "float", "nearest"),
  uTexSize: UniformSpec("v2")
};
var BlendBackDpoitShaderCode = ShaderCode("blend-back-dpoit", quad_vert, blendBackDpoit_frag);
function getBlendBackDpoitRenderable(ctx, dopitBlendBackTexture) {
  const values2 = {
    ...QuadValues,
    tDpoitBackColor: ValueCell.create(dopitBlendBackTexture),
    uTexSize: ValueCell.create(Vec2.create(dopitBlendBackTexture.getWidth(), dopitBlendBackTexture.getHeight()))
  };
  const schema = { ...BlendBackDpoitSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", BlendBackDpoitShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var EvaluateDpoitSchema = {
  ...QuadSchema,
  tDpoitFrontColor: TextureSpec("texture", "rgba", "float", "nearest"),
  uTexSize: UniformSpec("v2")
};
var EvaluateDpoitShaderCode = ShaderCode("evaluate-dpoit", quad_vert, evaluateDpoit_frag);
function getEvaluateDpoitRenderable(ctx, dpoitFrontColorTexture) {
  const values2 = {
    ...QuadValues,
    tDpoitFrontColor: ValueCell.create(dpoitFrontColorTexture),
    uTexSize: ValueCell.create(Vec2.create(dpoitFrontColorTexture.getWidth(), dpoitFrontColorTexture.getHeight()))
  };
  const schema = { ...EvaluateDpoitSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", EvaluateDpoitShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var DpoitPass = class _DpoitPass {
  get supported() {
    return this._supported;
  }
  bind() {
    const { state, gl, extensions: { blendMinMax } } = this.webgl;
    this.passCount = 0;
    this.depthFramebuffers[0].bind();
    state.clearColor(this.DEPTH_CLEAR_VALUE, this.DEPTH_CLEAR_VALUE, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this.depthFramebuffers[1].bind();
    state.clearColor(-this.MIN_DEPTH, this.MAX_DEPTH, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this.colorFramebuffers[0].bind();
    state.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this.colorFramebuffers[1].bind();
    state.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this.depthFramebuffers[0].bind();
    state.blendEquation(blendMinMax.MAX);
    state.depthMask(false);
    return {
      depth: this.depthTextures[1],
      frontColor: this.colorFrontTextures[1],
      backColor: this.colorBackTextures[1]
    };
  }
  bindDualDepthPeeling() {
    const { state, gl, extensions: { blendMinMax } } = this.webgl;
    this.readId = this.passCount % 2;
    this.writeId = 1 - this.readId;
    this.passCount += 1;
    this.depthFramebuffers[this.writeId].bind();
    state.clearColor(this.DEPTH_CLEAR_VALUE, this.DEPTH_CLEAR_VALUE, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this.colorFramebuffers[this.writeId].bind();
    state.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this.depthFramebuffers[this.writeId].bind();
    state.blendEquation(blendMinMax.MAX);
    state.depthMask(false);
    return {
      depth: this.depthTextures[this.readId],
      frontColor: this.colorFrontTextures[this.readId],
      backColor: this.colorBackTextures[this.readId]
    };
  }
  renderBlendBack() {
    if (isTimingMode)
      this.webgl.timer.mark("DpoitPass.renderBlendBack");
    const { state, gl } = this.webgl;
    state.blendEquation(gl.FUNC_ADD);
    state.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    ValueCell.update(this.blendBackRenderable.values.tDpoitBackColor, this.colorBackTextures[this.writeId]);
    this.blendBackRenderable.update();
    this.blendBackRenderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("DpoitPass.renderBlendBack");
  }
  render() {
    if (isTimingMode)
      this.webgl.timer.mark("DpoitPass.render");
    const { state, gl } = this.webgl;
    state.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    ValueCell.update(this.renderable.values.tDpoitFrontColor, this.colorFrontTextures[this.writeId]);
    this.renderable.update();
    this.renderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("DpoitPass.render");
  }
  setSize(width, height) {
    const [w, h] = this.renderable.values.uTexSize.ref.value;
    if (width !== w || height !== h) {
      for (let i = 0; i < 2; i++) {
        this.depthTextures[i].define(width, height);
        this.colorFrontTextures[i].define(width, height);
        this.colorBackTextures[i].define(width, height);
      }
      ValueCell.update(this.renderable.values.uTexSize, Vec2.set(this.renderable.values.uTexSize.ref.value, width, height));
      ValueCell.update(this.blendBackRenderable.values.uTexSize, Vec2.set(this.blendBackRenderable.values.uTexSize.ref.value, width, height));
    }
  }
  reset() {
    if (this._supported)
      this._init();
  }
  _init() {
    const { extensions: { drawBuffers } } = this.webgl;
    for (let i = 0; i < 2; i++) {
      this.depthFramebuffers[i].bind();
      drawBuffers.drawBuffers([
        drawBuffers.COLOR_ATTACHMENT0,
        drawBuffers.COLOR_ATTACHMENT1,
        drawBuffers.COLOR_ATTACHMENT2
      ]);
      this.colorFrontTextures[i].attachFramebuffer(this.depthFramebuffers[i], "color0");
      this.colorBackTextures[i].attachFramebuffer(this.depthFramebuffers[i], "color1");
      this.depthTextures[i].attachFramebuffer(this.depthFramebuffers[i], "color2");
      this.colorFramebuffers[i].bind();
      drawBuffers.drawBuffers([
        drawBuffers.COLOR_ATTACHMENT0,
        drawBuffers.COLOR_ATTACHMENT1
      ]);
      this.colorFrontTextures[i].attachFramebuffer(this.colorFramebuffers[i], "color0");
      this.colorBackTextures[i].attachFramebuffer(this.colorFramebuffers[i], "color1");
    }
  }
  static isSupported(webgl) {
    const { extensions: { drawBuffers, textureFloat, colorBufferFloat, depthTexture, blendMinMax } } = webgl;
    if (!textureFloat || !colorBufferFloat || !depthTexture || !drawBuffers || !blendMinMax) {
      if (isDebugMode) {
        const missing = [];
        if (!textureFloat)
          missing.push("textureFloat");
        if (!colorBufferFloat)
          missing.push("colorBufferFloat");
        if (!depthTexture)
          missing.push("depthTexture");
        if (!drawBuffers)
          missing.push("drawBuffers");
        if (!blendMinMax)
          missing.push("blendMinMax");
        console.log(`Missing "${missing.join('", "')}" extensions required for "dpoit"`);
      }
      return false;
    } else {
      return true;
    }
  }
  constructor(webgl, width, height) {
    this.webgl = webgl;
    this.DEPTH_CLEAR_VALUE = -99999;
    this.MAX_DEPTH = 1;
    this.MIN_DEPTH = 0;
    this.passCount = 0;
    this._supported = false;
    if (!_DpoitPass.isSupported(webgl))
      return;
    const { resources, extensions: { colorBufferHalfFloat, textureHalfFloat } } = webgl;
    if (isWebGL2(webgl.gl)) {
      this.depthTextures = [
        resources.texture("image-float32", "rg", "float", "nearest"),
        resources.texture("image-float32", "rg", "float", "nearest")
      ];
      this.colorFrontTextures = colorBufferHalfFloat && textureHalfFloat ? [
        resources.texture("image-float16", "rgba", "fp16", "nearest"),
        resources.texture("image-float16", "rgba", "fp16", "nearest")
      ] : [
        resources.texture("image-float32", "rgba", "float", "nearest"),
        resources.texture("image-float32", "rgba", "float", "nearest")
      ];
      this.colorBackTextures = colorBufferHalfFloat && textureHalfFloat ? [
        resources.texture("image-float16", "rgba", "fp16", "nearest"),
        resources.texture("image-float16", "rgba", "fp16", "nearest")
      ] : [
        resources.texture("image-float32", "rgba", "float", "nearest"),
        resources.texture("image-float32", "rgba", "float", "nearest")
      ];
    } else {
      this.depthTextures = [
        resources.texture("image-float32", "rgba", "float", "nearest"),
        resources.texture("image-float32", "rgba", "float", "nearest")
      ];
      this.colorFrontTextures = [
        resources.texture("image-float32", "rgba", "float", "nearest"),
        resources.texture("image-float32", "rgba", "float", "nearest")
      ];
      this.colorBackTextures = [
        resources.texture("image-float32", "rgba", "float", "nearest"),
        resources.texture("image-float32", "rgba", "float", "nearest")
      ];
    }
    this.depthTextures[0].define(width, height);
    this.depthTextures[1].define(width, height);
    this.colorFrontTextures[0].define(width, height);
    this.colorFrontTextures[1].define(width, height);
    this.colorBackTextures[0].define(width, height);
    this.colorBackTextures[1].define(width, height);
    this.depthFramebuffers = [resources.framebuffer(), resources.framebuffer()];
    this.colorFramebuffers = [resources.framebuffer(), resources.framebuffer()];
    this.blendBackRenderable = getBlendBackDpoitRenderable(webgl, this.colorBackTextures[0]);
    this.renderable = getEvaluateDpoitRenderable(webgl, this.colorFrontTextures[0]);
    this._supported = true;
    this._init();
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/marking/overlay.frag.js
var overlay_frag = `
precision highp float;
precision highp sampler2D;

uniform vec2 uTexSizeInv;
uniform sampler2D tEdgeTexture;
uniform vec3 uHighlightEdgeColor;
uniform vec3 uSelectEdgeColor;
uniform float uHighlightEdgeStrength;
uniform float uSelectEdgeStrength;
uniform float uGhostEdgeStrength;
uniform float uInnerEdgeFactor;

void main() {
    vec2 coords = gl_FragCoord.xy * uTexSizeInv;
    vec4 edgeValue = texture2D(tEdgeTexture, coords);
    if (edgeValue.a > 0.0) {
        vec3 edgeColor = edgeValue.b == 1.0 ? uHighlightEdgeColor : uSelectEdgeColor;
        gl_FragColor.rgb = edgeValue.g > 0.0 ? edgeColor : edgeColor * uInnerEdgeFactor;
        gl_FragColor.a = (edgeValue.r == 1.0 ? uGhostEdgeStrength : 1.0) * edgeValue.a;
        float edgeStrength = edgeValue.b == 1.0 ? uHighlightEdgeStrength : uSelectEdgeStrength;
        gl_FragColor.a *= edgeStrength;
    } else {
        gl_FragColor = vec4(0.0);
    }
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/marking/edge.frag.js
var edge_frag = `
precision highp float;
precision highp sampler2D;

uniform sampler2D tMaskTexture;
uniform vec2 uTexSizeInv;

void main() {
    vec2 coords = gl_FragCoord.xy * uTexSizeInv;
    vec4 offset = vec4(float(dEdgeScale), 0.0, 0.0, float(dEdgeScale)) * vec4(uTexSizeInv, uTexSizeInv);
    vec4 c0 = texture2D(tMaskTexture, coords);
    vec4 c1 = texture2D(tMaskTexture, coords + offset.xy);
    vec4 c2 = texture2D(tMaskTexture, coords - offset.xy);
    vec4 c3 = texture2D(tMaskTexture, coords + offset.yw);
    vec4 c4 = texture2D(tMaskTexture, coords - offset.yw);
    float diff1 = (c1.r - c2.r) * 0.5;
    float diff2 = (c3.r - c4.r) * 0.5;
    float d = length(vec2(diff1, diff2));
    if (d <= 0.0)
        discard;
    float a1 = min(c1.g, c2.g);
    float a2 = min(c3.g, c4.g);
    float visibility = min(a1, a2) > 0.001 ? 1.0 : 0.0;
    float mask = c0.r;
    float marker = min(c1.b, min(c2.b, min(c3.b, c4.b)));
    float fogAlpha = min(c1.a, min(c2.a, min(c3.a, c4.a)));
    gl_FragColor = vec4(visibility, mask, marker, fogAlpha);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/marking.js
var MarkingParams = {
  enabled: ParamDefinition.Boolean(true),
  highlightEdgeColor: ParamDefinition.Color(Color.darken(Color.fromNormalizedRgb(1, 0.4, 0.6), 1)),
  selectEdgeColor: ParamDefinition.Color(Color.darken(Color.fromNormalizedRgb(0.2, 1, 0.1), 1)),
  edgeScale: ParamDefinition.Numeric(1, { min: 1, max: 3, step: 1 }, { description: "Thickness of the edge." }),
  highlightEdgeStrength: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.1 }),
  selectEdgeStrength: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.1 }),
  ghostEdgeStrength: ParamDefinition.Numeric(0.3, { min: 0, max: 1, step: 0.1 }, { description: "Opacity of the hidden edges that are covered by other geometry. When set to 1, one less geometry render pass is done." }),
  innerEdgeFactor: ParamDefinition.Numeric(1.5, { min: 0, max: 3, step: 0.1 }, { description: "Factor to multiply the inner edge color with - for added contrast." })
};
var MarkingPass = class {
  static isEnabled(props) {
    return props.enabled;
  }
  constructor(webgl, width, height) {
    this.webgl = webgl;
    this.depthTarget = webgl.createRenderTarget(width, height);
    this.maskTarget = webgl.createRenderTarget(width, height);
    this.edgesTarget = webgl.createRenderTarget(width, height);
    this.edge = getEdgeRenderable(webgl, this.maskTarget.texture);
    this.overlay = getOverlayRenderable(webgl, this.edgesTarget.texture);
  }
  setEdgeState(viewport) {
    const { gl, state } = this.webgl;
    state.enable(gl.SCISSOR_TEST);
    state.enable(gl.BLEND);
    state.blendFunc(gl.ONE, gl.ONE);
    state.blendEquation(gl.FUNC_ADD);
    state.disable(gl.DEPTH_TEST);
    state.depthMask(false);
    const { x, y, width, height } = viewport;
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    state.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }
  setOverlayState(viewport) {
    const { gl, state } = this.webgl;
    state.enable(gl.SCISSOR_TEST);
    state.enable(gl.BLEND);
    state.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    state.blendEquation(gl.FUNC_ADD);
    state.disable(gl.DEPTH_TEST);
    state.depthMask(false);
    const { x, y, width, height } = viewport;
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
  }
  setSize(width, height) {
    const w = this.depthTarget.getWidth();
    const h = this.depthTarget.getHeight();
    if (width !== w || height !== h) {
      this.depthTarget.setSize(width, height);
      this.maskTarget.setSize(width, height);
      this.edgesTarget.setSize(width, height);
      ValueCell.update(this.edge.values.uTexSizeInv, Vec2.set(this.edge.values.uTexSizeInv.ref.value, 1 / width, 1 / height));
      ValueCell.update(this.overlay.values.uTexSizeInv, Vec2.set(this.overlay.values.uTexSizeInv.ref.value, 1 / width, 1 / height));
    }
  }
  update(props) {
    const { highlightEdgeColor, selectEdgeColor, edgeScale, innerEdgeFactor, ghostEdgeStrength, highlightEdgeStrength, selectEdgeStrength } = props;
    const { values: edgeValues } = this.edge;
    const _edgeScale = Math.max(1, Math.round(edgeScale * this.webgl.pixelRatio));
    if (edgeValues.dEdgeScale.ref.value !== _edgeScale) {
      ValueCell.update(edgeValues.dEdgeScale, _edgeScale);
      this.edge.update();
    }
    const { values: overlayValues } = this.overlay;
    ValueCell.update(overlayValues.uHighlightEdgeColor, Color.toVec3Normalized(overlayValues.uHighlightEdgeColor.ref.value, highlightEdgeColor));
    ValueCell.update(overlayValues.uSelectEdgeColor, Color.toVec3Normalized(overlayValues.uSelectEdgeColor.ref.value, selectEdgeColor));
    ValueCell.updateIfChanged(overlayValues.uInnerEdgeFactor, innerEdgeFactor);
    ValueCell.updateIfChanged(overlayValues.uGhostEdgeStrength, ghostEdgeStrength);
    ValueCell.updateIfChanged(overlayValues.uHighlightEdgeStrength, highlightEdgeStrength);
    ValueCell.updateIfChanged(overlayValues.uSelectEdgeStrength, selectEdgeStrength);
  }
  render(viewport, target) {
    if (isTimingMode)
      this.webgl.timer.mark("MarkingPass.render");
    this.edgesTarget.bind();
    this.setEdgeState(viewport);
    this.edge.render();
    if (target) {
      target.bind();
    } else {
      this.webgl.unbindFramebuffer();
    }
    this.setOverlayState(viewport);
    this.overlay.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("MarkingPass.render");
  }
};
var EdgeSchema = {
  ...QuadSchema,
  tMaskTexture: TextureSpec("texture", "rgba", "ubyte", "linear"),
  uTexSizeInv: UniformSpec("v2"),
  dEdgeScale: DefineSpec("number")
};
var EdgeShaderCode = ShaderCode("edge", quad_vert, edge_frag);
function getEdgeRenderable(ctx, maskTexture) {
  const width = maskTexture.getWidth();
  const height = maskTexture.getHeight();
  const values2 = {
    ...QuadValues,
    tMaskTexture: ValueCell.create(maskTexture),
    uTexSizeInv: ValueCell.create(Vec2.create(1 / width, 1 / height)),
    dEdgeScale: ValueCell.create(1)
  };
  const schema = { ...EdgeSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", EdgeShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var OverlaySchema = {
  ...QuadSchema,
  tEdgeTexture: TextureSpec("texture", "rgba", "ubyte", "linear"),
  uTexSizeInv: UniformSpec("v2"),
  uHighlightEdgeColor: UniformSpec("v3"),
  uSelectEdgeColor: UniformSpec("v3"),
  uHighlightEdgeStrength: UniformSpec("f"),
  uSelectEdgeStrength: UniformSpec("f"),
  uGhostEdgeStrength: UniformSpec("f"),
  uInnerEdgeFactor: UniformSpec("f")
};
var OverlayShaderCode = ShaderCode("overlay", quad_vert, overlay_frag);
function getOverlayRenderable(ctx, edgeTexture) {
  const width = edgeTexture.getWidth();
  const height = edgeTexture.getHeight();
  const values2 = {
    ...QuadValues,
    tEdgeTexture: ValueCell.create(edgeTexture),
    uTexSizeInv: ValueCell.create(Vec2.create(1 / width, 1 / height)),
    uHighlightEdgeColor: ValueCell.create(Vec3()),
    uSelectEdgeColor: ValueCell.create(Vec3()),
    uHighlightEdgeStrength: ValueCell.create(1),
    uSelectEdgeStrength: ValueCell.create(1),
    uGhostEdgeStrength: ValueCell.create(0),
    uInnerEdgeFactor: ValueCell.create(0)
  };
  const schema = { ...OverlaySchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", OverlayShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/draw.js
var DrawPass = class {
  setTransparency(transparency) {
    if (transparency === "wboit") {
      this.transparencyMode = this.wboit.supported ? "wboit" : "blended";
      if (isDebugMode && !this.wboit.supported) {
        console.log('Missing "wboit" support, falling back to "blended".');
      }
    } else if (transparency === "dpoit") {
      this.transparencyMode = this.dpoit.supported ? "dpoit" : "blended";
      if (isDebugMode && !this.dpoit.supported) {
        console.log('Missing "dpoit" support, falling back to "blended".');
      }
    } else {
      this.transparencyMode = "blended";
    }
    this.depthTextureOpaque.detachFramebuffer(this.postprocessing.target.framebuffer, "depth");
  }
  get transparency() {
    return this.transparencyMode;
  }
  constructor(webgl, assetManager, width, height, transparency) {
    this.webgl = webgl;
    this.transparencyMode = "blended";
    const { extensions, resources, isWebGL2: isWebGL22 } = webgl;
    this.drawTarget = createNullRenderTarget(webgl.gl);
    this.colorTarget = webgl.createRenderTarget(width, height, true, "uint8", "linear");
    this.transparentColorTarget = webgl.createRenderTarget(width, height, false, "uint8", "linear");
    this.packedDepth = !extensions.depthTexture;
    this.depthTargetTransparent = webgl.createRenderTarget(width, height);
    this.depthTextureTransparent = this.depthTargetTransparent.texture;
    this.depthTargetOpaque = this.packedDepth ? webgl.createRenderTarget(width, height) : null;
    this.depthTextureOpaque = this.depthTargetOpaque ? this.depthTargetOpaque.texture : resources.texture("image-depth", "depth", isWebGL22 ? "float" : "ushort", "nearest");
    if (!this.packedDepth) {
      this.depthTextureOpaque.define(width, height);
    }
    this.wboit = new WboitPass(webgl, width, height);
    this.dpoit = new DpoitPass(webgl, width, height);
    this.marking = new MarkingPass(webgl, width, height);
    this.postprocessing = new PostprocessingPass(webgl, assetManager, this);
    this.antialiasing = new AntialiasingPass(webgl, width, height);
    this.bloom = new BloomPass(webgl, width, height);
    this.dof = new DofPass(webgl, width, height);
    this.copyFboTarget = createCopyRenderable(webgl, this.colorTarget.texture);
    this.copyFboPostprocessing = createCopyRenderable(webgl, this.postprocessing.target.texture);
    this.setTransparency(transparency);
  }
  reset() {
    this.wboit.reset();
    this.dpoit.reset();
    this.postprocessing.reset();
  }
  setSize(width, height) {
    const w = this.colorTarget.getWidth();
    const h = this.colorTarget.getHeight();
    if (width !== w || height !== h) {
      this.colorTarget.setSize(width, height);
      this.depthTargetTransparent.setSize(width, height);
      this.transparentColorTarget.setSize(width, height);
      if (this.depthTargetOpaque) {
        this.depthTargetOpaque.setSize(width, height);
      } else {
        this.depthTextureOpaque.define(width, height);
      }
      ValueCell.update(this.copyFboTarget.values.uTexSize, Vec2.set(this.copyFboTarget.values.uTexSize.ref.value, width, height));
      ValueCell.update(this.copyFboPostprocessing.values.uTexSize, Vec2.set(this.copyFboPostprocessing.values.uTexSize.ref.value, width, height));
    }
    if (this.wboit.supported) {
      this.wboit.setSize(width, height);
    }
    if (this.dpoit.supported) {
      this.dpoit.setSize(width, height);
    }
    this.marking.setSize(width, height);
    this.postprocessing.setSize(width, height);
    this.antialiasing.setSize(width, height);
    this.dof.setSize(width, height);
    this.bloom.setSize(width, height);
  }
  _renderDpoit(renderer, camera, scene, iterations, transparentBackground, postprocessingProps) {
    if (!this.dpoit.supported)
      throw new Error("expected dpoit to be supported");
    this.depthTextureOpaque.attachFramebuffer(this.colorTarget.framebuffer, "depth");
    renderer.clear(true);
    if (scene.hasOpaque) {
      renderer.renderOpaque(scene.primitives, camera);
    }
    this.depthTextureOpaque.detachFramebuffer(this.colorTarget.framebuffer, "depth");
    if (PostprocessingPass.isTransparentDepthRequired(scene, postprocessingProps)) {
      this.depthTargetTransparent.bind();
      renderer.clearDepth(true);
      if (scene.opacityAverage < 1) {
        renderer.renderDepthTransparent(scene.primitives, camera, this.depthTextureOpaque);
      }
    }
    const isPostprocessingEnabled = PostprocessingPass.isEnabled(postprocessingProps);
    if (scene.opacityAverage < 1) {
      const target = isPostprocessingEnabled ? this.transparentColorTarget : this.colorTarget;
      if (isPostprocessingEnabled) {
        target.bind();
        renderer.clear(false, false, true);
      }
      const dpoitTextures = this.dpoit.bind();
      renderer.renderDpoitTransparent(scene.primitives, camera, this.depthTextureOpaque, dpoitTextures);
      for (let i = 0; i < iterations; i++) {
        if (isTimingMode)
          this.webgl.timer.mark("DpoitPass.layer");
        const dpoitTextures2 = this.dpoit.bindDualDepthPeeling();
        renderer.renderDpoitTransparent(scene.primitives, camera, this.depthTextureOpaque, dpoitTextures2);
        target.bind();
        this.dpoit.renderBlendBack();
        if (isTimingMode)
          this.webgl.timer.markEnd("DpoitPass.layer");
      }
      target.bind();
      this.dpoit.render();
    }
    if (PostprocessingPass.isEnabled(postprocessingProps)) {
      this.postprocessing.render(camera, scene, false, transparentBackground, renderer.props.backgroundColor, postprocessingProps, renderer.light, renderer.ambientColor);
    }
    if (scene.volumes.renderables.length > 0) {
      renderer.renderVolume(scene.volumes, camera, this.depthTextureOpaque);
    }
  }
  _renderWboit(renderer, camera, scene, transparentBackground, postprocessingProps) {
    if (!this.wboit.supported)
      throw new Error("expected wboit to be supported");
    this.depthTextureOpaque.attachFramebuffer(this.colorTarget.framebuffer, "depth");
    renderer.clear(true);
    if (scene.hasOpaque) {
      renderer.renderOpaque(scene.primitives, camera);
    }
    if (PostprocessingPass.isTransparentDepthRequired(scene, postprocessingProps)) {
      this.depthTargetTransparent.bind();
      renderer.clearDepth(true);
      if (scene.opacityAverage < 1) {
        renderer.renderDepthTransparent(scene.primitives, camera, this.depthTextureOpaque);
      }
    }
    const isPostprocessingEnabled = PostprocessingPass.isEnabled(postprocessingProps);
    if (scene.opacityAverage < 1) {
      const target = isPostprocessingEnabled ? this.transparentColorTarget : this.colorTarget;
      if (isPostprocessingEnabled) {
        target.bind();
        renderer.clear(false, false, true);
      }
      this.wboit.bind();
      renderer.renderWboitTransparent(scene.primitives, camera, this.depthTextureOpaque);
      target.bind();
      this.wboit.render();
    }
    if (PostprocessingPass.isEnabled(postprocessingProps)) {
      this.postprocessing.render(camera, scene, false, transparentBackground, renderer.props.backgroundColor, postprocessingProps, renderer.light, renderer.ambientColor);
    }
    if (scene.volumes.renderables.length > 0) {
      this.wboit.bind();
      renderer.renderWboitTransparent(scene.volumes, camera, this.depthTextureOpaque);
      const target = isPostprocessingEnabled ? this.postprocessing.target : this.colorTarget;
      target.bind();
      this.wboit.render();
    }
  }
  _renderBlended(renderer, camera, scene, toDrawingBuffer, transparentBackground, postprocessingProps) {
    var _a, _b, _c, _d, _e, _f;
    if (toDrawingBuffer) {
      this.drawTarget.bind();
    } else {
      if (!this.packedDepth) {
        this.depthTextureOpaque.attachFramebuffer(this.colorTarget.framebuffer, "depth");
      } else {
        this.colorTarget.bind();
      }
    }
    renderer.clear(true);
    if (scene.hasOpaque) {
      renderer.renderOpaque(scene.primitives, camera);
    }
    if (!toDrawingBuffer) {
      if (this.depthTargetOpaque) {
        this.depthTargetOpaque.bind();
        renderer.clearDepth(true);
        renderer.renderDepthOpaque(scene.primitives, camera);
        this.colorTarget.bind();
      }
      if (PostprocessingPass.isTransparentDepthRequired(scene, postprocessingProps)) {
        this.depthTargetTransparent.bind();
        renderer.clearDepth(true);
        if (scene.opacityAverage < 1) {
          renderer.renderDepthTransparent(scene.primitives, camera, this.depthTextureOpaque);
        }
      }
      const isPostprocessingEnabled = PostprocessingPass.isEnabled(postprocessingProps);
      if (scene.opacityAverage < 1) {
        if (isPostprocessingEnabled) {
          this.transparentColorTarget.bind();
          renderer.clear(false, false, true);
          if (!this.packedDepth) {
            this.depthTextureOpaque.attachFramebuffer(this.transparentColorTarget.framebuffer, "depth");
          } else {
            (_a = this.colorTarget.depthRenderbuffer) === null || _a === void 0 ? void 0 : _a.attachFramebuffer(this.transparentColorTarget.framebuffer);
          }
        }
        renderer.renderBlendedTransparent(scene.primitives, camera);
        if (isPostprocessingEnabled) {
          if (!this.packedDepth) {
            this.depthTextureOpaque.detachFramebuffer(this.transparentColorTarget.framebuffer, "depth");
          } else {
            (_b = this.colorTarget.depthRenderbuffer) === null || _b === void 0 ? void 0 : _b.detachFramebuffer(this.transparentColorTarget.framebuffer);
          }
        }
      }
      if (isPostprocessingEnabled) {
        if (!this.packedDepth) {
          this.depthTextureOpaque.detachFramebuffer(this.postprocessing.target.framebuffer, "depth");
        } else {
          (_c = this.colorTarget.depthRenderbuffer) === null || _c === void 0 ? void 0 : _c.detachFramebuffer(this.postprocessing.target.framebuffer);
        }
        this.postprocessing.render(camera, scene, false, transparentBackground, renderer.props.backgroundColor, postprocessingProps, renderer.light, renderer.ambientColor);
        if (!this.packedDepth) {
          this.depthTextureOpaque.attachFramebuffer(this.postprocessing.target.framebuffer, "depth");
        } else {
          (_d = this.colorTarget.depthRenderbuffer) === null || _d === void 0 ? void 0 : _d.attachFramebuffer(this.postprocessing.target.framebuffer);
        }
      }
      if (scene.volumes.renderables.length > 0) {
        const target = PostprocessingPass.isEnabled(postprocessingProps) ? this.postprocessing.target : this.colorTarget;
        if (!this.packedDepth) {
          this.depthTextureOpaque.detachFramebuffer(target.framebuffer, "depth");
        } else {
          (_e = this.colorTarget.depthRenderbuffer) === null || _e === void 0 ? void 0 : _e.detachFramebuffer(target.framebuffer);
        }
        target.bind();
        renderer.renderVolume(scene.volumes, camera, this.depthTextureOpaque);
        if (!this.packedDepth) {
          this.depthTextureOpaque.attachFramebuffer(target.framebuffer, "depth");
        } else {
          (_f = this.colorTarget.depthRenderbuffer) === null || _f === void 0 ? void 0 : _f.attachFramebuffer(target.framebuffer);
        }
        target.bind();
      }
    } else if (scene.opacityAverage < 1) {
      renderer.renderBlendedTransparent(scene.primitives, camera);
    }
  }
  _render(renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props) {
    var _a, _b;
    const volumeRendering = scene.volumes.renderables.length > 0;
    const postprocessingEnabled = PostprocessingPass.isEnabled(props.postprocessing);
    const antialiasingEnabled = AntialiasingPass.isEnabled(props.postprocessing);
    const markingEnabled = MarkingPass.isEnabled(props.marking);
    const dofEnabled = DofPass.isEnabled(props.postprocessing);
    const { x, y, width, height } = camera.viewport;
    renderer.setViewport(x, y, width, height);
    renderer.update(camera, scene);
    if (transparentBackground && !antialiasingEnabled && toDrawingBuffer) {
      this.drawTarget.bind();
      renderer.clear(false);
    }
    let oitEnabled = false;
    if (this.transparencyMode === "wboit" && this.wboit.supported) {
      this._renderWboit(renderer, camera, scene, transparentBackground, props.postprocessing);
      oitEnabled = true;
    } else if (this.transparencyMode === "dpoit" && this.dpoit.supported) {
      this._renderDpoit(renderer, camera, scene, props.dpoitIterations, transparentBackground, props.postprocessing);
      oitEnabled = true;
    } else {
      this._renderBlended(renderer, camera, scene, !volumeRendering && !postprocessingEnabled && !antialiasingEnabled && toDrawingBuffer, transparentBackground, props.postprocessing);
    }
    const target = postprocessingEnabled ? this.postprocessing.target : !toDrawingBuffer || volumeRendering || oitEnabled ? this.colorTarget : this.drawTarget;
    if (markingEnabled && scene.markerAverage > 0) {
      const markingDepthTest = props.marking.ghostEdgeStrength < 1;
      if (markingDepthTest && scene.markerAverage !== 1) {
        this.marking.depthTarget.bind();
        renderer.clear(false, true);
        renderer.renderMarkingDepth(scene.primitives, camera);
      }
      this.marking.maskTarget.bind();
      renderer.clear(false, true);
      renderer.renderMarkingMask(scene.primitives, camera, markingDepthTest ? this.marking.depthTarget.texture : null);
      this.marking.update(props.marking);
      this.marking.render(camera.viewport, target);
    } else {
      target.bind();
    }
    if (helper.debug.isEnabled) {
      helper.debug.syncVisibility();
      renderer.renderBlended(helper.debug.scene, camera);
    }
    if (helper.handle.isEnabled) {
      renderer.renderBlended(helper.handle.scene, camera);
    }
    if (helper.camera.isEnabled) {
      helper.camera.update(camera);
      renderer.update(helper.camera.camera, helper.camera.scene);
      renderer.renderBlended(helper.camera.scene, helper.camera.camera);
    }
    let needsTargetCopy = false;
    if (antialiasingEnabled) {
      const input = PostprocessingPass.isEnabled(props.postprocessing) ? this.postprocessing.target.texture : this.colorTarget.texture;
      this.antialiasing.render(camera, input, toDrawingBuffer && !dofEnabled, props.postprocessing);
    } else if (toDrawingBuffer && !DofPass.isEnabled(props.postprocessing)) {
      needsTargetCopy = true;
    }
    if (props.postprocessing.dof.name === "on") {
      const input = AntialiasingPass.isEnabled(props.postprocessing) ? this.antialiasing.target.texture : PostprocessingPass.isEnabled(props.postprocessing) ? this.postprocessing.target.texture : this.colorTarget.texture;
      this.dof.update(camera, input, ((_a = this.depthTargetOpaque) === null || _a === void 0 ? void 0 : _a.texture) || this.depthTextureOpaque, this.depthTextureTransparent, props.postprocessing.dof.params, scene.boundingSphereVisible);
      this.dof.render(camera.viewport, toDrawingBuffer ? void 0 : this.getColorTarget(props.postprocessing));
    } else if (toDrawingBuffer && !AntialiasingPass.isEnabled(props.postprocessing)) {
      needsTargetCopy = true;
    }
    if (needsTargetCopy) {
      this.drawTarget.bind();
      this.webgl.state.disable(this.webgl.gl.DEPTH_TEST);
      if (postprocessingEnabled) {
        this.copyFboPostprocessing.render();
      } else if (volumeRendering || oitEnabled) {
        this.copyFboTarget.render();
      }
    }
    if (props.postprocessing.bloom.name === "on") {
      const emissiveBloom = props.postprocessing.bloom.params.mode === "emissive";
      if (emissiveBloom && scene.emissiveAverage > 0) {
        this.bloom.emissiveTarget.bind();
        renderer.clear(false, true);
        renderer.update(camera, scene);
        renderer.renderEmissive(scene.primitives, camera);
      }
      if (!emissiveBloom || scene.emissiveAverage > 0) {
        this.bloom.update(this.colorTarget.texture, this.bloom.emissiveTarget.texture, ((_b = this.depthTargetOpaque) === null || _b === void 0 ? void 0 : _b.texture) || this.depthTextureOpaque, props.postprocessing.bloom.params);
        this.bloom.render(camera.viewport, toDrawingBuffer ? void 0 : this.getColorTarget(props.postprocessing));
      }
    }
    this.webgl.gl.flush();
  }
  render(ctx, props, toDrawingBuffer) {
    if (isTimingMode)
      this.webgl.timer.mark("DrawPass.render");
    const { renderer, camera, scene, helper } = ctx;
    this.postprocessing.setTransparentBackground(props.transparentBackground);
    const transparentBackground = props.transparentBackground || this.postprocessing.background.isEnabled(props.postprocessing.background);
    renderer.setTransparentBackground(transparentBackground);
    renderer.setDrawingBufferSize(this.colorTarget.getWidth(), this.colorTarget.getHeight());
    renderer.setPixelRatio(this.webgl.pixelRatio);
    if (StereoCamera.is(camera)) {
      if (isTimingMode)
        this.webgl.timer.mark("StereoCamera.left");
      this._render(renderer, camera.left, scene, helper, toDrawingBuffer, transparentBackground, props);
      if (isTimingMode)
        this.webgl.timer.markEnd("StereoCamera.left");
      if (isTimingMode)
        this.webgl.timer.mark("StereoCamera.right");
      this._render(renderer, camera.right, scene, helper, toDrawingBuffer, transparentBackground, props);
      if (isTimingMode)
        this.webgl.timer.markEnd("StereoCamera.right");
    } else {
      this._render(renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props);
    }
    if (isTimingMode)
      this.webgl.timer.markEnd("DrawPass.render");
  }
  getColorTarget(postprocessingProps) {
    if (DofPass.isEnabled(postprocessingProps)) {
      return this.dof.target;
    } else if (AntialiasingPass.isEnabled(postprocessingProps)) {
      return this.antialiasing.target;
    } else if (PostprocessingPass.isEnabled(postprocessingProps)) {
      return this.postprocessing.target;
    }
    return this.colorTarget;
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/helper/camera-helper.js
var AxesParams2 = {
  alpha: ParamDefinition.Numeric(0.51, { min: 0, max: 1, step: 0.01 }, { isEssential: true, label: "Opacity" }),
  colorX: ParamDefinition.Color(ColorNames.red, { isEssential: true }),
  colorY: ParamDefinition.Color(ColorNames.green, { isEssential: true }),
  colorZ: ParamDefinition.Color(ColorNames.blue, { isEssential: true }),
  scale: ParamDefinition.Numeric(0.33, { min: 0.1, max: 2, step: 0.1 }, { isEssential: true }),
  location: ParamDefinition.Select("bottom-left", ParamDefinition.arrayToOptions(["bottom-left", "bottom-right", "top-left", "top-right"])),
  locationOffsetX: ParamDefinition.Numeric(0),
  locationOffsetY: ParamDefinition.Numeric(0),
  originColor: ParamDefinition.Color(ColorNames.grey),
  radiusScale: ParamDefinition.Numeric(0.075, { min: 0.01, max: 0.3, step: 1e-3 }),
  showPlanes: ParamDefinition.Boolean(true),
  planeColorXY: ParamDefinition.Color(ColorNames.grey, { label: "Plane Color XY" }),
  planeColorXZ: ParamDefinition.Color(ColorNames.grey, { label: "Plane Color XZ" }),
  planeColorYZ: ParamDefinition.Color(ColorNames.grey, { label: "Plane Color YZ" }),
  showLabels: ParamDefinition.Boolean(false),
  labelX: ParamDefinition.Text("X"),
  labelY: ParamDefinition.Text("Y"),
  labelZ: ParamDefinition.Text("Z"),
  labelColorX: ParamDefinition.Color(ColorNames.grey),
  labelColorY: ParamDefinition.Color(ColorNames.grey),
  labelColorZ: ParamDefinition.Color(ColorNames.grey),
  labelOpacity: ParamDefinition.Numeric(1, { min: 0, max: 1, step: 0.01 }),
  labelScale: ParamDefinition.Numeric(0.25, { min: 0.1, max: 1, step: 0.01 })
};
var CameraHelperParams = {
  axes: ParamDefinition.MappedStatic("on", {
    on: ParamDefinition.Group(AxesParams2),
    off: ParamDefinition.Group({})
  }, { cycle: true, description: "Show camera orientation axes" })
};
var CameraHelper = class {
  constructor(webgl, props = {}) {
    this.webgl = webgl;
    this.props = {
      axes: { name: "off", params: {} }
    };
    this.pixelRatio = 1;
    this.eachGroup = (loci, apply) => {
      if (!isCameraAxesLoci(loci))
        return false;
      let changed = false;
      if (this.meshRenderObject) {
        const groupCount = this.meshRenderObject.values.uGroupCount.ref.value;
        for (const { groupId, instanceId } of loci.elements) {
          const idx = instanceId * groupCount + groupId;
          if (apply(Interval.ofSingleton(idx)))
            changed = true;
        }
      }
      if (this.textRenderObject) {
        const groupCount = this.textRenderObject.values.uGroupCount.ref.value;
        for (const { groupId, instanceId } of loci.elements) {
          const idx = instanceId * groupCount + groupId;
          if (apply(Interval.ofSingleton(idx)))
            changed = true;
        }
      }
      return changed;
    };
    this.scene = Scene.create(webgl, "blended");
    this.camera = new Camera();
    Vec3.set(this.camera.up, 0, 1, 0);
    Vec3.set(this.camera.target, 0, 0, 0);
    this.setProps(props);
  }
  setProps(props) {
    this.props = produce(this.props, (p) => {
      if (props.axes !== void 0) {
        p.axes.name = props.axes.name;
        if (props.axes.name === "on") {
          this.scene.clear();
          this.pixelRatio = this.webgl.pixelRatio;
          const params = {
            ...props.axes.params,
            scale: props.axes.params.scale * this.pixelRatio,
            labelScale: props.axes.params.labelScale * this.pixelRatio
          };
          this.meshRenderObject = createMeshRenderObject(params);
          this.scene.add(this.meshRenderObject);
          if (props.axes.params.showLabels) {
            this.textRenderObject = createTextRenderObject(params);
            this.scene.add(this.textRenderObject);
          } else {
            this.textRenderObject = void 0;
          }
          this.scene.commit();
          Vec3.set(this.camera.position, 0, 0, params.scale * 200);
          Mat4.lookAt(this.camera.view, this.camera.position, this.camera.target, this.camera.up);
          p.axes.params = { ...props.axes.params };
        }
      }
    });
  }
  get isEnabled() {
    return this.props.axes.name === "on";
  }
  getLoci(pickingId) {
    const { objectId, groupId, instanceId } = pickingId;
    if ((!this.meshRenderObject || objectId !== this.meshRenderObject.id) && (!this.textRenderObject || objectId !== this.textRenderObject.id) || groupId === CameraHelperAxis.None)
      return EmptyLoci;
    return CameraAxesLoci(this, groupId, instanceId);
  }
  mark(loci, action) {
    if (!MarkerActions.is(MarkerActions.Highlighting, action))
      return false;
    if (!isEveryLoci(loci)) {
      if (!isCameraAxesLoci(loci))
        return false;
      if (loci.data !== this)
        return false;
    }
    return Visual.mark(this.meshRenderObject, loci, action, this.eachGroup) || Visual.mark(this.textRenderObject, loci, action, this.eachGroup);
  }
  update(camera) {
    if (!this.meshRenderObject || this.props.axes.name === "off")
      return;
    if (this.pixelRatio !== this.webgl.pixelRatio) {
      this.setProps(this.props);
    }
    updateCamera(this.camera, camera.viewport, camera.viewOffset);
    Mat4.extractRotation(this.scene.view, camera.view);
    const r = this.textRenderObject ? this.textRenderObject.values.boundingSphere.ref.value.radius : this.meshRenderObject.values.boundingSphere.ref.value.radius;
    const l = this.props.axes.params.location;
    const ox = this.props.axes.params.locationOffsetX * this.pixelRatio;
    const oy = this.props.axes.params.locationOffsetY * this.pixelRatio;
    if (l === "bottom-left") {
      Mat4.setTranslation(this.scene.view, Vec3.create(-camera.viewport.width / 2 + r + ox, -camera.viewport.height / 2 + r + oy, 0));
    } else if (l === "bottom-right") {
      Mat4.setTranslation(this.scene.view, Vec3.create(camera.viewport.width / 2 - r - ox, -camera.viewport.height / 2 + r + oy, 0));
    } else if (l === "top-left") {
      Mat4.setTranslation(this.scene.view, Vec3.create(-camera.viewport.width / 2 + r + ox, camera.viewport.height / 2 - r - oy, 0));
    } else if (l === "top-right") {
      Mat4.setTranslation(this.scene.view, Vec3.create(camera.viewport.width / 2 - r - ox, camera.viewport.height / 2 - r - oy, 0));
    } else {
      assertUnreachable(l);
    }
  }
};
var CameraHelperAxis;
(function(CameraHelperAxis2) {
  CameraHelperAxis2[CameraHelperAxis2["None"] = 0] = "None";
  CameraHelperAxis2[CameraHelperAxis2["X"] = 1] = "X";
  CameraHelperAxis2[CameraHelperAxis2["Y"] = 2] = "Y";
  CameraHelperAxis2[CameraHelperAxis2["Z"] = 3] = "Z";
  CameraHelperAxis2[CameraHelperAxis2["XY"] = 4] = "XY";
  CameraHelperAxis2[CameraHelperAxis2["XZ"] = 5] = "XZ";
  CameraHelperAxis2[CameraHelperAxis2["YZ"] = 6] = "YZ";
  CameraHelperAxis2[CameraHelperAxis2["Origin"] = 7] = "Origin";
})(CameraHelperAxis || (CameraHelperAxis = {}));
function getAxisLabel(axis, cameraHelper) {
  const a5 = cameraHelper.props.axes;
  const x = a5.name === "on" ? a5.params.labelX : "X";
  const y = a5.name === "on" ? a5.params.labelY : "Y";
  const z = a5.name === "on" ? a5.params.labelZ : "Z";
  switch (axis) {
    case CameraHelperAxis.X:
      return `${x} Axis`;
    case CameraHelperAxis.Y:
      return `${y} Axis`;
    case CameraHelperAxis.Z:
      return `${z} Axis`;
    case CameraHelperAxis.XY:
      return `${x}${y} Plane`;
    case CameraHelperAxis.XZ:
      return `${x}${z} Plane`;
    case CameraHelperAxis.YZ:
      return `${y}${z} Plane`;
    case CameraHelperAxis.Origin:
      return "Origin";
    default:
      return "Axes";
  }
}
function CameraAxesLoci(cameraHelper, groupId, instanceId) {
  return DataLoci("camera-axes", cameraHelper, [{ groupId, instanceId }], void 0, () => getAxisLabel(groupId, cameraHelper));
}
function isCameraAxesLoci(x) {
  return x.kind === "data-loci" && x.tag === "camera-axes";
}
function updateCamera(camera, viewport, viewOffset) {
  const { near, far } = camera;
  const fullLeft = -viewport.width / 2;
  const fullRight = viewport.width / 2;
  const fullTop = viewport.height / 2;
  const fullBottom = -viewport.height / 2;
  const dx = (fullRight - fullLeft) / 2;
  const dy = (fullTop - fullBottom) / 2;
  const cx = (fullRight + fullLeft) / 2;
  const cy = (fullTop + fullBottom) / 2;
  let left = cx - dx;
  let right = cx + dx;
  let top = cy + dy;
  let bottom = cy - dy;
  if (viewOffset.enabled) {
    const scaleW = (fullRight - fullLeft) / viewOffset.width;
    const scaleH = (fullTop - fullBottom) / viewOffset.height;
    left += scaleW * viewOffset.offsetX;
    right = left + scaleW * viewOffset.width;
    top -= scaleH * viewOffset.offsetY;
    bottom = top - scaleH * viewOffset.height;
  }
  Mat4.ortho(camera.projection, left, right, top, bottom, near, far);
}
function createAxesMesh(props, mesh) {
  const state = MeshBuilder.createState(512, 256, mesh);
  const scale = 100 * props.scale;
  const radius = props.radiusScale * scale;
  const textScale = props.showLabels ? 100 * props.labelScale / 3 : 0;
  const x = Vec3.scale(Vec3(), Vec3.unitX, scale - textScale);
  const y = Vec3.scale(Vec3(), Vec3.unitY, scale - textScale);
  const z = Vec3.scale(Vec3(), Vec3.unitZ, scale - textScale);
  const cylinderProps = { radiusTop: radius, radiusBottom: radius, radialSegments: 32 };
  state.currentGroup = CameraHelperAxis.Origin;
  addSphere(state, Vec3.origin, radius, 2);
  state.currentGroup = CameraHelperAxis.X;
  addSphere(state, x, radius, 2);
  addCylinder(state, Vec3.origin, x, 1, cylinderProps);
  state.currentGroup = CameraHelperAxis.Y;
  addSphere(state, y, radius, 2);
  addCylinder(state, Vec3.origin, y, 1, cylinderProps);
  state.currentGroup = CameraHelperAxis.Z;
  addSphere(state, z, radius, 2);
  addCylinder(state, Vec3.origin, z, 1, cylinderProps);
  if (props.showPlanes) {
    Vec3.scale(x, x, 0.5);
    Vec3.scale(y, y, 0.5);
    Vec3.scale(z, z, 0.5);
    state.currentGroup = CameraHelperAxis.XY;
    MeshBuilder.addTriangle(state, Vec3.origin, x, y);
    MeshBuilder.addTriangle(state, Vec3.origin, y, x);
    const xy = Vec3.add(Vec3(), x, y);
    MeshBuilder.addTriangle(state, xy, x, y);
    MeshBuilder.addTriangle(state, xy, y, x);
    state.currentGroup = CameraHelperAxis.XZ;
    MeshBuilder.addTriangle(state, Vec3.origin, x, z);
    MeshBuilder.addTriangle(state, Vec3.origin, z, x);
    const xz = Vec3.add(Vec3(), x, z);
    MeshBuilder.addTriangle(state, xz, x, z);
    MeshBuilder.addTriangle(state, xz, z, x);
    state.currentGroup = CameraHelperAxis.YZ;
    MeshBuilder.addTriangle(state, Vec3.origin, y, z);
    MeshBuilder.addTriangle(state, Vec3.origin, z, y);
    const yz = Vec3.add(Vec3(), y, z);
    MeshBuilder.addTriangle(state, yz, y, z);
    MeshBuilder.addTriangle(state, yz, z, y);
  }
  return MeshBuilder.getMesh(state);
}
function getAxesMeshShape(props, shape) {
  const scale = 100 * props.scale;
  const mesh = createAxesMesh(props, shape === null || shape === void 0 ? void 0 : shape.geometry);
  mesh.setBoundingSphere(Sphere3D.create(Vec3.create(scale / 2, scale / 2, scale / 2), scale + scale / 4));
  const getColor = (groupId) => {
    switch (groupId) {
      case CameraHelperAxis.X:
        return props.colorX;
      case CameraHelperAxis.Y:
        return props.colorY;
      case CameraHelperAxis.Z:
        return props.colorZ;
      case CameraHelperAxis.XY:
        return props.planeColorXY;
      case CameraHelperAxis.XZ:
        return props.planeColorXZ;
      case CameraHelperAxis.YZ:
        return props.planeColorYZ;
      case CameraHelperAxis.Origin:
        return props.originColor;
      default:
        return ColorNames.grey;
    }
  };
  return Shape.create("axes-mesh", {}, mesh, getColor, () => 1, () => "");
}
function createMeshRenderObject(props) {
  const shape = getAxesMeshShape(props);
  return Shape.createRenderObject(shape, {
    ...ParamDefinition.getDefaultValues(Mesh.Params),
    ...props,
    ignoreLight: true,
    cellSize: 0
  });
}
function createAxesText(props, text) {
  const builder = TextBuilder.create(props, 8, 8, text);
  const scale = 100 * props.scale;
  const x = Vec3.scale(Vec3(), Vec3.unitX, scale);
  const y = Vec3.scale(Vec3(), Vec3.unitY, scale);
  const z = Vec3.scale(Vec3(), Vec3.unitZ, scale);
  const textScale = 100 * props.labelScale;
  builder.add(props.labelX, x[0], x[1], x[2], 0, textScale, CameraHelperAxis.X);
  builder.add(props.labelY, y[0], y[1], y[2], 0, textScale, CameraHelperAxis.Y);
  builder.add(props.labelZ, z[0], z[1], z[2], 0, textScale, CameraHelperAxis.Z);
  return builder.getText();
}
function getAxesTextShape(props, shape) {
  const scale = 100 * props.scale;
  const text = createAxesText(props, shape === null || shape === void 0 ? void 0 : shape.geometry);
  text.setBoundingSphere(Sphere3D.create(Vec3.create(scale / 2, scale / 2, scale / 2), scale));
  const getColor = (groupId) => {
    switch (groupId) {
      case CameraHelperAxis.X:
        return props.labelColorX;
      case CameraHelperAxis.Y:
        return props.labelColorY;
      case CameraHelperAxis.Z:
        return props.labelColorZ;
      default:
        return ColorNames.grey;
    }
  };
  return Shape.create("axes-text", {}, text, getColor, () => 1, () => "");
}
function createTextRenderObject(props) {
  const shape = getAxesTextShape(props);
  return Shape.createRenderObject(shape, {
    ...ParamDefinition.getDefaultValues(Text.Params),
    ...props,
    alpha: props.labelOpacity,
    cellSize: 0
  });
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/illumination/compose.frag.js
var compose_frag2 = `
precision highp float;
precision highp sampler2D;

uniform sampler2D tShaded;
uniform sampler2D tColor;
uniform sampler2D tNormal;
uniform sampler2D tTransparentColor;
uniform sampler2D tSsaoDepth;
uniform sampler2D tSsaoDepthTransparent;
uniform sampler2D tDepthOpaque;
uniform sampler2D tDepthTransparent;
uniform sampler2D tOutlines;
uniform vec2 uTexSize;

uniform float uNear;
uniform float uFar;
uniform float uFogNear;
uniform float uFogFar;
uniform vec3 uFogColor;
uniform vec3 uOutlineColor;
uniform vec3 uOcclusionColor;
uniform bool uTransparentBackground;

uniform float uDenoiseThreshold;

#include common

float getViewZ(const in float depth) {
    #if dOrthographic == 1
        return orthographicDepthToViewZ(depth, uNear, uFar);
    #else
        return perspectiveDepthToViewZ(depth, uNear, uFar);
    #endif
}

float getDepthOpaque(const in vec2 coords) {
    #ifdef depthTextureSupport
        return texture2D(tDepthOpaque, coords).r;
    #else
        return unpackRGBAToDepth(texture2D(tDepthOpaque, coords));
    #endif
}

float getDepthTransparent(const in vec2 coords) {
    #if defined(dTransparentOutline) || defined(dOcclusionEnable)
        return unpackRGBAToDepthWithAlpha(texture2D(tDepthTransparent, coords)).x;
    #else
        return 1.0;
    #endif
}

bool isBackground(const in float depth) {
    return depth == 1.0;
}

float getSsao(vec2 coords) {
    float rawSsao = unpackRGToUnitInterval(texture2D(tSsaoDepth, coords).xy);
    if (rawSsao > 0.999) {
        return 1.0;
    } else if (rawSsao > 0.001) {
        return rawSsao;
    }
    // treat values close to 0.0 as errors and return no occlusion
    return 1.0;
}

float getSsaoTransparent(vec2 coords) {
    float rawSsao = unpackRGToUnitInterval(texture2D(tSsaoDepthTransparent, coords).xy);
    if (rawSsao > 0.999) {
        return 1.0;
    } else if (rawSsao > 0.001) {
        return rawSsao;
    }
    // treat values close to 0.0 as errors and return no occlusion
    return 1.0;
}

//

// TODO: investigate
// https://interplayoflight.wordpress.com/2022/03/26/raytraced-global-illumination-denoising/

//

#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439  // 1.0/SQRT_OF_2PI
#define INV_PI 0.31830988618379067153776752674503

// https://github.com/BrutPitt/glslSmartDeNoise
//
//  smartDeNoise - parameters
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  sampler2D tex     - sampler image / texture
//  vec2 uv           - actual fragment coord
//  float sigma  >  0 - sigma Standard Deviation
//  float kSigma >= 0 - sigma coefficient
//      kSigma * sigma  -->  radius of the circular kernel
//  float threshold   - edge sharpening threshold

float NormalWeightStrength = 6.0;

vec4 smartDeNoise(sampler2D tex, vec2 uv) {
    float sigma = 3.0;
    float kSigma = 2.0;
    float threshold = uDenoiseThreshold;

    vec4 centrPx = texture2D(tex, uv);
    if (threshold == 0.0) return centrPx;

    float invSigmaQx2 = 0.5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)
    float invSigmaQx2PI = INV_PI * invSigmaQx2;    // 1.0 / (sqrt(PI) * sigma)

    float invThresholdSqx2 = 0.5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)
    float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma)

    float zBuff = 0.0;
    vec4 aBuff = vec4(0.0);

    vec3 normal = texture2D(tNormal, uv).xyz;

    for (int x = -6; x <= 6; ++x) {
        for (int y = -6; y <= 6; ++y) {
            vec2 d = vec2(float(x), float(y));

            float blurFactor = exp(-dot(d , d) * invSigmaQx2) * invSigmaQx2PI;
            vec2 uvSample = uv + d / uTexSize;

            vec3 normalSample = texture2D(tNormal, uvSample).xyz;
            float normalW = saturate(dot(normal, normalSample));
            normalW = pow(normalW, NormalWeightStrength);
            blurFactor *= normalW;

            vec4 walkPx =  texture2D(tex, uvSample);

            vec4 dC = walkPx - centrPx;
            float deltaFactor = exp(-dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;

            zBuff += deltaFactor;
            aBuff += deltaFactor * walkPx;
        }
    }
    return aBuff / zBuff;
}

int squaredOutlineScale = dOutlineScale * dOutlineScale;
float getOutline(const in vec2 coords, const in float opaqueDepth, const in float transparentDepth, out float closestTexel, out float isTransparent) {
    vec2 invTexSize = 1.0 / uTexSize;

    float outline = 1.0;
    closestTexel = 1.0;
    isTransparent = 0.0;
    for (int y = -dOutlineScale; y <= dOutlineScale; y++) {
        for (int x = -dOutlineScale; x <= dOutlineScale; x++) {
            if (x * x + y * y > squaredOutlineScale) {
                continue;
            }

            vec2 sampleCoords = coords + vec2(float(x), float(y)) * invTexSize;

            vec4 sampleOutlineCombined = texture2D(tOutlines, sampleCoords);
            float sampleOutline = sampleOutlineCombined.r;
            float sampleOutlineDepth = unpackRGToUnitInterval(sampleOutlineCombined.gb);

            if (sampleOutline == 0.0 && sampleOutlineDepth < closestTexel) {
                outline = 0.0;
                closestTexel = sampleOutlineDepth;
                isTransparent = sampleOutlineCombined.a;
            }
        }
    }
    return isTransparent == 0.0 ? outline : (closestTexel > opaqueDepth && closestTexel < transparentDepth) ? 1.0 : outline;
}

void main() {
    vec2 coords = gl_FragCoord.xy / uTexSize;

    #ifdef dDenoise
        vec4 color = smartDeNoise(tColor, coords);
    #else
        vec4 color = texture2D(tColor, coords);
    #endif

    float opaqueDepth = getDepthOpaque(coords);
    float backgroundViewZ = 2.0 * uFar;
    float opaqueSelfViewZ = isBackground(opaqueDepth) ? backgroundViewZ : getViewZ(opaqueDepth);
    float fogFactor = smoothstep(uFogNear, uFogFar, abs(opaqueSelfViewZ));
    float fogAlpha = 1.0 - fogFactor;

    float transparentDepth = 1.0;
    #ifdef dBlendTransparency
        bool blendTransparency = true;
        vec4 transparentColor = texture2D(tTransparentColor, coords);

        transparentDepth = getDepthTransparent(coords);
    #endif

    float alpha = 1.0;
    if (!uTransparentBackground) {
        // mix opaque objects with background color
        color.rgb = mix(color.rgb, uFogColor, fogFactor);
    } else {
        // pre-multiplied alpha expected for transparent background
        alpha = fogAlpha;
        color.rgb *= fogAlpha;
    }

    #if defined(dOcclusionEnable)
        if (!isBackground(opaqueDepth)) {
            float occlusionFactor = getSsao(coords);

            if (!uTransparentBackground) {
                color.rgb = mix(mix(uOcclusionColor, uFogColor, fogFactor), color.rgb, occlusionFactor);
            } else {
                color.rgb = mix(uOcclusionColor * (1.0 - fogFactor), color.rgb, occlusionFactor);
            }
        }
        #ifdef dBlendTransparency
            if (!isBackground(transparentDepth)) {
                float viewDist = abs(getViewZ(transparentDepth));
                float fogFactor = smoothstep(uFogNear, uFogFar, viewDist);
                float occlusionFactor = getSsaoTransparent(coords);
                transparentColor.rgb = mix(uOcclusionColor * (1.0 - fogFactor), transparentColor.rgb, occlusionFactor);
            }
        #endif
    #endif

    #ifdef dOutlineEnable
        float closestTexel;
        float isTransparentOutline;
        float outline = getOutline(coords, opaqueDepth, transparentDepth, closestTexel, isTransparentOutline);
        if (outline == 0.0) {
            float viewDist = abs(getViewZ(closestTexel));
            float fogFactor = smoothstep(uFogNear, uFogFar, viewDist);
            if (!uTransparentBackground) {
                    color.rgb = mix(uOutlineColor, uFogColor, fogFactor);
            } else {
                alpha = 1.0 - fogFactor;
                color.rgb = mix(uOutlineColor, vec3(0.0), fogFactor);
            }
            #ifdef dBlendTransparency
                if (isTransparentOutline == 1.0 || transparentDepth > closestTexel) {
                    blendTransparency = false;
                }
            #endif
        }
    #endif

    #ifdef dBlendTransparency
        if (blendTransparency) {
            if (transparentColor.a != 0.0) {
                if (isBackground(opaqueDepth)) {
                    if (uTransparentBackground) {
                        color = transparentColor;
                        alpha = transparentColor.a;
                    } else {
                        color.rgb = transparentColor.rgb + uFogColor * (1.0 - transparentColor.a);
                        alpha = 1.0;
                    }
                } else {
                    // blending
                    color = transparentColor + color * (1.0 - transparentColor.a);
                    alpha = transparentColor.a + alpha * (1.0 - transparentColor.a);
                }
            }
        }
    #endif

    gl_FragColor = vec4(color.rgb, alpha);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/illumination/trace.frag.js
var trace_frag = `
precision highp int;
precision highp float;
precision highp sampler2D;

uniform sampler2D tColor;
uniform sampler2D tNormal;
uniform sampler2D tShaded;
uniform sampler2D tThickness;
uniform sampler2D tAccumulate;
uniform sampler2D tDepth;
uniform vec2 uTexSize;
uniform vec4 uBounds;

uniform float uNear;
uniform float uFar;
uniform float uFogNear;
uniform float uFogFar;
uniform vec3 uFogColor;

#if dLightCount != 0
    uniform vec3 uLightDirection[dLightCount];
    uniform vec3 uLightColor[dLightCount];
#endif
uniform vec3 uAmbientColor;
uniform vec3 uLightStrength;

uniform int uFrameNo;

uniform float uRayDistance;
uniform float uMinThickness;
uniform float uThicknessFactor;
uniform float uThickness;

uniform float uShadowSoftness;
uniform float uShadowThickness;

uniform mat4 uProjection;
uniform mat4 uInvProjection;

#include common

// parts adapted from
// - https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/
// - https://github.com/0beqz/realism-effects/blob/v2-debug/src/ssgi/shader/ssgi.frag

//

// after a hit, it moves the ray this far along the normal away from a surface.
// Helps prevent incorrect intersections when rays bounce off of objects.
#define RayPosNormalNudge 0.0001

#if __VERSION__ == 100
    #define StateType float

    // from https://www.shadertoy.com/view/4djSRW
    float hash14(vec4 p4) {
        p4 = fract(p4  * vec4(0.1031, 0.1030, 0.0973, 0.1099));
        p4 += dot(p4, p4.wzxy + 33.33);
        return fract((p4.x + p4.y) * (p4.z + p4.w));
    }

    float randomFloat(inout float state) {
        state += 0.06711056;
        return 1.0 - hash14(vec4(gl_FragCoord.xy, float(uFrameNo), state));
    }
#else
    #define StateType uint

    // https://www.pcg-random.org/
    // https://jcgt.org/published/0009/03/02/
    uint pcg(inout uint seed) {
        seed = seed * 747796405u + 2891336453u;
        uint word = ((seed >> ((seed >> 28u) + 4u)) ^ seed) * 277803737u;
        return (word >> 22u) ^ word;
    }

    float randomFloat(inout uint state) {
        return float(pcg(state)) / 4294967296.0;
    }
#endif

vec3 randomUnitVector(inout StateType state) {
    float z = randomFloat(state) * 2.0 - 1.0;
    float a = randomFloat(state) * TWO_PI;
    float r = sqrt(1.0 - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return vec3(x, y, z);
}

struct RayHitInfo {
    bool missed;
    vec3 position;
    vec3 normal;
    vec3 color;
    vec3 emissive;
};

//

float getDepth(const in vec2 coords) {
    vec2 c = vec2(clamp(coords.x, uBounds.x, uBounds.z), clamp(coords.y, uBounds.y, uBounds.w));
    return texture2D(tDepth, c).r;
}

float getThickness(const in vec2 coords) {
    vec2 c = vec2(clamp(coords.x, uBounds.x, uBounds.z), clamp(coords.y, uBounds.y, uBounds.w));
    return unpackRGBAToDepth(texture2D(tThickness, c));
}

bool isBackground(const in float depth) {
    return depth == 1.0;
}

float getViewZ(const in float depth) {
    #if dOrthographic == 1
        return orthographicDepthToViewZ(depth, uNear, uFar);
    #else
        return perspectiveDepthToViewZ(depth, uNear, uFar);
    #endif
}

vec2 viewSpaceToScreenSpace(const vec3 position) {
    vec4 projectedCoord = uProjection * vec4(position, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    // [-1, 1] --> [0, 1] (NDC to screen position)
    projectedCoord.xy = projectedCoord.xy * 0.5 + 0.5;
    return projectedCoord.xy;
}

vec2 binarySearch(inout vec3 dir, inout vec3 hitPos) {
    float rayHitDepthDifference;
    vec2 coords;

    dir *= 0.5;
    hitPos -= dir;

    for (int i = 0; i < dRefineSteps; i++) {
        coords = viewSpaceToScreenSpace(hitPos);
        float depth = getDepth(coords);
        float z = getViewZ(depth);
        rayHitDepthDifference = z - hitPos.z;

        dir *= 0.5;
        if (rayHitDepthDifference >= 0.0) {
            hitPos -= dir;
        } else {
            hitPos += dir;
        }
    }

    coords = viewSpaceToScreenSpace(hitPos);

    return coords;
}

float calculateGrowthFactor(float begin, float end, float steps) {
    return pow(end / begin, 1.0 / steps);
}

vec2 rayMarch(in vec3 dir, in float thickness, inout vec3 hitPos, out bool missed) {
    float rayHitDepthDifference;
    vec2 coords;

    float begin = float(dFirstStepSize);
    dir *= begin;
    missed = false;
    float gf = calculateGrowthFactor(begin, uRayDistance, float(dSteps));

    for (int i = 1; i < dSteps; i++) {
        hitPos += dir;
        dir *= gf;

        coords = viewSpaceToScreenSpace(hitPos);
        float depth = getDepth(coords);
        float z = getViewZ(depth);
        rayHitDepthDifference = z - hitPos.z;

        if (thickness == 0.0) {
            #ifdef dThicknessMode_auto
                thickness = max(uMinThickness, (getViewZ(getThickness(coords)) - z) * uThicknessFactor * texture2D(tColor, coords).a);
            #else
                thickness = uThickness;
            #endif
        }

        if (rayHitDepthDifference >= 0.0 && rayHitDepthDifference < thickness) {
            if (dRefineSteps == 0) {
                return coords;
            } else {
                return binarySearch(dir, hitPos);
            }
        }
    }

    missed = true;

    return coords;
}

//

void trace(in vec3 rayPos, in vec3 rayDir, inout RayHitInfo hitInfo) {
    vec3 hitPos = vec3(rayPos);
    bool missed;
    vec2 coords;
    coords = rayMarch(rayDir, 0.0, hitPos, missed);

    hitInfo.missed = missed;
    hitInfo.position = hitPos;
    hitInfo.normal = -texture2D(tNormal, coords).rgb;
    hitInfo.color = texture2D(tColor, coords).rgb;
    hitInfo.emissive = texture2D(tColor, coords).rgb * texture2D(tNormal, coords).a * 2.0;

    float depth = getDepth(coords);
    if (isBackground(depth)) {
        hitInfo.emissive = vec3(0.0);
    }
}

vec3 viewPos;

vec3 colorForRay(in vec3 startRayPos, in vec3 startRayDir, inout StateType rngState) {
    vec3 ret = vec3(0.0, 0.0, 0.0);

    vec3 throughput = vec3(1.0, 1.0, 1.0);
    vec3 rayPos = startRayPos;
    vec3 rayDir = startRayDir;

    RayHitInfo hitInfo;
    RayHitInfo prevHitInfo;

    for (int bounceIndex = 0; bounceIndex <= dBounces; ++bounceIndex) {
        // shoot a ray out into the world
        if (bounceIndex == 0) {
            vec2 coords = gl_FragCoord.xy / uTexSize;
            float depth = getDepth(coords);

            hitInfo.missed = false;
            hitInfo.position = screenSpaceToViewSpace(vec3(coords, depth), uInvProjection);
            hitInfo.normal = -texture2D(tNormal, coords).rgb;
            hitInfo.color = texture2D(tShaded, coords).rgb;
            hitInfo.emissive = texture2D(tColor, coords).rgb * texture2D(tNormal, coords).a;

            // shadow
            #ifdef dShadowEnable
                #if dLightCount != 0
                    vec3 directLight = vec3(uAmbientColor);
                    #pragma unroll_loop_start
                    bool missed;
                    vec3 hitPos;
                    for (int i = 0; i < dLightCount; ++i) {
                        missed = false;
                        hitPos = viewPos + hitInfo.normal * RayPosNormalNudge;
                        hitPos += -uLightDirection[i] * (randomFloat(rngState));
                        rayMarch(-uLightDirection[i] + randomUnitVector(rngState) * uShadowSoftness, uShadowThickness, hitPos, missed);
                        if (missed) directLight += uLightColor[i];
                    }
                    #pragma unroll_loop_end
                    hitInfo.color *= directLight / uLightStrength;
                #endif
            #endif

            if (hitInfo.normal == vec3(0.0)) {
                hitInfo.missed = true;
            }
        } else {
            prevHitInfo = hitInfo;
            trace(rayPos, rayDir, hitInfo);
        }

        // if the ray missed, we are done
        if (hitInfo.missed) {
            vec3 accIrradiance = vec3(1.0);
            #ifdef dGlow
                if (bounceIndex > 1) {
                    accIrradiance = uLightStrength;
                }
            #else
                if (bounceIndex > 1) {
                    accIrradiance = uAmbientColor;
                    #if dLightCount != 0
                        #pragma unroll_loop_start
                        float dotNL;
                        vec3 irradiance;
                        for (int i = 0; i < dLightCount; ++i) {
                            dotNL = saturate(dot(prevHitInfo.normal, -uLightDirection[i]));
                            irradiance = dotNL * uLightColor[i];
                            accIrradiance += irradiance;
                        }
                        #pragma unroll_loop_end
                    #endif
                }
            #endif
            ret += prevHitInfo.color * accIrradiance * throughput;
            break;
        }

        // add emissive light
        ret += hitInfo.emissive * throughput;

        // update the ray position
        rayPos = hitInfo.position + hitInfo.normal * RayPosNormalNudge;

        // new ray direction from normal oriented cosine weighted hemisphere sample
        rayDir = normalize(hitInfo.normal + randomUnitVector(rngState));

        if (bounceIndex == 0) {
            continue;
        }

        // update the colorMultiplier.
        throughput *= hitInfo.color;

        // Russian Roulette
        // As the throughput gets smaller, the ray is more likely to get terminated early.
        // Survivors have their value boosted to make up for fewer samples being in the average.
        {
            float p = max(throughput.r, max(throughput.g, throughput.b));
            if (randomFloat(rngState) > p)
                break;

            // Add the energy we 'lose' by randomly terminating paths
            throughput *= 1.0 / p;
        }
    }

    // return pixel color
    return ret;
}

void main() {
    vec2 coords = gl_FragCoord.xy / uTexSize;
    float depth = getDepth(coords);

    if (isBackground(depth)) {
        gl_FragColor = texture2D(tColor, coords);
        return;
    }

    #if __VERSION__ == 100
        float rngState = 26699.0;
    #else
        // initialize a random number state based on gl_FragCoord and uFrameNo
        uint rngState = uint(uint(gl_FragCoord.x) * 1973u + uint(gl_FragCoord.y) * 9277u + uint(uFrameNo) * 26699u) | 1u;
    #endif

    vec3 cameraPos = vec3(0.0, 0.0, 0.0);
    viewPos = screenSpaceToViewSpace(vec3(coords, depth), uInvProjection);
    vec3 rayDir = normalize(viewPos);

    // raytrace for this pixel
    vec3 color = vec3(0.0, 0.0, 0.0);
    for (int index = 0; index < int(dRendersPerFrame); ++index) {
        color += colorForRay(cameraPos, rayDir, rngState) / float(dRendersPerFrame);
    }

    // average the frames together
    vec4 lastFrameColor = texture2D(tAccumulate, coords);
    float blend = (uFrameNo < 1 || lastFrameColor.a == 0.0) ? 1.0 : 1.0 / (1.0 + (1.0 / lastFrameColor.a));
    color = mix(lastFrameColor.rgb, color, blend);

    // show the result
    gl_FragColor = vec4(color, blend);
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/illumination/accumulate.frag.js
var accumulate_frag2 = `
precision highp float;
precision highp sampler2D;

uniform sampler2D tColor;
uniform vec2 uTexSize;
uniform float uWeight;

void main() {
    vec2 coords = gl_FragCoord.xy / uTexSize;
    gl_FragColor = texture2D(tColor, coords) * uWeight;
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/tracing.js
var TracingParams = {
  rendersPerFrame: ParamDefinition.Interval([1, 16], { min: 1, max: 64, step: 1 }, { description: "Number of rays per pixel each frame. May be adjusted to reach targetFps but will stay within given interval." }),
  targetFps: ParamDefinition.Numeric(30, { min: 0, max: 120, step: 0.1 }, { description: "Target FPS per frame. If observed FPS is lower or higher, some parameters may get adjusted." }),
  steps: ParamDefinition.Numeric(32, { min: 1, max: 1024, step: 1 }),
  firstStepSize: ParamDefinition.Numeric(0.01, { min: 1e-3, max: 1, step: 1e-3 }),
  refineSteps: ParamDefinition.Numeric(4, { min: 0, max: 8, step: 1 }, { description: "Number of refine steps per ray hit. May be lower to reach targetFps." }),
  rayDistance: ParamDefinition.Numeric(256, { min: 1, max: 8192, step: 1 }, { description: "Maximum distance a ray can travel (in world units)." }),
  thicknessMode: ParamDefinition.Select("auto", ParamDefinition.arrayToOptions(["auto", "fixed"])),
  minThickness: ParamDefinition.Numeric(0.5, { min: 0.1, max: 16, step: 0.1 }, { hideIf: (p) => p.thicknessMode === "fixed" }),
  thicknessFactor: ParamDefinition.Numeric(1, { min: 0.1, max: 2, step: 0.05 }, { hideIf: (p) => p.thicknessMode === "fixed" }),
  thickness: ParamDefinition.Numeric(4, { min: 0.1, max: 512, step: 0.1 }, { hideIf: (p) => p.thicknessMode === "auto" }),
  bounces: ParamDefinition.Numeric(4, { min: 1, max: 32, step: 1 }, { description: "Number of bounces for each ray." }),
  glow: ParamDefinition.Boolean(true, { description: "Bounced rays always get the full light. This produces a slight glowing effect." }),
  shadowEnable: ParamDefinition.Boolean(false),
  shadowSoftness: ParamDefinition.Numeric(0.1, { min: 0.01, max: 1, step: 0.01 }),
  shadowThickness: ParamDefinition.Numeric(0.5, { min: 0.1, max: 32, step: 0.1 })
};
var TracingPass = class {
  constructor(webgl, drawPass) {
    this.webgl = webgl;
    this.drawPass = drawPass;
    this.clearAdjustedProps = true;
    this.prevTime = 0;
    this.currTime = 0;
    this.rendersPerFrame = 1;
    this.refineSteps = 1;
    this.steps = 16;
    const { extensions: { drawBuffers, colorBufferHalfFloat, textureHalfFloat }, resources, isWebGL2: isWebGL22 } = webgl;
    const { depthTextureOpaque } = drawPass;
    const width = depthTextureOpaque.getWidth();
    const height = depthTextureOpaque.getHeight();
    if (isWebGL22) {
      this.shadedTextureOpaque = resources.texture("image-uint8", "rgba", "ubyte", "nearest");
      this.shadedTextureOpaque.define(width, height);
      this.normalTextureOpaque = colorBufferHalfFloat && textureHalfFloat ? resources.texture("image-float16", "rgba", "fp16", "nearest") : resources.texture("image-float32", "rgba", "float", "nearest");
      this.normalTextureOpaque.define(width, height);
      this.colorTextureOpaque = resources.texture("image-uint8", "rgba", "ubyte", "nearest");
      this.colorTextureOpaque.define(width, height);
    } else {
      this.shadedTextureOpaque = resources.texture("image-float32", "rgba", "float", "nearest");
      this.shadedTextureOpaque.define(width, height);
      this.normalTextureOpaque = resources.texture("image-float32", "rgba", "float", "nearest");
      this.normalTextureOpaque.define(width, height);
      this.colorTextureOpaque = resources.texture("image-float32", "rgba", "float", "nearest");
      this.colorTextureOpaque.define(width, height);
    }
    this.framebuffer = resources.framebuffer();
    this.framebuffer.bind();
    drawBuffers.drawBuffers([
      drawBuffers.COLOR_ATTACHMENT0,
      drawBuffers.COLOR_ATTACHMENT1,
      drawBuffers.COLOR_ATTACHMENT2
    ]);
    this.shadedTextureOpaque.attachFramebuffer(this.framebuffer, "color0");
    this.normalTextureOpaque.attachFramebuffer(this.framebuffer, "color1");
    this.colorTextureOpaque.attachFramebuffer(this.framebuffer, "color2");
    this.thicknessTarget = webgl.createRenderTarget(width, height, true, "uint8", "nearest");
    this.holdTarget = webgl.createRenderTarget(width, height, false, "float32");
    this.accumulateTarget = webgl.createRenderTarget(width, height, false, "float32");
    this.composeTarget = webgl.createRenderTarget(width, height, false, "uint8", "linear");
    this.traceRenderable = getTraceRenderable(webgl, this.colorTextureOpaque, this.normalTextureOpaque, this.shadedTextureOpaque, this.thicknessTarget.texture, this.accumulateTarget.texture, this.drawPass.depthTextureOpaque);
    this.accumulateRenderable = getAccumulateRenderable2(webgl, this.holdTarget.texture);
  }
  renderInput(renderer, camera, scene, props) {
    if (isTimingMode)
      this.webgl.timer.mark("TracePass.renderInput");
    const { gl, state } = this.webgl;
    this.framebuffer.bind();
    this.drawPass.depthTextureOpaque.attachFramebuffer(this.framebuffer, "depth");
    renderer.clear(true);
    renderer.renderTracing(scene.primitives, camera);
    if (props.thicknessMode === "auto") {
      this.thicknessTarget.bind();
      state.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      renderer.renderDepthOpaqueBack(scene.primitives, camera);
    }
    if (isTimingMode)
      this.webgl.timer.markEnd("TracePass.renderInput");
  }
  setSize(width, height) {
    const w = this.composeTarget.getWidth();
    const h = this.composeTarget.getHeight();
    if (width !== w || height !== h) {
      this.thicknessTarget.setSize(width, height);
      this.holdTarget.setSize(width, height);
      this.accumulateTarget.setSize(width, height);
      this.composeTarget.setSize(width, height);
      this.colorTextureOpaque.define(width, height);
      this.normalTextureOpaque.define(width, height);
      this.shadedTextureOpaque.define(width, height);
      ValueCell.update(this.traceRenderable.values.uTexSize, Vec2.set(this.traceRenderable.values.uTexSize.ref.value, width, height));
      ValueCell.update(this.accumulateRenderable.values.uTexSize, Vec2.set(this.accumulateRenderable.values.uTexSize.ref.value, width, height));
    }
  }
  reset() {
    const { drawBuffers } = this.webgl.extensions;
    this.framebuffer.bind();
    drawBuffers.drawBuffers([
      drawBuffers.COLOR_ATTACHMENT0,
      drawBuffers.COLOR_ATTACHMENT1,
      drawBuffers.COLOR_ATTACHMENT2
    ]);
    this.shadedTextureOpaque.attachFramebuffer(this.framebuffer, "color0");
    this.normalTextureOpaque.attachFramebuffer(this.framebuffer, "color1");
    this.colorTextureOpaque.attachFramebuffer(this.framebuffer, "color2");
    this.restart(true);
  }
  restart(clearAdjustedProps = false) {
    const { gl, state } = this.webgl;
    this.accumulateTarget.bind();
    state.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this.composeTarget.bind();
    state.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    if (clearAdjustedProps) {
      this.prevTime = 0;
      this.currTime = 0;
      this.clearAdjustedProps = true;
    }
  }
  increaseAdjustedProps(props) {
    this.steps += 1;
    if (this.steps > props.steps) {
      this.refineSteps += 1;
    }
    if (this.refineSteps > props.refineSteps) {
      this.rendersPerFrame += 1;
    }
  }
  decreaseAdjustedProps(props) {
    const minRefineSteps = Math.min(1, props.refineSteps);
    this.rendersPerFrame -= 1;
    if (this.rendersPerFrame < 1) {
      this.refineSteps -= 1;
    }
    if (this.refineSteps < minRefineSteps) {
      this.steps -= 1;
    }
  }
  getAdjustedProps(props, iteration) {
    this.currTime = now();
    const minRefineSteps = Math.min(1, props.refineSteps);
    const minSteps = Math.round(props.steps / 2);
    if (this.clearAdjustedProps) {
      this.rendersPerFrame = props.rendersPerFrame[0];
      this.refineSteps = minRefineSteps;
      this.steps = minSteps;
      this.clearAdjustedProps = false;
    }
    if (iteration > 0) {
      const targetTimeMs = 1e3 / props.targetFps;
      const deltaTime = this.currTime - this.prevTime;
      let f = Math.round(deltaTime / targetTimeMs);
      if (f >= 2) {
        while (f > 0) {
          this.decreaseAdjustedProps(props);
          f -= 1;
        }
      } else if (deltaTime < targetTimeMs) {
        this.increaseAdjustedProps(props);
      } else if (deltaTime > targetTimeMs + 0.5) {
        this.decreaseAdjustedProps(props);
      }
    }
    this.prevTime = this.currTime;
    this.rendersPerFrame = clamp(this.rendersPerFrame, props.rendersPerFrame[0], props.rendersPerFrame[1]);
    this.refineSteps = clamp(this.refineSteps, minRefineSteps, props.refineSteps);
    this.steps = clamp(this.steps, minSteps, props.steps);
    return {
      rendersPerFrame: iteration === 0 ? Math.ceil(this.rendersPerFrame / 2) : this.rendersPerFrame,
      refineSteps: iteration === 0 ? minRefineSteps : this.refineSteps,
      steps: iteration === 0 ? minSteps : this.steps
    };
  }
  render(ctx, transparentBackground, props, iteration, forceRenderInput) {
    const { rendersPerFrame, refineSteps, steps } = this.getAdjustedProps(props, iteration);
    if (isTimingMode) {
      this.webgl.timer.mark("TracePass.render", {
        note: `${rendersPerFrame} rendersPerFrame, ${refineSteps} refineSteps, ${steps} steps`
      });
    }
    const { renderer, camera, scene } = ctx;
    const { gl, state } = this.webgl;
    const { x, y, width, height } = camera.viewport;
    if (iteration === 0 || forceRenderInput) {
      renderer.setTransparentBackground(transparentBackground);
      renderer.setDrawingBufferSize(this.composeTarget.getWidth(), this.composeTarget.getHeight());
      renderer.setPixelRatio(this.webgl.pixelRatio);
      renderer.setViewport(x, y, width, height);
      renderer.update(camera, scene);
      this.renderInput(renderer, camera, scene, props);
    }
    state.disable(gl.BLEND);
    state.disable(gl.DEPTH_TEST);
    state.disable(gl.CULL_FACE);
    state.depthMask(false);
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    const invProjection = Mat4.identity();
    Mat4.invert(invProjection, camera.projection);
    const orthographic = camera.state.mode === "orthographic" ? 1 : 0;
    const [w, h] = this.traceRenderable.values.uTexSize.ref.value;
    const v3 = camera.viewport;
    const ambientColor = Vec3();
    Vec3.scale(ambientColor, Color.toArrayNormalized(renderer.props.ambientColor, ambientColor, 0), renderer.props.ambientIntensity);
    const lightStrength = Vec3.clone(ambientColor);
    for (let i = 0, il = renderer.light.count; i < il; ++i) {
      const light = Vec3.fromArray(Vec3(), renderer.light.color, i * 3);
      Vec3.add(lightStrength, lightStrength, light);
    }
    this.holdTarget.bind();
    let needsUpdateTrace = false;
    ValueCell.update(this.traceRenderable.values.uFrameNo, iteration);
    if (this.traceRenderable.values.dRendersPerFrame.ref.value !== rendersPerFrame) {
      ValueCell.update(this.traceRenderable.values.dRendersPerFrame, rendersPerFrame);
      needsUpdateTrace = true;
    }
    ValueCell.update(this.traceRenderable.values.uProjection, camera.projection);
    ValueCell.update(this.traceRenderable.values.uInvProjection, invProjection);
    Vec4.set(this.traceRenderable.values.uBounds.ref.value, v3.x / w, v3.y / h, (v3.x + v3.width) / w, (v3.y + v3.height) / h);
    ValueCell.update(this.traceRenderable.values.uBounds, this.traceRenderable.values.uBounds.ref.value);
    ValueCell.updateIfChanged(this.traceRenderable.values.uNear, camera.near);
    ValueCell.updateIfChanged(this.traceRenderable.values.uFar, camera.far);
    ValueCell.updateIfChanged(this.traceRenderable.values.uFogFar, camera.fogFar);
    ValueCell.updateIfChanged(this.traceRenderable.values.uFogNear, camera.fogNear);
    ValueCell.update(this.traceRenderable.values.uFogColor, Color.toVec3Normalized(this.traceRenderable.values.uFogColor.ref.value, renderer.props.backgroundColor));
    if (this.traceRenderable.values.dOrthographic.ref.value !== orthographic) {
      ValueCell.update(this.traceRenderable.values.dOrthographic, orthographic);
      needsUpdateTrace = true;
    }
    ValueCell.update(this.traceRenderable.values.uLightDirection, renderer.light.direction);
    ValueCell.update(this.traceRenderable.values.uLightColor, renderer.light.color);
    if (this.traceRenderable.values.dLightCount.ref.value !== renderer.light.count) {
      ValueCell.update(this.traceRenderable.values.dLightCount, renderer.light.count);
      needsUpdateTrace = true;
    }
    ValueCell.update(this.traceRenderable.values.uAmbientColor, ambientColor);
    ValueCell.update(this.traceRenderable.values.uLightStrength, lightStrength);
    if (this.traceRenderable.values.dGlow.ref.value !== props.glow) {
      ValueCell.update(this.traceRenderable.values.dGlow, props.glow);
      needsUpdateTrace = true;
    }
    if (this.traceRenderable.values.dBounces.ref.value !== props.bounces) {
      ValueCell.update(this.traceRenderable.values.dBounces, props.bounces);
      needsUpdateTrace = true;
    }
    if (this.traceRenderable.values.dSteps.ref.value !== steps) {
      ValueCell.update(this.traceRenderable.values.dSteps, steps);
      needsUpdateTrace = true;
    }
    if (this.traceRenderable.values.dFirstStepSize.ref.value !== props.firstStepSize) {
      ValueCell.update(this.traceRenderable.values.dFirstStepSize, props.firstStepSize);
      needsUpdateTrace = true;
    }
    if (this.traceRenderable.values.dRefineSteps.ref.value !== refineSteps) {
      ValueCell.update(this.traceRenderable.values.dRefineSteps, refineSteps);
      needsUpdateTrace = true;
    }
    ValueCell.updateIfChanged(this.traceRenderable.values.uRayDistance, props.rayDistance);
    if (this.traceRenderable.values.dThicknessMode.ref.value !== props.thicknessMode) {
      ValueCell.update(this.traceRenderable.values.dThicknessMode, props.thicknessMode);
      needsUpdateTrace = true;
    }
    ValueCell.updateIfChanged(this.traceRenderable.values.uMinThickness, props.minThickness);
    ValueCell.updateIfChanged(this.traceRenderable.values.uThicknessFactor, props.thicknessFactor);
    ValueCell.updateIfChanged(this.traceRenderable.values.uThickness, props.thickness);
    if (this.traceRenderable.values.dShadowEnable.ref.value !== props.shadowEnable) {
      ValueCell.update(this.traceRenderable.values.dShadowEnable, props.shadowEnable);
      needsUpdateTrace = true;
    }
    ValueCell.updateIfChanged(this.traceRenderable.values.uShadowSoftness, props.shadowSoftness);
    ValueCell.updateIfChanged(this.traceRenderable.values.uShadowThickness, props.shadowThickness);
    if (needsUpdateTrace)
      this.traceRenderable.update();
    if (isTimingMode)
      this.webgl.timer.mark("TracePass.renderTrace");
    this.traceRenderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("TracePass.renderTrace");
    this.accumulateTarget.bind();
    this.accumulateRenderable.render();
    if (isTimingMode)
      this.webgl.timer.markEnd("TracePass.render");
  }
};
var TraceSchema = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tNormal: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tShaded: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tThickness: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tAccumulate: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tDepth: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSize: UniformSpec("v2"),
  dOrthographic: DefineSpec("number"),
  uNear: UniformSpec("f"),
  uFar: UniformSpec("f"),
  uFogNear: UniformSpec("f"),
  uFogFar: UniformSpec("f"),
  uFogColor: UniformSpec("v3"),
  uProjection: UniformSpec("m4"),
  uInvProjection: UniformSpec("m4"),
  uBounds: UniformSpec("v4"),
  uLightDirection: UniformSpec("v3[]"),
  uLightColor: UniformSpec("v3[]"),
  dLightCount: DefineSpec("number"),
  uAmbientColor: UniformSpec("v3"),
  uLightStrength: UniformSpec("v3"),
  uFrameNo: UniformSpec("i"),
  dRendersPerFrame: DefineSpec("number"),
  dGlow: DefineSpec("boolean"),
  dBounces: DefineSpec("number"),
  dSteps: DefineSpec("number"),
  dFirstStepSize: DefineSpec("number"),
  dRefineSteps: DefineSpec("number"),
  uRayDistance: UniformSpec("f"),
  dThicknessMode: DefineSpec("string"),
  uMinThickness: UniformSpec("f"),
  uThicknessFactor: UniformSpec("f"),
  uThickness: UniformSpec("f"),
  dShadowEnable: DefineSpec("boolean"),
  uShadowSoftness: UniformSpec("f"),
  uShadowThickness: UniformSpec("f")
};
var TraceShaderCode = ShaderCode("trace", quad_vert, trace_frag);
function getTraceRenderable(ctx, colorTexture, normalTexture, shadedTexture, thicknessTexture, accumulateTexture, depthTexture) {
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(colorTexture),
    tNormal: ValueCell.create(normalTexture),
    tShaded: ValueCell.create(shadedTexture),
    tThickness: ValueCell.create(thicknessTexture),
    tAccumulate: ValueCell.create(accumulateTexture),
    tDepth: ValueCell.create(depthTexture),
    uTexSize: ValueCell.create(Vec2.create(colorTexture.getWidth(), colorTexture.getHeight())),
    dOrthographic: ValueCell.create(0),
    uNear: ValueCell.create(1),
    uFar: ValueCell.create(1e4),
    uFogNear: ValueCell.create(1e4),
    uFogFar: ValueCell.create(1e4),
    uFogColor: ValueCell.create(Vec3.create(1, 1, 1)),
    uProjection: ValueCell.create(Mat4.identity()),
    uInvProjection: ValueCell.create(Mat4.identity()),
    uBounds: ValueCell.create(Vec4()),
    uLightDirection: ValueCell.create([]),
    uLightColor: ValueCell.create([]),
    dLightCount: ValueCell.create(0),
    uAmbientColor: ValueCell.create(Vec3()),
    uLightStrength: ValueCell.create(Vec3.create(1, 1, 1)),
    uFrameNo: ValueCell.create(0),
    dRendersPerFrame: ValueCell.create(1),
    dGlow: ValueCell.create(true),
    dBounces: ValueCell.create(4),
    dSteps: ValueCell.create(32),
    dFirstStepSize: ValueCell.create(0.01),
    dRefineSteps: ValueCell.create(4),
    uRayDistance: ValueCell.create(256),
    dThicknessMode: ValueCell.create("auto"),
    uMinThickness: ValueCell.create(0.5),
    uThicknessFactor: ValueCell.create(1),
    uThickness: ValueCell.create(4),
    dShadowEnable: ValueCell.create(false),
    uShadowSoftness: ValueCell.create(0.1),
    uShadowThickness: ValueCell.create(0.1)
  };
  const schema = { ...TraceSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", TraceShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var AccumulateSchema = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSize: UniformSpec("v2"),
  uWeight: UniformSpec("f")
};
var AccumulateShaderCode = ShaderCode("accumulate", quad_vert, accumulate_frag2);
function getAccumulateRenderable2(ctx, colorTexture) {
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(colorTexture),
    uTexSize: ValueCell.create(Vec2.create(colorTexture.getWidth(), colorTexture.getHeight())),
    uWeight: ValueCell.create(1)
  };
  const schema = { ...AccumulateSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", AccumulateShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/illumination.js
var IlluminationParams = {
  enabled: ParamDefinition.Boolean(false),
  maxIterations: ParamDefinition.Numeric(5, { min: 0, max: 16, step: 1 }, { description: "Maximum number of tracing iterations. Final iteration count is 2^x." }),
  denoise: ParamDefinition.Boolean(true),
  denoiseThreshold: ParamDefinition.Interval([0.15, 1], { min: 0, max: 4, step: 0.01 }, { description: "Threshold for denoising. Automatically adjusted within given interval based on current iteration." }),
  ignoreOutline: ParamDefinition.Boolean(true, { description: "Ignore outline in illumination pass where it is generally not needed for visual clarity. Useful when illumination is often toggled on/off." }),
  ...TracingParams
};
var IlluminationPass = class _IlluminationPass {
  get iteration() {
    return this._iteration;
  }
  get colorTarget() {
    return this._colorTarget;
  }
  get supported() {
    return this._supported;
  }
  getMaxIterations(props) {
    return Math.pow(2, props.illumination.maxIterations);
  }
  static isSupported(webgl) {
    const { drawBuffers, textureFloat, colorBufferFloat, depthTexture } = webgl.extensions;
    if (!textureFloat || !colorBufferFloat || !depthTexture || !drawBuffers) {
      if (isDebugMode) {
        const missing = [];
        if (!textureFloat)
          missing.push("textureFloat");
        if (!colorBufferFloat)
          missing.push("colorBufferFloat");
        if (!depthTexture)
          missing.push("depthTexture");
        if (!drawBuffers)
          missing.push("drawBuffers");
        console.log(`Missing "${missing.join('", "')}" extensions required for "illumination"`);
      }
      return false;
    } else {
      return true;
    }
  }
  constructor(webgl, drawPass) {
    this.webgl = webgl;
    this.drawPass = drawPass;
    this._iteration = 0;
    this._supported = false;
    this.prevSampleIndex = -1;
    if (!_IlluminationPass.isSupported(webgl))
      return;
    const { colorTarget } = drawPass;
    const width = colorTarget.getWidth();
    const height = colorTarget.getHeight();
    this.tracing = new TracingPass(webgl, this.drawPass);
    this.transparentTarget = webgl.createRenderTarget(width, height, false, "uint8", "nearest");
    this.outputTarget = webgl.createRenderTarget(width, height, false, "uint8", "linear");
    this.copyRenderable = createCopyRenderable(webgl, this.transparentTarget.texture);
    this.composeRenderable = getComposeRenderable2(webgl, this.tracing.accumulateTarget.texture, this.tracing.normalTextureOpaque, this.tracing.colorTextureOpaque, this.drawPass.depthTextureOpaque, this.drawPass.depthTargetTransparent.texture, this.drawPass.postprocessing.outline.target.texture, this.transparentTarget.texture, this.drawPass.postprocessing.ssao.ssaoDepthTexture, this.drawPass.postprocessing.ssao.ssaoDepthTransparentTexture, false);
    this.multiSampleComposeTarget = webgl.createRenderTarget(width, height, false, "float32");
    this.multiSampleHoldTarget = webgl.createRenderTarget(width, height, false);
    this.multiSampleAccumulateTarget = webgl.createRenderTarget(width, height, false, "float32");
    this.multiSampleCompose = getMultiSampleComposeRenderable(webgl, this.outputTarget.texture);
    this._supported = true;
  }
  renderInput(renderer, camera, scene, props) {
    if (isTimingMode)
      this.webgl.timer.mark("IlluminationPass.renderInput");
    const { gl, state } = this.webgl;
    const markingEnabled = MarkingPass.isEnabled(props.marking);
    const hasTransparent = scene.opacityAverage < 1;
    const hasMarking = markingEnabled && scene.markerAverage > 0;
    this.transparentTarget.bind();
    state.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    const outlineEnabled = PostprocessingPass.isTransparentOutlineEnabled(props.postprocessing) && !props.illumination.ignoreOutline;
    const dofEnabled = DofPass.isEnabled(props.postprocessing);
    const ssaoEnabled = PostprocessingPass.isTransparentSsaoEnabled(scene, props.postprocessing);
    if (outlineEnabled || dofEnabled || ssaoEnabled) {
      this.drawPass.depthTargetTransparent.bind();
      renderer.clearDepth(true);
    }
    if (hasTransparent) {
      if (this.drawPass.transparency === "wboit") {
        this.drawPass.wboit.bind();
        renderer.renderWboitTransparent(scene.primitives, camera, this.drawPass.depthTextureOpaque);
        if (scene.volumes.renderables.length > 0) {
          renderer.renderWboitTransparent(scene.volumes, camera, this.drawPass.depthTextureOpaque);
        }
        this.transparentTarget.bind();
        this.drawPass.wboit.render();
      } else if (this.drawPass.transparency === "dpoit") {
        const dpoitTextures = this.drawPass.dpoit.bind();
        renderer.renderDpoitTransparent(scene.primitives, camera, this.drawPass.depthTextureOpaque, dpoitTextures);
        for (let i = 0, il = props.dpoitIterations; i < il; i++) {
          if (isTimingMode)
            this.webgl.timer.mark("DpoitPass.layer");
          const dpoitTextures2 = this.drawPass.dpoit.bindDualDepthPeeling();
          renderer.renderDpoitTransparent(scene.primitives, camera, this.drawPass.depthTextureOpaque, dpoitTextures2);
          this.transparentTarget.bind();
          this.drawPass.dpoit.renderBlendBack();
          if (isTimingMode)
            this.webgl.timer.markEnd("DpoitPass.layer");
        }
        this.transparentTarget.bind();
        this.drawPass.dpoit.render();
        if (scene.volumes.renderables.length > 0) {
          renderer.renderVolume(scene.volumes, camera, this.drawPass.depthTextureOpaque);
        }
      } else {
        this.transparentTarget.bind();
        this.drawPass.depthTextureOpaque.attachFramebuffer(this.transparentTarget.framebuffer, "depth");
        renderer.renderBlendedTransparent(scene.primitives, camera);
        this.drawPass.depthTextureOpaque.detachFramebuffer(this.transparentTarget.framebuffer, "depth");
        if (scene.volumes.renderables.length > 0) {
          renderer.renderVolume(scene.volumes, camera, this.drawPass.depthTextureOpaque);
        }
      }
      if (outlineEnabled || dofEnabled || ssaoEnabled) {
        this.drawPass.depthTargetTransparent.bind();
        if (scene.opacityAverage < 1) {
          renderer.renderDepthTransparent(scene.primitives, camera, this.drawPass.depthTextureOpaque);
        }
      }
      if (ssaoEnabled) {
        this.drawPass.postprocessing.ssao.update(camera, scene, props.postprocessing.occlusion.params, true);
        this.drawPass.postprocessing.ssao.render(camera);
      }
    }
    if (hasMarking) {
      const markingDepthTest = props.marking.ghostEdgeStrength < 1;
      if (markingDepthTest && scene.markerAverage !== 1) {
        this.drawPass.marking.depthTarget.bind();
        renderer.clear(false, true);
        renderer.renderMarkingDepth(scene.primitives, camera);
      }
      this.drawPass.marking.maskTarget.bind();
      renderer.clear(false, true);
      renderer.renderMarkingMask(scene.primitives, camera, markingDepthTest ? this.drawPass.marking.depthTarget.texture : null);
      this.drawPass.marking.update(props.marking);
      this.drawPass.marking.render(camera.viewport, this.transparentTarget);
    }
    this.tracing.composeTarget.bind();
    state.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    if (isTimingMode)
      this.webgl.timer.markEnd("IlluminationPass.renderInput");
  }
  shouldRender(props) {
    return this._supported && props.illumination.enabled && this._iteration < this.getMaxIterations(props);
  }
  setSize(width, height) {
    if (!this._supported)
      return;
    const w = this.outputTarget.getWidth();
    const h = this.outputTarget.getHeight();
    if (width !== w || height !== h) {
      this.tracing.setSize(width, height);
      this.transparentTarget.setSize(width, height);
      this.outputTarget.setSize(width, height);
      ValueCell.update(this.copyRenderable.values.uTexSize, Vec2.set(this.copyRenderable.values.uTexSize.ref.value, width, height));
      ValueCell.update(this.composeRenderable.values.uTexSize, Vec2.set(this.composeRenderable.values.uTexSize.ref.value, width, height));
      this.multiSampleComposeTarget.setSize(width, height);
      this.multiSampleHoldTarget.setSize(width, height);
      this.multiSampleAccumulateTarget.setSize(width, height);
      ValueCell.update(this.multiSampleCompose.values.uTexSize, Vec2.set(this.multiSampleCompose.values.uTexSize.ref.value, width, height));
    }
    this.drawPass.setSize(width, height);
  }
  reset() {
    if (!this._supported)
      return;
    this.tracing.reset();
    this._iteration = 0;
    this.prevSampleIndex = -1;
  }
  restart(clearAdjustedProps = false) {
    if (!this._supported)
      return;
    this.tracing.restart(clearAdjustedProps);
    this._iteration = 0;
    this.prevSampleIndex = -1;
  }
  renderInternal(ctx, props, toDrawingBuffer, forceRenderInput) {
    if (!this.shouldRender(props))
      return;
    if (isTimingMode) {
      this.webgl.timer.mark("IlluminationPass.render", {
        note: `iteration ${this._iteration + 1} of ${this.getMaxIterations(props)}`
      });
    }
    this.tracing.render(ctx, props.transparentBackground, props.illumination, this._iteration, forceRenderInput);
    const { renderer, camera, scene, helper } = ctx;
    const { gl, state } = this.webgl;
    const { x, y, width, height } = camera.viewport;
    if (this._iteration === 0 || forceRenderInput) {
      renderer.setTransparentBackground(props.transparentBackground);
      renderer.setDrawingBufferSize(this.tracing.composeTarget.getWidth(), this.tracing.composeTarget.getHeight());
      renderer.setPixelRatio(this.webgl.pixelRatio);
      renderer.setViewport(x, y, width, height);
      renderer.update(camera, scene);
      this.renderInput(renderer, camera, scene, props);
    }
    state.disable(gl.BLEND);
    state.disable(gl.DEPTH_TEST);
    state.disable(gl.CULL_FACE);
    state.depthMask(false);
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    const orthographic = camera.state.mode === "orthographic" ? 1 : 0;
    const outlinesEnabled = props.postprocessing.outline.name === "on" && !props.illumination.ignoreOutline;
    const occlusionEnabled = PostprocessingPass.isTransparentSsaoEnabled(scene, props.postprocessing);
    const markingEnabled = MarkingPass.isEnabled(props.marking);
    const hasTransparent = scene.opacityAverage < 1;
    const hasMarking = markingEnabled && scene.markerAverage > 0;
    let needsUpdateCompose = false;
    if (this.composeRenderable.values.dOutlineEnable.ref.value !== outlinesEnabled) {
      needsUpdateCompose = true;
      ValueCell.update(this.composeRenderable.values.dOutlineEnable, outlinesEnabled);
    }
    if (props.postprocessing.outline.name === "on") {
      const { transparentOutline, outlineScale } = this.drawPass.postprocessing.outline.update(camera, props.postprocessing.outline.params, this.drawPass.depthTargetTransparent.texture, this.drawPass.depthTextureOpaque);
      this.drawPass.postprocessing.outline.render();
      ValueCell.update(this.composeRenderable.values.uOutlineColor, Color.toVec3Normalized(this.composeRenderable.values.uOutlineColor.ref.value, props.postprocessing.outline.params.color));
      if (this.composeRenderable.values.dOutlineScale.ref.value !== outlineScale) {
        needsUpdateCompose = true;
        ValueCell.update(this.composeRenderable.values.dOutlineScale, outlineScale);
      }
      if (this.composeRenderable.values.dTransparentOutline.ref.value !== transparentOutline) {
        needsUpdateCompose = true;
        ValueCell.update(this.composeRenderable.values.dTransparentOutline, transparentOutline);
      }
    }
    if (this.composeRenderable.values.dOcclusionEnable.ref.value !== occlusionEnabled) {
      needsUpdateCompose = true;
      ValueCell.update(this.composeRenderable.values.dOcclusionEnable, occlusionEnabled);
    }
    if (props.postprocessing.occlusion.name === "on") {
      ValueCell.update(this.composeRenderable.values.uOcclusionColor, Color.toVec3Normalized(this.composeRenderable.values.uOcclusionColor.ref.value, props.postprocessing.occlusion.params.color));
    }
    const blendTransparency = hasTransparent || hasMarking;
    if (this.composeRenderable.values.dBlendTransparency.ref.value !== blendTransparency) {
      needsUpdateCompose = true;
      ValueCell.update(this.composeRenderable.values.dBlendTransparency, blendTransparency);
    }
    ValueCell.updateIfChanged(this.composeRenderable.values.uNear, camera.near);
    ValueCell.updateIfChanged(this.composeRenderable.values.uFar, camera.far);
    ValueCell.updateIfChanged(this.composeRenderable.values.uFogFar, camera.fogFar);
    ValueCell.updateIfChanged(this.composeRenderable.values.uFogNear, camera.fogNear);
    ValueCell.update(this.composeRenderable.values.uFogColor, Color.toVec3Normalized(this.composeRenderable.values.uFogColor.ref.value, renderer.props.backgroundColor));
    if (this.composeRenderable.values.dOrthographic.ref.value !== orthographic) {
      ValueCell.update(this.composeRenderable.values.dOrthographic, orthographic);
      needsUpdateCompose = true;
    }
    const _toDrawingBuffer = toDrawingBuffer && !AntialiasingPass.isEnabled(props.postprocessing) && props.postprocessing.dof.name === "off";
    if (_toDrawingBuffer) {
      this.webgl.unbindFramebuffer();
    } else {
      this.tracing.composeTarget.bind();
    }
    this._colorTarget = this.tracing.composeTarget;
    this.drawPass.postprocessing.background.update(camera, props.postprocessing.background);
    this.drawPass.postprocessing.background.clear(props.postprocessing.background, props.transparentBackground, renderer.props.backgroundColor);
    this.drawPass.postprocessing.background.render(props.postprocessing.background);
    ValueCell.updateIfChanged(this.composeRenderable.values.uTransparentBackground, props.transparentBackground || this.drawPass.postprocessing.background.isEnabled(props.postprocessing.background));
    if (this.composeRenderable.values.dDenoise.ref.value !== props.illumination.denoise) {
      ValueCell.update(this.composeRenderable.values.dDenoise, props.illumination.denoise);
      needsUpdateCompose = true;
    }
    const denoiseThreshold = props.multiSample.mode === "on" ? props.illumination.denoiseThreshold[0] : lerp(props.illumination.denoiseThreshold[1], props.illumination.denoiseThreshold[0], clamp(this.iteration / (this.getMaxIterations(props) / 2), 0, 1));
    ValueCell.updateIfChanged(this.composeRenderable.values.uDenoiseThreshold, denoiseThreshold);
    if (needsUpdateCompose)
      this.composeRenderable.update();
    this.composeRenderable.render();
    renderer.setDrawingBufferSize(this.tracing.composeTarget.getWidth(), this.tracing.composeTarget.getHeight());
    renderer.setPixelRatio(this.webgl.pixelRatio);
    renderer.setViewport(x, y, width, height);
    renderer.update(camera, scene);
    if (helper.debug.isEnabled) {
      helper.debug.syncVisibility();
      renderer.renderBlended(helper.debug.scene, camera);
    }
    if (helper.handle.isEnabled) {
      renderer.renderBlended(helper.handle.scene, camera);
    }
    if (helper.camera.isEnabled) {
      helper.camera.update(camera);
      renderer.update(helper.camera.camera, helper.camera.scene);
      renderer.renderBlended(helper.camera.scene, helper.camera.camera);
    }
    let targetIsDrawingbuffer = false;
    let swapTarget = this.outputTarget;
    if (AntialiasingPass.isEnabled(props.postprocessing)) {
      const _toDrawingBuffer2 = toDrawingBuffer && props.postprocessing.dof.name === "off";
      this.drawPass.antialiasing.render(camera, this.tracing.composeTarget.texture, _toDrawingBuffer2 ? true : this.outputTarget, props.postprocessing);
      if (_toDrawingBuffer2) {
        targetIsDrawingbuffer = true;
      } else {
        this._colorTarget = this.outputTarget;
        swapTarget = this.tracing.composeTarget;
      }
    }
    if (props.postprocessing.bloom.name === "on") {
      const _toDrawingBuffer2 = toDrawingBuffer && props.postprocessing.dof.name === "off" || targetIsDrawingbuffer;
      this.drawPass.bloom.update(this.tracing.colorTextureOpaque, this.tracing.normalTextureOpaque, this.drawPass.depthTextureOpaque, props.postprocessing.bloom.params);
      this.drawPass.bloom.render(camera.viewport, _toDrawingBuffer2 ? void 0 : this._colorTarget);
    }
    if (props.postprocessing.dof.name === "on") {
      const _toDrawingBuffer2 = toDrawingBuffer || targetIsDrawingbuffer;
      this.drawPass.dof.update(camera, this._colorTarget.texture, this.drawPass.depthTextureOpaque, this.drawPass.depthTargetTransparent.texture, props.postprocessing.dof.params, scene.boundingSphereVisible);
      this.drawPass.dof.render(camera.viewport, _toDrawingBuffer2 ? void 0 : swapTarget);
      if (!_toDrawingBuffer2) {
        this._colorTarget = swapTarget;
      }
    }
    this._iteration += 1;
    if (isTimingMode)
      this.webgl.timer.markEnd("IlluminationPass.render");
    this.webgl.gl.flush();
  }
  renderMultiSample(ctx, props, toDrawingBuffer) {
    const { camera } = ctx;
    const { multiSampleCompose, multiSampleComposeTarget, multiSampleHoldTarget, webgl } = this;
    const { gl, state } = webgl;
    const offsetList = JitterVectors[Math.max(0, Math.min(props.multiSample.sampleLevel, 5))];
    const maxIterations = this.getMaxIterations(props);
    const iteration = Math.min(this._iteration, maxIterations);
    const sampleIndex = Math.floor(iteration / maxIterations * offsetList.length);
    if (isTimingMode) {
      webgl.timer.mark("IlluminationPass.renderMultiSample", {
        note: `sampleIndex ${sampleIndex + 1} of ${offsetList.length}`
      });
    }
    const { x, y, width, height } = camera.viewport;
    const sampleWeight = 1 / maxIterations;
    if (iteration === 0) {
      this.renderInternal(ctx, props, false, true);
      ValueCell.update(multiSampleCompose.values.uWeight, 1);
      ValueCell.update(multiSampleCompose.values.tColor, this._colorTarget.texture);
      multiSampleCompose.update();
      multiSampleHoldTarget.bind();
      state.disable(gl.BLEND);
      state.disable(gl.DEPTH_TEST);
      state.depthMask(false);
      state.viewport(x, y, width, height);
      state.scissor(x, y, width, height);
      multiSampleCompose.render();
    } else {
      camera.viewOffset.enabled = true;
      ValueCell.update(multiSampleCompose.values.tColor, this._colorTarget.texture);
      ValueCell.update(multiSampleCompose.values.uWeight, sampleWeight);
      multiSampleCompose.update();
      const offset = offsetList[sampleIndex];
      Camera.setViewOffset(camera.viewOffset, width, height, offset[0], offset[1], width, height);
      camera.update();
      this.renderInternal(ctx, props, false, this.prevSampleIndex !== sampleIndex);
      multiSampleComposeTarget.bind();
      state.enable(gl.BLEND);
      state.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
      state.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
      state.disable(gl.DEPTH_TEST);
      state.depthMask(false);
      state.viewport(x, y, width, height);
      state.scissor(x, y, width, height);
      if (iteration === 1) {
        state.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      multiSampleCompose.render();
    }
    this.prevSampleIndex = sampleIndex;
    if (toDrawingBuffer) {
      this.webgl.unbindFramebuffer();
    } else {
      this.multiSampleAccumulateTarget.bind();
    }
    state.viewport(x, y, width, height);
    state.scissor(x, y, width, height);
    const accumulationWeight = iteration * sampleWeight;
    if (accumulationWeight > 0) {
      ValueCell.update(multiSampleCompose.values.uWeight, 1);
      ValueCell.update(multiSampleCompose.values.tColor, multiSampleComposeTarget.texture);
      multiSampleCompose.update();
      state.disable(gl.BLEND);
      multiSampleCompose.render();
    }
    if (accumulationWeight < 1) {
      ValueCell.update(multiSampleCompose.values.uWeight, 1 - accumulationWeight);
      ValueCell.update(multiSampleCompose.values.tColor, multiSampleHoldTarget.texture);
      multiSampleCompose.update();
      if (accumulationWeight === 0)
        state.disable(gl.BLEND);
      else
        state.enable(gl.BLEND);
      multiSampleCompose.render();
    }
    if (!toDrawingBuffer) {
      state.disable(gl.BLEND);
      this.colorTarget.bind();
      if (this.copyRenderable.values.tColor.ref.value !== this.multiSampleAccumulateTarget.texture) {
        ValueCell.update(this.copyRenderable.values.tColor, this.multiSampleAccumulateTarget.texture);
        this.copyRenderable.update();
      }
      this.copyRenderable.render();
    }
    camera.viewOffset.enabled = false;
    camera.update();
    if (isTimingMode)
      webgl.timer.markEnd("IlluminationPass.renderMultiSample");
  }
  render(ctx, props, toDrawingBuffer) {
    if (!this._supported)
      return;
    if (props.multiSample.mode === "on") {
      this.renderMultiSample(ctx, props, toDrawingBuffer);
    } else {
      this.renderInternal(ctx, props, toDrawingBuffer, false);
    }
  }
};
var ComposeSchema2 = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tNormal: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tShaded: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tTransparentColor: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  dBlendTransparency: DefineSpec("boolean"),
  tSsaoDepth: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tSsaoDepthTransparent: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tDepthOpaque: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tDepthTransparent: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  tOutlines: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSize: UniformSpec("v2"),
  dDenoise: DefineSpec("boolean"),
  uDenoiseThreshold: UniformSpec("f"),
  dOrthographic: DefineSpec("number"),
  uNear: UniformSpec("f"),
  uFar: UniformSpec("f"),
  uFogNear: UniformSpec("f"),
  uFogFar: UniformSpec("f"),
  uFogColor: UniformSpec("v3"),
  uOutlineColor: UniformSpec("v3"),
  uOcclusionColor: UniformSpec("v3"),
  uTransparentBackground: UniformSpec("b"),
  dOcclusionEnable: DefineSpec("boolean"),
  dOutlineEnable: DefineSpec("boolean"),
  dOutlineScale: DefineSpec("number"),
  dTransparentOutline: DefineSpec("boolean")
};
var ComposeShaderCode2 = ShaderCode("compose", quad_vert, compose_frag2);
function getComposeRenderable2(ctx, colorTexture, normalTexture, shadedTexture, depthTextureOpaque, depthTextureTransparent, outlinesTexture, transparentColorTexture, ssaoDepthOpaqueTexture, ssaoDepthTransparentTexture, transparentOutline) {
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(colorTexture),
    tNormal: ValueCell.create(normalTexture),
    tShaded: ValueCell.create(shadedTexture),
    tTransparentColor: ValueCell.create(transparentColorTexture),
    dBlendTransparency: ValueCell.create(true),
    tSsaoDepth: ValueCell.create(ssaoDepthOpaqueTexture),
    tSsaoDepthTransparent: ValueCell.create(ssaoDepthTransparentTexture),
    tDepthOpaque: ValueCell.create(depthTextureOpaque),
    tDepthTransparent: ValueCell.create(depthTextureTransparent),
    tOutlines: ValueCell.create(outlinesTexture),
    uTexSize: ValueCell.create(Vec2.create(colorTexture.getWidth(), colorTexture.getHeight())),
    dDenoise: ValueCell.create(true),
    uDenoiseThreshold: ValueCell.create(0.1),
    dOrthographic: ValueCell.create(0),
    uNear: ValueCell.create(1),
    uFar: ValueCell.create(1e4),
    uFogNear: ValueCell.create(1e4),
    uFogFar: ValueCell.create(1e4),
    uFogColor: ValueCell.create(Vec3.create(1, 1, 1)),
    uOutlineColor: ValueCell.create(Vec3.create(0, 0, 0)),
    uOcclusionColor: ValueCell.create(Vec3.create(0, 0, 0)),
    uTransparentBackground: ValueCell.create(false),
    dOcclusionEnable: ValueCell.create(false),
    dOutlineEnable: ValueCell.create(false),
    dOutlineScale: ValueCell.create(1),
    dTransparentOutline: ValueCell.create(transparentOutline)
  };
  const schema = { ...ComposeSchema2 };
  const renderItem = createComputeRenderItem(ctx, "triangles", ComposeShaderCode2, schema, values2);
  return createComputeRenderable(renderItem, values2);
}
var MultiSampleComposeSchema = {
  ...QuadSchema,
  tColor: TextureSpec("texture", "rgba", "ubyte", "nearest"),
  uTexSize: UniformSpec("v2"),
  uWeight: UniformSpec("f")
};
var MultiSampleComposeShaderCode = ShaderCode("compose", quad_vert, compose_frag);
function getMultiSampleComposeRenderable(ctx, colorTexture) {
  const values2 = {
    ...QuadValues,
    tColor: ValueCell.create(colorTexture),
    uTexSize: ValueCell.create(Vec2.create(colorTexture.getWidth(), colorTexture.getHeight())),
    uWeight: ValueCell.create(1)
  };
  const schema = { ...MultiSampleComposeSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", MultiSampleComposeShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/image.js
var ImageParams2 = {
  transparentBackground: ParamDefinition.Boolean(false),
  dpoitIterations: ParamDefinition.Numeric(2, { min: 1, max: 10, step: 1 }),
  multiSample: ParamDefinition.Group(MultiSampleParams),
  postprocessing: ParamDefinition.Group(PostprocessingParams),
  marking: ParamDefinition.Group(MarkingParams),
  illumination: ParamDefinition.Group(IlluminationParams),
  cameraHelper: ParamDefinition.Group(CameraHelperParams),
  renderer: ParamDefinition.Group(RendererParams)
};
var ImagePass = class {
  get colorTarget() {
    return this._colorTarget;
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  constructor(webgl, assetManager, renderer, scene, camera, helper, transparency, props) {
    this.webgl = webgl;
    this.renderer = renderer;
    this.scene = scene;
    this.camera = camera;
    this._width = 0;
    this._height = 0;
    this._camera = new Camera();
    this.props = { ...ParamDefinition.getDefaultValues(ImageParams2), ...props };
    this.drawPass = new DrawPass(webgl, assetManager, 128, 128, transparency);
    this.illuminationPass = new IlluminationPass(webgl, this.drawPass);
    this.multiSamplePass = new MultiSamplePass(webgl, this.drawPass);
    this.multiSampleHelper = new MultiSampleHelper(this.multiSamplePass);
    this.helper = {
      camera: new CameraHelper(webgl, this.props.cameraHelper),
      debug: helper.debug,
      handle: helper.handle
    };
    this.setSize(1024, 768);
  }
  updateBackground() {
    return new Promise((resolve) => {
      this.drawPass.postprocessing.background.update(this.camera, this.props.postprocessing.background, () => {
        resolve();
      });
    });
  }
  setSize(width, height) {
    if (width === this._width && height === this._height)
      return;
    this._width = width;
    this._height = height;
    this.drawPass.setSize(width, height);
    this.illuminationPass.setSize(width, height);
    this.multiSamplePass.syncSize();
  }
  setProps(props = {}) {
    Object.assign(this.props, props);
    if (props.cameraHelper)
      this.helper.camera.setProps(props.cameraHelper);
  }
  async render(runtime) {
    Camera.copySnapshot(this._camera.state, this.camera.state);
    Viewport.set(this._camera.viewport, 0, 0, this._width, this._height);
    this._camera.update();
    const ctx = { renderer: this.renderer, camera: this._camera, scene: this.scene, helper: this.helper };
    if (this.illuminationPass.supported && this.props.illumination.enabled) {
      await runtime.update({ message: "Tracing...", current: 1, max: this.illuminationPass.getMaxIterations(this.props) });
      this.illuminationPass.restart(true);
      while (this.illuminationPass.shouldRender(this.props)) {
        if (isTimingMode)
          this.webgl.timer.mark("ImagePass.render", { captureStats: true });
        this.illuminationPass.render(ctx, this.props, false);
        if (isTimingMode)
          this.webgl.timer.markEnd("ImagePass.render");
        if (runtime.shouldUpdate) {
          await runtime.update({ current: this.illuminationPass.iteration });
        }
        await this.webgl.waitForGpuCommandsComplete();
      }
      this._colorTarget = this.illuminationPass.colorTarget;
    } else {
      if (isTimingMode)
        this.webgl.timer.mark("ImagePass.render", { captureStats: true });
      if (MultiSamplePass.isEnabled(this.props.multiSample)) {
        this.multiSampleHelper.render(ctx, this.props, false);
        this._colorTarget = this.multiSamplePass.colorTarget;
      } else {
        this.drawPass.render(ctx, this.props, false);
        this._colorTarget = this.drawPass.getColorTarget(this.props.postprocessing);
      }
      if (isTimingMode)
        this.webgl.timer.markEnd("ImagePass.render");
    }
    if (isTimingMode) {
      const timerResults = this.webgl.timer.resolve();
      if (timerResults) {
        for (const result of timerResults) {
          printTimerResults([result]);
        }
      }
    }
    if (isTimingMode) {
      const timerResults = this.webgl.timer.resolve();
      if (timerResults) {
        for (const result of timerResults) {
          printTimerResults([result]);
        }
      }
    }
  }
  async getImageData(runtime, width, height, viewport) {
    var _a, _b;
    this.setSize(width, height);
    await this.render(runtime);
    this.colorTarget.bind();
    const w = (_a = viewport === null || viewport === void 0 ? void 0 : viewport.width) !== null && _a !== void 0 ? _a : width, h = (_b = viewport === null || viewport === void 0 ? void 0 : viewport.height) !== null && _b !== void 0 ? _b : height;
    const array = new Uint8Array(w * h * 4);
    if (!viewport) {
      this.webgl.readPixels(0, 0, w, h, array);
    } else {
      this.webgl.readPixels(viewport.x, height - viewport.y - viewport.height, w, h, array);
    }
    const pixelData = PixelData.create(array, w, h);
    PixelData.flipY(pixelData);
    PixelData.divideByAlpha(pixelData);
    return new ImageData(new Uint8ClampedArray(array), w, h);
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/helper/handle-helper.js
var HandleParams = {
  ...Mesh.Params,
  alpha: { ...Mesh.Params.alpha, defaultValue: 1 },
  ignoreLight: { ...Mesh.Params.ignoreLight, defaultValue: true },
  colorX: ParamDefinition.Color(ColorNames.red, { isEssential: true }),
  colorY: ParamDefinition.Color(ColorNames.green, { isEssential: true }),
  colorZ: ParamDefinition.Color(ColorNames.blue, { isEssential: true }),
  scale: ParamDefinition.Numeric(0.33, { min: 0.1, max: 2, step: 0.1 }, { isEssential: true })
};
var HandleHelperParams = {
  handle: ParamDefinition.MappedStatic("off", {
    on: ParamDefinition.Group(HandleParams),
    off: ParamDefinition.Group({})
  }, { cycle: true, description: "Show handle tool" })
};
var HandleHelper = class {
  getBoundingSphere(out, instanceId) {
    if (this.renderObject) {
      Sphere3D.copy(out, this.renderObject.values.invariantBoundingSphere.ref.value);
      Mat4.fromArray(this._transform, this.renderObject.values.aTransform.ref.value, instanceId * 16);
      Sphere3D.transform(out, out, this._transform);
    }
    return out;
  }
  setProps(props) {
    this.props = produce(this.props, (p) => {
      if (props.handle !== void 0) {
        p.handle.name = props.handle.name;
        if (props.handle.name === "on") {
          this.scene.clear();
          this.pixelRatio = this.webgl.pixelRatio;
          const params = {
            ...props.handle.params,
            scale: props.handle.params.scale * this.webgl.pixelRatio,
            cellSize: 0
          };
          this.renderObject = createHandleRenderObject(params);
          this.scene.add(this.renderObject);
          this.scene.commit();
          p.handle.params = { ...props.handle.params };
        }
      }
    });
  }
  get isEnabled() {
    return this.props.handle.name === "on";
  }
  // TODO could be a lists of position/rotation if we want to show more than one handle tool,
  //      they would be distingishable by their instanceId
  update(camera, position, rotation) {
    if (!this.renderObject)
      return;
    if (this.pixelRatio !== this.webgl.pixelRatio) {
      this.setProps(this.props);
    }
    Mat4.setTranslation(this.renderObject.values.aTransform.ref.value, position);
    Mat4.fromMat3(this.renderObject.values.aTransform.ref.value, rotation);
    ValueCell.update(this.renderObject.values.aTransform, this.renderObject.values.aTransform.ref.value);
    this.scene.update([this.renderObject], true);
  }
  getLoci(pickingId) {
    const { objectId, groupId, instanceId } = pickingId;
    if (!this.renderObject || objectId !== this.renderObject.id)
      return EmptyLoci;
    return HandleLoci(this, groupId, instanceId);
  }
  mark(loci, action) {
    if (!MarkerActions.is(MarkerActions.Highlighting, action))
      return false;
    if (!isEveryLoci(loci)) {
      if (!isHandleLoci(loci))
        return false;
      if (loci.data !== this)
        return false;
    }
    return Visual.mark(this.renderObject, loci, action, this.eachGroup);
  }
  constructor(webgl, props = {}) {
    this.webgl = webgl;
    this.props = {
      handle: { name: "off", params: {} }
    };
    this.pixelRatio = 1;
    this._transform = Mat4();
    this.eachGroup = (loci, apply) => {
      if (!this.renderObject)
        return false;
      if (!isHandleLoci(loci))
        return false;
      let changed = false;
      const groupCount = this.renderObject.values.uGroupCount.ref.value;
      const { elements } = loci;
      for (const { groupId, instanceId } of elements) {
        const idx = instanceId * groupCount + groupId;
        if (apply(Interval.ofSingleton(idx)))
          changed = true;
      }
      return changed;
    };
    this.scene = Scene.create(webgl, "blended");
    this.setProps(props);
  }
};
function createHandleMesh(scale, mesh) {
  const state = MeshBuilder.createState(512, 256, mesh);
  const radius = 0.05 * scale;
  const x = Vec3.scale(Vec3(), Vec3.unitX, scale);
  const y = Vec3.scale(Vec3(), Vec3.unitY, scale);
  const z = Vec3.scale(Vec3(), Vec3.unitZ, scale);
  const cylinderProps = { radiusTop: radius, radiusBottom: radius, radialSegments: 32 };
  state.currentGroup = HandleGroup.TranslateScreenXY;
  addSphere(state, Vec3.origin, radius * 3, 2);
  state.currentGroup = HandleGroup.TranslateObjectX;
  addSphere(state, x, radius, 2);
  addCylinder(state, Vec3.origin, x, 1, cylinderProps);
  state.currentGroup = HandleGroup.TranslateObjectY;
  addSphere(state, y, radius, 2);
  addCylinder(state, Vec3.origin, y, 1, cylinderProps);
  state.currentGroup = HandleGroup.TranslateObjectZ;
  addSphere(state, z, radius, 2);
  addCylinder(state, Vec3.origin, z, 1, cylinderProps);
  return MeshBuilder.getMesh(state);
}
var HandleGroup = {
  None: 0,
  TranslateScreenXY: 1,
  // TranslateScreenZ: 2,
  TranslateObjectX: 3,
  TranslateObjectY: 4,
  TranslateObjectZ: 5
  // TranslateObjectXY: 6,
  // TranslateObjectXZ: 7,
  // TranslateObjectYZ: 8,
  // RotateScreenZ: 9,
  // RotateObjectX: 10,
  // RotateObjectY: 11,
  // RotateObjectZ: 12,
};
function HandleLoci(handleHelper, groupId, instanceId) {
  return DataLoci("handle", handleHelper, [{ groupId, instanceId }], (boundingSphere) => handleHelper.getBoundingSphere(boundingSphere, instanceId), () => `Handle Helper | Group Id ${groupId} | Instance Id ${instanceId}`);
}
function isHandleLoci(x) {
  return x.kind === "data-loci" && x.tag === "handle";
}
function getHandleShape(props, shape) {
  const scale = 10 * props.scale;
  const mesh = createHandleMesh(scale, shape === null || shape === void 0 ? void 0 : shape.geometry);
  mesh.setBoundingSphere(Sphere3D.create(Vec3.create(scale / 2, scale / 2, scale / 2), scale + scale / 4));
  const getColor = (groupId) => {
    switch (groupId) {
      case HandleGroup.TranslateObjectX:
        return props.colorX;
      case HandleGroup.TranslateObjectY:
        return props.colorY;
      case HandleGroup.TranslateObjectZ:
        return props.colorZ;
      default:
        return ColorNames.grey;
    }
  };
  return Shape.create("handle", {}, mesh, getColor, () => 1, () => "");
}
function createHandleRenderObject(props) {
  const shape = getHandleShape(props);
  return Shape.createRenderObject(shape, props);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/helper/helper.js
var HelperParams = {
  debug: ParamDefinition.Group(DebugHelperParams),
  camera: ParamDefinition.Group({
    helper: ParamDefinition.Group(CameraHelperParams)
  }),
  handle: ParamDefinition.Group(HandleHelperParams)
};
var DefaultHelperProps = ParamDefinition.getDefaultValues(HelperParams);
var Helper = class {
  constructor(webgl, scene, props = {}) {
    const p = { ...DefaultHelperProps, ...props };
    this.debug = new BoundingSphereHelper(webgl, scene, p.debug);
    this.camera = new CameraHelper(webgl, p.camera.helper);
    this.handle = new HandleHelper(webgl, p.handle);
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/passes.js
var Passes = class {
  constructor(webgl, assetManager, attribs = {}) {
    this.webgl = webgl;
    const { gl } = webgl;
    this.draw = new DrawPass(webgl, assetManager, gl.drawingBufferWidth, gl.drawingBufferHeight, attribs.transparency || "blended");
    this.pick = new PickPass(webgl, this.draw, attribs.pickScale || 0.25);
    this.multiSample = new MultiSamplePass(webgl, this.draw);
    this.illumination = new IlluminationPass(webgl, this.draw);
  }
  setPickScale(pickScale) {
    this.pick.setPickScale(pickScale);
  }
  setTransparency(transparency) {
    this.draw.setTransparency(transparency);
  }
  updateSize() {
    const { gl } = this.webgl;
    const width = Math.max(gl.drawingBufferWidth, 2);
    const height = Math.max(gl.drawingBufferHeight, 2);
    this.draw.setSize(width, height);
    this.pick.syncSize();
    this.multiSample.syncSize();
    this.illumination.setSize(width, height);
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/shader/hi-z.frag.js
var hiZ_frag = `
precision highp float;
precision highp sampler2D;

uniform sampler2D tPreviousLevel;
uniform vec2 uInvSize;
uniform vec2 uOffset;

void main(void) {
    vec2 position = gl_FragCoord.xy * uInvSize + uOffset;

    float x = texture(tPreviousLevel, position).r;
    float y = textureOffset(tPreviousLevel, position, ivec2(-1, 0)).r;
    float z = textureOffset(tPreviousLevel, position, ivec2(-1, -1)).r;
    float w = textureOffset(tPreviousLevel, position, ivec2(0, -1)).r;

    gl_FragColor = vec4(max(max(x, y), max(z, w)));
}
`;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-gl/compute/hi-z.js
var HiZSchema = {
  ...QuadSchema,
  tPreviousLevel: TextureSpec("texture", "alpha", "float", "nearest"),
  uInvSize: UniformSpec("v2"),
  uOffset: UniformSpec("v2")
};
var HiZShaderCode = ShaderCode("hi-z", quad_vert, hiZ_frag);
function createHiZRenderable(ctx, previousLevel) {
  const values2 = {
    ...QuadValues,
    tPreviousLevel: ValueCell.create(previousLevel),
    uInvSize: ValueCell.create(Vec2()),
    uOffset: ValueCell.create(Vec2())
  };
  const schema = { ...HiZSchema };
  const renderItem = createComputeRenderItem(ctx, "triangles", HiZShaderCode, schema, values2);
  return createComputeRenderable(renderItem, values2);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-math/approx.js
var _a_fastPow2 = new ArrayBuffer(4);
var _i_fastPow2 = new Int32Array(_a_fastPow2);
var _f_fastPow2 = new Float32Array(_a_fastPow2);
var _a_fasterPow2 = new ArrayBuffer(4);
var _i_fasterPow2 = new Int32Array(_a_fasterPow2);
var _f_fasterPow2 = new Float32Array(_a_fasterPow2);
function fasterPow2(v3) {
  const clipNumber = v3 < -126 ? -126 : v3;
  _i_fasterPow2[0] = (1 << 23) * (clipNumber + 126.94269504);
  return _f_fasterPow2[0];
}
function fasterExp(v3) {
  return fasterPow2(1.44269504 * v3);
}
var _a_fastLog2 = new ArrayBuffer(8);
var _i_fastLog2 = new Int32Array(_a_fastLog2);
var _f_fastLog2 = new Float32Array(_a_fastLog2);
var _a_fasterLog2 = new ArrayBuffer(4);
var _i_fasterLog2 = new Int32Array(_a_fasterLog2);
var _f_fasterLog2 = new Float32Array(_a_fasterLog2);
function fasterLog2(v3) {
  _f_fasterLog2[0] = v3;
  const t2 = _i_fasterLog2[0] * 11920928955078125e-23;
  return t2 - 126.94269504;
}
var halfPi = Math.PI / 2;
var twoPi = 2 * Math.PI;
var invTwoPi = 1 / (2 * Math.PI);
var twoOverPi = 2 / Math.PI;
var fourOverPi = 4 / Math.PI;
var fourOverPiSq = 4 / (Math.PI * Math.PI);
var halfPiMinusTwoPi = Math.PI / 2 - 2 * Math.PI;
var _a_fastHalfSin = new ArrayBuffer(16);
var _i_fastHalfSin = new Int32Array(_a_fastHalfSin);
var _f_fastHalfSin = new Float32Array(_a_fastHalfSin);
var _a_fasterHalfSin = new ArrayBuffer(8);
var _i_fasterHalfSin = new Int32Array(_a_fasterHalfSin);
var _f_fasterHalfSin = new Float32Array(_a_fasterHalfSin);
var _a_fasterHalfCos = new ArrayBuffer(4);
var _i_fasterHalfCos = new Int32Array(_a_fasterHalfCos);
var _f_fasterHalfCos = new Float32Array(_a_fasterHalfCos);
var piOverFour = Math.PI / 4;

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/passes/hi-z.js
var v3transformMat42 = Vec3.transformMat4;
var v4set = Vec4.set;
var fasterLog22 = fasterLog2;
function perspectiveDepthToViewZ(depth, near, far) {
  return near * far / ((far - near) * depth - far);
}
function orthographicDepthToViewZ(depth, near, far) {
  return depth * (near - far) - near;
}
function depthToViewZ(depth, near, far, projection) {
  return projection[11] === -1 ? perspectiveDepthToViewZ(depth, near, far) : orthographicDepthToViewZ(depth, near, far);
}
function perspectiveProjectSphere(out, p, r, projection) {
  const prx = p[0] * r;
  const pry = p[1] * r;
  const prz = p[2] * r;
  const pzr2 = p[2] * p[2] - r * r;
  const vx = Math.sqrt(p[0] * p[0] + pzr2);
  const minx = (vx * p[0] - prz) / (vx * p[2] + prx) * projection[0];
  const maxx = (vx * p[0] + prz) / (vx * p[2] - prx) * projection[0];
  const vy = Math.sqrt(p[1] * p[1] + pzr2);
  const miny = (vy * p[1] - prz) / (vy * p[2] + pry) * projection[5];
  const maxy = (vy * p[1] + prz) / (vy * p[2] - pry) * projection[5];
  return v4set(out, maxx * -0.5 + 0.5, miny * 0.5 + 0.5, minx * -0.5 + 0.5, maxy * 0.5 + 0.5);
}
function orthographicProjectSphere(out, p, r, projection) {
  const sx = projection[0];
  const sy = projection[5];
  const minx = (p[0] + r) * sx;
  const maxx = (p[0] - r) * sx;
  const miny = (p[1] + r) * sy;
  const maxy = (p[1] - r) * sy;
  return v4set(out, maxx * 0.5 + 0.5, miny * -0.5 + 0.5, minx * 0.5 + 0.5, maxy * -0.5 + 0.5);
}
function projectSphere(out, p, r, projection) {
  return projection[11] === -1 ? perspectiveProjectSphere(out, p, r, projection) : orthographicProjectSphere(out, p, r, projection);
}
var HiZParams = {
  enabled: ParamDefinition.Boolean(false, { description: "Hierarchical Z-buffer occlusion culling. Only available for WebGL2." }),
  maxFrameLag: ParamDefinition.Numeric(10, { min: 1, max: 30, step: 1 }, { description: "Maximum number of frames to wait for Z-buffer data." }),
  minLevel: ParamDefinition.Numeric(3, { min: 1, max: 10, step: 1 })
};
var HiZPass = class {
  clear() {
    if (!this.supported)
      return;
    const { gl } = this.webgl;
    if (!isWebGL2(gl))
      return;
    if (this.sync !== null) {
      gl.deleteSync(this.sync);
      this.sync = null;
    }
    this.frameLag = 0;
    this.ready = false;
    if (this.debug) {
      this.debug.rect.style.display = "none";
      this.debug.container.style.display = "none";
    }
  }
  render(camera) {
    if (!this.supported || !this.props.enabled)
      return;
    const { gl, state } = this.webgl;
    if (!isWebGL2(gl) || this.sync !== null)
      return;
    this.nextNear = camera.near;
    this.nextFar = camera.far;
    Mat4.copy(this.nextView, camera.view);
    Mat4.copy(this.nextProjection, camera.projection);
    if (isTimingMode)
      this.webgl.timer.mark("hi-Z");
    state.disable(gl.CULL_FACE);
    state.disable(gl.BLEND);
    state.disable(gl.DEPTH_TEST);
    state.disable(gl.SCISSOR_TEST);
    state.depthMask(false);
    state.colorMask(true, true, true, true);
    state.clearColor(0, 0, 0, 0);
    const v3 = this.renderable.values;
    const s = Math.pow(2, Math.ceil(Math.log(Math.max(gl.drawingBufferWidth, gl.drawingBufferHeight)) / Math.log(2)) - 1);
    for (let i = 0, il = this.levelData.length; i < il; ++i) {
      const td = this.levelData[i];
      td.framebuffer.bind();
      if (i > 0) {
        ValueCell.update(v3.uInvSize, td.invSize);
        ValueCell.update(v3.uOffset, Vec2.set(v3.uOffset.ref.value, 0, 0));
        ValueCell.update(v3.tPreviousLevel, this.levelData[i - 1].texture);
      } else {
        ValueCell.update(v3.uInvSize, Vec2.set(v3.uInvSize.ref.value, 1 / s, 1 / s));
        ValueCell.update(v3.uOffset, Vec2.set(v3.uOffset.ref.value, this.viewport.x / gl.drawingBufferWidth, this.viewport.y / gl.drawingBufferHeight));
        ValueCell.update(v3.tPreviousLevel, this.drawPass.depthTextureOpaque);
      }
      state.currentRenderItemId = -1;
      state.viewport(0, 0, td.size[0], td.size[1]);
      gl.clear(gl.COLOR_BUFFER_BIT);
      this.renderable.update();
      this.renderable.render();
      if (i >= this.props.minLevel) {
        this.tex.bind(0);
        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, td.offset, 0, 0, 0, td.size[0], td.size[1]);
        this.tex.unbind(0);
      }
    }
    this.tex.attachFramebuffer(this.fb, 0);
    const hw = this.tex.getWidth();
    const hh = this.tex.getHeight();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this.buf);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, this.buffer.byteLength, gl.STREAM_READ);
    gl.readPixels(0, 0, hw, hh, gl.RED, gl.FLOAT, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    this.sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    gl.flush();
    if (isTimingMode)
      this.webgl.timer.markEnd("hi-Z");
  }
  tick() {
    if (!this.supported || !this.props.enabled || this.sync === null)
      return;
    const { gl } = this.webgl;
    if (!isWebGL2(gl))
      return;
    const res = gl.clientWaitSync(this.sync, 0, 0);
    if (res === gl.WAIT_FAILED || this.frameLag >= this.props.maxFrameLag) {
      gl.deleteSync(this.sync);
      this.sync = null;
      this.frameLag = 0;
      this.ready = false;
    } else if (res === gl.TIMEOUT_EXPIRED) {
      this.frameLag += 1;
    } else {
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, this.buf);
      gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, this.buffer);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
      gl.deleteSync(this.sync);
      this.sync = null;
      this.frameLag = 0;
      this.ready = true;
      this.near = this.nextNear;
      this.far = this.nextFar;
      Mat4.copy(this.view, this.nextView);
      Mat4.copy(this.projection, this.nextProjection);
    }
  }
  transform(s) {
    const { view, vp } = this;
    v3transformMat42(vp, s.center, view);
    const r = s.radius * 1.2 + 1.52;
    return { vp, r };
  }
  project(vp, r) {
    const { projection, aabb, viewport } = this;
    projectSphere(aabb, vp, r, projection);
    const w = aabb[2] - aabb[0];
    const h = aabb[3] - aabb[1];
    const pr = Math.max(w * viewport.width, h * viewport.height);
    const lod = Math.ceil(fasterLog22(pr / 2));
    return { aabb, w, h, pr, lod };
  }
  setViewport(x, y, width, height) {
    if (!this.supported)
      return;
    width = Math.max(width, 2);
    height = Math.max(height, 2);
    Viewport.set(this.viewport, x, y, width, height);
    const levels = Math.ceil(Math.log(Math.max(width, height)) / Math.log(2));
    if (levels === this.levelData.length)
      return;
    const { minLevel } = this.props;
    this.buffer = new Float32Array(Math.pow(2, levels - minLevel) * Math.pow(2, levels - 1 - minLevel));
    this.tex.define(Math.pow(2, levels - minLevel), Math.pow(2, levels - 1 - minLevel));
    for (const td of this.levelData) {
      td.framebuffer.destroy();
      td.texture.destroy();
    }
    this.levelData.length = 0;
    for (let i = 0; i < levels; ++i) {
      const framebuffer = this.webgl.resources.framebuffer();
      const levelSize = Math.pow(2, levels - i - 1);
      const size = Vec2.create(levelSize, levelSize);
      const invSize = Vec2.create(1 / levelSize, 1 / levelSize);
      const texture = this.webgl.resources.texture("image-float32", "alpha", "float", "nearest");
      texture.define(levelSize, levelSize);
      texture.attachFramebuffer(framebuffer, 0);
      this.levelData.push({ texture, framebuffer, size, invSize, offset: 0 });
    }
    let offset = 0;
    for (let i = 0, il = levels; i < il; ++i) {
      const td = this.levelData[i];
      if (i >= minLevel) {
        this.levelData[i].offset = offset;
        offset += td.size[0];
      }
    }
    this.clear();
  }
  setProps(props) {
    if (!this.supported)
      return;
    if (this.props.minLevel !== props.minLevel) {
      Object.assign(this.props, props);
      const { x, y, width, height } = this.viewport;
      this.setViewport(x, y, width, height);
    } else {
      Object.assign(this.props, props);
      if (!this.props.enabled)
        this.clear();
    }
  }
  initDebug(element) {
    if (!element.parentElement)
      return;
    const container = document.createElement("div");
    Object.assign(container.style, {
      display: "block",
      position: "absolute",
      pointerEvents: "none"
    });
    element.parentElement.appendChild(container);
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx)
      throw new Error("Could not create canvas 2d context");
    Object.assign(canvas.style, {
      width: "100%",
      height: "100%",
      imageRendering: "pixelated",
      position: "relative",
      pointerEvents: "none"
    });
    container.appendChild(canvas);
    const rect = document.createElement("div");
    Object.assign(rect.style, {
      display: "none",
      position: "absolute",
      pointerEvents: "none"
    });
    element.parentElement.appendChild(rect);
    this.debug = { container, canvas, ctx, rect };
  }
  canDebug(debug) {
    return this.supported && this.props.enabled && this.ready && !!this.debug;
  }
  showRect(p, occluded) {
    if (!this.canDebug(this.debug))
      return;
    const { gl: { drawingBufferHeight }, pixelRatio } = this.webgl;
    const { viewport: { x, y, width, height } } = this;
    const minx = (p[0] * width + x) / pixelRatio;
    const miny = (p[1] * height - y) / pixelRatio;
    const maxx = (p[2] * width + x) / pixelRatio;
    const maxy = (p[3] * height - y) / pixelRatio;
    const oy = (drawingBufferHeight - height) / pixelRatio;
    Object.assign(this.debug.rect.style, {
      border: occluded ? "solid red" : "solid green",
      display: "block",
      left: `${minx}px`,
      top: `${miny + oy}px`,
      width: `${maxx - minx}px`,
      height: `${maxy - miny}px`
    });
  }
  showBuffer(lod) {
    if (!this.canDebug(this.debug))
      return;
    if (lod >= this.levelData.length || lod < this.props.minLevel) {
      this.debug.container.style.display = "none";
      return;
    }
    const { offset, size: [tw, th] } = this.levelData[lod];
    const dw = this.tex.getWidth();
    const data = new Uint8ClampedArray(tw * th * 4);
    data.fill(255);
    for (let y2 = 0; y2 < th; ++y2) {
      for (let x2 = 0; x2 < tw; ++x2) {
        const i = (th - y2 - 1) * tw + x2;
        const v3 = this.buffer[y2 * dw + x2 + offset] * 255;
        data[i * 4 + 0] = v3;
        data[i * 4 + 3] = 255 - v3;
      }
    }
    const imageData = new ImageData(data, tw, th);
    this.debug.canvas.width = imageData.width;
    this.debug.canvas.height = imageData.height;
    this.debug.ctx.putImageData(imageData, 0, 0);
    const { viewport: { x, y, width, height }, webgl: { pixelRatio } } = this;
    Object.assign(this.debug.container.style, {
      display: "block",
      bottom: `${y / pixelRatio}px`,
      left: `${x / pixelRatio}px`,
      width: `${width / pixelRatio}px`,
      height: `${height / pixelRatio}px`
    });
  }
  debugOcclusion(s) {
    if (!this.canDebug(this.debug))
      return;
    if (!s) {
      this.debug.rect.style.display = "none";
      this.debug.container.style.display = "none";
      return;
    }
    const occluded = this.isOccluded(s);
    const { vp, r } = this.transform(s);
    const { aabb, lod } = this.project(vp, r);
    this.showRect(aabb, occluded);
    this.showBuffer(lod);
  }
  //
  dispose() {
    if (!this.supported)
      return;
    this.clear();
    this.fb.destroy();
    this.tex.destroy();
    this.webgl.gl.deleteBuffer(this.buf);
    this.renderable.dispose();
    for (const td of this.levelData) {
      td.framebuffer.destroy();
      td.texture.destroy();
    }
  }
  constructor(webgl, drawPass, canvas, props) {
    this.webgl = webgl;
    this.drawPass = drawPass;
    this.viewport = Viewport();
    this.near = 0;
    this.far = 0;
    this.view = Mat4();
    this.projection = Mat4();
    this.nextNear = 0;
    this.nextFar = 0;
    this.nextView = Mat4();
    this.nextProjection = Mat4();
    this.aabb = Vec4();
    this.vp = Vec3();
    this.levelData = [];
    this.sync = null;
    this.buffer = new Float32Array(0);
    this.frameLag = 0;
    this.ready = false;
    this.isOccluded = (s) => {
      if (!this.supported || !this.props.enabled || !this.ready)
        return false;
      const { vp, r } = this.transform(s);
      const { near, far, projection } = this;
      const z = vp[2] + r;
      if (-z < near)
        return false;
      const { aabb, w, h, lod } = this.project(vp, r);
      if (lod >= this.levelData.length || lod < this.props.minLevel)
        return false;
      const { offset, size } = this.levelData[lod];
      const u = aabb[0] + w / 2;
      const v3 = aabb[1] + h / 2;
      const ts = size[0];
      const x = u * ts;
      const y = v3 * ts;
      const dx = Math.floor(x);
      const dy = Math.ceil(y);
      const dw = this.tex.getWidth();
      if (dx + 1 >= ts || dy + 1 >= ts)
        return false;
      const di = (ts - dy - 1) * dw + dx + offset;
      if (z > depthToViewZ(this.buffer[di], near, far, projection))
        return false;
      if (z > depthToViewZ(this.buffer[di + 1], near, far, projection))
        return false;
      const di2 = (ts - dy + 1 - 1) * dw + dx + offset;
      if (z > depthToViewZ(this.buffer[di2], near, far, projection))
        return false;
      if (z > depthToViewZ(this.buffer[di2 + 1], near, far, projection))
        return false;
      return true;
    };
    const { gl, extensions } = webgl;
    if (!isWebGL2(gl) || !extensions.colorBufferFloat) {
      if (isDebugMode) {
        console.log('Missing webgl2 and/or colorBufferFloat support required for "Hi-Z"');
      }
      this.supported = false;
      return;
    }
    this.fb = webgl.resources.framebuffer();
    this.tex = webgl.resources.texture("image-float32", "alpha", "float", "nearest");
    this.tex.attachFramebuffer(this.fb, 0);
    const implFormat = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT);
    const implType = gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE);
    if (implFormat !== gl.RED || implType !== gl.FLOAT) {
      if (isDebugMode) {
        console.log('Missing red/float reading support required for "Hi-Z"');
      }
      this.supported = false;
      return;
    }
    this.supported = true;
    this.props = { ...ParamDefinition.getDefaultValues(HiZParams), ...props };
    this.buf = getBuffer(gl);
    this.renderable = createHiZRenderable(webgl, this.drawPass.depthTextureOpaque);
    if (isDebugMode && canvas) {
      this.initDebug(canvas);
    }
  }
};

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-util/browser.js
function isMobileBrowser() {
  if (typeof navigator === "undefined" || typeof window === "undefined")
    return false;
  let check = false;
  (function(a5) {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a5) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a5.substr(0, 4)))
      check = true;
  })(navigator.userAgent || navigator.vendor || window.opera);
  return check;
}
function is_iOS() {
  if (typeof navigator === "undefined" || typeof window === "undefined")
    return false;
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const isAppleDevice = navigator.userAgent.includes("Macintosh");
  const isTouchScreen = navigator.maxTouchPoints >= 4;
  return !window.MSStream && (isIOS || isAppleDevice && isTouchScreen);
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-canvas3d/canvas3d.js
var Canvas3DParams = {
  camera: ParamDefinition.Group({
    mode: ParamDefinition.Select("perspective", ParamDefinition.arrayToOptions(["perspective", "orthographic"]), { label: "Camera" }),
    helper: ParamDefinition.Group(CameraHelperParams, { isFlat: true }),
    stereo: ParamDefinition.MappedStatic("off", {
      on: ParamDefinition.Group(StereoCameraParams),
      off: ParamDefinition.Group({})
    }, { cycle: true, hideIf: (p) => (p === null || p === void 0 ? void 0 : p.mode) !== "perspective" }),
    fov: ParamDefinition.Numeric(45, { min: 10, max: 130, step: 1 }, { label: "Field of View" }),
    manualReset: ParamDefinition.Boolean(false, { isHidden: true })
  }, { pivot: "mode" }),
  cameraFog: ParamDefinition.MappedStatic("on", {
    on: ParamDefinition.Group({
      intensity: ParamDefinition.Numeric(15, { min: 1, max: 100, step: 1 })
    }),
    off: ParamDefinition.Group({})
  }, { cycle: true, description: "Show fog in the distance" }),
  cameraClipping: ParamDefinition.Group({
    radius: ParamDefinition.Numeric(100, { min: 0, max: 99, step: 1 }, { label: "Clipping", description: "How much of the scene to show." }),
    far: ParamDefinition.Boolean(true, { description: "Hide scene in the distance" }),
    minNear: ParamDefinition.Numeric(5, { min: 0.1, max: 100, step: 0.1 }, { description: "Note, may cause performance issues rendering impostors when set too small and cause issues with outline rendering when too close to 0." })
  }, { pivot: "radius" }),
  viewport: ParamDefinition.MappedStatic("canvas", {
    canvas: ParamDefinition.Group({}),
    "static-frame": ParamDefinition.Group({
      x: ParamDefinition.Numeric(0),
      y: ParamDefinition.Numeric(0),
      width: ParamDefinition.Numeric(128),
      height: ParamDefinition.Numeric(128)
    }),
    "relative-frame": ParamDefinition.Group({
      x: ParamDefinition.Numeric(0.33, { min: 0, max: 1, step: 0.01 }),
      y: ParamDefinition.Numeric(0.33, { min: 0, max: 1, step: 0.01 }),
      width: ParamDefinition.Numeric(0.5, { min: 0.01, max: 1, step: 0.01 }),
      height: ParamDefinition.Numeric(0.5, { min: 0.01, max: 1, step: 0.01 })
    })
  }),
  cameraResetDurationMs: ParamDefinition.Numeric(250, { min: 0, max: 1e3, step: 1 }, { description: "The time it takes to reset the camera." }),
  sceneRadiusFactor: ParamDefinition.Numeric(1, { min: 1, max: 10, step: 0.1 }),
  transparentBackground: ParamDefinition.Boolean(false),
  dpoitIterations: ParamDefinition.Numeric(2, { min: 1, max: 10, step: 1 }),
  pickPadding: ParamDefinition.Numeric(3, { min: 0, max: 10, step: 1 }, { description: "Extra pixels to around target to check in case target is empty." }),
  userInteractionReleaseMs: ParamDefinition.Numeric(250, { min: 0, max: 1e3, step: 1 }, { description: "The time before the user is not considered interacting anymore." }),
  multiSample: ParamDefinition.Group(MultiSampleParams),
  postprocessing: ParamDefinition.Group(PostprocessingParams),
  marking: ParamDefinition.Group(MarkingParams),
  illumination: ParamDefinition.Group(IlluminationParams),
  hiZ: ParamDefinition.Group(HiZParams),
  renderer: ParamDefinition.Group(RendererParams),
  trackball: ParamDefinition.Group(TrackballControlsParams),
  interaction: ParamDefinition.Group(Canvas3dInteractionHelperParams),
  debug: ParamDefinition.Group(DebugHelperParams),
  handle: ParamDefinition.Group(HandleHelperParams)
};
var DefaultCanvas3DParams = ParamDefinition.getDefaultValues(Canvas3DParams);
var Canvas3DContext;
(function(Canvas3DContext2) {
  Canvas3DContext2.DefaultAttribs = {
    powerPreference: "high-performance",
    failIfMajorPerformanceCaveat: false,
    /** true by default to avoid issues with Safari (Jan 2021) */
    antialias: true,
    /** true to support multiple Canvas3D objects with a single context */
    preserveDrawingBuffer: true,
    preferWebGl1: false,
    handleResize: () => {
    }
  };
  Canvas3DContext2.Params = {
    resolutionMode: ParamDefinition.Select("auto", ParamDefinition.arrayToOptions(["auto", "scaled", "native"])),
    pixelScale: ParamDefinition.Numeric(1, { min: 0.1, max: 2, step: 0.05 }),
    pickScale: ParamDefinition.Numeric(0.25, { min: 0.1, max: 1, step: 0.05 }),
    transparency: ParamDefinition.Select("wboit", [["blended", "Blended"], ["wboit", "Weighted, Blended"], ["dpoit", "Depth Peeling"]])
  };
  Canvas3DContext2.DefaultProps = ParamDefinition.getDefaultValues(Canvas3DContext2.Params);
  function fromCanvas(canvas, assetManager, attribs = {}, props = {}) {
    const a5 = { ...Canvas3DContext2.DefaultAttribs, ...attribs };
    const p = { ...Canvas3DContext2.DefaultProps, ...props };
    const { powerPreference, failIfMajorPerformanceCaveat, antialias, preserveDrawingBuffer, preferWebGl1 } = a5;
    const gl = getGLContext(canvas, {
      powerPreference,
      failIfMajorPerformanceCaveat,
      antialias,
      preserveDrawingBuffer,
      alpha: true,
      // the renderer requires an alpha channel
      depth: true,
      // the renderer requires a depth buffer
      premultipliedAlpha: true,
      // the renderer outputs PMA
      preferWebGl1
    });
    if (gl === null)
      throw new Error("Could not create a WebGL rendering context");
    const getPixelScale = () => {
      const scaled = p.pixelScale / (typeof window !== "undefined" ? (window === null || window === void 0 ? void 0 : window.devicePixelRatio) || 1 : 1);
      if (p.resolutionMode === "auto") {
        return isMobileBrowser() ? scaled : p.pixelScale;
      }
      return p.resolutionMode === "native" ? p.pixelScale : scaled;
    };
    const syncPixelScale = () => {
      const pixelScale2 = getPixelScale();
      input.setPixelScale(pixelScale2);
      webgl.setPixelScale(pixelScale2);
    };
    const { pickScale, transparency } = p;
    const pixelScale = getPixelScale();
    const input = InputObserver.fromElement(canvas, { pixelScale, preventGestures: true });
    const webgl = createContext(gl, { pixelScale });
    const passes = new Passes(webgl, assetManager, { pickScale, transparency });
    if (isDebugMode) {
      const loseContextExt = gl.getExtension("WEBGL_lose_context");
      if (loseContextExt) {
        canvas.addEventListener("mousedown", (e) => {
          if (webgl.isContextLost)
            return;
          if (!e.shiftKey || !e.ctrlKey || !e.altKey)
            return;
          if (isDebugMode)
            console.log("lose context");
          loseContextExt.loseContext();
          setTimeout(() => {
            if (!webgl.isContextLost)
              return;
            if (isDebugMode)
              console.log("restore context");
            loseContextExt.restoreContext();
          }, 1e3);
        }, false);
      }
    }
    const contextLost = new Subject();
    const handleWebglContextLost = (e) => {
      webgl.setContextLost();
      e.preventDefault();
      if (isDebugMode)
        console.log("context lost");
      contextLost.next(now());
    };
    const handlewWebglContextRestored = () => {
      if (!webgl.isContextLost)
        return;
      webgl.handleContextRestored(() => {
        passes.draw.reset();
        passes.pick.reset();
        passes.illumination.reset();
      });
      if (isDebugMode)
        console.log("context restored");
    };
    canvas.addEventListener("webglcontextlost", handleWebglContextLost, false);
    canvas.addEventListener("webglcontextrestored", handlewWebglContextRestored, false);
    const changed = new BehaviorSubject(void 0);
    return {
      canvas,
      webgl,
      input,
      passes,
      attribs: a5,
      get props() {
        return { ...p };
      },
      contextLost,
      contextRestored: webgl.contextRestored,
      assetManager,
      changed,
      get pixelScale() {
        return getPixelScale();
      },
      syncPixelScale,
      setProps: (props2) => {
        if (!props2)
          return;
        let hasChanged = false;
        let pixelScaleNeedsUpdate = false;
        if (props2.resolutionMode !== void 0 && props2.resolutionMode !== p.resolutionMode) {
          p.resolutionMode = props2.resolutionMode;
          pixelScaleNeedsUpdate = true;
        }
        if (props2.pixelScale !== void 0 && props2.pixelScale !== p.pixelScale) {
          p.pixelScale = props2.pixelScale;
          pixelScaleNeedsUpdate = true;
        }
        if (pixelScaleNeedsUpdate) {
          syncPixelScale();
          a5.handleResize();
          hasChanged = true;
        }
        if (props2.pickScale !== void 0 && props2.pickScale !== p.pickScale) {
          p.pickScale = props2.pickScale;
          passes.setPickScale(props2.pickScale);
          hasChanged = true;
        }
        if (props2.transparency !== void 0 && props2.transparency !== p.transparency) {
          p.transparency = props2.transparency;
          passes.setTransparency(props2.transparency);
          hasChanged = true;
        }
        if (hasChanged)
          changed.next(void 0);
      },
      dispose: (options) => {
        input.dispose();
        canvas.removeEventListener("webglcontextlost", handleWebglContextLost, false);
        canvas.removeEventListener("webglcontextrestored", handlewWebglContextRestored, false);
        webgl.destroy(options);
      }
    };
  }
  Canvas3DContext2.fromCanvas = fromCanvas;
})(Canvas3DContext || (Canvas3DContext = {}));
var requestAnimationFrame2 = typeof window !== "undefined" ? window.requestAnimationFrame : (f) => setImmediate(() => f(Date.now()));
var cancelAnimationFrame2 = typeof window !== "undefined" ? window.cancelAnimationFrame : (handle) => clearImmediate(handle);
var Canvas3D;
(function(Canvas3D2) {
  function create(ctx, props = {}) {
    var _a;
    const { webgl, input, passes, assetManager, canvas, contextLost } = ctx;
    const p = { ...deepClone(DefaultCanvas3DParams), ...deepClone(props) };
    const reprRenderObjects = /* @__PURE__ */ new Map();
    const reprUpdatedSubscriptions = /* @__PURE__ */ new Map();
    const reprCount = new BehaviorSubject(0);
    const interactionEvent = new Subject();
    let startTime = now();
    const didDraw = new BehaviorSubject(0);
    const commited = new BehaviorSubject(0);
    const commitQueueSize = new BehaviorSubject(0);
    const { gl, contextRestored } = webgl;
    let x = 0;
    let y = 0;
    let width = 128;
    let height = 128;
    let forceNextRender = false;
    let currentTime = 0;
    updateViewport();
    const scene = Scene.create(webgl, passes.draw.transparency);
    function getSceneRadius() {
      return scene.boundingSphere.radius * p.sceneRadiusFactor;
    }
    const camera = new Camera({
      position: Vec3.create(0, 0, 100),
      mode: p.camera.mode,
      fog: p.cameraFog.name === "on" ? p.cameraFog.params.intensity : 0,
      clipFar: p.cameraClipping.far,
      minNear: p.cameraClipping.minNear,
      fov: degToRad(p.camera.fov)
    }, { x, y, width, height });
    const stereoCamera = new StereoCamera(camera, p.camera.stereo.params);
    const controls = TrackballControls.create(input, camera, scene, p.trackball);
    const helper = new Helper(webgl, scene, p);
    const hiZ = new HiZPass(webgl, passes.draw, canvas, p.hiZ);
    const renderer = Renderer.create(webgl, p.renderer);
    renderer.setOcclusionTest(hiZ.isOccluded);
    const pickHelper = new PickHelper(webgl, renderer, scene, helper, passes.pick, { x, y, width, height }, p.pickPadding);
    const interactionHelper = new Canvas3dInteractionHelper(identify, getLoci, input, camera, controls, p.interaction);
    const multiSampleHelper = new MultiSampleHelper(passes.multiSample);
    passes.draw.postprocessing.background.update(camera, p.postprocessing.background, (changed) => {
      if (changed)
        requestDraw();
    });
    let cameraResetRequested = false;
    let nextCameraResetDuration = void 0;
    let nextCameraResetSnapshot = void 0;
    let resizeRequested = false;
    let notifyDidDraw = true;
    function getLoci(pickingId) {
      let loci = EmptyLoci;
      let repr = Representation.Empty;
      if (pickingId) {
        const cameraHelperLoci = helper.camera.getLoci(pickingId);
        if (cameraHelperLoci !== EmptyLoci)
          return { loci: cameraHelperLoci, repr };
        loci = helper.handle.getLoci(pickingId);
        reprRenderObjects.forEach((_, _repr) => {
          const _loci = _repr.getLoci(pickingId);
          if (!isEmptyLoci(_loci)) {
            if (!isEmptyLoci(loci)) {
              console.warn("found another loci, this should not happen");
            }
            loci = _loci;
            repr = _repr;
          }
        });
      }
      return { loci, repr };
    }
    let markBuffer = [];
    function mark(reprLoci, action) {
      markBuffer.push([reprLoci, action]);
    }
    function resolveMarking() {
      let changed = false;
      for (const [r, l] of markBuffer) {
        changed = applyMark(r, l) || changed;
      }
      markBuffer = [];
      if (changed) {
        scene.update(void 0, true);
        helper.handle.scene.update(void 0, true);
        helper.camera.scene.update(void 0, true);
        interactionEvent.next();
      }
      return changed;
    }
    function applyMark(reprLoci, action) {
      const { repr, loci } = reprLoci;
      let changed = false;
      if (repr) {
        changed = repr.mark(loci, action) || changed;
      } else {
        reprRenderObjects.forEach((_, _repr) => {
          changed = _repr.mark(loci, action) || changed;
        });
      }
      changed = helper.handle.mark(loci, action) || changed;
      changed = helper.camera.mark(loci, action) || changed;
      return changed;
    }
    let fenceSync = null;
    function render(force) {
      if (webgl.isContextLost)
        return false;
      let resized2 = false;
      if (resizeRequested) {
        handleResize(false);
        resizeRequested = false;
        resized2 = true;
      }
      if (x > gl.drawingBufferWidth || x + width < 0 || y > gl.drawingBufferHeight || y + height < 0)
        return false;
      if (fenceSync !== null) {
        if (webgl.checkSyncStatus(fenceSync)) {
          fenceSync = null;
        } else {
          return false;
        }
      }
      const markingUpdated = resolveMarking() && (renderer.props.colorMarker || p.marking.enabled);
      let didRender = false;
      controls.update(currentTime);
      const cameraChanged = camera.update();
      const shouldRender = force || cameraChanged || resized2 || forceNextRender;
      forceNextRender = false;
      if (passes.illumination.supported && p.illumination.enabled) {
        if (shouldRender || markingUpdated) {
          renderer.setOcclusionTest(null);
          passes.illumination.restart();
        }
        if (passes.illumination.shouldRender(p) && (!isActivelyInteracting && scene.count > 0 || passes.illumination.iteration === 0 || p.userInteractionReleaseMs === 0)) {
          if (isTimingMode)
            webgl.timer.mark("Canvas3D.render", { captureStats: true });
          const ctx2 = { renderer, camera, scene, helper };
          passes.illumination.render(ctx2, p, true);
          if (isTimingMode)
            webgl.timer.markEnd("Canvas3D.render");
          pickHelper.dirty = pickHelper.dirty || shouldRender;
          didRender = true;
        }
      } else {
        const multiSampleChanged = multiSampleHelper.update(markingUpdated || shouldRender, p.multiSample);
        if (shouldRender || multiSampleChanged || markingUpdated) {
          renderer.setOcclusionTest(hiZ.isOccluded);
          let cam = camera;
          if (p.camera.stereo.name === "on") {
            stereoCamera.update();
            cam = stereoCamera;
          }
          if (isTimingMode)
            webgl.timer.mark("Canvas3D.render", { captureStats: true });
          const ctx2 = { renderer, camera: cam, scene, helper };
          if (MultiSamplePass.isEnabled(p.multiSample)) {
            const forceOn = p.multiSample.reduceFlicker && !cameraChanged && markingUpdated && !controls.isAnimating;
            multiSampleHelper.render(ctx2, p, true, forceOn);
          } else {
            passes.draw.render(ctx2, p, true);
          }
          hiZ.render(camera);
          if (isTimingMode)
            webgl.timer.markEnd("Canvas3D.render");
          pickHelper.dirty = pickHelper.dirty || shouldRender;
          didRender = true;
        }
      }
      if (didRender) {
        fenceSync = webgl.getFenceSync();
      }
      return didRender;
    }
    let forceDrawAfterAllCommited = false;
    let drawPaused = false;
    let isContextLost = false;
    function draw(options) {
      if (drawPaused || isContextLost)
        return;
      if (render(!!(options === null || options === void 0 ? void 0 : options.force)) && notifyDidDraw) {
        didDraw.next(now() - startTime);
      }
    }
    function requestDraw() {
      forceNextRender = true;
    }
    let animationFrameHandle = 0;
    function tick(t2, options) {
      if (isContextLost)
        return;
      currentTime = t2;
      commit(options === null || options === void 0 ? void 0 : options.isSynchronous);
      if (options === null || options === void 0 ? void 0 : options.updateControls) {
        controls.update(currentTime);
      }
      camera.transition.tick(currentTime);
      hiZ.tick();
      if (options === null || options === void 0 ? void 0 : options.manualDraw) {
        return;
      }
      draw();
      if (!camera.transition.inTransition && !webgl.isContextLost) {
        interactionHelper.tick(currentTime);
      }
    }
    function _animate() {
      tick(now());
      animationFrameHandle = requestAnimationFrame2(_animate);
    }
    function resetTime(t2) {
      startTime = t2;
      controls.start(t2);
    }
    function animate() {
      drawPaused = false;
      controls.start(now());
      if (animationFrameHandle === 0)
        _animate();
    }
    function pause(noDraw = false) {
      drawPaused = noDraw;
      cancelAnimationFrame2(animationFrameHandle);
      animationFrameHandle = 0;
    }
    function identify(x2, y2) {
      const cam = p.camera.stereo.name === "on" ? stereoCamera : camera;
      return webgl.isContextLost ? void 0 : pickHelper.identify(x2, y2, cam);
    }
    function commit(isSynchronous = false) {
      const allCommited = commitScene(isSynchronous);
      if (allCommited) {
        resolveCameraReset();
        if (forceDrawAfterAllCommited) {
          if (helper.debug.isEnabled)
            helper.debug.update();
          draw({ force: true });
          forceDrawAfterAllCommited = false;
        }
        commited.next(now());
      }
    }
    function resolveCameraReset() {
      if (!cameraResetRequested)
        return;
      const boundingSphere = scene.boundingSphereVisible;
      const { center, radius } = boundingSphere;
      const autoAdjustControls = controls.props.autoAdjustMinMaxDistance;
      if (autoAdjustControls.name === "on") {
        const minDistance = autoAdjustControls.params.minDistanceFactor * radius + autoAdjustControls.params.minDistancePadding;
        const maxDistance = Math.max(autoAdjustControls.params.maxDistanceFactor * radius, autoAdjustControls.params.maxDistanceMin);
        controls.setProps({ minDistance, maxDistance });
      }
      if (radius > 0) {
        const duration = nextCameraResetDuration === void 0 ? p.cameraResetDurationMs : nextCameraResetDuration;
        const focus = camera.getFocus(center, radius);
        const next = typeof nextCameraResetSnapshot === "function" ? nextCameraResetSnapshot(scene, camera) : nextCameraResetSnapshot;
        const snapshot = next ? { ...focus, ...next } : focus;
        camera.setState({ ...snapshot, radiusMax: getSceneRadius() }, duration);
      }
      nextCameraResetDuration = void 0;
      nextCameraResetSnapshot = void 0;
      cameraResetRequested = false;
    }
    const oldBoundingSphereVisible = Sphere3D();
    const cameraSphere = Sphere3D();
    function shouldResetCamera() {
      if (camera.state.radiusMax === 0)
        return true;
      if (camera.transition.inTransition || nextCameraResetSnapshot)
        return false;
      let cameraSphereOverlapsNone = true, isEmpty3 = true;
      Sphere3D.set(cameraSphere, camera.state.target, camera.state.radius);
      for (const r of scene.renderables) {
        if (!r.state.visible)
          continue;
        const b5 = r.values.boundingSphere.ref.value;
        if (!b5.radius)
          continue;
        isEmpty3 = false;
        const cameraDist = Vec3.distance(cameraSphere.center, b5.center);
        if ((cameraDist > cameraSphere.radius || cameraDist > b5.radius || b5.radius > camera.state.radiusMax) && !Sphere3D.includes(oldBoundingSphereVisible, b5))
          return true;
        if (Sphere3D.overlaps(cameraSphere, b5))
          cameraSphereOverlapsNone = false;
      }
      return cameraSphereOverlapsNone || !isEmpty3 && cameraSphere.radius <= 0.1;
    }
    const sceneCommitTimeoutMs = 250;
    function commitScene(isSynchronous) {
      if (!scene.needsCommit)
        return true;
      Sphere3D.copy(oldBoundingSphereVisible, scene.boundingSphereVisible);
      hiZ.clear();
      if (!scene.commit(isSynchronous ? void 0 : sceneCommitTimeoutMs)) {
        commitQueueSize.next(scene.commitQueueSize);
        return false;
      }
      commitQueueSize.next(0);
      if (helper.debug.isEnabled)
        helper.debug.update();
      if (!p.camera.manualReset && (reprCount.value === 0 || shouldResetCamera())) {
        cameraResetRequested = true;
      }
      if (oldBoundingSphereVisible.radius === 0)
        nextCameraResetDuration = 0;
      if (!p.camera.manualReset)
        camera.setState({ radiusMax: getSceneRadius() }, 0);
      reprCount.next(reprRenderObjects.size);
      if (isDebugMode)
        consoleStats();
      return true;
    }
    function consoleStats() {
      const items = scene.renderables.map((r) => ({
        drawCount: r.values.drawCount.ref.value,
        instanceCount: r.values.instanceCount.ref.value,
        materialId: r.materialId,
        renderItemId: r.id
      }));
      console.groupCollapsed(`${items.length} RenderItems`);
      if (items.length < 50) {
        console.table(items);
      } else {
        console.log(items);
      }
      console.log(JSON.stringify(webgl.stats, void 0, 4));
      const { texture, attribute, elements } = webgl.resources.getByteCounts();
      console.log(JSON.stringify({
        texture: `${(texture / 1024 / 1024).toFixed(3)} MiB`,
        attribute: `${(attribute / 1024 / 1024).toFixed(3)} MiB`,
        elements: `${(elements / 1024 / 1024).toFixed(3)} MiB`
      }, void 0, 4));
      console.log(JSON.stringify(webgl.timer.formatedStats(), void 0, 4));
      console.groupEnd();
    }
    function add(repr) {
      registerAutoUpdate(repr);
      const oldRO = reprRenderObjects.get(repr);
      const newRO = /* @__PURE__ */ new Set();
      repr.renderObjects.forEach((o) => newRO.add(o));
      if (oldRO) {
        if (!SetUtils.areEqual(newRO, oldRO)) {
          newRO.forEach((o) => {
            if (!oldRO.has(o))
              scene.add(o);
          });
          oldRO.forEach((o) => {
            if (!newRO.has(o))
              scene.remove(o);
          });
        }
      } else {
        repr.renderObjects.forEach((o) => scene.add(o));
      }
      reprRenderObjects.set(repr, newRO);
      scene.update(repr.renderObjects, false);
      forceDrawAfterAllCommited = true;
      if (isDebugMode)
        consoleStats();
    }
    function remove3(repr) {
      unregisterAutoUpdate(repr);
      const renderObjects = reprRenderObjects.get(repr);
      if (renderObjects) {
        renderObjects.forEach((o) => scene.remove(o));
        reprRenderObjects.delete(repr);
        forceDrawAfterAllCommited = true;
        if (isDebugMode)
          consoleStats();
      }
    }
    function registerAutoUpdate(repr) {
      if (reprUpdatedSubscriptions.has(repr))
        return;
      reprUpdatedSubscriptions.set(repr, repr.updated.subscribe((_) => {
        if (!repr.state.syncManually)
          add(repr);
      }));
    }
    function unregisterAutoUpdate(repr) {
      const updatedSubscription = reprUpdatedSubscriptions.get(repr);
      if (updatedSubscription) {
        updatedSubscription.unsubscribe();
        reprUpdatedSubscriptions.delete(repr);
      }
    }
    function getProps() {
      const radius = scene.boundingSphere.radius > 0 ? 100 - Math.round(camera.transition.target.radius / getSceneRadius() * 100) : 0;
      return {
        camera: {
          mode: camera.state.mode,
          helper: { ...helper.camera.props },
          stereo: { ...p.camera.stereo },
          fov: Math.round(radToDeg(camera.state.fov)),
          manualReset: !!p.camera.manualReset
        },
        cameraFog: camera.state.fog > 0 ? { name: "on", params: { intensity: camera.state.fog } } : { name: "off", params: {} },
        cameraClipping: { far: camera.state.clipFar, radius, minNear: camera.state.minNear },
        cameraResetDurationMs: p.cameraResetDurationMs,
        sceneRadiusFactor: p.sceneRadiusFactor,
        transparentBackground: p.transparentBackground,
        dpoitIterations: p.dpoitIterations,
        pickPadding: p.pickPadding,
        userInteractionReleaseMs: p.userInteractionReleaseMs,
        viewport: p.viewport,
        postprocessing: { ...p.postprocessing },
        marking: { ...p.marking },
        multiSample: { ...p.multiSample },
        illumination: { ...p.illumination },
        hiZ: { ...hiZ.props },
        renderer: { ...renderer.props },
        trackball: { ...controls.props },
        interaction: { ...interactionHelper.props },
        debug: { ...helper.debug.props },
        handle: { ...helper.handle.props }
      };
    }
    const contextLostSub = contextLost === null || contextLost === void 0 ? void 0 : contextLost.subscribe(() => {
      isContextLost = true;
      fenceSync = null;
      pickHelper.dirty = true;
    });
    const contextRestoredSub = contextRestored.subscribe(() => {
      scene.forEach((r) => {
        var _a2;
        if ((_a2 = r.values.meta) === null || _a2 === void 0 ? void 0 : _a2.ref.value.reset) {
          r.values.meta.ref.value.reset();
          r.update();
        }
      });
      isContextLost = false;
      draw({ force: true });
      draw({ force: true });
    });
    const resized = new BehaviorSubject(0);
    function handleResize(draw2 = true) {
      passes.updateSize();
      updateViewport();
      syncViewport();
      if (draw2)
        requestDraw();
      resized.next(+/* @__PURE__ */ new Date());
    }
    addConsoleStatsProvider(consoleStats);
    const ctxChangedSub = (_a = ctx.changed) === null || _a === void 0 ? void 0 : _a.subscribe(() => {
      scene.setTransparency(passes.draw.transparency);
      requestDraw();
    });
    let isDragging = false;
    let isActivelyInteracting = false;
    let interactionSubs = [
      input.drag.subscribe(() => {
        isDragging = true;
      }),
      input.interactionEnd.subscribe(() => {
        isDragging = false;
      }),
      merge(input.drag, input.pinch, input.wheel, input.interactionEnd).subscribe(() => {
        interactionEvent.next();
      }),
      interactionEvent.subscribe(() => {
        isActivelyInteracting = true;
      }),
      interactionEvent.pipe(debounceTime(p.userInteractionReleaseMs)).subscribe(() => {
        isActivelyInteracting = isDragging;
        if (!isDragging && passes.illumination.supported && p.illumination.enabled) {
          requestDraw();
        }
      })
    ];
    if (isDebugMode && canvas) {
      let occlusionLoci = void 0;
      const printOcclusion = (loci) => {
        const s = loci && Loci.getBoundingSphere(Loci.normalize(loci, "residue"));
        hiZ.debugOcclusion(s);
      };
      input.click.subscribe((e) => {
        if (!e.modifiers.control || e.button !== 2)
          return;
        const p2 = identify(e.x, e.y);
        if (!p2) {
          occlusionLoci = void 0;
          printOcclusion(occlusionLoci);
          return;
        }
        const l = getLoci(p2.id);
        occlusionLoci = l.loci;
        printOcclusion(occlusionLoci);
      });
      didDraw.subscribe(() => {
        setTimeout(() => {
          printOcclusion(occlusionLoci);
        }, 100);
      });
    }
    return {
      webgl,
      add,
      remove: remove3,
      commit,
      update: (repr, keepSphere) => {
        if (repr) {
          if (!reprRenderObjects.has(repr))
            return;
          scene.update(repr.renderObjects, !!keepSphere);
        } else {
          scene.update(void 0, !!keepSphere);
        }
        forceDrawAfterAllCommited = true;
      },
      clear: () => {
        reprUpdatedSubscriptions.forEach((v3) => v3.unsubscribe());
        reprUpdatedSubscriptions.clear();
        reprRenderObjects.clear();
        scene.clear();
        helper.debug.clear();
        if (fenceSync !== null) {
          webgl.deleteSync(fenceSync);
          fenceSync = null;
        }
        requestDraw();
        reprCount.next(reprRenderObjects.size);
      },
      syncVisibility: () => {
        if (camera.state.radiusMax === 0) {
          cameraResetRequested = true;
          nextCameraResetDuration = 0;
        }
        if (scene.syncVisibility()) {
          if (helper.debug.isEnabled)
            helper.debug.update();
        }
        requestDraw();
      },
      requestDraw,
      tick,
      animate,
      resetTime,
      pause,
      resume: () => {
        drawPaused = false;
      },
      identify,
      mark,
      getLoci,
      handleResize,
      requestResize: () => {
        resizeRequested = true;
      },
      requestCameraReset: (options) => {
        nextCameraResetDuration = options === null || options === void 0 ? void 0 : options.durationMs;
        nextCameraResetSnapshot = options === null || options === void 0 ? void 0 : options.snapshot;
        cameraResetRequested = true;
      },
      camera,
      boundingSphere: scene.boundingSphere,
      boundingSphereVisible: scene.boundingSphereVisible,
      get notifyDidDraw() {
        return notifyDidDraw;
      },
      set notifyDidDraw(v3) {
        notifyDidDraw = v3;
      },
      didDraw,
      commited,
      commitQueueSize,
      reprCount,
      resized,
      setProps: (properties4, doNotRequestDraw = false) => {
        var _a2, _b, _c, _d;
        const props2 = typeof properties4 === "function" ? produce(getProps(), properties4) : properties4;
        if (props2.sceneRadiusFactor !== void 0) {
          p.sceneRadiusFactor = props2.sceneRadiusFactor;
          camera.setState({ radiusMax: getSceneRadius() }, 0);
        }
        const cameraState = /* @__PURE__ */ Object.create(null);
        if (props2.camera && props2.camera.mode !== void 0 && props2.camera.mode !== camera.state.mode) {
          cameraState.mode = props2.camera.mode;
        }
        const oldFov = Math.round(radToDeg(camera.state.fov));
        if (props2.camera && props2.camera.fov !== void 0 && props2.camera.fov !== oldFov) {
          cameraState.fov = degToRad(props2.camera.fov);
        }
        if (props2.cameraFog !== void 0 && props2.cameraFog.params) {
          const newFog = props2.cameraFog.name === "on" ? props2.cameraFog.params.intensity : 0;
          if (newFog !== camera.state.fog)
            cameraState.fog = newFog;
        }
        if (props2.cameraClipping !== void 0) {
          if (props2.cameraClipping.far !== void 0 && props2.cameraClipping.far !== camera.state.clipFar) {
            cameraState.clipFar = props2.cameraClipping.far;
          }
          if (props2.cameraClipping.minNear !== void 0 && props2.cameraClipping.minNear !== camera.state.minNear) {
            cameraState.minNear = props2.cameraClipping.minNear;
          }
          if (props2.cameraClipping.radius !== void 0) {
            const radius = getSceneRadius() / 100 * (100 - props2.cameraClipping.radius);
            if (radius > 0 && radius !== cameraState.radius) {
              cameraState.radius = Math.max(radius, 0.01);
            }
          }
        }
        if (Object.keys(cameraState).length > 0)
          camera.setState(cameraState);
        if ((_a2 = props2.camera) === null || _a2 === void 0 ? void 0 : _a2.helper)
          helper.camera.setProps(props2.camera.helper);
        if (((_b = props2.camera) === null || _b === void 0 ? void 0 : _b.manualReset) !== void 0)
          p.camera.manualReset = props2.camera.manualReset;
        if (((_c = props2.camera) === null || _c === void 0 ? void 0 : _c.stereo) !== void 0) {
          Object.assign(p.camera.stereo, props2.camera.stereo);
          stereoCamera.setProps(p.camera.stereo.params);
        }
        if (props2.cameraResetDurationMs !== void 0)
          p.cameraResetDurationMs = props2.cameraResetDurationMs;
        if (props2.transparentBackground !== void 0)
          p.transparentBackground = props2.transparentBackground;
        if (props2.dpoitIterations !== void 0)
          p.dpoitIterations = props2.dpoitIterations;
        if (props2.pickPadding !== void 0) {
          p.pickPadding = props2.pickPadding;
          pickHelper.setPickPadding(p.pickPadding);
        }
        if (props2.userInteractionReleaseMs !== void 0)
          p.userInteractionReleaseMs = props2.userInteractionReleaseMs;
        if (props2.viewport !== void 0) {
          const doNotUpdate = p.viewport === props2.viewport || p.viewport.name === props2.viewport.name && shallowEqual(p.viewport.params, props2.viewport.params);
          if (!doNotUpdate) {
            p.viewport = props2.viewport;
            updateViewport();
            syncViewport();
          }
        }
        if ((_d = props2.postprocessing) === null || _d === void 0 ? void 0 : _d.background) {
          Object.assign(p.postprocessing.background, props2.postprocessing.background);
          passes.draw.postprocessing.background.update(camera, p.postprocessing.background, (changed) => {
            if (changed && !doNotRequestDraw)
              requestDraw();
          });
        }
        if (props2.postprocessing)
          Object.assign(p.postprocessing, props2.postprocessing);
        if (props2.marking)
          Object.assign(p.marking, props2.marking);
        if (props2.illumination)
          Object.assign(p.illumination, props2.illumination);
        if (props2.multiSample)
          Object.assign(p.multiSample, props2.multiSample);
        if (props2.hiZ)
          hiZ.setProps(props2.hiZ);
        if (props2.renderer)
          renderer.setProps(props2.renderer);
        if (props2.trackball)
          controls.setProps(props2.trackball);
        if (props2.interaction)
          interactionHelper.setProps(props2.interaction);
        if (props2.debug)
          helper.debug.setProps(props2.debug);
        if (props2.handle)
          helper.handle.setProps(props2.handle);
        if (cameraState.mode === "orthographic") {
          p.camera.stereo.name = "off";
        }
        if (!doNotRequestDraw) {
          requestDraw();
        }
      },
      getImagePass: (props2 = {}) => {
        return new ImagePass(webgl, assetManager, renderer, scene, camera, helper, passes.draw.transparency, props2);
      },
      getRenderObjects() {
        const renderObjects = [];
        scene.forEach((_, ro) => renderObjects.push(ro));
        return renderObjects;
      },
      get props() {
        return getProps();
      },
      get input() {
        return input;
      },
      get stats() {
        return renderer.stats;
      },
      get interaction() {
        return interactionHelper.events;
      },
      dispose: () => {
        contextLostSub === null || contextLostSub === void 0 ? void 0 : contextLostSub.unsubscribe();
        contextRestoredSub.unsubscribe();
        ctxChangedSub === null || ctxChangedSub === void 0 ? void 0 : ctxChangedSub.unsubscribe();
        for (const s of interactionSubs)
          s.unsubscribe();
        interactionSubs = [];
        cancelAnimationFrame2(animationFrameHandle);
        markBuffer = [];
        scene.clear();
        helper.debug.clear();
        controls.dispose();
        renderer.dispose();
        interactionHelper.dispose();
        hiZ.dispose();
        if (fenceSync !== null) {
          webgl.deleteSync(fenceSync);
          fenceSync = null;
        }
        removeConsoleStatsProvider(consoleStats);
      }
    };
    function updateViewport() {
      const oldX = x, oldY = y, oldWidth = width, oldHeight = height;
      if (p.viewport.name === "canvas") {
        x = 0;
        y = 0;
        width = gl.drawingBufferWidth;
        height = gl.drawingBufferHeight;
      } else if (p.viewport.name === "static-frame") {
        x = p.viewport.params.x * webgl.pixelRatio;
        height = p.viewport.params.height * webgl.pixelRatio;
        y = gl.drawingBufferHeight - height - p.viewport.params.y * webgl.pixelRatio;
        width = p.viewport.params.width * webgl.pixelRatio;
      } else if (p.viewport.name === "relative-frame") {
        x = Math.round(p.viewport.params.x * gl.drawingBufferWidth);
        height = Math.round(p.viewport.params.height * gl.drawingBufferHeight);
        y = Math.round(gl.drawingBufferHeight - height - p.viewport.params.y * gl.drawingBufferHeight);
        width = Math.round(p.viewport.params.width * gl.drawingBufferWidth);
      }
      if (oldX !== x || oldY !== y || oldWidth !== width || oldHeight !== height) {
        forceNextRender = true;
      }
    }
    function syncViewport() {
      pickHelper.setViewport(x, y, width, height);
      renderer.setViewport(x, y, width, height);
      Viewport.set(camera.viewport, x, y, width, height);
      Viewport.set(controls.viewport, x, y, width, height);
      hiZ.setViewport(x, y, width, height);
    }
  }
  Canvas3D2.create = create;
})(Canvas3D || (Canvas3D = {}));

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-plugin-state/formats/provider.js
function DataFormatProvider(provider) {
  return provider;
}
function guessCifVariant(info, data) {
  if (info.ext === "bcif") {
    try {
      const { encoder } = decodeMsgPack(data);
      if (encoder.startsWith("VolumeServer"))
        return "dscif";
      if (encoder.startsWith("volseg-volume-server"))
        return "segcif";
    } catch (e) {
      console.error(e);
    }
  } else if (info.ext === "cif") {
    const str3 = data;
    if (str3.startsWith("data_SERVER\n#\n_density_server_result"))
      return "dscif";
    if (str3.startsWith("data_SERVER\n#\ndata_SEGMENTATION_DATA"))
      return "segcif";
    if (str3.includes("atom_site_fract_x") || str3.includes("atom_site.fract_x"))
      return "coreCif";
  }
  return -1;
}

// ../node_modules/.pnpm/molstar@4.18.0_@types+react@18.3.27_fp-ts@2.16.11_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/molstar/lib/mol-geo/geometry/spheres/spheres-builder.js
var caAdd34 = ChunkedArray.add3;
var caAdd5 = ChunkedArray.add;
var SpheresBuilder;
(function(SpheresBuilder2) {
  function create(initialCount = 2048, chunkSize = 1024, spheres) {
    const centers = ChunkedArray.create(Float32Array, 3, chunkSize, spheres ? spheres.centerBuffer.ref.value : initialCount);
    const groups = ChunkedArray.create(Float32Array, 1, chunkSize, spheres ? spheres.groupBuffer.ref.value : initialCount);
    return {
      add: (x, y, z, group) => {
        caAdd34(centers, x, y, z);
        caAdd5(groups, group);
      },
      getSpheres: () => {
        const cb2 = ChunkedArray.compact(centers, true);
        const gb = ChunkedArray.compact(groups, true);
        return Spheres.create(cb2, gb, centers.elementCount, spheres);
      }
    };
  }
  SpheresBuilder2.create = create;
})(SpheresBuilder || (SpheresBuilder = {}));

export {
  StateObject,
  StateObjectRef,
  List,
  OrderedMap,
  StateAction,
  Transformer,
  Transform,
  StateTree,
  StateSelection,
  Subject,
  BehaviorSubject,
  map2 as map,
  merge,
  filter3 as filter,
  debounceTime,
  take2 as take,
  distinctUntilChanged,
  skip2 as skip,
  throttleTime,
  RxEventHelper,
  produce,
  setAutoFreeze,
  LogEntry,
  StateTreeSpine,
  State,
  NullLocation,
  DataLocation,
  LocationIterator,
  EmptyLocationIterator,
  PositionLocation,
  createIdentityTransform,
  ColorThemeCategory,
  Material,
  Clip,
  VisualQualityOptions,
  ColorSmoothingParams,
  getColorSmoothingProps,
  BaseGeometry,
  PluginStateObject,
  PluginStateTransform,
  Download,
  DownloadBlob,
  RawData,
  ReadFile,
  ParseCif,
  ParseCcp4,
  transformPositionArray,
  createTextureImage,
  createMarkers,
  ShaderCode,
  printTimerResults,
  isWebGL2,
  createColors,
  Mesh,
  createPrimitive,
  PrimitiveBuilder,
  createCage,
  sphereVertexCount,
  addSphere,
  polygon,
  DiamondPrism,
  PentagonalPrism,
  HexagonalPrism,
  ShiftedHexagonalPrism,
  HeptagonalPrism,
  addSimpleCylinder,
  addCylinder,
  addDoubleCylinder,
  addFixedCountDashedCylinder,
  MeshBuilder,
  packIntToRGBArray,
  unpackRGBToInt,
  createSizes,
  Points,
  Text,
  LinesBuilder,
  Lines,
  Box,
  PerforatedBox,
  BoxCage,
  Grid,
  volumeFromDensityServerData,
  Volume,
  DirectVolume,
  Spheres,
  TextureMesh,
  AttributeSpec,
  UniformSpec,
  TextureSpec,
  DefineSpec,
  ValueSpec,
  quad_vert,
  createComputeRenderItem,
  Plane3D,
  createComputeRenderable,
  QuadSchema,
  QuadValues,
  InterpolationTypes,
  Image2 as Image,
  Cylinders,
  Geometry,
  getNextMaterialId,
  createRenderObject,
  Shape,
  Script,
  RootStructureDefinition,
  StructureQueryHelper,
  StaticStructureComponentTypes,
  createStructureComponent,
  TrajectoryFromModelAndCoordinates,
  TrajectoryFromMmCif,
  TrajectoryFromPDB,
  ModelFromTrajectory,
  StructureFromModel,
  TransformStructureConformation,
  StructureComponent,
  CustomModelProperties,
  CustomStructureProperties,
  VolumeFromCcp4,
  VolumeFromDensityServerCif,
  getPaletteParams,
  getPalette,
  ChainIdColorThemeProvider,
  OperatorNameColorThemeProvider,
  ColorTheme,
  SizeTheme,
  Theme,
  MarkerAction,
  applyMarkerAction,
  EveryLoci,
  isEveryLoci,
  EmptyLoci,
  isEmptyLoci,
  DataLoci,
  Loci,
  Overpaint,
  Transparency,
  VisualUpdateState,
  getStructureQuality,
  getQualityProps,
  eachVolumeLoci,
  createVolumeCellLocationIterator,
  getVolumeTexture2dLayout,
  createVolumeTexture2d,
  createVolumeTexture3d,
  createSegmentTexture2d,
  applyMeshColorSmoothing,
  applyTextureMeshColorSmoothing,
  Visual,
  Clipping,
  Substance,
  Emissive,
  RepresentationRegistry,
  Representation,
  TextBuilder,
  lociLabel,
  structureElementStatsLabel,
  structureElementLociLabelMany,
  bondLabel,
  elementLabel,
  distanceLabel,
  angleLabel,
  dihedralLabel,
  MeasurementRepresentationCommonTextParams,
  addEllipsoid,
  Circle,
  StructureRepresentation3D,
  VolumeRepresentation3DHelpers,
  VolumeRepresentation3D,
  ShapeRepresentation3D,
  StateTransforms,
  StructureSelectionCategory,
  StructureSelectionQuery,
  getElementQueries,
  getNonStandardResidueQueries,
  getPolymerAndBranchedEntityQueries,
  StructureSelectionQueries,
  StructureSelectionQueryRegistry,
  is_iOS,
  ComplexRepresentation,
  typeSymbol,
  formalCharge,
  atomId,
  altLoc,
  compId,
  bondCount,
  bondToElementCount,
  connectedTo,
  eachIntraBondedAtom,
  eachBondedAtom,
  isSulfonicAcid,
  isSulfate,
  isPhosphate,
  isCarboxylate,
  isGuanidine,
  isAcetamidine,
  getResidueLoci,
  getAltResidueLoci,
  getAltResidueLociFromId,
  getVolumeSliceInfo,
  ensureReasonableResolution,
  CommonSurfaceParams,
  getUnitConformationAndRadius,
  getStructureConformationAndRadius,
  isHydrogen,
  isTrace,
  getUnitKindsParam,
  ComplexMeshParams,
  ComplexMeshVisual,
  ComplexSpheresParams,
  ComplexSpheresVisual,
  ComplexCylindersParams,
  ComplexCylindersVisual,
  ComplexPointsParams,
  ComplexPointsVisual,
  ComplexLinesParams,
  ComplexLinesVisual,
  ComplexTextParams,
  ComplexTextVisual,
  ComplexDirectVolumeParams,
  ComplexDirectVolumeVisual,
  ComplexTextureMeshParams,
  ComplexTextureMeshVisual,
  ComplexImageParams,
  ComplexImageVisual,
  UnitsRepresentation,
  UnitsMeshParams,
  UnitsMeshVisual,
  UnitsSpheresParams,
  UnitsSpheresVisual,
  UnitsCylindersParams,
  UnitsCylindersVisual,
  UnitsPointsParams,
  UnitsPointsVisual,
  UnitsLinesParams,
  UnitsLinesVisual,
  UnitsDirectVolumeParams,
  UnitsDirectVolumeVisual,
  UnitsTextureMeshParams,
  UnitsTextureMeshVisual,
  StructureRepresentationStateBuilder,
  StructureRepresentationProvider,
  PluginBehavior,
  PluginComponent,
  StatefulPluginComponent,
  PLUGIN_VERSION,
  PLUGIN_VERSION_DATE,
  resizeCanvas,
  canvasToBlob,
  PluginStateSnapshotManager,
  PluginCommandManager,
  PluginCommands,
  getButtons,
  getButton,
  getModifiers,
  ModifiersKeys,
  ButtonsType,
  EmptyKeyInput,
  normalizeWheel,
  Binding,
  Camera,
  PostprocessingParams,
  CameraHelperParams,
  CameraHelperAxis,
  isCameraAxesLoci,
  fasterExp,
  Canvas3DParams,
  DefaultCanvas3DParams,
  Canvas3DContext,
  Canvas3D,
  DataFormatProvider,
  guessCifVariant,
  SpheresBuilder
};
/*! Bundled license information:

immutable/dist/immutable.es.js:
  (**
   * @license
   * MIT License
   * 
   * Copyright (c) 2014-present, Lee Byron and other contributors.
   * 
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   * 
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   * 
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *)
*/
//# sourceMappingURL=chunk-CLY72GQO.js.map
